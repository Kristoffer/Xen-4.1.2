! 1 
! 1 # 1 "_rombios_.c"
! 1 extern unsigned long pci_mem_start, pci_mem_end;
!BCC_EOS
! 2 struct bios_info {
! 3     unsigned char com1_present:1;
!BCC_EOS
! 4     unsigned char com2_present:1;
!BCC_EOS
! 5     unsigned char lpt1_present:1;
!BCC_EOS
! 6     unsigned char hpet_present:1;
!BCC_EOS
! 7     unsigned long pci_min, pci_len;
!BCC_EOS
! 8     unsigned long madt_csum_addr;
!BCC_EOS
! 9     unsigned long madt_lapic0_addr;
!BCC_EOS
! 10     unsigned long bios32_entry;
!BCC_EOS
! 11 };
!BCC_EOS
! 12 #asm
!BCC_ASM
.rom
.org 0x0000
use16 386
MACRO HALT
  ;; the HALT macro is called with the line number of the HALT call.
  ;; The line number is then sent to the 0x400, causing Bochs/Plex
  ;; to print a BX_PANIC message. This will normally halt the simulation
  ;; with a message such as "BIOS panic at rombios.c, line 4091".
  ;; However, users can choose to make panics non-fatal and continue.
  mov dx,#0x400
  mov ax,#?1
  out dx,ax
MEND
MACRO JMP_AP
  db 0xea
  dw ?2
  dw ?1
MEND
MACRO SET_INT_VECTOR
  mov ax, ?3
  mov ?1*4, ax
  mov ax, ?2
  mov ?1*4+2, ax
MEND
! 37 endasm
!BCC_ENDASM
! 38 typedef unsigned char Bit8u;
!BCC_EOS
! 39 typedef unsigned short Bit16u;
!BCC_EOS
! 40 typedef unsigned short bx_bool;
!BCC_EOS
! 41 typedef unsigned long Bit32u;
!BCC_EOS
! 42   void memsetb(seg,offset,value,count);
!BCC_EOS
! 43   void memcpyb(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 44   void memcpyd(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 45     void
! 46   memsetb(seg,offset,value,count)
! 47     Bit16u seg;
export	_memsetb
_memsetb:
!BCC_EOS
! 48     Bit16u offset;
!BCC_EOS
! 49     Bit16u value;
!BCC_EOS
! 50     Bit16u count;
!BCC_EOS
! 51   {
! 52 #asm
!BCC_ASM
_memsetb.count	set	8
_memsetb.seg	set	2
_memsetb.value	set	6
_memsetb.offset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      mov cx, 10[bp] ; count
      test cx, cx
      je memsetb_end
      mov ax, 4[bp] ; segment
      mov es, ax
      mov ax, 6[bp] ; offset
      mov di, ax
      mov al, 8[bp] ; value
      cld
      rep
       stosb
  memsetb_end:
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 76 endasm
!BCC_ENDASM
! 77   }
ret
! 78     void
! 79   memcpyb(dseg,doffset,sseg,soffset,count)
! 80     Bit16u dseg;
export	_memcpyb
_memcpyb:
!BCC_EOS
! 81     Bit16u doffset;
!BCC_EOS
! 82     Bit16u sseg;
!BCC_EOS
! 83     Bit16u soffset;
!BCC_EOS
! 84     Bit16u count;
!BCC_EOS
! 85   {
! 86 #asm
!BCC_ASM
_memcpyb.count	set	$A
_memcpyb.sseg	set	6
_memcpyb.soffset	set	8
_memcpyb.dseg	set	2
_memcpyb.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyb_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsb
  memcpyb_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 117 endasm
!BCC_ENDASM
! 118   }
ret
! 119     void
! 120   memcpyd(dseg,doffset,sseg,soffset,count)
! 121     Bit16u dseg;
export	_memcpyd
_memcpyd:
!BCC_EOS
! 122     Bit16u doffset;
!BCC_EOS
! 123     Bit16u sseg;
!BCC_EOS
! 124     Bit16u soffset;
!BCC_EOS
! 125     Bit16u count;
!BCC_EOS
! 126   {
! 127 #asm
!BCC_ASM
_memcpyd.count	set	$A
_memcpyd.sseg	set	6
_memcpyd.soffset	set	8
_memcpyd.dseg	set	2
_memcpyd.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyd_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsd
  memcpyd_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 158 endasm
!BCC_ENDASM
! 159   }
ret
! 160   static Bit32u read_dword();
!BCC_EOS
! 161   static void write_dword();
!BCC_EOS
! 162     Bit32u
! 163   read_dword(seg, offset)
! 164     Bit16u seg;
export	_read_dword
_read_dword:
!BCC_EOS
! 165     Bit16u offset;
!BCC_EOS
! 166   {
! 167 #asm
!BCC_ASM
_read_dword.seg	set	2
_read_dword.offset	set	4
    push bp
    mov bp, sp
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, [bx]
      add bx, #2
      mov dx, [bx]
      ;; ax = return value (word)
      ;; dx = return value (word)
      pop ds
      pop bx
    pop bp
! 183 endasm
!BCC_ENDASM
! 184   }
ret
! 185     void
! 186   write_dword(seg, offset, data)
! 187     Bit16u seg;
export	_write_dword
_write_dword:
!BCC_EOS
! 188     Bit16u offset;
!BCC_EOS
! 189     Bit32u data;
!BCC_EOS
! 190   {
! 191 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
    push bp
    mov bp, sp
      push ax
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, 8[bp] ; data word
      mov [bx], ax ; write data word
      add bx, #2
      mov ax, 10[bp] ; data word
      mov [bx], ax ; write data word
      pop ds
      pop bx
      pop ax
    pop bp
! 209 endasm
!BCC_ENDASM
! 210   }
ret
! 211 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
  ;; and function
  landl:
  landul:
    SEG SS
      and ax,[di]
    SEG SS
      and bx,2[di]
    ret
  ;; add function
  laddl:
  laddul:
    SEG SS
      add ax,[di]
    SEG SS
      adc bx,2[di]
    ret
  ;; cmp function
  lcmpl:
  lcmpul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    SEG SS
      cmp eax, dword ptr [di]
    ret
  ;; sub function
  lsubl:
  lsubul:
    SEG SS
    sub ax,[di]
    SEG SS
    sbb bx,2[di]
    ret
  ;; mul function
  lmull:
  lmulul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    SEG SS
    mul eax, dword ptr [di]
    mov ebx, eax
    shr ebx, #16
    ret
  ;; dec function
  ldecl:
  ldecul:
    SEG SS
    dec dword ptr [bx]
    ret
  ;; or function
  lorl:
  lorul:
    SEG SS
    or ax,[di]
    SEG SS
    or bx,2[di]
    ret
  ;; inc function
  lincl:
  lincul:
    SEG SS
    inc dword ptr [bx]
    ret
  ;; tst function
  ltstl:
  ltstul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    test eax, eax
    ret
  ;; sr function
  lsrul:
    mov cx,di
    jcxz lsr_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsr_loop:
    shr eax, #1
    loop lsr_loop
    mov ebx, eax
    shr ebx, #16
  lsr_exit:
    ret
  ;; sl function
  lsll:
  lslul:
    mov cx,di
    jcxz lsl_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsl_loop:
    shl eax, #1
    loop lsl_loop
    mov ebx, eax
    shr ebx, #16
  lsl_exit:
    ret
  idiv_:
    cwd
    idiv bx
    ret
  idiv_u:
    xor dx,dx
    div bx
    ret
  ldivul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    xor edx, edx
    SEG SS
    mov bx, 2[di]
    shl ebx, #16
    SEG SS
    mov bx, [di]
    div ebx
    mov ebx, eax
    shr ebx, #16
    ret
! 337 endasm
!BCC_ENDASM
! 338 typedef struct {
! 339   unsigned char filler1[0x400];
!BCC_EOS
! 340   unsigned char filler2[0x6c];
!BCC_EOS
! 341   Bit16u ticks_low;
!BCC_EOS
! 342   Bit16u ticks_high;
!BCC_EOS
! 343   Bit8u midnight_flag;
!BCC_EOS
! 344   } bios_data_t;
!BCC_EOS
! 345   typedef struct {
! 346     Bit16u heads;
!BCC_EOS
! 347     Bit16u cylinders;
!BCC_EOS
! 348     Bit16u spt;
!BCC_EOS
! 349     } chs_t;
!BCC_EOS
! 350   typedef struct {
! 351     Bit16u iobase1;
!BCC_EOS
! 352     Bit16u iobase2;
!BCC_EOS
! 353     Bit8u prefix;
!BCC_EOS
! 354     Bit8u unused;
!BCC_EOS
! 355     Bit8u irq;
!BCC_EOS
! 356     Bit8u blkcount;
!BCC_EOS
! 357     Bit8u dma;
!BCC_EOS
! 358     
! 358 Bit8u pio;
!BCC_EOS
! 359     Bit16u options;
!BCC_EOS
! 360     Bit16u reserved;
!BCC_EOS
! 361     Bit8u revision;
!BCC_EOS
! 362     Bit8u checksum;
!BCC_EOS
! 363     } dpte_t;
!BCC_EOS
! 364   typedef struct {
! 365     Bit8u iface;
!BCC_EOS
! 366     Bit16u iobase1;
!BCC_EOS
! 367     Bit16u iobase2;
!BCC_EOS
! 368     Bit8u irq;
!BCC_EOS
! 369     } ata_channel_t;
!BCC_EOS
! 370   typedef struct {
! 371     Bit8u type;
!BCC_EOS
! 372     Bit8u device;
!BCC_EOS
! 373     Bit8u removable;
!BCC_EOS
! 374     Bit8u lock;
!BCC_EOS
! 375     Bit8u mode;
!BCC_EOS
! 376     Bit16u blksize;
!BCC_EOS
! 377     Bit8u translation;
!BCC_EOS
! 378     chs_t lchs;
!BCC_EOS
! 379     chs_t pchs;
!BCC_EOS
! 380     Bit32u sectors_low;
!BCC_EOS
! 381     Bit32u sectors_high;
!BCC_EOS
! 382     } ata_device_t;
!BCC_EOS
! 383   typedef struct {
! 384     ata_channel_t channels[4];
!BCC_EOS
! 385     ata_device_t devices[(4*2)];
!BCC_EOS
! 386     Bit8u hdcount, hdidmap[(4*2)];
!BCC_EOS
! 387     Bit8u cdcount, cdidmap[(4*2)];
!BCC_EOS
! 388     dpte_t dpte;
!BCC_EOS
! 389     Bit16u trsfsectors;
!BCC_EOS
! 390     Bit32u trsfbytes;
!BCC_EOS
! 391     } ata_t;
!BCC_EOS
! 392   typedef struct {
! 393     Bit8u active;
!BCC_EOS
! 394     Bit8u media;
!BCC_EOS
! 395     Bit8u emulated_drive;
!BCC_EOS
! 396     Bit8u controller_index;
!BCC_EOS
! 397     Bit16u device_spec;
!BCC_EOS
! 398     Bit32u ilba;
!BCC_EOS
! 399     Bit16u buffer_segment;
!BCC_EOS
! 400     Bit16u load_segment;
!BCC_EOS
! 401     Bit16u sector_count;
!BCC_EOS
! 402     chs_t vdevice;
!BCC_EOS
! 403     } cdemu_t;
!BCC_EOS
! 404 Bit32u TCGInterruptHandler ();
!BCC_EOS
! 405 void tcpa_acpi_init ();
!BCC_EOS
! 406 Bit32u tcpa_extend_acpi_log ();
!BCC_EOS
! 407 void tcpa_calling_int19h ();
!BCC_EOS
! 408 void tcpa_returned_int19h ();
!BCC_EOS
! 409 void tcpa_add_event_separators ();
!BCC_EOS
! 410 void tcpa_wake_event ();
!BCC_EOS
! 411 void tcpa_add_bootdevice ();
!BCC_EOS
! 412 void tcpa_start_option_rom_scan ();
!BCC_EOS
! 413 void tcpa_option_rom ();
!BCC_EOS
! 414 void tcpa_ipl ();
!BCC_EOS
! 415 void tcpa_measure_post ();
!BCC_EOS
! 416 Bit32u tcpa_initialize_tpm ();
!BCC_EOS
! 417 Bit32u get_s3_waking_vector ();
!BCC_EOS
! 418 Bit32u pmm ();
!BCC_EOS
! 419   typedef struct {
! 420     unsigned char ebda_size;
!BCC_EOS
! 421     unsigned char cmos_shutdown_status;
!BCC_EOS
! 422     unsigned char filler1[0x3B];
!BCC_EOS
! 423     unsigned char fdpt0[0x10];
!BCC_EOS
! 424     unsigned char fdpt1[0x10];
!BCC_EOS
! 425     unsigned char filler2[0xC4];
!BCC_EOS
! 426     ata_t ata;
!BCC_EOS
! 427     cdemu_t cdemu;
!BCC_EOS
! 428     } ebda_data_t;
!BCC_EOS
! 429   typedef struct {
! 430     Bit8u size;
!BCC_EOS
! 431     Bit8u reserved;
!BCC_EOS
! 432     Bit16u count;
!BCC_EOS
! 433     Bit16u offset;
!BCC_EOS
! 434     Bit16u segment;
!BCC_EOS
! 435     Bit32u lba1;
!BCC_EOS
! 436     Bit32u lba2;
!BCC_EOS
! 437     } int13ext_t;
!BCC_EOS
! 438   typedef struct {
! 439     Bit16u size;
!BCC_EOS
! 440     Bit16u infos;
!BCC_EOS
! 441     Bit32u cylinders;
!BCC_EOS
! 442     Bit32u heads;
!BCC_EOS
! 443     Bit32u spt;
!BCC_EOS
! 444     Bit32u sector_count1;
!BCC_EOS
! 445     Bit32u sector_count2;
!BCC_EOS
! 446     Bit16u blksize;
!BCC_EOS
! 447     Bit16u dpte_offset;
!BCC_EOS
! 448     Bit16u dpte_segment;
!BCC_EOS
! 449     Bit1
! 449 6u key;
!BCC_EOS
! 450     Bit8u dpi_length;
!BCC_EOS
! 451     Bit8u reserved1;
!BCC_EOS
! 452     Bit16u reserved2;
!BCC_EOS
! 453     Bit8u host_bus[4];
!BCC_EOS
! 454     Bit8u iface_type[8];
!BCC_EOS
! 455     Bit8u iface_path[8];
!BCC_EOS
! 456     Bit8u device_path[8];
!BCC_EOS
! 457     Bit8u reserved3;
!BCC_EOS
! 458     Bit8u checksum;
!BCC_EOS
! 459     } dpt_t;
!BCC_EOS
! 460 typedef struct {
! 461   union {
! 462     struct {
! 463       Bit16u di, si, bp, sp;
!BCC_EOS
! 464       Bit16u bx, dx, cx, ax;
!BCC_EOS
! 465       } r16;
!BCC_EOS
! 466     struct {
! 467       Bit16u filler[4];
!BCC_EOS
! 468       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
!BCC_EOS
! 469       } r8;
!BCC_EOS
! 470     } u;
!BCC_EOS
! 471   } pusha_regs_t;
!BCC_EOS
! 472 typedef struct {
! 473  union {
! 474   struct {
! 475     Bit32u edi, esi, ebp, esp;
!BCC_EOS
! 476     Bit32u ebx, edx, ecx, eax;
!BCC_EOS
! 477     } r32;
!BCC_EOS
! 478   struct {
! 479     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
!BCC_EOS
! 480     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
!BCC_EOS
! 481     } r16;
!BCC_EOS
! 482   struct {
! 483     Bit32u filler[4];
!BCC_EOS
! 484     Bit8u bl, bh;
!BCC_EOS
! 485     Bit16u filler1;
!BCC_EOS
! 486     Bit8u dl, dh;
!BCC_EOS
! 487     Bit16u filler2;
!BCC_EOS
! 488     Bit8u cl, ch;
!BCC_EOS
! 489     Bit16u filler3;
!BCC_EOS
! 490     Bit8u al, ah;
!BCC_EOS
! 491     Bit16u filler4;
!BCC_EOS
! 492     } r8;
!BCC_EOS
! 493   } u;
!BCC_EOS
! 494 } pushad_regs_t;
!BCC_EOS
! 495 typedef struct {
! 496   union {
! 497     struct {
! 498       Bit16u flags;
!BCC_EOS
! 499       } r16;
!BCC_EOS
! 500     struct {
! 501       Bit8u flagsl;
!BCC_EOS
! 502       Bit8u flagsh;
!BCC_EOS
! 503       } r8;
!BCC_EOS
! 504     } u;
!BCC_EOS
! 505   } flags_t;
!BCC_EOS
! 506 typedef struct {
! 507   Bit16u ip;
!BCC_EOS
! 508   Bit16u cs;
!BCC_EOS
! 509   flags_t flags;
!BCC_EOS
! 510   } iret_addr_t;
!BCC_EOS
! 511 typedef struct {
! 512   Bit16u type;
!BCC_EOS
! 513   Bit16u flags;
!BCC_EOS
! 514   Bit32u vector;
!BCC_EOS
! 515   Bit32u description;
!BCC_EOS
! 516   Bit32u reserved;
!BCC_EOS
! 517   } ipl_entry_t;
!BCC_EOS
! 518 static Bit8u inb();
!BCC_EOS
! 519 static Bit8u inb_cmos();
!BCC_EOS
! 520 static void outb();
!BCC_EOS
! 521 static void outb_cmos();
!BCC_EOS
! 522 static Bit16u inw();
!BCC_EOS
! 523 static void outw();
!BCC_EOS
! 524 static void init_rtc();
!BCC_EOS
! 525 static bx_bool rtc_updating();
!BCC_EOS
! 526 static Bit8u read_byte();
!BCC_EOS
! 527 static Bit16u read_word();
!BCC_EOS
! 528 static void write_byte();
!BCC_EOS
! 529 static void write_word();
!BCC_EOS
! 530 static void bios_printf();
!BCC_EOS
! 531 static Bit8u inhibit_mouse_int_and_events();
!BCC_EOS
! 532 static void enable_mouse_int_and_events();
!BCC_EOS
! 533 static Bit8u send_to_mouse_ctrl();
!BCC_EOS
! 534 static Bit8u get_mouse_data();
!BCC_EOS
! 535 static void set_kbd_command_byte();
!BCC_EOS
! 536 static void int09_function();
!BCC_EOS
! 537 static void int13_harddisk();
!BCC_EOS
! 538 static void int13_cdrom();
!BCC_EOS
! 539 static void int13_cdemu();
!BCC_EOS
! 540 static void int13_eltorito();
!BCC_EOS
! 541 static void int13_diskette_function();
!BCC_EOS
! 542 static void int14_function();
!BCC_EOS
! 543 static void int15_function();
!BCC_EOS
! 544 sta
! 544 tic void int16_function();
!BCC_EOS
! 545 static void int17_function();
!BCC_EOS
! 546 static void int18_function();
!BCC_EOS
! 547 static void int1a_function();
!BCC_EOS
! 548 static void int70_function();
!BCC_EOS
! 549 static void int74_function();
!BCC_EOS
! 550 static Bit16u get_CS();
!BCC_EOS
! 551 static Bit16u get_SS();
!BCC_EOS
! 552 static unsigned int enqueue_key();
!BCC_EOS
! 553 static unsigned int dequeue_key();
!BCC_EOS
! 554 static void get_hd_geometry();
!BCC_EOS
! 555 static void set_diskette_ret_status();
!BCC_EOS
! 556 static void set_diskette_current_cyl();
!BCC_EOS
! 557 static void determine_floppy_media();
!BCC_EOS
! 558 static bx_bool floppy_drive_exists();
!BCC_EOS
! 559 static bx_bool floppy_drive_recal();
!BCC_EOS
! 560 static bx_bool floppy_media_known();
!BCC_EOS
! 561 static bx_bool floppy_media_sense();
!BCC_EOS
! 562 static bx_bool set_enable_a20();
!BCC_EOS
! 563 static void debugger_on();
!BCC_EOS
! 564 static void debugger_off();
!BCC_EOS
! 565 static void keyboard_init();
!BCC_EOS
! 566 static void keyboard_panic();
!BCC_EOS
! 567 static void shutdown_status_panic();
!BCC_EOS
! 568 static void nmi_handler_msg();
!BCC_EOS
! 569 static void delay_ticks();
!BCC_EOS
! 570 static void delay_ticks_and_check_for_keystroke();
!BCC_EOS
! 571 static void interactive_bootkey();
!BCC_EOS
! 572 static void print_bios_banner();
!BCC_EOS
! 573 static void print_boot_device();
!BCC_EOS
! 574 static void print_boot_failure();
!BCC_EOS
! 575 static void print_cdromboot_failure();
!BCC_EOS
! 576 void ata_init();
!BCC_EOS
! 577 void ata_detect();
!BCC_EOS
! 578 void ata_reset();
!BCC_EOS
! 579 Bit16u ata_cmd_non_data();
!BCC_EOS
! 580 Bit16u ata_cmd_data_in();
!BCC_EOS
! 581 Bit16u ata_cmd_data_out();
!BCC_EOS
! 582 Bit16u ata_cmd_packet();
!BCC_EOS
! 583 Bit16u atapi_get_sense();
!BCC_EOS
! 584 Bit16u atapi_is_ready();
!BCC_EOS
! 585 Bit16u atapi_is_cdrom();
!BCC_EOS
! 586 void cdemu_init();
!BCC_EOS
! 587 Bit8u cdemu_isactive();
!BCC_EOS
! 588 Bit8u cdemu_emulated_drive();
!BCC_EOS
! 589 Bit16u cdrom_boot();
!BCC_EOS
! 590 static char bios_cvs_version_string[] = "$Revision: 1.221 $ $Date: 2008/12/07 17:32:29 $";
.data
_bios_cvs_version_string:
.1:
.ascii	"$Revision: 1.221 $ $Date: 2008/12/07 17:"
.ascii	"32:29 $"
.byte	0
!BCC_EOS
! 591 static struct {
! 592   Bit16u normal;
!BCC_EOS
! 593   Bit16u shift;
!BCC_EOS
! 594   Bit16u control;
!BCC_EOS
! 595   Bit16u alt;
!BCC_EOS
! 596   Bit8u lock_flags;
!BCC_EOS
! 597   } scan_to_scanascii[0x58 + 1] = {
_scan_to_scanascii:
! 598       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 599       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
.word	$11B
.word	$11B
.word	$11B
.word	$100
.byte	0
.blkb	1
! 600       { 0x0231, 0x0221, 0, 0x7800, 0 },
.word	$231
.word	$221
.word	0
.word	$7800
.byte	0
.blkb	1
! 601       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
.word	$332
.word	$340
.word	$300
.word	$7900
.byte	0
.blkb	1
! 602       { 0x0433, 0x0423, 0, 0x7a00, 0 },
.word	$433
.word	$423
.word	0
.word	$7A00
.byte	0
.blkb	1
! 603       { 0x0534, 0x0524, 0, 0x7b00, 0 },
.word	$534
.word	$524
.word	0
.word	$7B00
.byte	0
.blkb	1
! 604       { 0x0635, 0x0625, 0, 0x7c00, 0 },
.word	$635
.word	$625
.word	0
.word	$7C00
.byte	0
.blkb	1
! 605       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
.word	$736
.word	$75E
.word	$71E
.word	$7D00
.byte	0
.blkb	1
! 606       { 0x0837, 0x0826, 0, 0x7e00, 0 },
.word	$837
.word	$826
.word	0
.word	$7E00
.byte	0
.blkb	1
! 607       { 0x0938, 0x092a, 0, 0x7f00, 0 },
.word	$938
.word	$92A
.word	0
.word	$7F00
.byte	0
.blkb	1
! 608       { 0x0a39, 0x0a28, 0, 0x800
.word	$A39
.word	$A28
.word	0
! 608 0, 0 },
.word	$8000
.byte	0
.blkb	1
! 609       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
.word	$B30
.word	$B29
.word	0
.word	$8100
.byte	0
.blkb	1
! 610       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
.word	$C2D
.word	$C5F
.word	$C1F
.word	$8200
.byte	0
.blkb	1
! 611       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
.word	$D3D
.word	$D2B
.word	0
.word	$8300
.byte	0
.blkb	1
! 612       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
.word	$E08
.word	$E08
.word	$E7F
.word	0
.byte	0
.blkb	1
! 613       { 0x0f09, 0x0f00, 0, 0, 0 },
.word	$F09
.word	$F00
.word	0
.word	0
.byte	0
.blkb	1
! 614       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
.word	$1071
.word	$1051
.word	$1011
.word	$1000
.byte	$40
.blkb	1
! 615       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
.word	$1177
.word	$1157
.word	$1117
.word	$1100
.byte	$40
.blkb	1
! 616       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
.word	$1265
.word	$1245
.word	$1205
.word	$1200
.byte	$40
.blkb	1
! 617       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
.word	$1372
.word	$1352
.word	$1312
.word	$1300
.byte	$40
.blkb	1
! 618       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
.word	$1474
.word	$1454
.word	$1414
.word	$1400
.byte	$40
.blkb	1
! 619       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
.word	$1579
.word	$1559
.word	$1519
.word	$1500
.byte	$40
.blkb	1
! 620       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
.word	$1675
.word	$1655
.word	$1615
.word	$1600
.byte	$40
.blkb	1
! 621       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
.word	$1769
.word	$1749
.word	$1709
.word	$1700
.byte	$40
.blkb	1
! 622       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
.word	$186F
.word	$184F
.word	$180F
.word	$1800
.byte	$40
.blkb	1
! 623       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
.word	$1970
.word	$1950
.word	$1910
.word	$1900
.byte	$40
.blkb	1
! 624       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
.word	$1A5B
.word	$1A7B
.word	$1A1B
.word	0
.byte	0
.blkb	1
! 625       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
.word	$1B5D
.word	$1B7D
.word	$1B1D
.word	0
.byte	0
.blkb	1
! 626       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
.word	$1C0D
.word	$1C0D
.word	$1C0A
.word	0
.byte	0
.blkb	1
! 627       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 628       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
.word	$1E61
.word	$1E41
.word	$1E01
.word	$1E00
.byte	$40
.blkb	1
! 629       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
.word	$1F73
.word	$1F53
.word	$1F13
.word	$1F00
.byte	$40
.blkb	1
! 630       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
.word	$2064
.word	$2044
.word	$2004
.word	$2000
.byte	$40
.blkb	1
! 631       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
.word	$2166
.word	$2146
.word	$2106
.word	$2100
.byte	$40
.blkb	1
! 632       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
.word	$2267
.word	$2247
.word	$2207
.word	$2200
.byte	$40
.blkb	1
! 633       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
.word	$2368
.word	$2348
.word	$2308
.word	$2300
.byte	$40
.blkb	1
! 634       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
.word	$246A
.word	$244A
.word	$240A
.word	$2400
.byte	$40
.blkb	1
! 635       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
.word	$256B
.word	$254B
.word	$250B
.word	$2500
.byte	$40
.blkb	1
! 636       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
.word	$266C
.word	$264C
.word	$260C
.word	$2600
.byte	$40
.blkb	1
! 637       { 0x273b, 0x273a, 0, 0, 0 },
.word	$273B
.word	$273A
.word	0
.word	0
.byte	0
.blkb	1
! 638       { 0x2827, 0x2822, 0, 0, 0 },
.word	$2827
.word	$2822
.word	0
.word	0
.byte	0
.blkb	1
! 639       { 0x2960, 0x297e, 0, 0, 0 },
.word	$2960
.word	$297E
.word	0
.word	0
.byte	0
.blkb	1
! 640       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 641       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
.word	$2B5C
.word	$2B7C
.word	$2B1C
.word	0
.byte	0
.blkb	1
! 642       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
.word	$2C7A
.word	$2C5A
.word	$2C1A
.word	$2C00
.byte	$40
.blkb	1
! 643       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
.word	$2D78
.word	$2D58
.word	$2D18
.word	$2D00
.byte	$40
.blkb	1
! 644       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
.word	$2E63
.word	$2E43
.word	$2E03
.word	$2E00
.byte	$40
.blkb	1
! 645       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
.word	$2F76
.word	$2F56
.word	$2F16
.word	$2F00
.byte	$40
.blkb	1
! 646       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
.word	$3062
.word	$3042
.word	$3002
.word	$3000
.byte	$40
.blkb	1
! 647       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
.word	$316E
.word	$314E
.word	$310E
.word	$3100
.byte	$40
.blkb	1
! 648       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
.word	$326D
.word	$324D
.word	$320D
.word	$3200
.byte	$40
.blkb	1
! 649       { 0x332c, 0x333c, 0, 0, 0 },
.word	$332C
.word	$333C
.word	0
.word	0
.byte	0
.blkb	1
! 650       { 0x342e, 0x343e, 0, 0, 0 },
.word	$342E
.word	$343E
.word	0
.word	0
.byte	0
.blkb	1
! 651       { 0x352f, 0x353f, 0, 0, 0 },
.word	$352F
.word	$353F
.word	0
.word	0
.byte	0
.blkb	1
! 652       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 653       { 0x372a, 0x372a, 0, 0, 0 },
.word	$372A
.word	$372A
.word	0
.word	0
.byte	0
.blkb	1
! 654       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 655       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
.word	$3920
.word	$3920
.word	$3920
.word	$3920
.byte	0
.blkb	1
! 656       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 657       { 0x3b00, 0
.word	$3B00
! 657 x5400, 0x5e00, 0x6800, 0 },
.word	$5400
.word	$5E00
.word	$6800
.byte	0
.blkb	1
! 658       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
.word	$3C00
.word	$5500
.word	$5F00
.word	$6900
.byte	0
.blkb	1
! 659       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
.word	$3D00
.word	$5600
.word	$6000
.word	$6A00
.byte	0
.blkb	1
! 660       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
.word	$3E00
.word	$5700
.word	$6100
.word	$6B00
.byte	0
.blkb	1
! 661       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
.word	$3F00
.word	$5800
.word	$6200
.word	$6C00
.byte	0
.blkb	1
! 662       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
.word	$4000
.word	$5900
.word	$6300
.word	$6D00
.byte	0
.blkb	1
! 663       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
.word	$4100
.word	$5A00
.word	$6400
.word	$6E00
.byte	0
.blkb	1
! 664       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
.word	$4200
.word	$5B00
.word	$6500
.word	$6F00
.byte	0
.blkb	1
! 665       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
.word	$4300
.word	$5C00
.word	$6600
.word	$7000
.byte	0
.blkb	1
! 666       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
.word	$4400
.word	$5D00
.word	$6700
.word	$7100
.byte	0
.blkb	1
! 667       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 668       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 669       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
.word	$4700
.word	$4737
.word	$7700
.word	0
.byte	$20
.blkb	1
! 670       { 0x4800, 0x4838, 0, 0, 0x20 },
.word	$4800
.word	$4838
.word	0
.word	0
.byte	$20
.blkb	1
! 671       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
.word	$4900
.word	$4939
.word	$8400
.word	0
.byte	$20
.blkb	1
! 672       { 0x4a2d, 0x4a2d, 0, 0, 0 },
.word	$4A2D
.word	$4A2D
.word	0
.word	0
.byte	0
.blkb	1
! 673       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
.word	$4B00
.word	$4B34
.word	$7300
.word	0
.byte	$20
.blkb	1
! 674       { 0x4c00, 0x4c35, 0, 0, 0x20 },
.word	$4C00
.word	$4C35
.word	0
.word	0
.byte	$20
.blkb	1
! 675       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
.word	$4D00
.word	$4D36
.word	$7400
.word	0
.byte	$20
.blkb	1
! 676       { 0x4e2b, 0x4e2b, 0, 0, 0 },
.word	$4E2B
.word	$4E2B
.word	0
.word	0
.byte	0
.blkb	1
! 677       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
.word	$4F00
.word	$4F31
.word	$7500
.word	0
.byte	$20
.blkb	1
! 678       { 0x5000, 0x5032, 0, 0, 0x20 },
.word	$5000
.word	$5032
.word	0
.word	0
.byte	$20
.blkb	1
! 679       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
.word	$5100
.word	$5133
.word	$7600
.word	0
.byte	$20
.blkb	1
! 680       { 0x5200, 0x5230, 0, 0, 0x20 },
.word	$5200
.word	$5230
.word	0
.word	0
.byte	$20
.blkb	1
! 681       { 0x5300, 0x532e, 0, 0, 0x20 },
.word	$5300
.word	$532E
.word	0
.word	0
.byte	$20
.blkb	1
! 682       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 683       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 684       { 0x565c, 0x567c, 0, 0, 0 },
.word	$565C
.word	$567C
.word	0
.word	0
.byte	0
.blkb	1
! 685       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
.word	$8500
.word	$8700
.word	$8900
.word	$8B00
.byte	0
.blkb	1
! 686       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
.word	$8600
.word	$8800
.word	$8A00
.word	$8C00
.byte	0
.blkb	1
! 687       };
!BCC_EOS
! 688   Bit8u
! 689 inb(port)
! 690   Bit16u port;
.text
export	_inb
_inb:
!BCC_EOS
! 691 {
! 692 #asm
!BCC_ASM
_inb.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in al, dx
    pop dx
  pop bp
! 700 endasm
!BCC_ENDASM
! 701 }
ret
! 702   Bit16u
! 703 inw(port)
! 704   Bit16u port;
export	_inw
_inw:
!BCC_EOS
! 705 {
! 706 #asm
!BCC_ASM
_inw.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in ax, dx
    pop dx
  pop bp
! 714 endasm
!BCC_ENDASM
! 715 }
ret
! 716   void
! 717 outb(port, val)
! 718   Bit16u port;
export	_outb
_outb:
!BCC_EOS
! 719   Bit8u val;
!BCC_EOS
! 720 {
! 721 #asm
!BCC_ASM
_outb.val	set	4
_outb.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov al, 6[bp]
    out dx, al
    pop dx
    pop ax
  pop bp
! 732 endasm
!BCC_ENDASM
! 733 }
ret
! 734   void
! 735 outw(port, val)
! 736   Bit16u port;
export	_outw
_outw:
!BCC_EOS
! 737   Bit16u val;
!BCC_EOS
! 738 {
! 739 #asm
!BCC_ASM
_outw.val	set	4
_outw.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov ax, 6[bp]
    out dx, ax
    pop dx
    pop ax
  pop bp
! 750 endasm
!BCC_ENDASM
! 751 }
ret
! 752   void
! 753 outb_cmos(cmos_reg, val)
! 754   Bit8u cmos_reg;
export	_outb_cmos
_outb_cmos:
!BCC_EOS
! 755   Bit8u val;
!BCC_EOS
! 756 {
! 757 #asm
!BCC_ASM
_outb_cmos.cmos_reg	set	2
_outb_cmos.val	set	4
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    mov al, 6[bp] ;; val
    out 0x71, al
  pop bp
! 765 e
!BCC_ENDASM
! 766 }
ret
! 767   Bit8u
! 768 inb_cmos(cmos_reg)
! 769   Bit8u cmos_reg;
export	_inb_cmos
_inb_cmos:
!BCC_EOS
! 770 {
! 771 #asm
!BCC_ASM
_inb_cmos.cmos_reg	set	2
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    in al, 0x71
  pop bp
! 778 endasm
!BCC_ENDASM
! 779 }
ret
! 780   void
! 781 init_rtc()
! 782 {
export	_init_rtc
_init_rtc:
! 783   outb_cmos(0x0a, 0x26);
push	bp
mov	bp,sp
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 784   outb_cmos(0x0b, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 785   inb_cmos(0x0c);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 786   inb_cmos(0x0d);
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 787 }
pop	bp
ret
! 788   bx_bool
! 789 rtc_updating()
! 790 {
export	_rtc_updating
_rtc_updating:
! 791   Bit16u count;
!BCC_EOS
! 792   count = 25000;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
mov	ax,#$61A8
mov	-2[bp],ax
!BCC_EOS
! 793   while (--count != 0) {
jmp .3
.4:
! 794     if ( (inb_cmos(0x0a) & 0x80) == 0 )
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.5
.6:
! 795       return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 796     }
.5:
! 797   return(1);
.3:
! Debug: predec unsigned short count = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.4
.7:
.2:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 798 }
! 799   Bit8u
! 800 read_byte(seg, offset)
! 801   Bit16u seg;
export	_read_byte
_read_byte:
!BCC_EOS
! 802   Bit16u offset;
!BCC_EOS
! 803 {
! 804 #asm
!BCC_ASM
_read_byte.seg	set	2
_read_byte.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, [bx]
    ;; al = return value (byte)
    pop ds
    pop bx
  pop bp
! 817 endasm
!BCC_ENDASM
! 818 }
ret
! 819   Bit16u
! 820 read_word(seg, offset)
! 821   Bit16u seg;
export	_read_word
_read_word:
!BCC_EOS
! 822   Bit16u offset;
!BCC_EOS
! 823 {
! 824 #asm
!BCC_ASM
_read_word.seg	set	2
_read_word.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, [bx]
    ;; ax = return value (word)
    pop ds
    pop bx
  pop bp
! 837 endasm
!BCC_ENDASM
! 838 }
ret
! 839   void
! 840 write_byte(seg, offset, data)
! 841   Bit16u seg;
export	_write_byte
_write_byte:
!BCC_EOS
! 842   Bit16u offset;
!BCC_EOS
! 843   Bit8u data;
!BCC_EOS
! 844 {
! 845 #asm
!BCC_ASM
_write_byte.seg	set	2
_write_byte.data	set	6
_write_byte.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, 8[bp] ; data byte
    mov [bx], al ; write data byte
    pop ds
    pop bx
    pop ax
  pop bp
! 860 endasm
!BCC_ENDASM
! 861 }
ret
! 862   void
! 863 write_word(seg, offset, data)
! 864   Bit16u seg;
export	_write_word
_write_word:
!BCC_EOS
! 865   Bit16u offset;
!BCC_EOS
! 866   Bit16u data;
!BCC_EOS
! 867 {
! 868 #asm
!BCC_ASM
_write_word.seg	set	2
_write_word.data	set	6
_write_word.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, 8[bp] ; data word
    mov [bx], ax ; write data word
    pop ds
    pop bx
    pop ax
  pop bp
! 883 endasm
!BCC_ENDASM
! 884 }
ret
! 885   Bit16u
! 886 get_CS()
! 887 {
export	_get_CS
_get_CS:
! 888 #asm
!BCC_ASM
  mov ax, cs
! 890 endasm
!BCC_ENDASM
! 891 }
ret
! 892   Bit16u
! 893 get_SS()
! 894 {
export	_get_SS
_get_SS:
! 895 #asm
!BCC_ASM
  mov ax, ss
! 897 endasm
!BCC_ENDASM
! 898 }
ret
! 899 void
! 900 fixup_base_mem_in_k()
! 901 {
export	_fixup_base_mem_in_k
_fixup_base_mem_in_k:
! 902   Bit32u base_mem = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 8);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+6-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 903   write_word(0x40, 0x13, base_mem >> 10);
! Debug: sr int = const $A to unsigned long base_mem = [S+6-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*2
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $13 (used reg = )
mov	ax,*$13
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 904 }
mov	sp,bp
pop	bp
ret
! 905 void enable_rom_write_access()
! Register BX used in function fixup_base_mem_in_k
! 906 {
export	_enable_rom_write_access
_enable_rom_write_access:
! 907     outb(0x10, 0);
push	bp
mov	bp,sp
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 908 }
pop	bp
ret
! 909 void disable_rom_write_access()
! 910 {
export	_disable_rom_write_access
_disable_rom_write_access:
! 911     outb(0x10, 1);
push	bp
mov	bp,sp
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 912 }
pop	bp
ret
! 913   void
! 914 wrch(c)
! 915   Bit8u c;
export	_wrch
_wrch:
!BCC_EOS
! 916 {
! 917 #asm
!BCC_ASM
_wrch.c	set	2
  push bp
  mov bp, sp
  push bx
  mov ah, #0x0e
  mov al, 4[bp]
  xor bx,bx
  int #0x10
  pop bx
  pop bp
! 927 endasm
!BCC_ENDASM
! 928 }
ret
! 929   void
! 930 send(action, c)
! 931   Bit16u action;
export	_send
_send:
!BCC_EOS
! 932   Bit8u c;
!BCC_EOS
! 933 {
! 934   outb(0xE9, c);
push	bp
mov	bp,sp
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $E9 (used reg = )
mov	ax,#$E9
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 935   if (action & 8) outb(0x403, c);
! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*8
test	al,al
je  	.8
.9:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $403 (used reg = )
mov	ax,#$403
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 936   if (action & 4) outb(0x402, c);
.8:
! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*4
test	al,al
je  	.A
.B:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $402 (used reg = )
mov	ax,#$402
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 937   if (action & 2) {
.A:
! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*2
test	al,al
je  	.C
.D:
! 938     if (c == '\n') wrch('\r');
! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
cmp	al,*$A
jne 	.E
.F:
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 939     wrch(c);
.E:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 940   }
! 941 }
.C:
pop	bp
ret
! 942   void
! 943 put_int(action, val, width, neg)
! 944   Bit16u action;
export	_put_int
_put_int:
!BCC_EOS
! 945   short val, width;
!BCC_EOS
! 946   bx_bool neg;
!BCC_EOS
! 947 {
! 948   short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
cwd
idiv	bx
! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 949   if (nval)
mov	ax,-2[bp]
test	ax,ax
je  	.10
.11:
! 950     put_int(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 951   else {
jmp .12
.10:
! 952     while (--width > 0) send(action, ' ');
jmp .14
.15:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 953     if (neg) send(action, '-');
.14:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.15
.16:
.13:
mov	ax,$A[bp]
test	ax,ax
je  	.17
.18:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 954   }
.17:
! 955   send(action, val - (nval * 10) + '0');
.12:
! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to int = ax+0 (used reg = )
! Debug: list int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 956 }
mov	sp,bp
pop	bp
ret
! 957   void
! Register BX used in function put_int
! 958 put_uint(action, val, width, neg)
! 959   Bit16u action;
export	_put_uint
_put_uint:
!BCC_EOS
! 960   unsigned short val;
!BCC_EOS
! 961   short width;
!BCC_EOS
! 962   bx_bool neg;
!BCC_EOS
! 963 {
! 964   unsigned short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
call	idiv_u
! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 965   if (nval)
mov	ax,-2[bp]
test	ax,ax
je  	.19
.1A:
! 966     put_uint(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 967   else {
jmp .1B
.19:
! 968     while (--width > 0) send(action, ' ');
jmp .1D
.1E:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 969     if (neg) send(action, '-');
.1D:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.1E
.1F:
.1C:
mov	ax,$A[bp]
test	ax,ax
je  	.20
.21:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 970   }
.20:
! 971   send(action, val - (nval * 10) + '0');
.1B:
! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 972 }
mov	sp,bp
pop	bp
ret
! 973   void
! Register BX used in function put_uint
! 974 put_luint(action, val, width, neg)
! 975   Bit16u action;
export	_put_luint
_put_luint:
!BCC_EOS
! 976   unsigned long val;
!BCC_EOS
! 977   short width;
!BCC_EOS
! 978   bx_bool neg;
!BCC_EOS
! 979 {
! 980   unsigned long nval = val / 10;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
mov	ax,*$A
xor	bx,bx
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 981   if (nval)
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
je  	.22
.23:
! 982     put_luint(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+6+$A] (used reg = )
push	$C[bp]
! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned long nval = [S+$A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short action = [S+$E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 983   else {
jmp .24
.22:
! 984     while (--width > 0) send(action, ' ');
jmp .26
.27:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 985     if (neg) send(action, '-');
.26:
! Debug: predec short width = [S+6+8] (used reg = )
mov	ax,$A[bp]
dec	ax
mov	$A[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.27
.28:
.25:
mov	ax,$C[bp]
test	ax,ax
je  	.29
.2A:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 986   }
.29:
! 987   send(action, val - (nval * 10) + '0');
.24:
! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$A
xor	bx,bx
lea	di,-4[bp]
call	lmulul
! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	lsubul
add	sp,*4
! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$30
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-$C[bp]
call	laddul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*6
!BCC_EOS
! 988 }
mov	sp,bp
pop	bp
ret
! 989 void put_str(action, segment, offset)
! Register BX used in function put_luint
! 990   Bit16u action;
export	_put_str
_put_str:
!BCC_EOS
! 991   Bit16u segment;
!BCC_EOS
! 992   Bit16u offset;
!BCC_EOS
! 993 {
! 994   Bit8u c;
!BCC_EOS
! 995   while (c = read_byte(segment, offset)) {
push	bp
mov	bp,sp
dec	sp
dec	sp
jmp .2C
.2D:
! 996     send(action, c);
! Debug: list unsigned char c = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 997     offset++;
! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
mov	ax,8[bp]
inc	ax
mov	8[bp],ax
!BCC_EOS
! 998   }
! 999 }
.2C:
! Debug: list unsigned short offset = [S+4+6] (used reg = )
push	8[bp]
! Debug: list unsigned short segment = [S+6+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
mov	-1[bp],al
test	al,al
jne	.2D
.2E:
.2B:
mov	sp,bp
pop	bp
ret
! 1000   void
! 1001 delay_ticks(ticks)
! 1002   Bit16u ticks;
export	_delay_ticks
_delay_ticks:
!BCC_EOS
! 1003 {
! 1004   long ticks_to_wait, delta;
!BCC_EOS
! 1005   Bit32u prev_ticks, t;
!BCC_EOS
! 1006 #asm
push	bp
mov	bp,sp
add	sp,*-$10
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  pushf
  sti
! 1009 endasm
!BCC_ENDASM
!BCC_EOS
! 1010   ticks_to_wait = ticks;
! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,4[bp]
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1011   prev_ticks = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 1012   do
! 1013   {
.31:
! 1014 #asm
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
    hlt
! 1016 endasm
!BCC_ENDASM
!BCC_EOS
! 1017     t = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 1018     if (t > prev_ticks)
! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jae 	.32
.33:
! 1019     {
! 1020       delta = t - prev_ticks;
! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
lea	di,-$C[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1021       ticks_to_wait -= delta;
! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-8[bp]
call	lsubl
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1022     }
! 1023     else if (t < prev_ticks)
jmp .34
.32:
! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jbe 	.35
.36:
! 1024     {
! 1025       ticks_to_wait -= t;
! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-$10[bp]
call	lsubul
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1026     }
! 1027     prev_ticks = t;
.35:
.34:
! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 1028   } while (ticks_to_wait > 0);
.30:
! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
xor	ax,ax
xor	bx,bx
lea	di,-4[bp]
call	lcmpl
blt 	.31
.37:
!BCC_EOS
! 1029 #asm
.2F:
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  cli
  popf
! 1032 endasm
!BCC_ENDASM
!BCC_EOS
! 1033 }
mov	sp,bp
pop	bp
ret
! 1034   Bit8u
! Register BX used in function delay_ticks
! 1035 check_for_keystroke()
! 1036 {
export	_check_for_keystroke
_check_for_keystroke:
! 1037 #asm
!BCC_ASM
  mov ax, #0x100
  int #0x16
  jz no_key
  mov al, #1
  jmp done
no_key:
  xor al, al
done:
! 1046 endasm
!BCC_ENDASM
! 1047 }
ret
! 1048   Bit8u
! 1049 get_keystroke()
! 1050 {
export	_get_keystroke
_get_keystroke:
! 1051 #asm
!BCC_ASM
  mov ax, #0x0
  int #0x16
  xchg ah, al
! 1055 endasm
!BCC_ENDASM
! 1056 }
ret
! 1057   void
! 1058 delay_ticks_and_check_for_keystroke(ticks, count)
! 1059   Bit16u ticks, count;
export	_delay_ticks_and_check_for_keystroke
_delay_ticks_and_check_for_keystroke:
!BCC_EOS
! 1060 {
! 1061   Bit16u i;
!BCC_EOS
! 1062   for (i = 1; i <= count; i++) {
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
!BCC_EOS
jmp .3A
.3B:
! 1063     delay_ticks(ticks);
! Debug: list unsigned short ticks = [S+4+2] (used reg = )
push	4[bp]
! Debug: func () void = delay_ticks+0 (used reg = )
call	_delay_ticks
inc	sp
inc	sp
!BCC_EOS
! 1064     if (check_for_keystroke())
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
je  	.3C
.3D:
! 1065       break;
jmp .38
!BCC_EOS
! 1066   }
.3C:
! 1067 }
.39:
! Debug: postinc unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
inc	ax
mov	-2[bp],ax
.3A:
! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,6[bp]
jbe	.3B
.3E:
.38:
mov	sp,bp
pop	bp
ret
! 1068   void
! 1069 bios_printf(action, s)
! 1070   Bit16u action;
export	_bios_printf
_bios_printf:
!BCC_EOS
! 1071   Bit8u *s;
!BCC_EOS
! 1072 {
! 1073   Bit8u c, format_char;
!BCC_EOS
! 1074   bx_bool in_format;
!BCC_EOS
! 1075   short i;
!BCC_EOS
! 1076   Bit16u *arg_ptr;
!BCC_EOS
! 1077   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
!BCC_EOS
! 1078   arg_ptr = &s;
push	bp
mov	bp,sp
add	sp,*-$16
! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
lea	bx,6[bp]
mov	-8[bp],bx
!BCC_EOS
! 1079   arg_seg = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 1080   in_format = 0;
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1081   format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1082   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*7
! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
cmp	al,*7
jne 	.3F
.40:
! 1083     outb(0x401, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $401 (used reg = )
mov	ax,#$401
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1084     bios_printf (2, "FATAL: ");
! Debug: list * char = .41+0 (used reg = )
mov	bx,#.41
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1085   }
! 1086   while (c = read_byte(get_CS(), s)) {
.3F:
br 	.43
.44:
! 1087     if ( c == '%' ) {
! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$25
jne 	.45
.46:
! 1088       in_format = 1;
! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
mov	ax,*1
mov	-4[bp],ax
!BCC_EOS
! 1089       format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1090       }
! 1091     else if (in_format) {
br 	.47
.45:
mov	ax,-4[bp]
test	ax,ax
beq 	.48
.49:
! 1092       if ( (c>='0') && (c<='9') ) {
! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$30
jb  	.4A
.4C:
! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$39
ja  	.4A
.4B:
! 1093         format_width = (format_width * 10) + (c - '0');
! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
add	ax,*-$30
push	ax
! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
add	ax,-$18[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1094         }
! 1095       else {
br 	.4D
.4A:
! 1096         arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1097         arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1098         if (c == 'x' || c == 'X') {
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.4F
.50:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
bne 	.4E
.4F:
! 1099           if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.51
.52:
! 1100             format_width = 4;
! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*4
mov	-$14[bp],ax
!BCC_EOS
! 1101           if (c == 'x')
.51:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.53
.54:
! 1102             hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1103           else
! 1104             hexadd = 'A';
jmp .55
.53:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1105           for (i=format_width-1; i>=0; i--) {
.55:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .58
.59:
! 1106             nibble = (arg >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	bx,ax
mov	ax,-$C[bp]
mov	cx,bx
shr	ax,cl
! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 1107             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.5A
.5B:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .5C
.5A:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.5C:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1108             }
! 1109           }
.57:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.58:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.59
.5D:
.56:
! 1110         else if (c == 'u') {
br 	.5E
.4E:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.5F
.60:
! 1111           put_uint(action, arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 1112           }
! 1113         else if (c == 'l') {
br 	.61
.5F:
! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$6C
bne 	.62
.63:
! 1114           s++;
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1115           c = read_byte(get_CS(), s);
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1116           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1117           hibyte = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 1118           if (c == 'd') {
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
jne 	.64
.65:
! 1119             if (hibyte & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$10[bp]
and	ax,#$8000
test	ax,ax
je  	.66
.67:
! 1120               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
push	bx
push	ax
xor	ax,ax
xor	bx,bx
lea	di,-$1E[bp]
call	lsubul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1121             else
! 1122               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
jmp .68
.66:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1123            }
.68:
! 1124           else if (c == 'u') {
br 	.69
.64:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.6A
.6B:
! 1125             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1126      
! 1126       }
! 1127           else if (c == 'x' || c == 'X')
br 	.6C
.6A:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.6E
.6F:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
bne 	.6D
.6E:
! 1128            {
! 1129             if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.70
.71:
! 1130               format_width = 8;
! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*8
mov	-$14[bp],ax
!BCC_EOS
! 1131             if (c == 'x')
.70:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.72
.73:
! 1132               hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1133             else
! 1134               hexadd = 'A';
jmp .74
.72:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1135             for (i=format_width-1; i>=0; i--) {
.74:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .77
.78:
! 1136               nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
lea	di,-$1C[bp]
call	lorul
add	sp,*4
! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
mov	di,-$18[bp]
call	lsrul
inc	sp
inc	sp
! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 1137               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.79
.7A:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .7B
.79:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.7B:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1138               }
! 1139            }
.76:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.77:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.78
.7C:
.75:
! 1140           }
.6D:
.6C:
.69:
! 1141         else if (c == 'd') {
br 	.7D
.62:
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
jne 	.7E
.7F:
! 1142           if (arg & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
mov	ax,-$C[bp]
and	ax,#$8000
test	ax,ax
je  	.80
.81:
! 1143             put_int(action, -arg, format_width - 1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
xor	ax,ax
sub	ax,-$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1144           else
! 1145             put_int(action, arg, format_width, 0);
jmp .82
.80:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1146           }
.82:
! 1147         else if (c == 's') {
jmp .83
.7E:
! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$73
jne 	.84
.85:
! 1148           put_str(action, get_CS(), arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1149           }
! 1150         else if (c == 'S') {
jmp .86
.84:
! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
jne 	.87
.88:
! 1151           hibyte = arg;
! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$C[bp]
mov	-$10[bp],ax
!BCC_EOS
! 1152           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1153           arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1154           put_str(action, hibyte, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1155           }
! 1156         else if (c == 'c') {
jmp .89
.87:
! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$63
jne 	.8A
.8B:
! 1157           send(action, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1158           }
! 1159         else
! 1160           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
jmp .8C
.8A:
! Debug: list * char = .8D+0 (used reg = )
mov	bx,#.8D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1161           in_format = 0;
.8C:
.89:
.86:
.83:
.7D:
.61:
.5E:
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1162         }
! 1163       }
.4D:
! 1164     else {
jmp .8E
.48:
! 1165       send(action, c);
! Debug: list unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1166       }
! 1167     s ++;
.8E:
.47:
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1168     }
! 1169   if (action & 1) {
.43:
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
test	al,al
bne 	.44
.8F:
.42:
! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*1
test	al,al
je  	.90
.91:
! 1170 #asm
!BCC_EOS
!BCC_ASM
_bios_printf.format_width	set	2
.bios_printf.format_width	set	-$14
_bios_printf.format_char	set	$14
.bios_printf.format_char	set	-2
_bios_printf.hibyte	set	6
.bios_printf.hibyte	set	-$10
_bios_printf.arg_ptr	set	$E
.bios_printf.arg_ptr	set	-8
_bios_printf.action	set	$1A
.bios_printf.action	set	4
_bios_printf.i	set	$10
.bios_printf.i	set	-6
_bios_printf.arg_seg	set	$C
.bios_printf.arg_seg	set	-$A
_bios_printf.shift_count	set	4
.bios_printf.shift_count	set	-$12
_bios_printf.in_format	set	$12
.bios_printf.in_format	set	-4
_bios_printf.s	set	$1C
.bios_printf.s	set	6
_bios_printf.nibble	set	8
.bios_printf.nibble	set	-$E
_bios_printf.c	set	$15
.bios_printf.c	set	-1
_bios_printf.hexadd	set	0
.bios_printf.hexadd	set	-$16
_bios_printf.arg	set	$A
.bios_printf.arg	set	-$C
    cli
 halt2_loop:
    hlt
    jmp halt2_loop
! 1175 endasm
!BCC_ENDASM
!BCC_EOS
! 1176     }
! 1177 }
.90:
mov	sp,bp
pop	bp
ret
! 1178   void
! Register BX used in function bios_printf
! 1179 keyboard_init()
! 1180 {
export	_keyboard_init
_keyboard_init:
! 1181     Bit16u max;
!BCC_EOS
! 1182     max=0xffff;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1183     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .93
.94:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1184     max=0x2000;
.93:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.95
.96:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.94
.95:
.92:
! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$2000
mov	-2[bp],ax
!BCC_EOS
! 1185     while (--max > 0) {
jmp .98
.99:
! 1186         outb(0x80, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1187         if (inb(0x64) & 0x01) {
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
je  	.9A
.9B:
! 1188             inb(0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 1189             max = 0x2000;
! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$2000
mov	-2[bp],ax
!BCC_EOS
! 1190             }
! 1191         }
.9A:
! 1192     outb(0x64, 0xaa);
.98:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.99
.9C:
.97:
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1193     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1194     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .9E
.9F:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1195     if (max==0x0) keyboard_panic(00);
.9E:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.A0
.A1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.9F
.A0:
.9D:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A2
.A3:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1196     max=0xffff;
.A2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1197     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
jmp .A5
.A6:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1198     if (max==0x0) keyboard_panic(01);
.A5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.A7
.A8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.A6
.A7:
.A4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A9
.AA:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1199     if ((inb(0x60) != 0x55)){
.A9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
cmp	al,*$55
je  	.AB
.AC:
! 1200         keyboard_panic(991);
! Debug: list int = const $3DF (used reg = )
mov	ax,#$3DF
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1201     }
! 1202     outb(0x64,0xab);
.AB:
! Debug: list int = const $AB (used reg = )
mov	ax,#$AB
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1203     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1204     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
jmp .AE
.AF:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1205     if (max==0x0) keyboard_panic(10);
.AE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.B0
.B1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.AF
.B0:
.AD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B2
.B3:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1206     max=0xffff;
.B2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1207     while ( ((inb
! 1207 (0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
jmp .B5
.B6:
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1208     if (max==0x0) keyboard_panic(11);
.B5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.B7
.B8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.B6
.B7:
.B4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B9
.BA:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1209     if ((inb(0x60) != 0x00)) {
.B9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.BB
.BC:
! 1210         keyboard_panic(992);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1211     }
! 1212     outb(0x64,0xae);
.BB:
! Debug: list int = const $AE (used reg = )
mov	ax,#$AE
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1213     outb(0x64,0xa8);
! Debug: list int = const $A8 (used reg = )
mov	ax,#$A8
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1214     outb(0x60, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1215     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1216     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20);
jmp .BE
.BF:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1217     if (max==0x0) keyboard_panic(20);
.BE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.C0
.C1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.BF
.C0:
.BD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C2
.C3:
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1218     max=0xffff;
.C2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1219     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
jmp .C5
.C6:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1220     if (max==0x0) keyboard_panic(21);
.C5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.C7
.C8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.C6
.C7:
.C4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C9
.CA:
! Debug: list int = const $15 (used reg = )
mov	ax,*$15
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1221     if ((inb(0x60) != 0xfa)) {
.C9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.CB
.CC:
! 1222         keyboard_panic(993);
! Debug: list int = const $3E1 (used reg = )
mov	ax,#$3E1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1223     }
! 1224     max=0xffff;
.CB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1225     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
jmp .CE
.CF:
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1226     if (max==0x0) keyboard_panic(31);
.CE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.D0
.D1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.CF
.D0:
.CD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.D2
.D3:
! Debug: list int = const $1F (used reg = )
mov	ax,*$1F
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1227     if ((inb(0x60) != 0xaa)) {
.D2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
cmp	al,#$AA
je  	.D4
.D5:
! 1228         keyboard_panic(994);
! Debug: list int = const $3E2 (used reg = )
mov	ax,#$3E2
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1229     }
! 1230     outb(0x60, 0xf5);
.D4:
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1231     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1232     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
jmp .D7
.D8:
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1233     if (max==0x0) keyboard_panic(40);
.D7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.D9
.DA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.D8
.D9:
.D6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.DB
.DC:
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1234     max=0xffff;
.DB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1235     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
jmp .DE
.DF:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1236     if (max==0x0) keyboard_panic(41);
.DE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.E0
.E1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.DF
.E0:
.DD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.E2
.E3:
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1237     if ((inb(0x60) != 0xfa)) {
.E2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.E4
.E5:
! 1238         keyboard_panic(995);
! Debug: list int = const $3E3 (used reg = )
mov	ax,#$3E3
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1239     }
! 1240     outb(0x64, 0x60);
.E4:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1241     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1242     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
jmp .E7
.E8:
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1243     if (max==0x0) keyboard_panic(50);
.E7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.E9
.EA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.E8
.E9:
.E6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.EB
.EC:
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1244     outb(0x60, 0x61);
.EB:
! Debug: list int = const $61 (used reg = )
mov	ax,*$61
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1245     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1246     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
jmp .EE
.EF:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1247     if (max==0x0) keyboard_panic(60);
.EE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F0
.F1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.EF
.F0:
.ED:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F2
.F3:
! Debug: list int = const $3C (used reg = )
mov	ax,*$3C
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1248     outb(0x60, 0xf4);
.F2:
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1249     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1250     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
jmp .F5
.F6:
! Debug: list int = const $70 (used reg = )
mov	ax,*$70
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1251     if (max==0x0) keyboard_panic(70);
.F5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F7
.F8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.F6
.F7:
.F4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F9
.FA:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1252     max=0xffff;
.F9:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1253     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
jmp .FC
.FD:
! Debug: list int = const $71 (used reg = )
mov	ax,*$71
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1254     if (max==0x0) keyboard_panic(70);
.FC:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.FE
.FF:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.FD
.FE:
.FB:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.100
.101:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1255     if ((inb(0x60) != 0xfa)) {
.100:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.102
.103:
! 1256         keyboard_panic(996);
! Debug: list int = const $3E4 (used reg = )
mov	ax,#$3E4
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1257     }
! 1258     outb(0x80, 0x77);
.102:
! Debug: list int = const $77 (used reg = )
mov	ax,*$77
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1259 }
mov	sp,bp
pop	bp
ret
! 1260   void
! 1261 keyboard_panic(status)
! 1262   Bit16u status;
export	_keyboard_panic
_keyboard_panic:
!BCC_EOS
! 1263 {
! 1264   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
push	bp
mov	bp,sp
! Debug: list unsigned short status = [S+2+2] (used reg = )
push	4[bp]
! Debug: list * char = .104+0 (used reg = )
mov	bx,#.104
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1265 }
pop	bp
ret
! 1266   void
! Register BX used in function keyboard_panic
! 1267 machine_reset()
! 1268 {
export	_machine_reset
_machine_reset:
! 1269 #asm
!BCC_ASM
;we must check whether 0xFE is set or not
;if it is s3 resume, just jmp back to normal Post Entry
;below port io will prevent s3 resume
  mov al, #0x0f
  out 0x70, al
  in al, 0x71
  cmp al, #0xFE
  jz post
! 1278 endasm
!BCC_ENDASM
! 1279   outb(0x64, 0x6
push	bp
mov	bp,sp
! 1279 0);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1280   outb(0x60, 0x14);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1281   outb(0x64, 0xfe);
! Debug: list int = const $FE (used reg = )
mov	ax,#$FE
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1282   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
! Debug: list * char = .105+0 (used reg = )
mov	bx,#.105
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1283 }
pop	bp
ret
! 1284   void
! Register BX used in function machine_reset
! 1285 clobber_entry_point()
! 1286 {
export	_clobber_entry_point
_clobber_entry_point:
! 1287     write_word(0xffff, 0x0001, machine_reset);
push	bp
mov	bp,sp
! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
! Debug: list * () void = machine_reset+0 (used reg = )
mov	bx,#_machine_reset
push	bx
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 1288 }
pop	bp
ret
! 1289   void
! Register BX used in function clobber_entry_point
! 1290 shutdown_status_panic(status)
! 1291   Bit16u status;
export	_shutdown_status_panic
_shutdown_status_panic:
!BCC_EOS
! 1292 {
! 1293   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
push	bp
mov	bp,sp
! Debug: list unsigned char status = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list * char = .106+0 (used reg = )
mov	bx,#.106
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1294 }
pop	bp
ret
! 1295 void s3_resume_panic()
! Register BX used in function shutdown_status_panic
! 1296 {
export	_s3_resume_panic
_s3_resume_panic:
! 1297   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
push	bp
mov	bp,sp
! Debug: list * char = .107+0 (used reg = )
mov	bx,#.107
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1298 }
pop	bp
ret
! 1299 void
! Register BX used in function s3_resume_panic
! 1300 print_bios_banner()
! 1301 {
export	_print_bios_banner
_print_bios_banner:
! 1302   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "06/23/99", bios_cvs_version_string);
push	bp
mov	bp,sp
! Debug: list * char = bios_cvs_version_string+0 (used reg = )
mov	bx,#_bios_cvs_version_string
push	bx
! Debug: list * char = .109+0 (used reg = )
mov	bx,#.109
push	bx
! Debug: list * char = .108+0 (used reg = )
mov	bx,#.108
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1303   bios_printf(2, "apmbios " "pcibios " "eltorito " "PMM " "\n\n");
! Debug: list * char = .10A+0 (used reg = )
mov	bx,#.10A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1304 }
pop	bp
ret
! 1305 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
! Register BX used in function print_bios_banner
.data
_drivetypes:
.10B:
.byte	0
.blkb	9
.10C:
.ascii	"Floppy"
.byte	0
.blkb	3
.10D:
.ascii	"Hard Disk"
.byte	0
.10E:
.ascii	"CD-Rom"
.byte	0
.blkb	3
.10F:
.ascii	"Network"
.byte	0
.blkb	2
!BCC_EOS
! 1306 static void
! 1307 init_boot_vectors()
! 1308 {
.text
_init_boot_vectors:
! 1309   ipl_entry_t e;
!BCC_EOS
! 1310   Bit16u count = 0;
push	bp
mov	bp,sp
add	sp,*-$12
! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
xor	ax,ax
mov	-$12[bp],ax
!BCC_EOS
! 1311   Bit16u ss = get_SS();
dec	sp
dec	sp
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1312   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$18-$18] (used reg = )
mov	-$16[bp],ax
!BCC_EOS
! 1313   memsetb(ebda_seg, 0x0300, 0, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $300 (used reg = )
mov	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$1E-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 1314   write_word(ebda_seg, 0x0384, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1315   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 1 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*1
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1316   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1317   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1318   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 2 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*2
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1319   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1320   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1321   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 3 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*3
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1322   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1323   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1324   write_word(ebda_seg, 0x0380, count);
! Debug: list unsigned short count = [S+$18-$14] (used reg = )
push	-$12[bp]
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1325   write_word(ebda_seg, 0x0382, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $382 (used reg = )
mov	ax,#$382
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1326 }
mov	sp,bp
pop	bp
ret
! 1327 static Bit8u
! Register BX used in function init_boot_vectors
! 1328 get_boot_vector(i, e)
! 1329 Bit16u i; ipl_entry_t *e;
_get_boot_vector:
!BCC_EOS
!BCC_EOS
! 1330 {
! 1331   Bit16u count;
!BCC_EOS
! 1332   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-4
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1333   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1334   count = read_word(ebda_seg, 0x0380);
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-8] (used reg = )
push	-6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+8-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1335   if (i >= count) return 0;
! Debug: ge unsigned short count = [S+8-4] to unsigned short i = [S+8+2] (used reg = )
mov	ax,4[bp]
cmp	ax,-2[bp]
jb  	.110
.111:
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1336   memcpyb(ss, e, ebda_seg, 0x0300 + i * sizeof (*e), sizeof (*e));
.110:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
mov	ax,4[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-8] (used reg = )
push	-6[bp]
! Debug: list * struct  e = [S+$E+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$10-6] (used reg = )
push	-4[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1337   return 1;
mov	al,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1338 }
! 1339   void
! 1340 interactive_bootkey()
! 1341 {
export	_interactive_bootkey
_interactive_bootkey:
! 1342   ipl_entry_t e;
!BCC_EOS
! 1343   Bit16u count;
!BCC_EOS
! 1344   char description[33];
!BCC_EOS
! 1345   Bit8u scan_code;
!BCC_EOS
! 1346   Bit8u i;
!BCC_EOS
! 1347   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$38
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
mov	-$38[bp],ax
!BCC_EOS
! 1348   Bit16u valid_choice = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
xor	ax,ax
mov	-$3A[bp],ax
!BCC_EOS
! 1349   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$3E-$3E] (used reg = )
mov	-$3C[bp],ax
!BCC_EOS
! 1350   bios_printf(2, "\n\nPress F12 for boot menu.\n\n");
! Debug: list * char = .112+0 (used reg = )
mov	bx,#.112
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1351   while (check_f
! 1351 or_keystroke())
! 1352   {
br 	.114
.115:
! 1353     scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1354     if (scan_code != 0x86)
! Debug: ne int = const $86 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,#$86
je  	.116
.117:
! 1355       continue;
br 	.114
!BCC_EOS
! 1356     while (check_for_keystroke())
.116:
! 1357       get_keystroke();
jmp .119
.11A:
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
!BCC_EOS
! 1358     bios_printf(2, "Select boot device:\n\n");
.119:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
jne	.11A
.11B:
.118:
! Debug: list * char = .11C+0 (used reg = )
mov	bx,#.11C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1359     count = read_word(ebda_seg, 0x0380);
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$40-$3E] (used reg = )
push	-$3C[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3E-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 1360     for (i = 0; i < count; i++)
! Debug: eq int = const 0 to unsigned char i = [S+$3E-$37] (used reg = )
xor	al,al
mov	-$35[bp],al
!BCC_EOS
!BCC_EOS
! 1361     {
br 	.11F
.120:
! 1362       memcpyb(ss, &e, ebda_seg, 0x0300 + i * sizeof (e), sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
push	-$3C[bp]
! Debug: list * struct  e = S+$44-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1363       bios_printf(2, "%d. ", i+1);
! Debug: add int = const 1 to unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * char = .121+0 (used reg = )
mov	bx,#.121
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1364       switch(e.type)
mov	ax,-$10[bp]
! 1365       {
br 	.124
! 1366         case 0x01:
! 1367         case 0x02:
.125:
! 1368         case 0x03:
.126:
! 1369           bios_printf(2, "%s\n", drivetypes[e.type]);
.127:
! Debug: ptradd unsigned short e = [S+$3E-$12] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,-$10[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .128+0 (used reg = )
mov	bx,#.128
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1370           break;
br 	.122
!BCC_EOS
! 1371         case 0x80:
! 1372           bios_printf(2, "%s", drivetypes[4]);
.129:
! Debug: list * char = drivetypes+$28 (used reg = )
mov	bx,#_drivetypes+$28
push	bx
! Debug: list * char = .12A+0 (used reg = )
mov	bx,#.12A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1373           if (e.description != 0)
! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3E-$A] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-2+..FFFF[bp]
call	lcmpul
lea	sp,2+..FFFF[bp]
je  	.12B
.12C:
! 1374           {
! 1375             memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$40-$A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-8[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: sr int = const $10 to unsigned long e = [S+$42-$A] (used reg = )
mov	ax,-8[bp]
mov	bx,-6[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$44-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1376             description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$3E-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 1377             bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$3E-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$40-$3A] (used reg = )
push	-$38[bp]
! Debug: list * char = .12D+0 (used reg = )
mov	bx,#.12D
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1378          }
! 1379          bios_printf(2, "\n");
.12B:
! Debug: list * char = .12E+0 (used reg = )
mov	bx,#.12E
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1380          break;
jmp .122
!BCC_EOS
! 1381       }
! 1382     }
jmp .122
.124:
sub	ax,*1
beq 	.125
sub	ax,*1
beq 	.126
sub	ax,*1
beq 	.127
sub	ax,*$7D
beq 	.129
.122:
..FFFF	=	-$3E
! 1383     count++;
.11E:
! Debug: postinc unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
inc	ax
mov	-$35[bp],al
.11F:
! Debug: lt unsigned short count = [S+$3E-$14] to unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
cmp	ax,-$12[bp]
blo 	.120
.12F:
.11D:
! Debug: postinc unsigned short count = [S+$3E-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1384     while (!valid_choice) {
jmp .131
.132:
! 1385       scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1386       if (scan_code == 0x01 || scan_code == 0x58)
! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*1
je  	.134
.135:
! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*$58
jne 	.133
.134:
! 1387       {
! 1388         valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1389       }
! 1390       else if (scan_code <= count)
jmp .136
.133:
! Debug: le unsigned short count = [S+$3E-$14] to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
cmp	ax,-$12[bp]
ja  	.137
.138:
! 1391       {
! 1392         valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1393         scan_code -= 1;
! Debug: subab int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
dec	ax
mov	-$34[bp],al
!BCC_EOS
! 1394         write_word(ebda_seg, 0x0384, scan_code);
! Debug: list unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
push	-$3C[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1395       }
! 1396     }
.137:
.136:
! 1397     bios_printf(2, "\n");
.131:
mov	ax,-$3A[bp]
test	ax,ax
je 	.132
.139:
.130:
! Debug: list * char = .13A+0 (used reg = )
mov	bx,#.13A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1398     break;
jmp .113
!BCC_EOS
! 1399   }
! 1400 }
.114:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
bne 	.115
.13B:
.113:
mov	sp,bp
pop	bp
ret
! 1401 void
! Register BX used in function interactive_bootkey
! 1402 print_boot_device(type, desc)
! 1403   Bit16u type; Bit32u desc;
export	_print_boot_device
_print_boot_device:
!BCC_EOS
!BCC_EOS
! 1404 {
! 1405   char description[33];
!BCC_EOS
! 1406   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$24
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$26-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 1407   if (type == 0x80) type = 0x4;
! Debug: logeq int = const $80 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,#$80
jne 	.13C
.13D:
! Debug: eq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,*4
mov	4[bp],ax
!BCC_EOS
! 1408   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
.13C:
! Debug: logeq int = const 0 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
je  	.13F
.140:
! Debug: gt int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jbe 	.13E
.13F:
! Debug: list * char = .141+0 (used reg = )
mov	bx,#.141
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1409   bios_printf(2, "Booting from %s", drivetypes[type]);
.13E:
! Debug: ptradd unsigned short type = [S+$26+2] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,4[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .142+0 (used reg = )
mov	bx,#.142
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1410   if (type == 4 && desc != 0) {
! Debug: logeq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jne 	.143
.145:
! Debug: ne unsigned long = const 0 to unsigned long desc = [S+$26+4] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-$28[bp]
call	lcmpul
lea	sp,-$24[bp]
je  	.143
.144:
! 1411     memcpyb(ss, &description, (Bit16u)(desc >> 16), (Bit16u)(desc & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: and unsigned long = const $FFFF to unsigned long desc = [S+$28+4] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,6[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: sr int = const $10 to unsigned long desc = [S+$2A+4] (used reg = )
mov	ax,6[bp]
mov	bx,8[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$2C-$23 (used reg = )
lea	bx,-$21[bp]
push	bx
! Debug: list unsigned short ss = [S+$2E-$26] (used reg = )
push	-$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1412     description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$26-3] (used reg = )
xor	al,al
mov	-1[bp],al
!BCC_EOS
! 1413     bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$26-$23 (used reg = )
lea	bx,-$21[bp]
push	bx
! Debug: list unsigned short ss = [S+$28-$26] (used reg = )
push	-$24[bp]
! Debug: list * char = .146+0 (used reg = )
mov	bx,#.146
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1414   }
! 1415   bios_printf(2, "...\n");
.143:
! Debug: list * char = .147+0 (used reg = )
mov	bx,#.147
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1416 }
mov	sp,bp
pop	bp
ret
! 1417   void
! Register BX used in function print_boot_device
! 1418 print_boot_failure(type, reason)
! 1419   Bit16u type; Bit8u reason;
export	_print_boot_failure
_print_boot_failure:
!BCC_EOS
!BCC_EOS
! 1420 {
! 1421   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
push	bp
mov	bp,sp
! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
je  	.149
.14A:
! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*3
jbe 	.148
.149:
! Debug: list * char = .14B+0 (used reg = )
mov	bx,#.14B
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1422   bios_printf(2, "Boot from %s failed", drivetypes[type]);
.148:
! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,4[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .14C+0 (used reg = )
mov	bx,#.14C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1423   if (type < 4) {
! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jae 	.14D
.14E:
! 1424     if (reason==0)
! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
mov	al,6[bp]
test	al,al
jne 	.14F
.150:
! 1425       bios_printf(2, "
! 1425 : not a bootable disk");
! Debug: list * char = .151+0 (used reg = )
mov	bx,#.151
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1426     else
! 1427       bios_printf(2, ": could not read the boot disk");
jmp .152
.14F:
! Debug: list * char = .153+0 (used reg = )
mov	bx,#.153
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1428   }
.152:
! 1429   bios_printf(2, "\n\n");
.14D:
! Debug: list * char = .154+0 (used reg = )
mov	bx,#.154
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1430 }
pop	bp
ret
! 1431   void
! Register BX used in function print_boot_failure
! 1432 print_cdromboot_failure( code )
! 1433   Bit16u code;
export	_print_cdromboot_failure
_print_cdromboot_failure:
!BCC_EOS
! 1434 {
! 1435   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
push	bp
mov	bp,sp
! Debug: list unsigned short code = [S+2+2] (used reg = )
push	4[bp]
! Debug: list * char = .155+0 (used reg = )
mov	bx,#.155
push	bx
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1436   return;
pop	bp
ret
!BCC_EOS
! 1437 }
! 1438 void
! Register BX used in function print_cdromboot_failure
! 1439 nmi_handler_msg()
! 1440 {
export	_nmi_handler_msg
_nmi_handler_msg:
! 1441   bios_printf((2 | 4 | 1), "NMI Handler called\n");
push	bp
mov	bp,sp
! Debug: list * char = .156+0 (used reg = )
mov	bx,#.156
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1442 }
pop	bp
ret
! 1443 void
! Register BX used in function nmi_handler_msg
! 1444 int18_panic_msg()
! 1445 {
export	_int18_panic_msg
_int18_panic_msg:
! 1446   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
push	bp
mov	bp,sp
! Debug: list * char = .157+0 (used reg = )
mov	bx,#.157
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1447 }
pop	bp
ret
! 1448 void
! Register BX used in function int18_panic_msg
! 1449 log_bios_start()
! 1450 {
export	_log_bios_start
_log_bios_start:
! 1451   bios_printf(4, "%s\n", bios_cvs_version_string);
push	bp
mov	bp,sp
! Debug: list * char = bios_cvs_version_string+0 (used reg = )
mov	bx,#_bios_cvs_version_string
push	bx
! Debug: list * char = .158+0 (used reg = )
mov	bx,#.158
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1452 }
pop	bp
ret
! 1453   bx_bool
! Register BX used in function log_bios_start
! 1454 set_enable_a20(val)
! 1455   bx_bool val;
export	_set_enable_a20
_set_enable_a20:
!BCC_EOS
! 1456 {
! 1457   Bit8u oldval;
!BCC_EOS
! 1458   oldval = inb(0x92);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1459   if (val)
mov	ax,4[bp]
test	ax,ax
je  	.159
.15A:
! 1460     outb(0x92, oldval | 0x02);
! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1461   else
! 1462     outb(0x92, oldval & 0xfd);
jmp .15B
.159:
! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1463   return((oldval & 0x02) != 0);
.15B:
! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.15C
mov	al,*1
jmp	.15D
.15C:
xor	al,al
.15D:
! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
xor	ah,ah
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1464 }
! 1465   void
! 1466 debugger_on()
! 1467 {
export	_debugger_on
_debugger_on:
! 1468   outb(0xfedc, 0x01);
push	bp
mov	bp,sp
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1469 }
pop	bp
ret
! 1470   void
! 1471 debugger_off()
! 1472 {
export	_debugger_off
_debugger_off:
! 1473   outb(0xfedc, 0x00);
push	bp
mov	bp,sp
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1474 }
pop	bp
ret
! 1475 int
! 1476 s3_resume()
! 1477 {
export	_s3_resume
_s3_resume:
! 1478     Bit32u s3_wakeup_vector;
!BCC_EOS
! 1479     Bit8u s3_resume_flag;
!BCC_EOS
! 1480     s3_resume_flag = read_byte(0x40, 0xb0);
push	bp
mov	bp,sp
add	sp,*-6
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 1481     s3_wakeup_vector = get_s3_waking_vector();
! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
call	_get_s3_waking_vector
mov	bx,dx
! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1482     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list * char = .15E+0 (used reg = )
mov	bx,#.15E
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 1483     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FE
jne 	.160
.161:
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
jne 	.15F
.160:
! 1484      return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1485     write_byte(0x40, 0xb0, 0);
.15F:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1486     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$F
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B6 (used reg = )
mov	ax,#$B6
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1487     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	di,*4
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B8 (used reg = )
mov	ax,#$B8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1488     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$F
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	di,*4
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list * char = .162+0 (used reg = )
mov	bx,#.162
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$C
!BCC_EOS
! 1489 #asm
!BCC_EOS
!BCC_ASM
_s3_resume.s3_resume_flag	set	1
.s3_resume.s3_resume_flag	set	-5
_s3_resume.s3_wakeup_vector	set	2
.s3_resume.s3_wakeup_vector	set	-4
    jmpf [0x04b6]
! 1491 endasm
!BCC_ENDASM
!BCC_EOS
! 1492     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1493 }
! 1494 void ata_init( )
! Register BX used in function s3_resume
! 1495 {
export	_ata_init
_ata_init:
! 1496   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1497   Bit8u channel, device;
!BCC_EOS
! 1498   for (channel=0; channel<4; channel++) {
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
!BCC_EOS
br 	.165
.166:
! 1499     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1500     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1501     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1502     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1503     }
! 1504   for (device=0; device<(4*2); device++) {
.164:
! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
.165:
! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
cmp	al,*4
jb 	.166
.167:
.163:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
br 	.16A
.16B:
! 1505     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1506     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1507     w
! 1507 rite_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1508     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1509     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1510     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1511     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1512     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1513     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1514     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1515     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1516     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1517     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1518     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1519     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1520     }
! 1521   for (device=0; device<(4*2); device++) {
.169:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.16A:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
blo 	.16B
.16C:
.168:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
jmp .16F
.170:
! 1522     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1523     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1524     }
! 1525   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
.16E:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.16F:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
jb 	.170
.171:
.16D:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1526   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1527 }
mov	sp,bp
pop	bp
ret
! 1528 int await_ide();
! Register BX used in function ata_init
!BCC_EOS
! 1529 static int await_ide(when_done,base,timeout)
! 1530   Bit8u when_done;
_await_ide:
!BCC_EOS
! 1531   Bit16u base;
!BCC_EOS
! 1532   Bit16u timeout;
!BCC_EOS
! 1533 {
! 1534   Bit32u time=0,last=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*-4
! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1535   Bit16u status;
!BCC_EOS
! 1536   Bit8u result;
!BCC_EOS
! 1537   status = inb(base + 7);
add	sp,*-4
! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
xor	ah,ah
mov	-$A[bp],ax
!BCC_EOS
! 1538   for(;;) {
!BCC_EOS
!BCC_EOS
.174:
! 1539     status = inb(base+7);
! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
xor	ah,ah
mov	-$A[bp],ax
!BCC_EOS
! 1540     time++;
! Debug: postinc unsigned long time = [S+$E-6] (used reg = )
mov	ax,-4[bp]
mov	si,-2[bp]
lea	bx,-4[bp]
call	lincl
!BCC_EOS
! 1541     if (when_done == 1)
! Debug: logeq int = const 1 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jne 	.175
.176:
! 1542       result = status & 0x80;
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1543     else if (when_done == 2)
br 	.177
.175:
! Debug: logeq int = const 2 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*2
jne 	.178
.179:
! 1544       result = !(status & 0x80);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.17A
.17B:
mov	al,*1
jmp	.17C
.17A:
xor	al,al
.17C:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1545     else if (when_done == 3)
br 	.17D
.178:
! Debug: logeq int = const 3 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*3
jne 	.17E
.17F:
! 1546       result = !(status & 0x80) && (status & 0x08);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.180
.182:
! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*8
test	al,al
je  	.180
.181:
mov	al,*1
jmp	.183
.180:
xor	al,al
.183:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1547     else if (when_done == 4)
jmp .184
.17E:
! Debug: logeq int = const 4 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*4
jne 	.185
.186:
! 1548       result = !(status & 0x80) && !(status & 0x08);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.187
.189:
! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*8
test	al,al
jne 	.187
.188:
mov	al,*1
jmp	.18A
.187:
xor	al,al
.18A:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1549     else if (when_done == 5)
jmp .18B
.185:
! Debug: logeq int = const 5 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
cmp	al,*5
jne 	.18C
.18D:
! 1550       result = !(status & 0x80) && (status & 0x40);
! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,#$80
test	al,al
jne 	.18E
.190:
! Debug: and int = const $40 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*$40
test	al,al
je  	.18E
.18F:
mov	al,*1
jmp	.191
.18E:
xor	al,al
.191:
! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1551     else if (when_done == 0)
jmp .192
.18C:
! Debug: logeq int = const 0 to unsigned char when_done = [S+$E+2] (used reg = )
mov	al,4[bp]
test	al,al
jne 	.193
.194:
! 1552       result = 0;
! Debug: eq int = const 0 to unsigned char result = [S+$E-$D] (used reg = )
xor	al,al
mov	-$B[bp],al
!BCC_EOS
! 1553     if (result) retu
.193:
.192:
.18B:
.184:
.17D:
.177:
mov	al,-$B[bp]
test	al,al
je  	.195
.196:
! 1553 rn 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1554     if (time>>16 != last)
.195:
! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: ne unsigned long last = [S+$E-$A] to unsigned long = bx+0 (used reg = )
lea	di,-8[bp]
call	lcmpul
je  	.197
.198:
! 1555     {
! 1556       last = time >>16;
! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$E-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1557       ;
!BCC_EOS
! 1558     }
! 1559     if (status & 0x01)
.197:
! Debug: and int = const 1 to unsigned short status = [S+$E-$C] (used reg = )
mov	al,-$A[bp]
and	al,*1
test	al,al
je  	.199
.19A:
! 1560     {
! 1561       ;
!BCC_EOS
! 1562       return -1;
mov	ax,*-1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1563     }
! 1564     if ((timeout == 0) || ((time>>11) > timeout)) break;
.199:
! Debug: logeq int = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
je  	.19C
.19D:
! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sr int = const $B to unsigned long time = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: gt unsigned long (temp) = [S+$12-$12] to unsigned long = bx+0 (used reg = )
lea	di,-$10[bp]
call	lcmpul
lea	sp,-$C[bp]
jbe 	.19B
.19C:
jmp .172
!BCC_EOS
! 1565   }
.19B:
! 1566   bios_printf(4, "IDE time out\n");
.173:
br 	.174
.172:
! Debug: list * char = .19E+0 (used reg = )
mov	bx,#.19E
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1567   return -1;
mov	ax,*-1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1568 }
! 1569 void ata_detect( )
! Register BX used in function await_ide
! 1570 {
export	_ata_detect
_ata_detect:
! 1571   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1572   Bit8u hdcount, cdcount, device, type;
!BCC_EOS
! 1573   Bit8u buffer[0x0200];
!BCC_EOS
! 1574   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
add	sp,#-$204
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $122 (used reg = )
mov	ax,#$122
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1575   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
! Debug: list int = const $1F0 (used reg = )
mov	ax,#$1F0
push	ax
! Debug: list * unsigned short = const $124 (used reg = )
mov	ax,#$124
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1576   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
! Debug: list int = const $3F0 (used reg = )
mov	ax,#$3F0
push	ax
! Debug: list * unsigned short = const $126 (used reg = )
mov	ax,#$126
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1577   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list * unsigned char = const $128 (used reg = )
mov	ax,#$128
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1578   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $12A (used reg = )
mov	ax,#$12A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1579   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
! Debug: list int = const $170 (used reg = )
mov	ax,#$170
push	ax
! Debug: list * unsigned short = const $12C (used reg = )
mov	ax,#$12C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1580   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
! Debug: list int = const $370 (used reg = )
mov	ax,#$370
push	ax
! Debug: list * unsigned short = const $12E (used reg = )
mov	ax,#$12E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1581   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned char = const $130 (used reg = )
mov	ax,#$130
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1582   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $132 (used reg = )
mov	ax,#$132
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1583   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
! Debug: list int = const $1E8 (used reg = )
mov	ax,#$1E8
push	ax
! Debug: list * unsigned short = const $134 (used reg = )
mov	ax,#$134
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1584   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: list * unsigned short = const $136 (used reg = )
mov	ax,#$136
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1585   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list * unsigned char = const $138 (used reg = )
mov	ax,#$138
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1586   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $13A (used reg = )
mov	ax,#$13A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1587   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
! Debug: list int = const $168 (used reg = )
mov	ax,#$168
push	ax
! Debug: list * unsigned short = const $13C (used reg = )
mov	ax,#$13C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1588   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
! Debug: list int = const $360 (used reg = )
mov	ax,#$360
push	ax
! Debug: list * unsigned short = const $13E (used reg = )
mov	ax,#$13E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1589   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: list * unsigned char = const $140 (used reg = )
mov	ax,#$140
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1590   hdcount=cdcount=0;
! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
xor	al,al
mov	-4[bp],al
! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 1591   for(device=0; device<(4*2); device++) {
! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
xor	al,al
mov	-5[bp],al
!BCC_EOS
!BCC_EOS
br 	.1A1
.1A2:
! 1592     Bit16u iobase1, iobase2;
!BCC_EOS
! 1593     Bit8u channel, slave, shift;
!BCC_EOS
! 1594     Bit8u sc, sn, cl, ch, st;
!BCC_EOS
! 1595     channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
mov	-$20B[bp],al
!BCC_EOS
! 1596     slave = device % 2;
! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
mov	-$20C[bp],al
!BCC_EOS
! 1597     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	-$208[bp],ax
!BCC_EOS
! 1598     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
mov	-$20A[bp],ax
!BCC_EOS
! 1599     outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
mov	ax,-$20A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1600     outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.1A3
.1A4:
mov	al,#$B0
jmp .1A5
.1A3:
mov	al,#$A0
.1A5:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1601     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1602     outb(iobase
! 1602 1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1603     outb(iobase1+2, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1604     outb(iobase1+3, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1605     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1606     outb(iobase1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1607     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1608     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1609     if ( (sc == 0x55) && (sn == 0xaa) ) {
! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*$55
bne 	.1A6
.1A8:
! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,#$AA
bne 	.1A6
.1A7:
! 1610       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1611       ata_reset(device);
! Debug: list unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 1612       outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.1A9
.1AA:
mov	al,#$B0
jmp .1AB
.1A9:
mov	al,#$A0
.1AB:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1613       sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1614       sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1615       if ((sc==0x01) && (sn==0x01)) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*1
bne 	.1AC
.1AE:
! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,*1
bne 	.1AC
.1AD:
! 1616         cl = inb(iobase1+4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	-$210[bp],al
!BCC_EOS
! 1617         ch = inb(iobase1+5);
! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	-$211[bp],al
!BCC_EOS
! 1618         st = inb(iobase1+7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
mov	-$212[bp],al
!BCC_EOS
! 1619         if ((cl==0x14) && (ch==0xeb)) {
! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,*$14
jne 	.1AF
.1B1:
! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$EB
jne 	.1AF
.1B0:
! 1620           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1621         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
jmp .1B2
.1AF:
! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
test	al,al
jne 	.1B3
.1B6:
! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
test	al,al
jne 	.1B3
.1B5:
! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
mov	al,-$212[bp]
test	al,al
je  	.1B3
.1B4:
! 1622           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1623         } else if ((cl==0xff) && (ch==0xff)) {
jmp .1B7
.1B3:
! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,#$FF
jne 	.1B8
.1BA:
! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$FF
jne 	.1B8
.1B9:
! 1624           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1625         }
! 1626       }
.1B8:
.1B7:
.1B2:
! 1627     }
.1AC:
! 1628     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
.1A6:
! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 1629     if(type == 0x02) {
! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*2
bne 	.1BB
.1BC:
! 1630       Bit32u sectors_low, sectors_high;
!BCC_EOS
! 1631       Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 1632       Bit8u translation, removable, mode;
!BCC_EOS
! 1633       mode = 0x00;
add	sp,*-$14
! Debug: eq int = const 0 to unsigned char mode = [S+$228-$227] (used reg = )
xor	al,al
mov	-$225[bp],al
!BCC_EOS
! 1634       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1635       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1636       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $EC (used reg = )
mov	ax,#$EC
push	ax
! Debug: list unsigned char device = [S+$23E-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1BD
.1BE:
! 1637         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
! Debug: list * char = .1BF+0 (used reg = )
mov	bx,#.1BF
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1638       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
.1BD:
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.1C0
.1C1:
mov	al,*1
jmp .1C2
.1C0:
xor	al,al
.1C2:
! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
mov	-$224[bp],al
!BCC_EOS
! 1639       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.1C3
.1C4:
mov	al,*1
jmp .1C5
.1C3:
xor	al,al
.1C5:
! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
mov	-$225[bp],al
!BCC_EOS
! 1640       blksize = read_word(get_SS(),buffer+10);
! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
lea	bx,-$1FC[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
mov	-$222[bp],ax
!BCC_EOS
! 1641       cylinders = read_word(get_SS(),buffer+(1*2));
! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
lea	bx,-$204[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1642       heads = read_word(get_SS(),buffer+(3*2));
! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
lea	bx,-$200[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1643       spt = read_word(get_SS(),buffer+(6*2));
! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
lea	bx,-$1FA[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
mov	-$220[bp],ax
!BCC_EOS
! 1644       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
lea	bx,-$160[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
and	ax,#$400
test	ax,ax
je  	.1C6
.1C7:
! 1645         sectors_low = read_dword(get_SS(),buffer+(100*2));
! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
lea	bx,-$13E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1646         sectors_high = read_dword(get_SS(),buffer+(102*2));
! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
lea	bx,-$13A[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1647       } else {
jmp .1C8
.1C6:
! 1648      
! 1648    sectors_low = read_dword(get_SS(),buffer+(60*2));
! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
lea	bx,-$18E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1649         sectors_high = 0;
! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1650       }
! 1651       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
.1C8:
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1652       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
mov	al,-$224[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1653       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
mov	al,-$225[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1654       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
push	-$222[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1655       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1656       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1657       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1658       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
push	-$214[bp]
push	-$216[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1659       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
push	-$218[bp]
push	-$21A[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1660       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
push	-$21E[bp]
! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
push	-$21C[bp]
! Debug: list unsigned char slave = [S+$22E-$20E] (used reg = )
mov	al,-$20C[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char channel = [S+$230-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .1C9+0 (used reg = )
mov	bx,#.1C9
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$E
!BCC_EOS
! 1661       translation = inb_cmos(0x39 + channel/2);
! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
mov	-$223[bp],al
!BCC_EOS
! 1662       for (shift=device%4; shift>0; shift--) translation >>= 2;
! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	-$20D[bp],al
!BCC_EOS
!BCC_EOS
jmp .1CC
.1CD:
! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
shr	ax,*1
shr	ax,*1
mov	-$223[bp],al
!BCC_EOS
! 1663       translation &= 0x03;
.1CB:
! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
dec	ax
mov	-$20D[bp],al
.1CC:
! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
test	al,al
jne	.1CD
.1CE:
.1CA:
! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
and	al,*3
mov	-$223[bp],al
!BCC_EOS
! 1664       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1665       switch (translation) {
mov	al,-$223[bp]
jmp .1D1
! 1666         case 0:
! 1667           bios_printf(4, "none");
.1D2:
! Debug: list * char = .1D3+0 (used reg = )
mov	bx,#.1D3
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1668           break;
jmp .1CF
!BCC_EOS
! 1669         case 1:
! 1670           bios_printf(4, "lba");
.1D4:
! Debug: list * char = .1D5+0 (used reg = )
mov	bx,#.1D5
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1671           break;
jmp .1CF
!BCC_EOS
! 1672         case 2:
! 1673           bios_printf(4, "large");
.1D6:
! Debug: list * char = .1D7+0 (used reg = )
mov	bx,#.1D7
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1674           break;
jmp .1CF
!BCC_EOS
! 1675         case 3:
! 1676           bios_printf(4, "r-echs");
.1D8:
! Debug: list * char = .1D9+0 (used reg = )
mov	bx,#.1D9
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1677           break;
jmp .1CF
!BCC_EOS
! 1678         }
! 1679       switch (translation) {
jmp .1CF
.1D1:
sub	al,*0
je 	.1D2
sub	al,*1
je 	.1D4
sub	al,*1
je 	.1D6
sub	al,*1
je 	.1D8
.1CF:
..FFFE	=	-$228
mov	al,-$223[bp]
br 	.1DC
! 1680         case 0:
! 1681           break;
.1DD:
br 	.1DA
!BCC_EOS
! 1682         case 1:
! 1683           spt = 63;
.1DE:
! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
mov	ax,*$3F
mov	-$220[bp],ax
!BCC_EOS
! 1684           sectors_low /= 63;
! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,*$3F
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
mov	-$216[bp],ax
mov	-$214[bp],bx
add	sp,*4
!BCC_EOS
! 1685           heads = sectors_low / 1024;
! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,#$400
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1686           if (heads>128) heads = 255;
! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,#$80
jbe 	.1DF
.1E0:
! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$FF
mov	-$21E[bp],ax
!BCC_EOS
! 1687           else if (heads>64) heads = 128;
jmp .1E1
.1DF:
! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$40
jbe 	.1E2
.1E3:
! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$80
mov	-$21E[bp],ax
!BCC_EOS
! 1688           else if (heads>32) heads = 64;
jmp .1E4
.1E2:
! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$20
jbe 	.1E5
.1E6:
! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$40
mov	-$21E[bp],ax
!BCC_EOS
! 1689           else if (heads>16) heads = 32;
jmp .1E7
.1E5:
! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jbe 	.1E8
.1E9:
! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$20
mov	-$21E[bp],ax
!BCC_EOS
! 1690           else heads=16;
jmp .1EA
.1E8:
! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$10
mov	-$21E[bp],ax
!BCC_EOS
! 1691           cylinders = sectors_low / heads;
.1EA:
.1E7:
.1E4:
.1E1:
! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1692           break;
br 	.1DA
!BCC_EOS
! 1693         case 3:
! 1694           if (heads==16) {
.1EB:
! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jne 	.1EC
.1ED:
! 1695             if(cylinders>61439) cylinders=61439;
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$EFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lcmpul
lea	sp,2+..FFFD[bp]
jbe 	.1EE
.1EF:
! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$EFFF
mov	-$21C[bp],ax
!BCC_EOS
! 1696            
! 1696  heads=15;
.1EE:
! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$F
mov	-$21E[bp],ax
!BCC_EOS
! 1697             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$10
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lmulul
add	sp,*8
! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	ldivul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1698             }
! 1699         case 2:
.1EC:
! 1700           while(cylinders > 1024) {
.1F0:
jmp .1F2
.1F3:
! 1701             cylinders >>= 1;
! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
shr	ax,*1
mov	-$21C[bp],ax
!BCC_EOS
! 1702             heads <<= 1;
! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
shl	ax,*1
mov	-$21E[bp],ax
!BCC_EOS
! 1703             if (heads > 127) break;
! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$7F
jbe 	.1F4
.1F5:
jmp .1F1
!BCC_EOS
! 1704           }
.1F4:
! 1705           break;
.1F2:
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
ja 	.1F3
.1F6:
.1F1:
jmp .1DA
!BCC_EOS
! 1706         }
! 1707       if (cylinders > 1024) cylinders=1024;
jmp .1DA
.1DC:
sub	al,*0
beq 	.1DD
sub	al,*1
beq 	.1DE
sub	al,*1
je 	.1F0
sub	al,*1
beq 	.1EB
.1DA:
..FFFD	=	-$228
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
jbe 	.1F7
.1F8:
! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$400
mov	-$21C[bp],ax
!BCC_EOS
! 1708       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
.1F7:
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
push	-$21E[bp]
! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
push	-$21C[bp]
! Debug: list * char = .1F9+0 (used reg = )
mov	bx,#.1F9
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 1709       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1710       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1711       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1712       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
! Debug: list unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1713       hdcount++;
! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
!BCC_EOS
! 1714       }
add	sp,*$14
! 1715     if(type == 0x03) {
.1BB:
! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*3
bne 	.1FA
.1FB:
! 1716       Bit8u type, removable, mode;
!BCC_EOS
! 1717       Bit16u blksize;
!BCC_EOS
! 1718       mode = 0x00;
add	sp,*-6
! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
xor	al,al
mov	-$215[bp],al
!BCC_EOS
! 1719       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1720       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1721       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: list unsigned char device = [S+$230-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1FC
.1FD:
! 1722         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
! Debug: list * char = .1FE+0 (used reg = )
mov	bx,#.1FE
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1723       type = read_byte(get_SS(),buffer+1) & 0x1f;
.1FC:
! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
lea	bx,-$205[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
and	al,*$1F
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
mov	-$213[bp],al
!BCC_EOS
! 1724       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.1FF
.200:
mov	al,*1
jmp .201
.1FF:
xor	al,al
.201:
! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
mov	-$214[bp],al
!BCC_EOS
! 1725       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.202
.203:
mov	al,*1
jmp .204
.202:
xor	al,al
.204:
! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
mov	-$215[bp],al
!BCC_EOS
! 1726       blksize = 2048;
! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
mov	ax,#$800
mov	-$218[bp],ax
!BCC_EOS
! 1727       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
mov	al,-$213[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1728       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
mov	al,-$214[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1729       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
mov	al,-$215[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1730       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
push	-$218[bp]
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1731       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
! Debug: list unsigned char device = [S+$21A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1732       cdcount++;
! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
!BCC_EOS
! 1733       }
add	sp,*6
! 1734       {
.1FA:
! 1735       Bit32u sizeinmb;
!BCC_EOS
! 1736       Bit16u ataversion;
!BCC_EOS
! 1737       Bit8u c, i, version, model[41];
!BCC_EOS
! 1738       switch (type) {
add	sp,*-$32
mov	al,-6[bp]
br 	.207
! 1739         case 0x02:
! 1740           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) <
.208:
! 1740 < 21)
! 1741             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
mov	cl,*5
shl	ax,cl
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFFC[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1742         case 0x03:
! 1743           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
.209:
! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
lea	bx,-$166[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
lea	bx,-$165[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
or	al,0+..FFFC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
mov	-$218[bp],ax
!BCC_EOS
! 1744           for(version=15;version>0;version--) {
! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,*$F
mov	-$21B[bp],al
!BCC_EOS
!BCC_EOS
jmp .20C
.20D:
! 1745             if((ataversion&(1<<version))!=0)
! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
mov	bx,ax
mov	ax,*1
mov	cx,bx
shl	ax,cl
! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
! Debug: expression subtree swapping
and	ax,-$218[bp]
! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
test	ax,ax
je  	.20E
.20F:
! 1746             break;
jmp .20A
!BCC_EOS
! 1747             }
.20E:
! 1748           for(i=0;i<20;i++){
.20B:
! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
dec	ax
mov	-$21B[bp],al
.20C:
! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
test	al,al
jne	.20D
.210:
.20A:
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .213
.214:
! 1749             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
! Debug: list * unsigned char = bx-$1CF (used reg = )
add	bx,#-$1CF
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1750             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: list * unsigned char = bx-$1D0 (used reg = )
add	bx,#-$1D0
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
! Debug: list * unsigned char = bx-$243 (used reg = )
add	bx,#-$243
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1751           }
! 1752           write_byte(get_SS(),model+40,0x00);
.212:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
.213:
! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$14
blo 	.214
.215:
.211:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$21E (used reg = )
lea	bx,-$21C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1753           for(i=39;i>0;i--){
! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$27
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .218
.219:
! 1754             if(read_byte(get_SS(),model+i)==0x20)
! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
cmp	al,*$20
jne 	.21A
.21B:
! 1755               write_byte(get_SS(),model+i,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1756             else break;
jmp .21C
.21A:
jmp .216
!BCC_EOS
! 1757           }
.21C:
! 1758           if (i>36) {
.217:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.218:
! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
test	al,al
jne	.219
.21D:
.216:
! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$24
jbe 	.21E
.21F:
! 1759             write_byte(get_SS(),model+36,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$222 (used reg = )
lea	bx,-$220[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1760             for(i=35;i>32;i--){
! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$23
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .222
.223:
! 1761               write_byte(get_SS(),model+i,0x2E);
! Debug: list int = const $2E (used reg = )
mov	ax,*$2E
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1762             }
! 1763           }
.221:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.222:
! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$20
ja 	.223
.224:
.220:
! 1764           break;
.21E:
jmp .205
!BCC_EOS
! 1765         }
! 1766       switch (type) {
jmp .205
.207:
sub	al,*2
beq 	.208
sub	al,*1
beq 	.209
.205:
..FFFC	=	-$246
mov	al,-6[bp]
br 	.227
! 1767         case 0x02:
! 1768           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
.228:
mov	al,-$20C[bp]
test	al,al
je  	.22C
.22D:
mov	bx,#.22A
jmp .22E
.22C:
mov	bx,#.22B
.22E:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .229+0 (used reg = )
mov	bx,#.229
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1769           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
jmp .230
.231:
! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
mov	al,-$219[bp]
xor	ah,ah
push	ax
! Debug: list * char = .232+0 (used reg = )
mov	bx,#.232
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1770    if (sizeinmb < (1UL<<16))
.230:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
dec	ax
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
mov	-$219[bp],al
test	al,al
jne	.231
.233:
.22F:
! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
xor	ax,ax
mov	bx,*1
lea	di,-$216[bp]
call	lcmpul
jbe 	.234
.235:
! 1771             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
push	-$216[bp]
! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .236+0 (used reg = )
mov	bx,#.236
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1772    else
! 1773             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
jmp .237
.234:
! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	ax,-$216[bp]
mov	bx,-$214[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*2
call	lsrul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .238+0 (used reg = )
mov	bx,#.238
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1774           break;
.237:
br 	.225
!BCC_EOS
! 1775         case 0x03:
! 1776           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
.239:
mov	al,-$20C[bp]
test	al,al
je  	.23D
.23E:
mov	bx,#.23B
jmp .23F
.23D:
mov	bx,#.23C
.23F:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .23A+0 (used reg = )
mov	bx,#.23A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1777           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
jmp .241
.242:
! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
mov	al,-$219[bp]
xor	ah,ah
push	ax
! Debug: list * char = .243+0 (used reg = )
mov	bx,#.243
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1778           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
.241:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
dec	ax
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
mov	-$219[bp],al
test	al,al
jne	.242
.244:
.240:
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
jne 	.245
.246:
! 1779             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .247+0 (used reg = )
mov	bx,#.247
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1780           else
! 1781             bios_printf(2, " ATAPI-%d Device\n",version);
jmp .248
.245:
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .249+0 (used reg = )
mov	bx,#.249
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1782           break;
.248:
jmp .225
!BCC_EOS
! 1783         case 0x01:
! 1784           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
.24A:
mov	al,-$20C[bp]
test	al,al
je  	.24E
.24F:
mov	bx,#.24C
jmp .250
.24E:
mov	bx,#.24D
.250:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .24B+0 (used reg = )
mov	bx,#.24B
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1785           break;
jmp .225
!BCC_EOS
! 1786         }
! 1787       }
jmp .225
.227:
sub	al,*1
je 	.24A
sub	al,*1
beq 	.228
sub	al,*1
beq 	.239
.225:
..FFFB	=	-$246
add	sp,*$32
! 1788     }
add	sp,*$C
! 1789   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
.1A0:
! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
.1A1:
! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
blo 	.1A2
.251:
.19F:
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1790   write_byte(eb
! 1790 da_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1791   write_byte(0x40,0x75, hdcount);
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $75 (used reg = )
mov	ax,*$75
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1792   bios_printf(2, "\n");
! Debug: list * char = .252+0 (used reg = )
mov	bx,#.252
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1793 }
mov	sp,bp
pop	bp
ret
! 1794 void ata_reset(device)
! Register BX used in function ata_detect
! 1795 Bit16u device;
export	_ata_reset
_ata_reset:
!BCC_EOS
! 1796 {
! 1797   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1798   Bit16u iobase1, iobase2;
!BCC_EOS
! 1799   Bit8u channel, slave, sn, sc;
!BCC_EOS
! 1800   Bit8u type;
!BCC_EOS
! 1801   Bit16u max;
!BCC_EOS
! 1802   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 1803   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
mov	-8[bp],al
!BCC_EOS
! 1804   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1805   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1806   outb(iobase2+6, 0x08 | 0x02 | 0x04);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1807   await_ide(1, iobase1, 20);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1808   outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1809   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1810   if (type != 0x00) {
! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
beq 	.253
.254:
! 1811     outb(iobase1+6, slave?0xb0:0xa0);
mov	al,-8[bp]
test	al,al
je  	.255
.256:
mov	al,#$B0
jmp .257
.255:
mov	al,#$A0
.257:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1812     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1813     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1814     if ( (sc==0x01) && (sn==0x01) ) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
mov	al,-$A[bp]
cmp	al,*1
jne 	.258
.25A:
! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
mov	al,-9[bp]
cmp	al,*1
jne 	.258
.259:
! 1815       if (type == 0x02)
! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
cmp	al,*2
jne 	.25B
.25C:
! 1816         await_ide(5, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1817       else
! 1818         await_ide(2, iobase1, 32000u);
jmp .25D
.25B:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1819     }
.25D:
! 1820     await_ide(2, iobase1, 32000u);
.258:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1821   }
! 1822   outb(iobase2+6, 0x08);
.253:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1823 }
mov	sp,bp
pop	bp
ret
! 1824 Bit16u ata_cmd_non_data()
! Register BX used in function ata_reset
! 1825 {return 0;}
export	_ata_cmd_non_data
_ata_cmd_non_data:
push	bp
mov	bp,sp
xor	ax,ax
pop	bp
ret
!BCC_EOS
! 1826 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! 1827 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_in
_ata_cmd_data_in:
!BCC_EOS
! 1828 Bit32u lba_low, lba_high;
!BCC_EOS
! 1829 {
! 1830   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1831   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1832   Bit8u channel, slave;
!BCC_EOS
! 1833   Bit8u status, current, mode;
!BCC_EOS
! 1834   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1835   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1836   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1837   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1838   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1839   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1840   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.25E
.25F:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1841   else blksize>>=1;
jmp .260
.25E:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1842   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.260:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1843   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1844   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1845   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1846   if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.261
.262:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1847   outb(iobase2 + 6, 0x08 | 0x02);
.261:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1848   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.263
.264:
! 1849     if ((count >= 1 << 8) || lb
! 1849 a_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.269
mov	al,*1
jmp	.26A
.269:
xor	al,al
.26A:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.266
.268:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.266
.267:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.265
.266:
! 1850       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1851       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1852       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1853       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1854       outb(iobase1 + 5, lba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1855       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1856       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1857       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1858       }
! 1859     sector = (Bit16u) (lba_low & 0x000000ffL);
.265:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1860     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1861     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1862   }
! 1863   outb(iobase1 + 1, 0x00);
.263:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1864   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1865   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1866   outb(iobase1 + 4, cylinder & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1867   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1868   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.26C
.26D:
mov	al,#$B0
jmp .26E
.26C:
mov	al,#$A0
.26E:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1869   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1870   await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1871   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1872   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.26F
.270:
! 1873     ;
!BCC_EOS
! 1874     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1875     } else if ( !(status & 0x08) ) {
jmp .271
.26F:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.272
.273:
! 1876     ;
!BCC_EOS
! 1877     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1878   }
! 1879 #asm
.272:
.271:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1881 endasm
!BCC_ENDASM
!BCC_EOS
! 1882   while (1) {
.276:
! 1883 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        push bp
        mov bp, sp
        mov di, _ata_cmd_data_in.offset + 2[bp]
        mov ax, _ata_cmd_data_in.segment + 2[bp]
        mov cx, _ata_cmd_data_in.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp di, #0xf800 ;;
        jbe ata_in_no_adjust
ata_in_adjust:
        sub di, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_in_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
        mov ah, _ata_cmd_data_in.mode + 2[bp]
        cmp ah, #0x01
        je ata_in_32
ata_in_16:
        rep
          insw ;; CX words transfered from port(DX) to ES:[DI]
        jmp ata_in_done
ata_in_32:
        rep
          insd ;; CX dwords transfered from port(DX) to ES:[DI]
ata_in_done:
        mov _ata_cmd_data_in.offset + 2[bp], di
        mov _ata_cmd_data_in.segment + 2[bp], es
        pop bp
! 1912 endasm
!BCC_ENDASM
!BCC_EOS
! 1913     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 1914     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,curr
! 1914 ent);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1915     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 1916     await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1917     status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1918     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.277
.278:
! 1919       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1920           != 0x40 ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.279
.27A:
! 1921         ;
!BCC_EOS
! 1922         return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1923         }
! 1924       break;
.279:
jmp .274
!BCC_EOS
! 1925       }
! 1926     else {
jmp .27B
.277:
! 1927       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1928           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.27C
.27D:
! 1929         ;
!BCC_EOS
! 1930         return 5;
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1931       }
! 1932       continue;
.27C:
jmp .275
!BCC_EOS
! 1933     }
! 1934   }
.27B:
! 1935   outb(iobase2+6, 0x08);
.275:
jmp	.276
.27E:
.274:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1936   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1937 }
! 1938 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! Register BX used in function ata_cmd_data_in
! 1939 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_out
_ata_cmd_data_out:
!BCC_EOS
! 1940 Bit32u lba_low, lba_high;
!BCC_EOS
! 1941 {
! 1942   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1943   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1944   Bit8u channel, slave;
!BCC_EOS
! 1945   Bit8u status, current, mode;
!BCC_EOS
! 1946   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1947   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1948   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1949   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1950   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1951   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1952   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.27F
.280:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1953   else blksize>>=1;
jmp .281
.27F:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1954   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.281:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1955   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1956   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1957   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1958   if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.282
.283:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1959   outb(iobase2 + 6, 0x08 | 0x02);
.282:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1960   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.284
.285:
! 1961     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.28A
mov	al,*1
jmp	.28B
.28A:
xor	al,al
.28B:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.287
.289:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.287
.288:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.286
.287:
! 1962       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1963       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1964       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1965       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1966       outb(iobase1 + 5, lba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1967       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1968       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1969       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1970       }
! 1971     sector = (Bit16u) (lba_low & 0x000000ffL);
.286:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1972     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1973     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1974   }
! 1975   outb(iobase1 + 1, 0x00);
.284:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1976   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1977   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1978   outb(iobase1 + 4, cylin
! 1978 der & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1979   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1980   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.28D
.28E:
mov	al,#$B0
jmp .28F
.28D:
mov	al,#$A0
.28F:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1981   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1982   await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1983   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1984   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.290
.291:
! 1985     ;
!BCC_EOS
! 1986     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1987     } else if ( !(status & 0x08) ) {
jmp .292
.290:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.293
.294:
! 1988     ;
!BCC_EOS
! 1989     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1990     }
! 1991 #asm
.293:
.292:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1993 endasm
!BCC_ENDASM
!BCC_EOS
! 1994   while (1) {
.297:
! 1995 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        push bp
        mov bp, sp
        mov si, _ata_cmd_data_out.offset + 2[bp]
        mov ax, _ata_cmd_data_out.segment + 2[bp]
        mov cx, _ata_cmd_data_out.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp si, #0xf800 ;;
        jbe ata_out_no_adjust
ata_out_adjust:
        sub si, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_out_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
        mov ah, _ata_cmd_data_out.mode + 2[bp]
        cmp ah, #0x01
        je ata_out_32
ata_out_16:
        seg ES
        rep
          outsw ;; CX words transfered from port(DX) to ES:[SI]
        jmp ata_out_done
ata_out_32:
        seg ES
        rep
          outsd ;; CX dwords transfered from port(DX) to ES:[SI]
ata_out_done:
        mov _ata_cmd_data_out.offset + 2[bp], si
        mov _ata_cmd_data_out.segment + 2[bp], es
        pop bp
! 2026 endasm
!BCC_ENDASM
!BCC_EOS
! 2027     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 2028     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2029     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 2030     status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2031     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.298
.299:
! 2032       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
! 2033           != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.29A
.29B:
! 2034         ;
!BCC_EOS
! 2035         return 6;
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2036         }
! 2037       break;
.29A:
jmp .295
!BCC_EOS
! 2038       }
! 2039     else {
jmp .29C
.298:
! 2040       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 2041           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.29D
.29E:
! 2042         ;
!BCC_EOS
! 2043         return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2044       }
! 2045       continue;
.29D:
jmp .296
!BCC_EOS
! 2046     }
! 2047   }
.29C:
! 2048   outb(iobase2+6, 0x08);
.296:
jmp	.297
.29F:
.295:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2049   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2050 }
! 2051 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
! Register BX used in function ata_cmd_data_out
! 2052 Bit8u cmdlen,inout;
export	_ata_cmd_packet
_ata_cmd_packet:
!BCC_EOS
! 2053 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
! 2053 
!BCC_EOS
! 2054 Bit16u header;
!BCC_EOS
! 2055 Bit32u length;
!BCC_EOS
! 2056 {
! 2057   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2058   Bit16u iobase1, iobase2;
!BCC_EOS
! 2059   Bit16u lcount, lbefore, lafter, count;
!BCC_EOS
! 2060   Bit8u channel, slave;
!BCC_EOS
! 2061   Bit8u status, mode, lmode;
!BCC_EOS
! 2062   Bit32u total, transfer;
!BCC_EOS
! 2063   channel = device / 2;
add	sp,*-$1A
! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 2064   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
mov	-$10[bp],al
!BCC_EOS
! 2065   if (inout == 0x02) {
! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.2A0
.2A1:
! 2066     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
! Debug: list * char = .2A2+0 (used reg = )
mov	bx,#.2A2
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2067     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2068     }
! 2069   if (header & 1) {
.2A0:
! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
mov	al,$C[bp]
and	al,*1
test	al,al
je  	.2A3
.2A4:
! 2070     ;
!BCC_EOS
! 2071     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2072     }
! 2073   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
.2A3:
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2074   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2075   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 2076   transfer= 0L;
! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2077   if (cmdlen < 12) cmdlen=12;
! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jae 	.2A5
.2A6:
! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$C
mov	6[bp],al
!BCC_EOS
! 2078   if (cmdlen > 12) cmdlen=16;
.2A5:
! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jbe 	.2A7
.2A8:
! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$10
mov	6[bp],al
!BCC_EOS
! 2079   cmdlen>>=1;
.2A7:
! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
shr	ax,*1
mov	6[bp],al
!BCC_EOS
! 2080   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2081   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2082   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2083   if (status & 0x80) return 2;
! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$80
test	al,al
je  	.2A9
.2AA:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2084   outb(iobase2 + 6, 0x08 | 0x02);
.2A9:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2085   outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2086   outb(iobase1 + 2, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2087   outb(iobase1 + 3, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2088   outb(iobase1 + 4, 0xfff0 & 0x00ff);
! Debug: list unsigned int = const $F0 (used reg = )
mov	ax,#$F0
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2089   outb(iobase1 + 5, 0xfff0 >> 8);
! Debug: list unsigned int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2090   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
mov	al,-$10[bp]
test	al,al
je  	.2AB
.2AC:
mov	al,#$B0
jmp .2AD
.2AB:
mov	al,#$A0
.2AD:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2091   outb(iobase1 + 7, 0xA0);
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2092   await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2093   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2094   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.2AE
.2AF:
! 2095     ;
!BCC_EOS
! 2096     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2097     } else if ( !(status & 0x08) ) {
jmp .2B0
.2AE:
! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*8
test	al,al
jne 	.2B1
.2B2:
! 2098     ;
!BCC_EOS
! 2099     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2100     }
! 2101   cmdseg += (cmdoff / 16);
.2B1:
.2B0:
! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
add	ax,8[bp]
mov	8[bp],ax
!BCC_EOS
! 2102   cmdoff %= 16;
! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
and	al,*$F
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 2103 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$26
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$28
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$E
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$10
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$18
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$D
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$24
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$22
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	9
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$20
.ata_cmd_packet.device	set	4
_ata_cmd_packet.ebda_seg	set	$1A
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$14
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	4
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$B
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$A
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$32
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	0
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.iobase2	set	$16
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$12
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$30
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$C
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$2E
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2A
.ata_cmd_packet.length	set	$E
      sti ;; enable higher priority interrupts
      push bp
      mov bp, sp
      mov si, _ata_cmd_packet.cmdoff + 2[bp]
      mov ax, _ata_cmd_packet.cmdseg + 2[bp]
      mov cx, _ata_cmd_packet.cmdlen + 2[bp]
      mov es, ax ;; segment in es
      mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
      seg ES
      rep
        outsw ;; CX words transfered from port(DX) to ES:[SI]
      pop bp
! 2116 endasm
!BCC_ENDASM
!BCC_EOS
! 2117   if (inout == 0x00) {
! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
test	al,al
jne 	.2B3
.2B4:
! 2118     await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2119     status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2120     }
! 2121   else {
br 	.2B5
.2B3:
! 2122         Bit16u loops = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
xor	ax,ax
mov	-$1E[bp],ax
!BCC_EOS
! 2123         Bit8u sc;
!BCC_EOS
! 2124   while (1) {
dec	sp
dec	sp
.2B8:
! 2125       if (loops == 0) {
! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
test	ax,ax
jne 	.2B9
.2BA:
! 2126         sta
! 2126 tus = inb(iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2127         await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2128       }
! 2129       else
! 2130         await_ide(2, iobase1, 32000u);
jmp .2BB
.2B9:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () int = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 2131       loops++;
.2BB:
! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
inc	ax
mov	-$1E[bp],ax
!BCC_EOS
! 2132       status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2133       sc = inb(iobase1 + 2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
mov	-$1F[bp],al
!BCC_EOS
! 2134       if(((inb(iobase1 + 2)&0x7)==0x3) &&
! 2135          ((status & (0x40 | 0x01)) == 0x40)) break;
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
and	al,*7
! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
jne 	.2BC
.2BE:
! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*$41
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.2BC
.2BD:
br 	.2B6
!BCC_EOS
! 2136       if (status & 0x01) {
.2BC:
! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.2BF
.2C0:
! 2137         ;
!BCC_EOS
! 2138         return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2139       }
! 2140       bufseg += (bufoff / 16);
.2BF:
! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
add	ax,$14[bp]
mov	$14[bp],ax
!BCC_EOS
! 2141       bufoff %= 16;
! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
and	al,*$F
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 2142       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
add	al,-$22[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 2143       if(header>lcount) {
! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
cmp	ax,-8[bp]
jbe 	.2C1
.2C2:
! 2144          lbefore=lcount;
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2145          header-=lcount;
! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
sub	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 2146          lcount=0;
! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 2147          }
! 2148       else {
jmp .2C3
.2C1:
! 2149         lbefore=header;
! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,$C[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2150         header=0;
! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
xor	ax,ax
mov	$C[bp],ax
!BCC_EOS
! 2151         lcount-=lbefore;
! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
sub	ax,-$A[bp]
mov	-8[bp],ax
!BCC_EOS
! 2152         }
! 2153       if(lcount>length) {
.2C3:
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lcmpul
jbe 	.2C4
.2C5:
! 2154         lafter=lcount-length;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 2155         lcount=length;
! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,$E[bp]
mov	-8[bp],ax
!BCC_EOS
! 2156         length=0;
! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$E[bp],ax
mov	$10[bp],bx
!BCC_EOS
! 2157         }
! 2158       else {
jmp .2C6
.2C4:
! 2159         lafter=0;
! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 2160         length-=lcount;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
push	bx
push	ax
mov	ax,$E[bp]
mov	bx,$10[bp]
lea	di,-$24[bp]
call	lsubul
mov	$E[bp],ax
mov	$10[bp],bx
add	sp,*4
!BCC_EOS
! 2161         }
! 2162       count = lcount;
.2C6:
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-8[bp]
mov	-$E[bp],ax
!BCC_EOS
! 2163       ;
!BCC_EOS
! 2164       ;
!BCC_EOS
! 2165       lmode = mode;
! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$12[bp]
mov	-$13[bp],al
!BCC_EOS
! 2166       if (lbefore & 0x03) lmode=0x00;
! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	al,-$A[bp]
and	al,*3
test	al,al
je  	.2C7
.2C8:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2167       if (lcount & 0x03) lmode=0x00;
.2C7:
! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*3
test	al,al
je  	.2C9
.2CA:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2168       if (lafter & 0x03) lmode=0x00;
.2C9:
! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*3
test	al,al
je  	.2CB
.2CC:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2169       if (lcount & 0x01) {
.2CB:
! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*1
test	al,al
je  	.2CD
.2CE:
! 2170         lcount+=1;
! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 2171         if ((lafter > 0) && (lafter & 0x01)) {
! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.2CF
.2D1:
! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*1
test	al,al
je  	.2CF
.2D0:
! 2172           lafter-=1;
! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
dec	ax
mov	-$C[bp],ax
!BCC_EOS
! 2173           }
! 2174         }
.2CF:
! 2175       if (lmode == 0x01) {
.2CD:
! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$13[bp]
cmp	al,*1
jne 	.2D2
.2D3:
! 2176         lcount>>=2; lbefore>>=2; lafter>>=2;
! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2177         }
! 2178       else {
jmp .2D4
.2D2:
! 2179         lcount>>=1; lbefore>>=1; lafter>>=1;
! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2180         }
! 2181        ;
.2D4:
!BCC_EOS
! 2182 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$2A
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$2C
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$12
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$14
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$1C
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$11
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$28
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$26
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	$D
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$24
.ata_cmd_packet.device	set	4
_ata_cmd_packet.loops	set	2
.ata_cmd_packet.loops	set	-$1E
_ata_cmd_packet.ebda_seg	set	$1E
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$18
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	8
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$F
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$E
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$36
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	4
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.sc	set	1
.ata_cmd_packet.sc	set	-$1F
_ata_cmd_packet.iobase2	set	$1A
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$16
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$34
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$10
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$32
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2E
.ata_cmd_packet.length	set	$E
        push bp
        mov bp, sp
        mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
        mov cx, _ata_cmd_packet.lbefore + 2[bp]
        jcxz ata_packet_no_before
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_before_32
ata_packet_in_before_16:
        in ax, dx
        loop ata_packet_in_before_16
        jmp ata_packet_no_before
ata_packet_in_before_32:
        push eax
ata_packet_in_before_32_loop:
        in eax, dx
        loop ata_packet_in_before_32_loop
        pop eax
ata_packet_no_before:
        mov cx, _ata_cmd_packet.lcount + 2[bp]
        jcxz ata_packet_after
        mov di, _ata_cmd_packet.bufoff + 2[bp]
        mov ax, _ata_cmd_packet.bufseg + 2[bp]
        mov es, ax
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_32
ata_packet_in_16:
        rep
          insw ;; CX words transfered tp port(DX) to ES:[DI]
        jmp ata_packet_after
ata_packet_in_32:
        rep
          insd ;; CX dwords transfered to port(DX) to ES:[DI]
ata_packet_after:
        mov cx, _ata_cmd_packet.lafter + 2[bp]
        jcxz ata_packet_done
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_after_32
ata_packet_in_after_16:
        in ax, dx
        loop ata_packet_in_after_16
        jmp ata_packet_done
ata_packet_in_after_32:
        push eax
ata_packet_in_after_32_loop:
        in eax, dx
        loop ata_packet_in_after_32_loop
        pop eax
ata_packet_done:
        pop bp
! 2235 endasm
!BCC_ENDASM
!BCC_EOS
! 2236       bufoff += count;
! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
add	ax,-$E[bp]
mov	$16[bp],ax
!BCC_EOS
! 2237       transfer += count;
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
lea	di,-$1C[bp]
call	laddul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2238       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2239       }
! 2240     }
.2B7:
br 	.2B8
.2D5:
.2B6:
add	sp,*4
! 2241   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
.2B5:
! 2242          != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.2D6
.2D7:
! 2243     ;
!BCC_EOS
! 2244     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2245     }
! 2246   outb(iobase2+6, 0x08);
.2D6:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2247   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2248 }
! 2249   Bit16u
! Register BX used in function ata_cmd_packet
! 2250 atapi_get_sense(device, seg, asc, ascq)
! 2251   Bit16u device;
export	_atapi_get_sense
_atapi_get_sense:
!BCC_EOS
! 2252 {
! 2253   Bit8u atacmd[12];
!BCC_EOS
! 2254   Bit8u buffer[18];
!BCC_EOS
! 2255   Bit8u i;
!BCC_EOS
! 2256   memsetb(get_SS(),atacmd,0,12);
push	bp
mov	bp,sp
add	sp,*-$20
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2257   atacmd[0]=0x03;
! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	al,*3
mov	-$C[bp],al
!BCC_EOS
! 2258   atacmd[4]=sizeof(buffer);
! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
mov	al,*$12
mov	-8[bp],al
!BCC_EOS
! 2259   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $12 (used reg = )
mov	ax,*$12
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$34+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.2D8
.2D9:
! 2260     return 0x0002;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2261   write_byte(seg,asc,buffer[12]);
.2D8:
! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int asc = [S+$24+6] (used reg = )
push	8[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2262   write_byte(seg,ascq,buffer[13]);
! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int ascq = [S+$24+8] (used reg = )
push	$A[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2263   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2264 }
! 2265   Bit16u
! Register BX used in function atapi_get_sense
! 2266 atapi_is_ready(device)
! 2267   Bit16u device;
export	_atapi_is_ready
_atapi_is_ready:
!BCC_EOS
! 2268 {
! 2269   Bit8u packet[12];
!BCC_EOS
! 2270   Bit8u buf[8];
!BCC_EOS
! 2271   Bit32u block_len;
!BCC_EOS
! 2272   Bit32u sectors;
!BCC_EOS
! 2273   Bit32u timeout;
!BCC_EOS
! 2274   Bit32u time;
!BCC_EOS
! 2275   Bit8u asc, ascq;
!BCC_EOS
! 2276   Bit8u in_progress;
!BCC_EOS
! 2277   Bit16u ebda_seg = read_word(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$2A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 2278   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2DA
.2DB:
! 2279     bios_printf(2, "not implemented for non-ATAPI device\n");
! Debug: list * char = .2DC+0 (used reg = )
mov	bx,#.2DC
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2280     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2281   }
! 2282   ;
.2DA:
!BCC_EOS
! 2283   memsetb(get_SS(),packet, 0, sizeof packet);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$30-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2284   packet[0] = 0x25;
! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
mov	al,*$25
mov	-$C[bp],al
!BCC_EOS
! 2285   timeout = 5000;
! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$1388
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2286   time = 0;
! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$24[bp],ax
mov	-$22[bp],bx
!BCC_EOS
! 2287   in_progress = 0;
! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
xor	al,al
mov	-$27[bp],al
!BCC_EOS
! 2288   while (time < timeout) {
br 	.2DE
.2DF:
! 2289     if
! 2289  (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
lea	bx,-$14[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const 8 (used reg = )
mov	ax,*8
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$38-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$3E+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2E0
.2E1:
! 2290       goto ok;
add	sp,#..FFFA+$2C
br 	.FFFA
!BCC_EOS
! 2291     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
.2E0:
! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
lea	bx,-$26[bp]
push	bx
! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
lea	bx,-$25[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short device = [S+$32+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
call	_atapi_get_sense
add	sp,*8
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2E2
.2E3:
! 2292       if (asc == 0x3a) {
! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*$3A
jne 	.2E4
.2E5:
! 2293         ;
!BCC_EOS
! 2294         return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2295       }
! 2296       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
.2E4:
! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*4
jne 	.2E6
.2E9:
! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*1
jne 	.2E6
.2E8:
mov	al,-$27[bp]
test	al,al
jne 	.2E6
.2E7:
! 2297         bios_printf(2, "Waiting for device to detect medium... ");
! Debug: list * char = .2EA+0 (used reg = )
mov	bx,#.2EA
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2298         timeout = 30000;
! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$7530
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2299         in_progress = 1;
! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
mov	al,*1
mov	-$27[bp],al
!BCC_EOS
! 2300       }
! 2301     }
.2E6:
! 2302     time += 100;
.2E2:
! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,*$64
xor	bx,bx
push	bx
push	ax
mov	ax,-$24[bp]
mov	bx,-$22[bp]
lea	di,-$2E[bp]
call	laddul
mov	-$24[bp],ax
mov	-$22[bp],bx
add	sp,*4
!BCC_EOS
! 2303   }
! 2304   ;
.2DE:
! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,-$20[bp]
mov	bx,-$1E[bp]
lea	di,-$24[bp]
call	lcmpul
bhi 	.2DF
.2EB:
.2DD:
!BCC_EOS
! 2305   return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2306 ok:
.FFFA:
..FFFA	=	-$2C
! 2307   block_len = (Bit32u) buf[4] << 24
! 2308     | (Bit32u) buf[5] << 16
! 2309     | (Bit32u) buf[6] << 8
! 2310     | (Bit32u) buf[7] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
mov	al,-$10[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
mov	-$18[bp],ax
mov	-$16[bp],bx
!BCC_EOS
! 2311   ;
!BCC_EOS
! 2312   if (block_len!= 2048 && block_len!= 512)
! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2EC
.2EE:
! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2EC
.2ED:
! 2313   {
! 2314     bios_printf(2, "Unsupported sector size %u\n", block_len);
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: list * char = .2EF+0 (used reg = )
mov	bx,#.2EF
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2315     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2316   }
! 2317   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
.2EC:
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2318   sectors = (Bit32u) buf[0] << 24
! 2319     | (Bit32u) buf[1] << 16
! 2320     | (Bit32u) buf[2] << 8
! 2321     | (Bit32u) buf[3] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2322   ;
!BCC_EOS
! 2323   if (block_len == 2048)
! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
jne 	.2F0
.2F1:
! 2324     sectors <<= 2;
! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	di,*2
call	lslul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2325   if (sectors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
.2F0:
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
! Debug: expression subtree swapping
lea	di,-$1C[bp]
call	lcmpul
je  	.2F2
.2F3:
! 2326     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list * char = .2F4+0 (used reg = )
mov	bx,#.2F4
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2327   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
.2F2:
! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2328   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2329 }
! 2330   Bit16u
! Register BX used in function atapi_is_ready
! 2331 atapi_is_cdrom(device)
! 2332   Bit8u device;
export	_atapi_is_cdrom
_atapi_is_cdrom:
!BCC_EOS
! 2333 {
! 2334   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2335   if (device >= (4*2))
! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
mov	al,4[bp]
cmp	al,*8
jb  	.2F5
.2F6:
! 2336     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2337   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
.2F5:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2F7
.2F8:
! 2338     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2339   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
.2F7:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
je  	.2F9
.2FA:
! 2340     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2341   return 1;
.2F9:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2342 }
! 2343   void
! Register BX used in function atapi_is_cdrom
! 2344 cdemu_init()
! 2345 {
export	_cdemu_init
_cdemu_init:
! 2346   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2347   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2348 }
mov	sp,bp
pop	bp
ret
! 2349   Bit8u
! 2350 cdemu_isactive()
! 2351 {
export	_cdemu_isactive
_cdemu_isactive:
! 2352   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2353   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2354 }
! 2355   Bit8u
! 2356 cdemu_emulated_drive()
! 2357 {
export	_cdemu_emulated_drive
_cdemu_emulated_drive:
! 2358   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2359   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2360 }
! 2361 static char isotag[6]="CD001";
.data
_isotag:
.2FB:
.ascii	"CD001"
.byte	0
!BCC_EOS
! 2362 static char eltorito[24]="EL T
! 2362 ORITO SPECIFICATION";
_eltorito:
.2FC:
.ascii	"EL TORITO SPECIFICATION"
.byte	0
!BCC_EOS
! 2363   Bit16u
! 2364 cdrom_boot()
! 2365 {
.text
export	_cdrom_boot
_cdrom_boot:
! 2366   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2367   Bit8u atacmd[12], buffer[2048];
!BCC_EOS
! 2368   Bit32u lba;
!BCC_EOS
! 2369   Bit16u boot_segment, nbsectors, i, error;
!BCC_EOS
! 2370   Bit8u device;
!BCC_EOS
! 2371   for (device=0; device<(4*2);device++) {
add	sp,#-$81A
! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
xor	al,al
mov	-$81B[bp],al
!BCC_EOS
!BCC_EOS
jmp .2FF
.300:
! 2372     if (atapi_is_cdrom(device)) break;
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
call	_atapi_is_cdrom
inc	sp
inc	sp
test	ax,ax
je  	.301
.302:
jmp .2FD
!BCC_EOS
! 2373     }
.301:
! 2374   if(device >= (4*2)) return 2;
.2FE:
! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
inc	ax
mov	-$81B[bp],al
.2FF:
! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb 	.300
.303:
.2FD:
! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb  	.304
.305:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2375   if(error = atapi_is_ready(device) != 0)
.304:
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
call	_atapi_is_ready
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je 	.308
mov	al,*1
jmp	.309
.308:
xor	al,al
.309:
! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
xor	ah,ah
mov	-$81A[bp],ax
test	ax,ax
je  	.306
.307:
! 2376     bios_printf(4, "ata_is_ready returned %d\n",error);
! Debug: list unsigned short error = [S+$81E-$81C] (used reg = )
push	-$81A[bp]
! Debug: list * char = .30A+0 (used reg = )
mov	bx,#.30A
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2377   memsetb(get_SS(),atacmd,0,12);
.306:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2378   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2379   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2380   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2381   atacmd[2]=(0x11 & 0xff000000) >> 24;
! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2382   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
xor	al,al
mov	-$B[bp],al
!BCC_EOS
! 2383   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
xor	al,al
mov	-$A[bp],al
!BCC_EOS
! 2384   atacmd[5]=(0x11 & 0x000000ff);
! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	al,*$11
mov	-9[bp],al
!BCC_EOS
! 2385   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.30B
.30C:
! 2386     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2387   if(buffer[0]!=0)return 4;
.30B:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
test	al,al
je  	.30D
.30E:
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2388   for(i=0;i<5;i++){
.30D:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
jmp .311
.312:
! 2389     if(read_byte(get_SS(),&buffer[1+i])!=read_byte(0xf000,&isotag[i]))return 5;
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_isotag+0] (used reg = )
! Debug: list * char = bx+_isotag+0 (used reg = )
add	bx,#_isotag
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
inc	ax
mov	bx,bp
add	bx,ax
! Debug: address unsigned char = [bx-$80E] (used reg = )
! Debug: list * unsigned char = bx-$80E (used reg = )
add	bx,#-$80E
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
beq 	.313
.314:
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2390    }
.313:
! 2391   for(i=0;i<23;i++)
.310:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.311:
! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*5
jb 	.312
.315:
.30F:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
! 2392     if(read_byte(get_SS(),&buffer[7+i])!=read_byte(0xf000,&eltorito[i]))return 6;
jmp .318
.319:
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_eltorito+0] (used reg = )
! Debug: list * char = bx+_eltorito+0 (used reg = )
add	bx,#_eltorito
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
add	ax,*7
mov	bx,bp
add	bx,ax
! Debug: address unsigned char = [bx-$80E] (used reg = )
! Debug: list * unsigned char = bx-$80E (used reg = )
add	bx,#-$80E
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
je  	.31A
.31B:
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2393   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
.31A:
.317:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.318:
! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*$17
jb 	.319
.31C:
.316:
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
mov	al,-$7C7[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
mov	al,-$7C6[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
mov	al,-$7C5[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
mov	al,-$7C4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2394   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2395   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2396   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2397   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2398   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2399   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2400   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2401   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2402   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.31D
.31E:
! 2403     return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2404   if(buffer[0x00]!=0x01)return 8;
.31D:
! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
cmp	al,*1
je  	.31F
.320:
mov	ax,*8
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2405   if(buffer[0x01]!=0x00)return 9;
.31F:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
mov	al,-$80D[bp]
test	al,al
je  	.321
.322:
mov	ax,*9
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2406   if(buffer[0x1E]!=0x55)return 10;
.321:
! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
mov	al,-$7F0[bp]
cmp	al,*$55
je  	.323
.324:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2407   if(buffer[0x1F]!=0xAA)return 10;
.323:
! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
mov	al,-$7EF[bp]
cmp	al,#$AA
je  	.325
.326:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2408   if(buffer[0x20]!=0x88)return 11;
.325:
! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
mov	al,-$7EE[bp]
cmp	al,#$88
je  	.327
.328:
mov	ax,*$B
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2409   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
.327:
! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2410   if(buffer[0x21]==0){
! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
test	al,al
jne 	.329
.32A:
! 2411     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
! Debug: list int = const $E0 (used reg = )
mov	ax,#$E0
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2412     }
! 2413   else if(buffer[0x21]<4)
jmp .32B
.329:
! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
cmp	al,*4
jae 	.32C
.32D:
! 2414     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2415   else
! 2416     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
jmp .32E
.32C:
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2417   write_byte(ebda_seg,&((ebda_data_t 
.32E:
.32B:
! 2417 *) 0)->cdemu.controller_index,device/2);
! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
shr	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2418   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2419   boot_segment=buffer[0x23]*0x100+buffer[0x22];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
mov	al,-$7EB[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
add	al,-$7EC[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	-$814[bp],ax
!BCC_EOS
! 2420   if(boot_segment==0x0000)boot_segment=0x07C0;
! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,-$814[bp]
test	ax,ax
jne 	.32F
.330:
! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,#$7C0
mov	-$814[bp],ax
!BCC_EOS
! 2421   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
.32F:
! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
push	-$814[bp]
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2422   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2423   nbsectors=buffer[0x27]*0x100+buffer[0x26];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
mov	al,-$7E7[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
add	al,-$7E8[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	-$816[bp],ax
!BCC_EOS
! 2424   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
push	-$816[bp]
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2425   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
mov	al,-$7E6[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
mov	al,-$7E5[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
mov	al,-$7E4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
mov	al,-$7E3[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2426   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
push	-$810[bp]
push	-$812[bp]
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2427   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2428   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2429   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
inc	ax
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2430   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
inc	ax
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 2431   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2432   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2433   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2434   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2435   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
mov	ax,-$816[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$826[bp]
mov	bx,-$824[bp]
lea	di,-$82A[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.331
.332:
! 2436     return 12;
mov	ax,*$C
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2437   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
.331:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
br 	.335
! 2438     case 0x01:
! 2439       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
.336:
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2440       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2441       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2442       break;
br 	.333
!BCC_EOS
! 2443     case 0x02:
! 2444       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
.337:
! Debug: list int = const $12 (used reg = )
mov	ax,*$12
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2445       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2446       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2447       break;
br 	.333
!BCC_EOS
! 2448     case 0x03:
! 2449       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
.338:
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2450       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2451       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2452       break;
br 	.333
!BCC_EOS
! 2453     case 0x04:
! 2454       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
.339:
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2455       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
! 2456           
! 2456     (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
! Debug: list int = const $1C5 (used reg = )
mov	ax,#$1C5
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
add	al,0+..FFF9[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2457       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
! Debug: list int = const $1C3 (used reg = )
mov	ax,#$1C3
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2458       break;
jmp .333
!BCC_EOS
! 2459    }
! 2460   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
jmp .333
.335:
sub	al,*1
beq 	.336
sub	al,*1
beq 	.337
sub	al,*1
beq 	.338
sub	al,*1
beq 	.339
.333:
..FFF9	=	-$81E
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.33A
.33B:
! 2461     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.33C
.33D:
! 2462       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
or	al,*$41
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2463     else
! 2464       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
jmp .33E
.33C:
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2465    }
.33E:
! 2466   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
.33A:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.33F
.340:
! 2467     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2468   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
.33F:
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2469 }
! 2470   void
! Register BX used in function cdrom_boot
! 2471 int14_function(regs, ds, iret_addr)
! 2472   pusha_regs_t regs;
export	_int14_function
_int14_function:
!BCC_EOS
! 2473   Bit16u ds;
!BCC_EOS
! 2474   iret_addr_t iret_addr;
!BCC_EOS
! 2475 {
! 2476   Bit16u addr,timer,val16;
!BCC_EOS
! 2477   Bit8u timeout;
!BCC_EOS
! 2478 #asm
push	bp
mov	bp,sp
add	sp,*-8
!BCC_EOS
!BCC_ASM
_int14_function.ds	set	$1C
.int14_function.ds	set	$14
_int14_function.timer	set	4
.int14_function.timer	set	-4
_int14_function.timeout	set	1
.int14_function.timeout	set	-7
_int14_function.iret_addr	set	$1E
.int14_function.iret_addr	set	$16
_int14_function.addr	set	6
.int14_function.addr	set	-2
_int14_function.val16	set	2
.int14_function.val16	set	-6
_int14_function.regs	set	$C
.int14_function.regs	set	4
  sti
! 2480 endasm
!BCC_ENDASM
!BCC_EOS
! 2481   addr = read_word(0x0040, (regs.u.r16.dx << 1));
! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2482   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$7C (used reg = )
add	ax,*$7C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2483   if ((regs.u.r16.dx < 4) && (addr > 0)) {
! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*4
bhis	.341
.343:
! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.341
.342:
! 2484     switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.346
! 2485       case 0:
! 2486         outb(addr+3, inb(addr+3) | 0x80);
.347:
! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2487         if (regs.u.r8.al & 0xE0 == 0) {
! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	al,al
test	al,al
je  	.348
.349:
! 2488           outb(addr, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2489           outb(addr+1, 0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2490         } else {
jmp .34A
.348:
! 2491           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,#$E0
! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*5
shr	ax,cl
! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
mov	bx,ax
mov	ax,#$600
mov	cx,bx
sar	ax,cl
! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2492           outb(addr, val16 & 0xFF);
! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
mov	al,-6[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2493           outb(addr+1, val16 >> 8);
! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2494         }
! 2495         outb(addr+3, regs.u.r8.al & 0x1F);
.34A:
! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,*$1F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2496         regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2497         regs.u.r8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2498         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2499         break;
br 	.344
!BCC_EOS
! 2500       case 1:
! 2501         timer = read_word(0x0040, 0x006C);
.34B:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2502         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
jmp .34D
.34E:
! 2503           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2504           if (val16 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.34F
.350:
! 2505             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2506             timeout--;
! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2507             }
! 2508           }
.34F:
! 2509         if (timeout) outb(addr, regs.u.r8.al);
.34D:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
cmp	al,*$60
je  	.351
.352:
mov	al,-7[bp]
test	al,al
jne	.34E
.351:
.34C:
mov	al,-7[bp]
test	al,al
je  	.353
.354:
! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2510         regs.u.r8.ah = inb(addr+5);
.353:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2511         if (!timeout) regs.u.r8.ah |= 0x80;
mov	al,-7[bp]
test	al,al
jne 	.355
.356:
! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
mov	al,$13[bp]
or	al,#$80
mov	$13[bp],al
!BCC_EOS
! 2512         iret_addr.flags.u.r8.flagsl &= 0xfe;
.355:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2513         break;
br 	.344
!BCC_EOS
! 2514       case 2:
! 2515 
! 2515         timer = read_word(0x0040, 0x006C);
.357:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2516         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
jmp .359
.35A:
! 2517           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2518           if (val16 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.35B
.35C:
! 2519             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2520             timeout--;
! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2521             }
! 2522           }
.35B:
! 2523         if (timeout) {
.359:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.35D
.35E:
mov	al,-7[bp]
test	al,al
jne	.35A
.35D:
.358:
mov	al,-7[bp]
test	al,al
je  	.35F
.360:
! 2524           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2525           regs.u.r8.al = inb(addr);
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2526         } else {
jmp .361
.35F:
! 2527           regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2528           }
! 2529         iret_addr.flags.u.r8.flagsl &= 0xfe;
.361:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2530         break;
jmp .344
!BCC_EOS
! 2531       case 3:
! 2532         regs.u.r8.ah = inb(addr+5);
.362:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2533         regs.u.r8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2534         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2535         break;
jmp .344
!BCC_EOS
! 2536       default:
! 2537         iret_addr.flags.u.r8.flagsl |= 0x01;
.363:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2538       }
! 2539   } else {
jmp .344
.346:
sub	al,*0
beq 	.347
sub	al,*1
beq 	.34B
sub	al,*1
beq 	.357
sub	al,*1
je 	.362
jmp	.363
.344:
..FFF8	=	-$A
jmp .364
.341:
! 2540     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2541     }
! 2542 }
.364:
mov	sp,bp
pop	bp
ret
! 2543   void
! Register BX used in function int14_function
! 2544 int15_function(regs, ES, DS, FLAGS)
! 2545   pusha_regs_t regs;
export	_int15_function
_int15_function:
!BCC_EOS
! 2546   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2547 {
! 2548   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2549   bx_bool prev_a20_enable;
!BCC_EOS
! 2550   Bit16u base15_00;
!BCC_EOS
! 2551   Bit8u base23_16;
!BCC_EOS
! 2552   Bit16u ss;
!BCC_EOS
! 2553   Bit16u CX,DX;
!BCC_EOS
! 2554   Bit16u bRegister;
!BCC_EOS
! 2555   Bit8u irqDisable;
!BCC_EOS
! 2556 ;
add	sp,*-$10
!BCC_EOS
! 2557   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.367
! 2558     case 0x24:
! 2559       switch (regs.u.r8.al) {
.368:
mov	al,$12[bp]
br 	.36B
! 2560         case 0x00:
! 2561           set_enable_a20(0);
.36C:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2562           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2563           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2564           break;
br 	.369
!BCC_EOS
! 2565         case 0x01:
! 2566           set_enable_a20(1);
.36D:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2567           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2568           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2569           break;
jmp .369
!BCC_EOS
! 2570         case 0x02:
! 2571           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
.36E:
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
shr	ax,*1
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2572           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2573           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2574           break;
jmp .369
!BCC_EOS
! 2575         case 0x03:
! 2576           FLAGS &= 0xfffe;
.36F:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2577           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2578           regs.u.r16.bx = 3;
! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
mov	ax,*3
mov	$C[bp],ax
!BCC_EOS
! 2579           break;
jmp .369
!BCC_EOS
! 2580         default:
! 2581           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
.370:
! Debug: list unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list * char = .371+0 (used reg = )
mov	bx,#.371
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2582           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2583           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2584       }
! 2585       break;
jmp .369
.36B:
sub	al,*0
beq 	.36C
sub	al,*1
beq 	.36D
sub	al,*1
je 	.36E
sub	al,*1
je 	.36F
jmp	.370
.369:
br 	.365
!BCC_EOS
! 2586     case 0x41:
! 2587       FLAGS |= 0x0001;
.372:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2588       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2589       break;
br 	.365
!BCC_EOS
! 2590     case 0x4f:
! 2591       FLAGS |= 0x0001;
.373:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2592       break;
br 	.365
!BCC_EOS
! 2593     case 0x52:
! 2594       FLAGS &= 0xfffe;
.374:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2595       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2596       break;
br 	.365
!BCC_EOS
! 2597     case 0x83: {
.375:
! 2598       if( regs.u.r8.al == 
! 2598 0 ) {
! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
test	al,al
bne 	.376
.377:
! 2599         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
bne 	.378
.379:
! 2600           write_byte( 0x40, 0xA0, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2601           write_word( 0x40, 0x98, ES );
! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
push	$14[bp]
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2602           write_word( 0x40, 0x9A, regs.u.r16.bx );
! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
push	$C[bp]
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2603           write_word( 0x40, 0x9C, regs.u.r16.dx );
! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
push	$E[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2604           write_word( 0x40, 0x9E, regs.u.r16.cx );
! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
push	$10[bp]
! Debug: list int = const $9E (used reg = )
mov	ax,#$9E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2605           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2606           irqDisable = inb( 0xA1 );
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2607           outb( 0xA1, irqDisable & 0xFE );
! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2608           bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 2609           outb_cmos( 0xB, bRegister | 0x40 );
! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
mov	ax,-$10[bp]
or	al,*$40
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2610         } else {
jmp .37A
.378:
! 2611           ;
!BCC_EOS
! 2612           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2613           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2614         }
! 2615       } else if( regs.u.r8.al == 1 ) {
.37A:
jmp .37B
.376:
! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*1
jne 	.37C
.37D:
! 2616         write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2617         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2618         bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 2619         outb_cmos( 0xB, bRegister & ~0x40 );
! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
mov	ax,-$10[bp]
and	al,#$BF
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2620       } else {
jmp .37E
.37C:
! 2621         ;
!BCC_EOS
! 2622         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2623         regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2624         regs.u.r8.al--;
! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
dec	ax
mov	$12[bp],al
!BCC_EOS
! 2625       }
! 2626       break;
.37E:
.37B:
br 	.365
!BCC_EOS
! 2627     }
! 2628     case 0x87:
! 2629 #asm
.37F:
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
  cli
! 2631 endasm
!BCC_ENDASM
!BCC_EOS
! 2632       prev_a20_enable = set_enable_a20(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2633       base15_00 = (ES << 4) + regs.u.r16.si;
! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2634       base23_16 = ES >> 12;
! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2635       if (base15_00 < (ES<<4))
! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
cmp	ax,-6[bp]
jbe 	.380
.381:
! 2636         base23_16++;
! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
inc	ax
mov	-7[bp],al
!BCC_EOS
! 2637       write_word(ES, regs.u.r16.si+0x08+0, 47);
.380:
! Debug: list int = const $2F (used reg = )
mov	ax,*$2F
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2638       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
push	-6[bp]
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2639       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2640       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$D (used reg = )
add	ax,*$D
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2641       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2642       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2643       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2644       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2645       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
! Debug: list int = const $9B (used reg = )
mov	ax,#$9B
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2646       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2647       ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 2648       base15_00 = ss << 4;
! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
mov	ax,-$A[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2649       base23_16 = ss >> 12;
! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2650       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2651       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
push	-6[bp]
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2652       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2C (used reg = )
add	ax,*$2C
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2653       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2D (used reg = )
add	ax,*$2D
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2654       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2E (used reg = )
add	ax,*$2E
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2655       CX = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
mov	ax,$10[bp]
mov	-$C[bp],ax
!BCC_EOS
! 2656 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
      mov bx, sp
      SEG SS
        mov cx, _int15_function.CX [bx]
      push eax
      xor eax, eax
      mov ds, ax
      mov 0x0469, ss
      mov 0x0467, sp
      SEG ES
        lgdt [si + 0x08]
      SEG CS
        lidt [pmode_IDT_info]
      ;; perhaps do something with IDT here
      ;; set PE bit in CR0
      mov eax, cr0
      or al, #0x01
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to protected mode
      JMP_AP(0x0020, protected_mode)
protected_mode:
      ;; GDT points to valid descriptor table, now load SS, DS, ES
      mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
      mov ss, ax
      mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
      mov ds, ax
      mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
      mov es, ax
      xor si, si
      xor di, di
      cld
      rep
        movsw ;; move CX words from DS:SI to ES:DI
      ;; make sure DS and ES limits are 64KB
      mov ax, #0x28
      mov ds, ax
      mov es, ax
      ;; reset PG bit in CR0 ???
      mov eax, cr0
      and al, #0xFE
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to real mode
      JMP_AP(0xf000, real_mode)
real_mode:
      ;; restore IDT to normal real-mode defaults
      SEG CS
        lidt [rmode_IDT_info]
      xor ax, ax
      mov ds, ax
      mov ss, 0x0469
      mov sp, 0x0467
      pop eax
! 2708 endasm
!BCC_ENDASM
!BCC_EOS
! 2709       set_enable_a20(prev_a20_enable);
! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2710 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
  sti
! 2712 endasm
!BCC_ENDASM
!BCC_EOS
! 2713       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2714       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2715       break;
br 	.365
!BCC_EOS
! 2716     case 0x88:
! 2717       regs.u.r8.al = inb_cmos(0x30);
.382:
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2718       regs.u.r8.ah = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2719       if(regs.u.r16.ax > 0xffc0)
! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
mov	ax,$12[bp]
cmp	ax,#$FFC0
jbe 	.383
.384:
! 2720         regs.u.r16.ax = 0xffc0;
! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
mov	ax,#$FFC0
mov	$12[bp],ax
!BCC_EOS
! 2721       FLAGS &= 0xfffe;
.383:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2722       break;
br 	.365
!BCC_EOS
! 2723     case 0x90:
! 2724       break;
.385:
br 	.365
!BCC_EOS
! 2725     case 0x91:
! 2726       break;
.386:
br 	.365
!BCC_EOS
! 2727     case 0xbf:
! 2728       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
.387:
! Debug: list * char = .388+0 (used reg = )
mov	bx,#.388
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2729       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2730       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2731       break;
br 	.365
!BCC_EOS
! 2732     case 0xC0:
! 2733       FLAGS &= 0xfffe;
.389:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2734       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2735       regs.u.r16.bx = 0xe6f5;
! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
mov	ax,#$E6F5
mov	$C[bp],ax
!BCC_EOS
! 2736       ES = 0xF000;
! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,#$F000
mov	$14[bp],ax
!BCC_EOS
! 2737       break;
br 	.365
!BCC_EOS
! 2738     case 0xc1:
! 2739       ES = ebda_seg;
.38A:
! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,-2[bp]
mov	$14[bp],ax
!BCC_EOS
! 2740       FL
! 2740 AGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2741       break;
br 	.365
!BCC_EOS
! 2742     case 0xd8:
! 2743       bios_printf(8, "EISA BIOS not present\n");
.38B:
! Debug: list * char = .38C+0 (used reg = )
mov	bx,#.38C
push	bx
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2744       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2745       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2746       break;
br 	.365
!BCC_EOS
! 2747     default:
! 2748       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
.38D:
! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
push	$C[bp]
! Debug: list unsigned short regs = [S+$16+$10] (used reg = )
push	$12[bp]
! Debug: list * char = .38E+0 (used reg = )
mov	bx,#.38E
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2749       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2750       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2751       break;
jmp .365
!BCC_EOS
! 2752     }
! 2753 }
jmp .365
.367:
sub	al,*$24
beq 	.368
sub	al,*$1D
beq 	.372
sub	al,*$E
beq 	.373
sub	al,*3
beq 	.374
sub	al,*$31
beq 	.375
sub	al,*4
beq 	.37F
sub	al,*1
beq 	.382
sub	al,*8
beq 	.385
sub	al,*1
beq 	.386
sub	al,*$2E
beq 	.387
sub	al,*1
beq 	.389
sub	al,*1
beq 	.38A
sub	al,*$17
beq 	.38B
br 	.38D
.365:
..FFF7	=	-$14
mov	sp,bp
pop	bp
ret
! 2754   void
! Register BX used in function int15_function
! 2755 int15_function_mouse(regs, ES, DS, FLAGS)
! 2756   pusha_regs_t regs;
export	_int15_function_mouse
_int15_function_mouse:
!BCC_EOS
! 2757   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2758 {
! 2759   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2760   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 2761   Bit16u mouse_driver_seg;
!BCC_EOS
! 2762   Bit16u mouse_driver_offset;
!BCC_EOS
! 2763   Bit8u comm_byte, prev_command_byte;
!BCC_EOS
! 2764   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
!BCC_EOS
! 2765 ;
add	sp,*-$C
!BCC_EOS
! 2766   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.391
! 2767     case 0xC2:
! 2768       switch (regs.u.r8.al) {
.392:
mov	al,$12[bp]
br 	.395
! 2769         case 0:
! 2770 ;
.396:
!BCC_EOS
! 2771           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.399
! 2772             case 0:
! 2773 ;
.39A:
!BCC_EOS
! 2774               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2775               ret = send_to_mouse_ctrl(0xF5);
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2776               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.39B
.39C:
! 2777                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2778                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
je  	.39E
.39F:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.39D
.39E:
! 2779                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2780                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2781                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2782                   }
! 2783                 }
.39D:
! 2784               FLAGS |= 0x0001;
.39B:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2785               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2786               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2787               break;
br 	.397
!BCC_EOS
! 2788             case 1:
! 2789 ;
.3A0:
!BCC_EOS
! 2790               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2791               if ( (mouse_flags_2 & 0x80) == 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.3A1
.3A2:
! 2792                 ;
!BCC_EOS
! 2793                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2794                 regs.u.r8.ah = 5;
! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*5
mov	$13[bp],al
!BCC_EOS
! 2795                 return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2796                 }
! 2797               inhibit_mouse_int_and_events();
.3A1:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2798               ret = send_to_mouse_ctrl(0xF4);
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2799               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3A3
.3A4:
! 2800                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2801                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3A5
.3A7:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.3A5
.3A6:
! 2802                   enable_mouse_int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2803                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2804                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2805                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2806                   }
! 2807                 }
.3A5:
! 2808               FLAGS |= 0x0001;
.3A3:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2809               
! 2809 regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2810               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2811             default:
! 2812               ;
.3A8:
!BCC_EOS
! 2813               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2814               regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 2815               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2816             }
! 2817           break;
jmp .397
.399:
sub	al,*0
beq 	.39A
sub	al,*1
beq 	.3A0
jmp	.3A8
.397:
br 	.393
!BCC_EOS
! 2818         case 1:
! 2819         case 5:
.3A9:
! 2820 ;
.3AA:
!BCC_EOS
! 2821           if (regs.u.r8.al == 5) {
! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*5
jne 	.3AB
.3AC:
! 2822             if (regs.u.r8.bh != 3) {
! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*3
je  	.3AD
.3AE:
! 2823               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2824               regs.u.r8.ah = 0x02;
! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*2
mov	$13[bp],al
!BCC_EOS
! 2825               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2826             }
! 2827             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
.3AD:
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2828             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	al,al
! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
or	al,$D[bp]
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2829             mouse_flags_1 = 0x00;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
! 2830             write_byte(ebda_seg, 0x0026, mouse_flags_1);
! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2831             write_byte(ebda_seg, 0x0027, mouse_flags_2);
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2832           }
! 2833           inhibit_mouse_int_and_events();
.3AB:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2834           ret = send_to_mouse_ctrl(0xFF);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2835           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3AF
.3B0:
! 2836             ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2837             if (mouse_data3 == 0xfe) {
! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FE
jne 	.3B1
.3B2:
! 2838               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2839               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2840             }
! 2841             if (mouse_data3 != 0xfa)
.3B1:
! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FA
je  	.3B3
.3B4:
! 2842               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3B5+0 (used reg = )
mov	bx,#.3B5
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2843             if ( ret == 0 ) {
.3B3:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3B6
.3B7:
! 2844               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2845               if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3B8
.3B9:
! 2846                 ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2847                 if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3BA
.3BB:
! 2848                   enable_mouse_int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2849                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2850                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2851                   regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2852                   regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2853                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2854                   }
! 2855                 }
.3BA:
! 2856               }
.3B8:
! 2857             }
.3B6:
! 2858           FLAGS |= 0x0001;
.3AF:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2859           regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2860           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2861         case 2:
! 2862 ;
.3BC:
!BCC_EOS
! 2863           switch (regs.u.r8.bh) {
mov	al,$D[bp]
jmp .3BF
! 2864             case 0: mouse_data1 = 10; break;
.3C0:
! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$A
mov	-$C[bp],al
!BCC_EOS
jmp .3BD
!BCC_EOS
! 2865             case 1: mouse_data1 = 20; break;
.3C1:
! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$14
mov	-$C[bp],al
!BCC_EOS
jmp .3BD
!BCC_EOS
! 2866             case 2: mouse_data1 = 40; break;
.3C2:
! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$28
mov	-$C[bp],al
!BCC_EOS
jmp .3BD
!BCC_EOS
! 2867             case 3: mouse_data1 = 60; break;
.3C3:
! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$3C
mov	-$C[bp],al
!BCC_EOS
jmp .3BD
!BCC_EOS
! 2868             case 4: mouse_data1 = 80; break;
.3C4:
! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$50
mov	-$C[bp],al
!BCC_EOS
jmp .3BD
!BCC_EOS
! 2869             case 5: mouse_data1 = 100; break;
.3C5:
! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$64
mov	-$C[bp],al
!BCC_EOS
jmp .3BD
!BCC_EOS
! 2870             case 6: mouse_data1 = 200; break;
.3C6:
! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,#$C8
mov	-$C[bp],al
!BCC_EOS
jmp .3BD
!BCC_EOS
! 2871   
! 2871           default: mouse_data1 = 0;
.3C7:
! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2872           }
! 2873           if (mouse_data1 > 0) {
jmp .3BD
.3BF:
sub	al,*0
jb 	.3C7
cmp	al,*6
ja  	.3C8
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.3C9[bx]
.3C9:
.word	.3C0
.word	.3C1
.word	.3C2
.word	.3C3
.word	.3C4
.word	.3C5
.word	.3C6
.3C8:
jmp	.3C7
.3BD:
! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
test	al,al
je  	.3CA
.3CB:
! 2874             ret = send_to_mouse_ctrl(0xF3);
! Debug: list int = const $F3 (used reg = )
mov	ax,#$F3
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2875             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3CC
.3CD:
! 2876               ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2877               ret = send_to_mouse_ctrl(mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2878               ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2879               FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2880               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2881             } else {
jmp .3CE
.3CC:
! 2882               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2883               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2884             }
! 2885           } else {
.3CE:
jmp .3CF
.3CA:
! 2886             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2887             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2888           }
! 2889           break;
.3CF:
br 	.393
!BCC_EOS
! 2890         case 3:
! 2891 ;
.3D0:
!BCC_EOS
! 2892           comm_byte = inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2893           if (regs.u.r8.bh < 4) {
! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*4
bhis	.3D1
.3D2:
! 2894             ret = send_to_mouse_ctrl(0xE8);
! Debug: list int = const $E8 (used reg = )
mov	ax,#$E8
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2895             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3D3
.3D4:
! 2896               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2897               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3D5
.3D6:
! 2898                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3D7+0 (used reg = )
mov	bx,#.3D7
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2899               ret = send_to_mouse_ctrl(regs.u.r8.bh);
.3D5:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2900               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2901               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3D8
.3D9:
! 2902                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3DA+0 (used reg = )
mov	bx,#.3DA
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2903               FLAGS &= 0xfffe;
.3D8:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2904               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2905             } else {
jmp .3DB
.3D3:
! 2906               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2907               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2908             }
! 2909           } else {
.3DB:
jmp .3DC
.3D1:
! 2910             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2911             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2912           }
! 2913           set_kbd_command_byte(comm_byte);
.3DC:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2914           break;
br 	.393
!BCC_EOS
! 2915         case 4:
! 2916 ;
.3DD:
!BCC_EOS
! 2917           inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2918           ret = send_to_mouse_ctrl(0xF2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2919           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3DE
.3DF:
! 2920             ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2921             ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2922             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2923             regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2924             regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2925           } else {
jmp .3E0
.3DE:
! 2926             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2927             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2928           }
! 2929           break;
.3E0:
br 	.393
!BCC_EOS
! 2930         case 6:
! 2931 ;
.3E1:
!BCC_EOS
! 2932           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.3E4
! 2933             case 0:
! 2934           
! 2934     comm_byte = inhibit_mouse_int_and_events();
.3E5:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2935               ret = send_to_mouse_ctrl(0xE9);
! Debug: list int = const $E9 (used reg = )
mov	ax,#$E9
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2936               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3E6
.3E7:
! 2937                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2938                 if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3E8
.3E9:
! 2939                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3EA+0 (used reg = )
mov	bx,#.3EA
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2940                 if (ret == 0) {
.3E8:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3EB
.3EC:
! 2941                   ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2942                   if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3ED
.3EE:
! 2943                     ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2944                     if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3EF
.3F0:
! 2945                       ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2946                       if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3F1
.3F2:
! 2947                         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2948                         regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2949                         regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2950                         regs.u.r8.cl = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
mov	al,-$D[bp]
mov	$10[bp],al
!BCC_EOS
! 2951                         regs.u.r8.dl = mouse_data3;
! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
mov	al,-$E[bp]
mov	$E[bp],al
!BCC_EOS
! 2952                         set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2953                         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2954                         }
! 2955                       }
.3F1:
! 2956                     }
.3EF:
! 2957                   }
.3ED:
! 2958                 }
.3EB:
! 2959               FLAGS |= 0x0001;
.3E6:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2960               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2961               set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2962               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2963             case 1:
! 2964             case 2:
.3F3:
! 2965               comm_byte = inhibit_mouse_int_and_events();
.3F4:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2966               if (regs.u.r8.bh == 1) {
! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*1
jne 	.3F5
.3F6:
! 2967                 ret = send_to_mouse_ctrl(0xE6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2968               } else {
jmp .3F7
.3F5:
! 2969                 ret = send_to_mouse_ctrl(0xE7);
! Debug: list int = const $E7 (used reg = )
mov	ax,#$E7
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2970               }
! 2971               if (ret == 0) {
.3F7:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3F8
.3F9:
! 2972                 get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
!BCC_EOS
! 2973                 ret = (mouse_data1 != 0xFA);
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je 	.3FA
mov	al,*1
jmp	.3FB
.3FA:
xor	al,al
.3FB:
! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2974               }
! 2975               if (ret == 0) {
.3F8:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3FC
.3FD:
! 2976                 FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2977                 regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2978               } else {
jmp .3FE
.3FC:
! 2979                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2980                 regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2981               }
! 2982               set_kbd_command_byte(comm_byte);
.3FE:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2983               break;
jmp .3E2
!BCC_EOS
! 2984             default:
! 2985               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
.3FF:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: list * char = .400+0 (used reg = )
mov	bx,#.400
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2986             }
! 2987           break;
jmp .3E2
.3E4:
sub	al,*0
beq 	.3E5
sub	al,*1
beq 	.3F3
sub	al,*1
beq 	.3F4
jmp	.3FF
.3E2:
br 	.393
!BCC_EOS
! 2988 
! 2988         case 7:
! 2989 ;
.401:
!BCC_EOS
! 2990           mouse_driver_seg = ES;
! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,$14[bp]
mov	-6[bp],ax
!BCC_EOS
! 2991           mouse_driver_offset = regs.u.r16.bx;
! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,$C[bp]
mov	-8[bp],ax
!BCC_EOS
! 2992           write_word(ebda_seg, 0x0022, mouse_driver_offset);
! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $22 (used reg = )
mov	ax,*$22
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2993           write_word(ebda_seg, 0x0024, mouse_driver_seg);
! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
push	-6[bp]
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2994           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2995           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
test	ax,ax
jne 	.402
.404:
! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jne 	.402
.403:
! 2996             if ( (mouse_flags_2 & 0x80) != 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.405
.406:
! 2997               mouse_flags_2 &= ~0x80;
! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,*$7F
mov	-4[bp],al
!BCC_EOS
! 2998               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2999               }
! 3000             }
.405:
! 3001           else {
jmp .407
.402:
! 3002             mouse_flags_2 |= 0x80;
! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
or	al,#$80
mov	-4[bp],al
!BCC_EOS
! 3003             }
! 3004           write_byte(ebda_seg, 0x0027, mouse_flags_2);
.407:
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3005           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 3006           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 3007           break;
jmp .393
!BCC_EOS
! 3008         default:
! 3009 ;
.408:
!BCC_EOS
! 3010           regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 3011           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 3012         }
! 3013       break;
jmp .393
.395:
sub	al,*0
jb 	.408
cmp	al,*7
ja  	.409
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.40A[bx]
.40A:
.word	.396
.word	.3A9
.word	.3BC
.word	.3D0
.word	.3DD
.word	.3AA
.word	.3E1
.word	.401
.409:
jmp	.408
.393:
jmp .38F
!BCC_EOS
! 3014     default:
! 3015       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
.40B:
! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
push	$C[bp]
! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
push	$12[bp]
! Debug: list * char = .40C+0 (used reg = )
mov	bx,#.40C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3016       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 3017       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 3018       break;
jmp .38F
!BCC_EOS
! 3019     }
! 3020 }
jmp .38F
.391:
sub	al,#$C2
beq 	.392
jmp	.40B
.38F:
..FFF6	=	-$10
mov	sp,bp
pop	bp
ret
! 3021 void set_e820_range(ES, DI, start, end, type)
! Register BX used in function int15_function_mouse
! 3022      Bit16u ES;
export	_set_e820_range
_set_e820_range:
!BCC_EOS
! 3023      Bit16u DI;
!BCC_EOS
! 3024      Bit32u start;
!BCC_EOS
! 3025      Bit32u end;
!BCC_EOS
! 3026      Bit16u type;
!BCC_EOS
! 3027 {
! 3028     write_word(ES, DI, start);
push	bp
mov	bp,sp
! Debug: list unsigned long start = [S+2+6] (used reg = )
push	$A[bp]
push	8[bp]
! Debug: list unsigned short DI = [S+6+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3029     write_word(ES, DI+2, start >> 16);
! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
mov	ax,8[bp]
mov	bx,$A[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3030     write_word(ES, DI+4, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3031     write_word(ES, DI+6, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3032     end -= start;
! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
lea	di,8[bp]
call	lsubul
mov	$C[bp],ax
mov	$E[bp],bx
!BCC_EOS
! 3033     write_word(ES, DI+8, end);
! Debug: list unsigned long end = [S+2+$A] (used reg = )
push	$E[bp]
push	$C[bp]
! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3034     write_word(ES, DI+10, end >> 16);
! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3035     write_word(ES, DI+12, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3036     write_word(ES, DI+14, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3037     write_word(ES, DI+16, type);
! Debug: list unsigned short type = [S+2+$E] (used reg = )
push	$10[bp]
! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3038     write_word(ES, DI+18, 0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3039 }
pop	bp
ret
! 3040   void
! Register BX used in function set_e820_range
! 3041 int15_function32(regs, ES, DS, FLAGS)
! 3042   pushad_regs_t regs;
export	_int15_function32
_int15_function32:
!BCC_EOS
! 3043   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 3044 {
! 3045   Bit32u extended_memory_size=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3046   Bit16u CX,DX;
!BCC_EOS
! 3047   Bit16u off, e820_table_size;
!BCC_EOS
! 3048   Bit32u base, type, size;
!BCC_EOS
! 3049 ;
add	sp,*-$14
!BCC_EOS
! 3050   switch (regs.u.r8.ah) {
mov	al,$21[bp]
br 	.40F
! 3051     case 0x86:
! 3052       CX = regs.u.r16.cx;
.410:
! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
mov	ax,$1C[bp]
mov	-6[bp],ax
!BCC_EOS
! 3053       DX = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
mov	ax,$18[bp]
mov	-8[bp],ax
!BCC_EOS
! 3054 #asm
!BCC_EOS
!BCC_ASM
_int15_function32.CX	set	$12
.int15_function32.CX	set	-6
_int15_function32.extended_memory_size	set	$14
.int15_function32.extended_memory_size	set	-4
_int15_function32.FLAGS	set	$40
.int15_function32.FLAGS	set	$28
_int15_function32.type	set	4
.int15_function32.type	set	-$14
_int15_function32.DS	set	$3E
.int15_function32.DS	set	$26
_int15_function32.DX	set	$10
.int15_function32.DX	set	-8
_int15_function32.size	set	0
.int15_function32.size	set	-$18
_int15_function32.ES	set	$3C
.int15_function32.ES	set	$24
_int15_function32.e820_table_size	set	$C
.int15_function32.e820_table_size	set	-$C
_int15_function32.base	set	8
.int15_function32.base	set	-$10
_int15_function32.regs	set	$1C
.int15_function32.regs	set	4
_int15_function32.off	set	$E
.int15_function32.off	set	-$A
      sti
      ;; Get the count in eax
      mov bx, sp
SEG SS
      mov ax, _int15_function32.CX [bx]
      shl eax, #16
SEG SS
      mov ax, _int15_function32.DX [bx]
      ;; convert to numbers of 15usec ticks
      mov ebx, #15
      xor edx, edx
      div eax, ebx
      mov ecx, eax
      ;; wait for ecx number of refresh requests
      in al, #0x61
      and al,#0x10
      mov ah, al
      or ecx, ecx
      je int1586_tick_end
int1586_tick:
      in al, #0x61
      and al,#0x10
      cmp al, ah
      je int1586_tick
      mov ah, al
      dec ecx
      jnz int1586_tick
int1586_tick_end:
! 3083 endasm
!BCC_ENDASM
!BCC_EOS
! 3084       break;
br 	.40D
!BCC_EOS
! 3085     case 0xe8:
! 3086         switch(regs.u.r8.al)
.411:
mov	al,$20[bp]
! 3087         {
br 	.414
! 3088        case 0x20: {
.415:
! 3089             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3090             if (regs.u.r32.edx != 0x534D4150)
! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$4150
mov	bx,#$534D
push	bx
push	ax
mov	ax,$18[bp]
mov	bx,$1A[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
je  	.416
.417:
! 3091                 goto int15_unimplemented;
add	sp,#..FFF4-..FFF5
br 	.FFF4
!BCC_EOS
! 3092             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
.416:
! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,*$14
call	idiv_u
! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
cmp	ax,$14[bp]
bne 	.418
.419:
! 3093                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
add	ax,*$14
cmp	ax,-$C[bp]
ja  	.41A
.41B:
! 3094                     memcpyb(ES, regs.u.r16.di,
! 3095                             (Bit16u)(0x000EA100 >> 4), 0x8 + regs.u.r16.bx, 0x14);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: add unsigned short regs = [S+$1C+$12] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,$14[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: list unsigned short regs = [S+$20+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
push	$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 3096                 regs.u.r32.ebx += 0x14;
.41A:
! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
mov	ax,*$14
xor	bx,bx
push	bx
push	ax
mov	ax,$14[bp]
mov	bx,$16[bp]
lea	di,-2+..FFF5[bp]
call	laddul
mov	$14[bp],ax
mov	$16[bp],bx
add	sp,*4
!BCC_EOS
! 3097                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$14
xor	bx,bx
lea	di,$14[bp]
call	laddul
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-6+..FFF5[bp]
mov	bx,-4+..FFF5[bp]
lea	di,-$A+..FFF5[bp]
call	lsubul
add	sp,*8
! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jbe 	.41C
.41D:
! 3098                     regs.u.r32.ebx = 0;
! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3099             } else if (regs.u.r16.bx == 1) {
.41C:
br 	.41E
.418:
! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
cmp	ax,*1
bne 	.41F
.420:
! 3100                 for (off = 0; off < e820_table_size; off += 0x14) {
! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
xor	ax,ax
mov	-$A[bp],ax
!BCC_EOS
!BCC_EOS
jmp .423
.424:
! 3101                     base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 3102                     type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
mov	-$14[bp],ax
mov	-$12[bp],bx
!BCC_EOS
! 3103                     if ((base >= 0x100000) && (type == 1))
! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
xor	ax,ax
mov	bx,*$10
lea	di,-$10[bp]
call	lcmpul
ja  	.425
.427:
! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-$14[bp]
mov	bx,-$12[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jne 	.425
.426:
! 3104                         break;
jmp .421
!BCC_EOS
! 3105                 }
.425:
! 3106                 if (off == e820_table_size) {
.422:
! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
add	ax,*$14
mov	-$A[bp],ax
.423:
! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jb 	.424
.428:
.421:
! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jne 	.429
.42A:
! 3107                     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 3108                     break;
br 	.412
!BCC_EOS
! 3109                 }
! 3110                 memcpyb(ES, regs.u.r16.di, (Bit16u)(0x000EA100 >> 4), 0x8 + off, 0x14);
.429:
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: add unsigned short off = [S+$1C-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: list unsigned short regs = [S+$20+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
push	$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 3111                 regs.u.r32.ebx = 0;
! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3112             } else {
jmp .42B
.41F:
! 3113                 goto int15_unimplemented;
add	sp,#..FFF4-..FFF5
br 	.FFF4
!BCC_EOS
! 3114             }
! 3115             regs.u.r32.eax = 0x534D4150;
.42B:
.41E:
! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
mov	ax,#$4150
mov	bx,#$534D
mov	$20[bp],ax
mov	$22[bp],bx
!BCC_EOS
! 3116             regs.u.r32.ecx = 0x14;
! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
mov	ax,*$14
xor	bx,bx
mov	$1C[bp],ax
mov	$1E[bp],bx
!BCC_EOS
! 3117             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3118             break;
br 	.412
!BCC_EOS
! 3119         }
! 3120         case 0x01: {
.42C:
! 3121             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3122             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3123             regs.u.r8.cl = inb_cmos(0x30);
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
mov	$1C[bp],al
!BCC_EOS
! 3124       
! 3124       regs.u.r8.ch = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
mov	$1D[bp],al
!BCC_EOS
! 3125             if (regs.u.r16.cx > (15*1024))
! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
mov	ax,$1C[bp]
cmp	ax,#$3C00
jbe 	.42D
.42E:
! 3126                 regs.u.r16.cx = 15*1024;
! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
mov	ax,#$3C00
mov	$1C[bp],ax
!BCC_EOS
! 3127             for (off = 0; off < e820_table_size; off += 0x14) {
.42D:
! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
xor	ax,ax
mov	-$A[bp],ax
!BCC_EOS
!BCC_EOS
jmp .431
.432:
! 3128                 base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 3129                 type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
mov	-$14[bp],ax
mov	-$12[bp],bx
!BCC_EOS
! 3130                 if ((base >= 0x100000) && (type == 1))
! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
xor	ax,ax
mov	bx,*$10
lea	di,-$10[bp]
call	lcmpul
ja  	.433
.435:
! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-$14[bp]
mov	bx,-$12[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jne 	.433
.434:
! 3131                     break;
jmp .42F
!BCC_EOS
! 3132             }
.433:
! 3133             regs.u.r16.dx = 0;
.430:
! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
add	ax,*$14
mov	-$A[bp],ax
.431:
! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jb 	.432
.436:
.42F:
! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
xor	ax,ax
mov	$18[bp],ax
!BCC_EOS
! 3134             if (off != e820_table_size) {
! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
je  	.437
.438:
! 3135                 size = base + read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
! Debug: expression subtree swapping
lea	di,-$10[bp]
call	laddul
! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
mov	-$18[bp],ax
mov	-$16[bp],bx
!BCC_EOS
! 3136                 if (size > 0x1000000) {
! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
xor	ax,ax
mov	bx,#$100
lea	di,-$18[bp]
call	lcmpul
jae 	.439
.43A:
! 3137                     size -= 0x1000000;
! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-2+..FFF5[bp]
call	lsubul
mov	-$18[bp],ax
mov	-$16[bp],bx
add	sp,*4
!BCC_EOS
! 3138                     regs.u.r16.dx = (Bit16u)(size >> 16);
! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
mov	ax,-$18[bp]
mov	bx,-$16[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3139                 }
! 3140             }
.439:
! 3141             regs.u.r16.ax = regs.u.r16.cx;
.437:
! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
mov	ax,$1C[bp]
mov	$20[bp],ax
!BCC_EOS
! 3142             regs.u.r16.bx = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$18[bp]
mov	$14[bp],ax
!BCC_EOS
! 3143             break;
jmp .412
!BCC_EOS
! 3144         }
! 3145         default:
! 3146             goto int15_unimplemented;
.43B:
add	sp,#..FFF4-..FFF5
jmp .FFF4
!BCC_EOS
! 3147         }
! 3148         break;
jmp .412
.414:
sub	al,*1
beq 	.42C
sub	al,*$1F
beq 	.415
jmp	.43B
.412:
jmp .40D
!BCC_EOS
! 3149     int15_unimplemented:
.FFF4:
! 3150     default:
! 3151       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
.43C:
! Debug: list unsigned short regs = [S+$1A+$12] (used reg = )
push	$14[bp]
! Debug: list unsigned short regs = [S+$1C+$1E] (used reg = )
push	$20[bp]
! Debug: list * char = .43D+0 (used reg = )
mov	bx,#.43D
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3152       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 3153       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
mov	al,#$86
mov	$21[bp],al
!BCC_EOS
! 3154       break;
jmp .40D
!BCC_EOS
! 3155     }
! 3156 }
jmp .40D
.40F:
sub	al,#$86
beq 	.410
sub	al,*$62
beq 	.411
jmp	.43C
.40D:
..FFF5	=	-$1A
..FFF4	=	-$1A
mov	sp,bp
pop	bp
ret
! 3157   void
! Register BX used in function int15_function32
! 3158 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
! 3159   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
export	_int16_function
_int16_function:
!BCC_EOS
! 3160 {
! 3161   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
!BCC_EOS
! 3162   Bit16u kbd_code, max;
!BCC_EOS
! 3163   ;
push	bp
mov	bp,sp
add	sp,*-$A
!BCC_EOS
! 3164   shift_flags = read_byte(0x0040, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3165   led_flags = read_byte(0x0040, 0x97);
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3166   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
push	ax
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	al,-$C[bp]
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.43E
.43F:
! 3167 #asm
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    cli
! 3169 endasm
!BCC_ENDASM
!BCC_EOS
! 3170     outb(0x60, 0xed);
! Debug: list int = const $ED (used reg = )
mov	ax,#$ED
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3171     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .441
.442:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3172     if ((inb(0x60) == 0xfa)) {
.441:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.442
.443:
.440:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.444
.445:
! 3173       led_flags &= 0xf8;
! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,#$F8
mov	-4[bp],al
!BCC_EOS
! 3174       led_flags |= ((shift_flags >> 4) & 0x07);
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
or	al,-4[bp]
mov	-4[bp],al
!BCC_EOS
! 3175       outb(0x60, led_flags & 0x07);
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3176       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .447
.448:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3177       inb(0x60);
.447:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.448
.449:
.446:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 3178       write_byte(0x0040, 0x97, led_flags);
! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3179     }
! 3180 #asm
.444:
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    sti
! 3182 endasm
!BCC_ENDASM
!BCC_EOS
! 3183   }
! 3184   switch (( AX >> 8 )) {
.43E:
! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
br 	.44C
! 3185     case 0x00:
! 3186       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.44D:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.44E
.44F:
! 3187         bios_printf(
! 3187 (2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
! Debug: list * char = .450+0 (used reg = )
mov	bx,#.450
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3188         }
! 3189       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.44E:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.451
.453:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.451
.452:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3190       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .454
.451:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.455
.456:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3191       AX = (scan_code << 8) | ascii_code;
.455:
.454:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3192       break;
br 	.44A
!BCC_EOS
! 3193     case 0x01:
! 3194       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.457:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.458
.459:
! 3195         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3196         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3197         }
! 3198       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.458:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.45A
.45C:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.45A
.45B:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3199       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .45D
.45A:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.45E
.45F:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3200       AX = (scan_code << 8) | ascii_code;
.45E:
.45D:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3201       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3202       break;
br 	.44A
!BCC_EOS
! 3203     case 0x02:
! 3204       shift_flags = read_byte(0x0040, 0x17);
.460:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3205       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3206       break;
br 	.44A
!BCC_EOS
! 3207     case 0x05:
! 3208       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
.461:
! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
mov	ax,$10[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
test	ax,ax
jne 	.462
.463:
! 3209         AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3210         }
! 3211       else {
jmp .464
.462:
! 3212         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3213         }
! 3214       break;
.464:
br 	.44A
!BCC_EOS
! 3215     case 0x09:
! 3216       AX = ((AX & 0xff00) | (0x30));
.465:
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
or	al,*$30
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3217       break;
br 	.44A
!BCC_EOS
! 3218     case 0x0A:
! 3219       count = 2;
.466:
! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
mov	al,*2
mov	-5[bp],al
!BCC_EOS
! 3220       kbd_code = 0x0;
! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 3221       outb(0x60, 0xf2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3222       max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3223       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .468
.469:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3224       if (max>0x0) {
.468:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.46A
.46B:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.469
.46A:
.467:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
je  	.46C
.46D:
! 3225         if ((inb(0x60) == 0xfa)) {
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.46E
.46F:
! 3226           do {
.472:
! 3227             max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3228             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .474
.475:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3229             if (max>0x0) {
.474:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.476
.477:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.475
.476:
.473:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
je  	.478
.479:
! 3230               kbd_code >>= 8;
! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
mov	-8[bp],ax
!BCC_EOS
! 3231               kbd_code |= (inb(0x60) << 8);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
or	ax,-8[bp]
mov	-8[bp],ax
!BCC_EOS
! 3232             }
! 3233           } while (--count>0);
.478:
.471:
! Debug: predec unsigned char count = [S+$C-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne	.472
.47A:
!BCC_EOS
! 3234         }
.470:
! 3235       }
.46E:
! 3236       BX=kbd_code;
.46C:
! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
mov	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 3237       break;
br 	.44A
!BCC_EOS
! 3238     case 0x10:
! 3239       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.47B:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.47C
.47D:
! 3240         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
! Debug: list * char = .47E+0 (used reg = )
mov	bx,#.47E
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3241         }
! 3242       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.47C:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.47F
.481:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.47F
.480:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3243       AX = (scan_code << 8) | ascii_code;
.47F:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3244       break;
br 	.44A
!BCC_EOS
! 3245     case 0x11:
! 3246       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.482:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.483
.484:
! 3247         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3248         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3249         }
! 3250       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.483:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.485
.487:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.485
.486:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3251       AX = (scan_code << 8) | ascii_code;
.485:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3252       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3253       break;
br 	.44A
!BCC_EOS
! 3254     case 0x12:
! 3255       shift_flags = read_byte(0x0040, 
.488:
! 3255 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3256       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3257       shift_flags = read_byte(0x0040, 0x18) & 0x73;
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
and	al,*$73
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3258       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $C to unsigned char = al+0 (used reg = )
and	al,*$C
! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
or	al,-3[bp]
mov	-3[bp],al
!BCC_EOS
! 3259       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF3[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3260       ;
!BCC_EOS
! 3261       break;
br 	.44A
!BCC_EOS
! 3262     case 0x92:
! 3263       AX = ((AX & 0x00ff) | ((0x80) << 8));
.489:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3264       break;
jmp .44A
!BCC_EOS
! 3265     case 0xA2:
! 3266       break;
.48A:
jmp .44A
!BCC_EOS
! 3267     case 0x6F:
! 3268       if (( AX & 0x00ff ) == 0x08)
.48B:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
cmp	al,*8
jne 	.48C
.48D:
! 3269         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3270     default:
.48C:
! 3271       bios_printf(4, "KBD: unsupported int 16h function %02x\n", ( AX >> 8 ));
.48E:
! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .48F+0 (used reg = )
mov	bx,#.48F
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3272     }
! 3273 }
jmp .44A
.44C:
sub	ax,*0
jl 	.48E
cmp	ax,*$12
ja  	.490
shl	ax,*1
mov	bx,ax
seg	cs
br	.491[bx]
.491:
.word	.44D
.word	.457
.word	.460
.word	.48E
.word	.48E
.word	.461
.word	.48E
.word	.48E
.word	.48E
.word	.465
.word	.466
.word	.48E
.word	.48E
.word	.48E
.word	.48E
.word	.48E
.word	.47B
.word	.482
.word	.488
.490:
sub	ax,*$6F
je 	.48B
sub	ax,*$23
je 	.489
sub	ax,*$10
je 	.48A
jmp	.48E
.44A:
..FFF3	=	-$C
mov	sp,bp
pop	bp
ret
! 3274   unsigned int
! Register BX used in function int16_function
! 3275 dequeue_key(scan_code, ascii_code, incr)
! 3276   Bit8u *scan_code;
export	_dequeue_key
_dequeue_key:
!BCC_EOS
! 3277   Bit8u *ascii_code;
!BCC_EOS
! 3278   unsigned int incr;
!BCC_EOS
! 3279 {
! 3280   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
!BCC_EOS
! 3281   Bit16u ss;
!BCC_EOS
! 3282   Bit8u acode, scode;
!BCC_EOS
! 3283   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$C
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3284   buffer_end = read_word(0x0040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3285   buffer_head = read_word(0x0040, 0x001a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3286   buffer_tail = read_word(0x0040, 0x001c);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3287   if (buffer_head != buffer_tail) {
! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-8[bp]
beq 	.492
.493:
! 3288     ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3289     acode = read_byte(0x0040, buffer_head);
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 3290     scode = read_byte(0x0040, buffer_head+1);
! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 3291     write_byte(ss, ascii_code, acode);
! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
mov	al,-$B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3292     write_byte(ss, scan_code, scode);
! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3293     if (incr) {
mov	ax,8[bp]
test	ax,ax
je  	.494
.495:
! 3294       buffer_head += 2;
! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
inc	ax
inc	ax
mov	-6[bp],ax
!BCC_EOS
! 3295       if (buffer_head >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
jb  	.496
.497:
! 3296         buffer_head = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-2[bp]
mov	-6[bp],ax
!BCC_EOS
! 3297       write_word(0x0040, 0x001a, buffer_head);
.496:
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3298       }
! 3299     return(1);
.494:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3300     }
! 3301   else {
jmp .498
.492:
! 3302     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3303     }
! 3304 }
.498:
mov	sp,bp
pop	bp
ret
! 3305 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
.data
_panic_msg_keyb_buffer_full:
.499:
.ascii	"%s: keyboard input buffer full"
.byte	$A
.byte	0
!BCC_EOS
! 3306   Bit8u
! 3307 inhibit_mouse_int_and_events()
! 3308 {
.text
export	_inhibit_mouse_int_and_events
_inhibit_mouse_int_and_events:
! 3309   Bit8u command_byte, prev_command_byte;
!BCC_EOS
! 3310   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.49A
.49B:
! 3311     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .49C+0 (used reg = )
mov	bx,#.49C
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3312   outb(0x64, 0x20);
.49A:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3313   while ( (inb(0x64) & 0x01) != 0x01 );
jmp .49E
.49F:
!BCC_EOS
! 3314   prev_command_byte = inb(0x60);
.49E:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.49F
.4A0:
.49D:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 3315   command_byte = prev_command_byte;
! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-2[bp]
mov	-1[bp],al
!BCC_EOS
! 3316   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4A1
.4A2:
! 3317     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .4A3+0 (used reg = )
mov	bx,#.4A3
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3318   command_byte &= 0xfd;
.4A1:
! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
mov	-1[bp],al
!BCC_EOS
! 3319   command_byte |= 0x20;
! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*$20
mov	-1[bp],al
!BCC_EOS
! 3320   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3321   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3322   return(prev_command_byte);
mov	al,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3323 }
! 3324   void
! Register BX used in function inhibit_mouse_int_and_events
! 3325 enable_mouse_int_and_events()
! 3326 {
export	_enable_mouse_int_and_events
_enable_mouse_int_and_events:
! 3327   Bit8u command_byte;
!BCC_EOS
! 3328   if ( inb(0x64) & 0x
push	bp
mov	bp,sp
dec	sp
dec	sp
! 3328 02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4A4
.4A5:
! 3329     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! Debug: list * char = .4A6+0 (used reg = )
mov	bx,#.4A6
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3330   outb(0x64, 0x20);
.4A4:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3331   while ( (inb(0x64) & 0x01) != 0x01 );
jmp .4A8
.4A9:
!BCC_EOS
! 3332   command_byte = inb(0x60);
.4A8:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.4A9
.4AA:
.4A7:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3333   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4AB
.4AC:
! 3334     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! Debug: list * char = .4AD+0 (used reg = )
mov	bx,#.4AD
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3335   command_byte |= 0x02;
.4AB:
! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 3336   command_byte &= 0xdf;
! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$DF
mov	-1[bp],al
!BCC_EOS
! 3337   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3338   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3339 }
mov	sp,bp
pop	bp
ret
! 3340   Bit8u
! Register BX used in function enable_mouse_int_and_events
! 3341 send_to_mouse_ctrl(sendbyte)
! 3342   Bit8u sendbyte;
export	_send_to_mouse_ctrl
_send_to_mouse_ctrl:
!BCC_EOS
! 3343 {
! 3344   Bit8u response;
!BCC_EOS
! 3345   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4AE
.4AF:
! 3346     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
! Debug: list * char = .4B0+0 (used reg = )
mov	bx,#.4B0
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3347   outb(0x64, 0xD4);
.4AE:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3348   outb(0x60, sendbyte);
! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3349   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3350 }
! 3351   Bit8u
! Register BX used in function send_to_mouse_ctrl
! 3352 get_mouse_data(data)
! 3353   Bit8u *data;
export	_get_mouse_data
_get_mouse_data:
!BCC_EOS
! 3354 {
! 3355   Bit8u response;
!BCC_EOS
! 3356   Bit16u ss;
!BCC_EOS
! 3357   while ( (inb(0x64) & 0x21) != 0x21 ) {
push	bp
mov	bp,sp
add	sp,*-4
jmp .4B2
.4B3:
! 3358     }
! 3359   response = inb(0x60);
.4B2:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
jne	.4B3
.4B4:
.4B1:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3360   ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3361   write_byte(ss, data, response);
! Debug: list unsigned char response = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char data = [S+8+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$A-6] (used reg = )
push	-4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3362   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3363 }
! 3364   void
! 3365 set_kbd_command_byte(command_byte)
! 3366   Bit8u command_byte;
export	_set_kbd_command_byte
_set_kbd_command_byte:
!BCC_EOS
! 3367 {
! 3368   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
mov	sp,bp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4B5
.4B6:
! 3369     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
! Debug: list * char = .4B7+0 (used reg = )
mov	bx,#.4B7
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 3370   outb(0x64, 0xD4);
.4B5:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3371   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3372   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3373 }
pop	bp
ret
! 3374   void
! Register BX used in function set_kbd_command_byte
! 3375 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
! 3376   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
export	_int09_function
_int09_function:
!BCC_EOS
! 3377 {
! 3378   Bit8u scancode, asciicode, shift_flags;
!BCC_EOS
! 3379   Bit8u mf2_flags, mf2_state;
!BCC_EOS
! 3380   scancode = ( AX & 0x00ff );
push	bp
mov	bp,sp
add	sp,*-6
! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
mov	al,$12[bp]
! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3381   if (scancode == 0) {
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.4B8
.4B9:
! 3382     bios_printf(4, "KBD: int09 handler: AL=0\n");
! Debug: list * char = .4BA+0 (used reg = )
mov	bx,#.4BA
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3383     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3384     }
! 3385   shift_flags = read_byte(0x0040, 0x17);
.4B8:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3386   mf2_flags = read_byte(0x0040, 0x18);
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3387   mf2_state = read_byte(0x0040, 0x96);
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3388   asciicode = 0;
! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3389   switch (scancode) {
mov	al,-1[bp]
br 	.4BD
! 3390     case 0x3a:
! 3391       shift_flags ^= 0x40;
.4BE:
! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$40
mov	-3[bp],al
!BCC_EOS
! 3392       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3393       mf2_flags |= 0x40;
! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$40
mov	-4[bp],al
!BCC_EOS
! 3394       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3395       break;
br 	.4BB
!BCC_EOS
! 3396     case 0xba:
! 3397       mf2_flags &= ~0x40;
.4BF:
! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$BF
mov	-4[bp],al
!BCC_EOS
! 3398       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3399       break;
br 	.4BB
!BCC_EOS
! 3400     case 0x2a:
! 3401       shift_flags |= 0x02;
.4C0:
! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*2
mov	-3[bp],al
!BCC_EOS
! 3402       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3403       break;
br 	.4BB
!BCC_EOS
! 3404     case 0xaa:
! 3405       shift_flags &= ~0x02;
.4C1:
! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FD
mov	-3[bp],al
!BCC_EOS
! 3406       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3407       break;
br 	.4BB
!BCC_EOS
! 3408     case 0x36:
! 3409       shift_flags |= 0x01;
.4C2:
! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*1
mov	-3[bp],al
!BCC_EOS
! 3410       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3411       break;
br 	.4BB
!BCC_EOS
! 3412 
! 3412     case 0xb6:
! 3413       shift_flags &= ~0x01;
.4C3:
! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FE
mov	-3[bp],al
!BCC_EOS
! 3414       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3415       break;
br 	.4BB
!BCC_EOS
! 3416     case 0x1d:
! 3417       if ((mf2_state & 0x01) == 0) {
.4C4:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4C5
.4C6:
! 3418         shift_flags |= 0x04;
! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*4
mov	-3[bp],al
!BCC_EOS
! 3419         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3420         if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4C7
.4C8:
! 3421           mf2_state |= 0x04;
! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
mov	-5[bp],al
!BCC_EOS
! 3422           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3423         } else {
jmp .4C9
.4C7:
! 3424           mf2_flags |= 0x01;
! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*1
mov	-4[bp],al
!BCC_EOS
! 3425           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3426         }
! 3427       }
.4C9:
! 3428       break;
.4C5:
br 	.4BB
!BCC_EOS
! 3429     case 0x9d:
! 3430       if ((mf2_state & 0x01) == 0) {
.4CA:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4CB
.4CC:
! 3431         shift_flags &= ~0x04;
! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FB
mov	-3[bp],al
!BCC_EOS
! 3432         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3433         if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4CD
.4CE:
! 3434           mf2_state &= ~0x04;
! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
mov	-5[bp],al
!BCC_EOS
! 3435           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3436         } else {
jmp .4CF
.4CD:
! 3437           mf2_flags &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FE
mov	-4[bp],al
!BCC_EOS
! 3438           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3439         }
! 3440       }
.4CF:
! 3441       break;
.4CB:
br 	.4BB
!BCC_EOS
! 3442     case 0x38:
! 3443       shift_flags |= 0x08;
.4D0:
! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*8
mov	-3[bp],al
!BCC_EOS
! 3444       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3445       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4D1
.4D2:
! 3446         mf2_state |= 0x08;
! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*8
mov	-5[bp],al
!BCC_EOS
! 3447         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3448       } else {
jmp .4D3
.4D1:
! 3449         mf2_flags |= 0x02;
! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*2
mov	-4[bp],al
!BCC_EOS
! 3450         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3451       }
! 3452       break;
.4D3:
br 	.4BB
!BCC_EOS
! 3453     case 0xb8:
! 3454       shift_flags &= ~0x08;
.4D4:
! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$F7
mov	-3[bp],al
!BCC_EOS
! 3455       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3456       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4D5
.4D6:
! 3457         mf2_state &= ~0x08;
! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$F7
mov	-5[bp],al
!BCC_EOS
! 3458         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3459       } else {
jmp .4D7
.4D5:
! 3460         mf2_flags &= ~0x02;
! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FD
mov	-4[bp],al
!BCC_EOS
! 3461         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3462       }
! 3463       break;
.4D7:
br 	.4BB
!BCC_EOS
! 3464     case 0x45:
! 3465       if ((mf2_state & 0x03) == 0) {
.4D8:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4D9
.4DA:
! 3466         mf2_flags |= 0x20;
! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$20
mov	-4[bp],al
!BCC_EOS
! 3467         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3468         shift_flags ^= 0x20;
! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$20
mov	-3[bp],al
!BCC_EOS
! 3469         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3470       }
! 3471       break;
.4D9:
br 	.4BB
!BCC_EOS
! 3472     case 0xc5:
! 3473       if ((mf2_state & 0x03) == 0) {
.4DB:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4DC
.4DD:
! 3474         mf2_flags &= ~0x20;
! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$DF
mov	-4[bp],al
!BCC_EOS
! 3475         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3476       }
! 3477       break;
.4DC:
br 	.4BB
!BCC_EOS
! 3478     case 0x46:
! 3479       mf2_flags |= 0x10;
.4DE:
! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$10
mov	-4[bp],al
!BCC_EOS
! 3480       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3481       shift_flags ^= 0x10;
! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$10
mov	-3[bp],al
!BCC_EOS
! 3482       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3483       break;
br 	.4BB
!BCC_EOS
! 3484     case 0xc6:
! 3485       mf2_flags &= ~0x10;
.4DF:
! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$EF
mov	-4[bp],al
!BCC_EOS
! 3486       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3487       br
! 3487 eak;
br 	.4BB
!BCC_EOS
! 3488     case 0x53:
! 3489         if ((shift_flags & 0x0c) == 0x0c)
.4E0:
! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*$C
! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
cmp	al,*$C
jne 	.4E1
.4E2:
! 3490             machine_reset();
! Debug: func () void = machine_reset+0 (used reg = )
call	_machine_reset
!BCC_EOS
! 3491     default:
.4E1:
! 3492       if (scancode & 0x80) {
.4E3:
! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
test	al,al
je  	.4E4
.4E5:
! 3493         break;
br 	.4BB
!BCC_EOS
! 3494       }
! 3495       if (scancode > 0x58) {
.4E4:
! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
jbe 	.4E6
.4E7:
! 3496         bios_printf(4, "KBD: int09h_handler(): unknown scancode read: 0x%02x!\n", scancode);
! Debug: list unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list * char = .4E8+0 (used reg = )
mov	bx,#.4E8
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3497         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3498       }
! 3499       if (shift_flags & 0x08) {
.4E6:
! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*8
test	al,al
je  	.4E9
.4EA:
! 3500         asciicode = scan_to_scanascii[scancode].alt;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,6[bx]
mov	-2[bp],al
!BCC_EOS
! 3501         scancode = scan_to_scanascii[scancode].alt >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
mov	ax,6[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3502       } else if (shift_flags & 0x04) {
br 	.4EB
.4E9:
! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*4
test	al,al
je  	.4EC
.4ED:
! 3503         asciicode = scan_to_scanascii[scancode].control;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,4[bx]
mov	-2[bp],al
!BCC_EOS
! 3504         scancode = scan_to_scanascii[scancode].control >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
mov	ax,4[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3505       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
br 	.4EE
.4EC:
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.4EF
.4F1:
! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$47
jb  	.4EF
.4F2:
! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
ja  	.4EF
.4F0:
! 3506         asciicode = 0xe0;
! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,#$E0
mov	-2[bp],al
!BCC_EOS
! 3507         scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3508       } else if (shift_flags & 0x03) {
br 	.4F3
.4EF:
! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*3
test	al,al
beq 	.4F4
.4F5:
! 3509         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4F6
.4F7:
! 3510           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3511           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3512         } else {
jmp .4F8
.4F6:
! 3513           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3514           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3515         }
! 3516       } else {
.4F8:
br 	.4F9
.4F4:
! 3517         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4FA
.4FB:
! 3518           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3519           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3520         } else {
jmp .4FC
.4FA:
! 3521           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3522           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3523         }
! 3524       }
.4FC:
! 3525       if (scancode==0 && asciicode==0) {
.4F9:
.4F3:
.4EE:
.4EB:
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.4FD
.4FF:
! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
test	al,al
jne 	.4FD
.4FE:
! 3526         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
! Debug: list * char = .500+0 (used reg = )
mov	bx,#.500
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3527       }
! 3528       enqueue_key(scancode, asciicode);
.4FD:
! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
!BCC_EOS
! 3529       break;
jmp .4BB
!BCC_EOS
! 3530   }
! 3531   if ((scancode & 0x7f) != 0x1d) {
jmp .4BB
.4BD:
sub	al,*$1D
beq 	.4C4
sub	al,*$D
beq 	.4C0
sub	al,*$C
beq 	.4C2
sub	al,*2
beq 	.4D0
sub	al,*2
beq 	.4BE
sub	al,*$B
beq 	.4D8
sub	al,*1
beq 	.4DE
sub	al,*$D
beq 	.4E0
sub	al,*$4A
beq 	.4CA
sub	al,*$D
beq 	.4C1
sub	al,*$C
beq 	.4C3
sub	al,*2
beq 	.4D4
sub	al,*2
beq 	.4BF
sub	al,*$B
beq 	.4DB
sub	al,*1
beq 	.4DF
br 	.4E3
.4BB:
..FFF2	=	-8
! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
cmp	al,*$1D
je  	.501
.502:
! 3532     mf2_state &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
mov	-5[bp],al
!BCC_EOS
! 3533   }
! 3534   mf2_state &= ~0x02;
.501:
! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FD
mov	-5[bp],al
!BCC_EOS
! 3535   write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3536 }
mov	sp,bp
pop	bp
ret
! 3537   unsigned int
! Register BX used in function int09_function
! 3538 enqueue_key(scan_code, ascii_code)
! 3539   Bit8u scan_code, ascii_code;
export	_enqueue_key
_enqueue_key:
!BCC_EOS
! 3540 {
! 3541   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
!BCC_EOS
! 3542   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3543   buffer_end = read_word(0x0
! 3543 040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3544   buffer_head = read_word(0x0040, 0x001A);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3545   buffer_tail = read_word(0x0040, 0x001C);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3546   temp_tail = buffer_tail;
! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 3547   buffer_tail += 2;
! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 3548   if (buffer_tail >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-4[bp]
jb  	.503
.504:
! 3549     buffer_tail = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-2[bp]
mov	-8[bp],ax
!BCC_EOS
! 3550   if (buffer_tail == buffer_head) {
.503:
! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-6[bp]
jne 	.505
.506:
! 3551     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3552     }
! 3553    write_byte(0x0040, temp_tail, ascii_code);
.505:
! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3554    write_byte(0x0040, temp_tail+1, scan_code);
! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3555    write_word(0x0040, 0x001C, buffer_tail);
! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3556    return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3557 }
! 3558   void
! 3559 int74_function(make_farcall, Z, Y, X, status)
! 3560   Bit16u make_farcall, Z, Y, X, status;
export	_int74_function
_int74_function:
!BCC_EOS
! 3561 {
! 3562   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3563   Bit8u in_byte, index, package_count;
!BCC_EOS
! 3564   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 3565 ;
add	sp,*-6
!BCC_EOS
! 3566   make_farcall = 0;
! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
xor	ax,ax
mov	4[bp],ax
!BCC_EOS
! 3567   in_byte = inb(0x64);
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3568   if ( (in_byte & 0x21) != 0x21 ) {
! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
je  	.507
.508:
! 3569     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3570     }
! 3571   in_byte = inb(0x60);
.507:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3572 ;
!BCC_EOS
! 3573   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 3574   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 3575   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
je  	.509
.50A:
! 3576       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3577   }
! 3578   package_count = mouse_flags_2 & 0x07;
.509:
! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3579   index = mouse_flags_1 & 0x07;
! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3580   write_byte(ebda_seg, 0x28 + index, in_byte);
! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
! Debug: expression subtree swapping
mov	al,-4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3581   if ( (index+1) >= package_count ) {
! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
inc	ax
push	ax
mov	al,-5[bp]
xor	ah,ah
cmp	ax,-$A[bp]
lea	sp,-8[bp]
ja  	.50B
.50C:
! 3582 ;
!BCC_EOS
! 3583     status = read_byte(ebda_seg, 0x0028 + 0);
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
xor	ah,ah
mov	$C[bp],ax
!BCC_EOS
! 3584     X = read_byte(ebda_seg, 0x0028 + 1);
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 3585     Y = read_byte(ebda_seg, 0x0028 + 2);
! Debug: list int = const $2A (used reg = )
mov	ax,*$2A
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
xor	ah,ah
mov	8[bp],ax
!BCC_EOS
! 3586     Z = 0;
! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 3587     mouse_flags_1 = 0;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 3588     if (mouse_flags_2 & 0x80)
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
test	al,al
je  	.50D
.50E:
! 3589       make_farcall = 1;
! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
mov	ax,*1
mov	4[bp],ax
!BCC_EOS
! 3590     }
.50D:
! 3591   else {
jmp .50F
.50B:
! 3592     mouse_flags_1++;
! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
inc	ax
mov	-6[bp],al
!BCC_EOS
! 3593     }
! 3594   write_byte(ebda_seg, 0x0026, mouse_flags_1);
.50F:
! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3595 }
mov	sp,bp
pop	bp
ret
! 3596   void
! 3597 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3598   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_harddisk
_int13_harddisk:
!BCC_EOS
! 3599 {
! 3600   Bit32u lba_low, lba_high;
!BCC_EOS
! 3601   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3602   Bit16u cylinder, head, sector;
!BCC_EOS
! 3603   Bit16u segment, offset;
!BCC_EOS
! 3604   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
!BCC_EOS
! 3605   Bit16u size, count;
!BCC_EOS
! 3606   Bit8u device, status;
!BCC_EOS
! 3607   ;
add	sp,*-$1C
!BCC_EOS
! 3608   write_byte(0x0040, 0x008e, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $8E (used reg = )
mov	ax,#$8E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3609   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jb  	.511
.512:
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
cmp	al,#$88
jb  	.510
.511:
! 3610     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .513+0 (used reg = )
mov	bx,#.513
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3611     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3612     }
! 3613   device=read_byte(ebda_seg,&((ebda
.510:
! 3613 _data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
add	ax,*-$80
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 3614   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*8
jb  	.514
.515:
! 3615     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .516+0 (used reg = )
mov	bx,#.516
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3616     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3617     }
! 3618   switch (( AX >> 8 )) {
.514:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.519
! 3619     case 0x00:
! 3620       ata_reset (device);
.51A:
! Debug: list unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 3621       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3622       break;
br 	.517
!BCC_EOS
! 3623     case 0x01:
! 3624       status = read_byte(0x0040, 0x0074);
.51B:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3625       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3626       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3627       if (status) goto int13_fail_nostatus;
mov	al,-$26[bp]
test	al,al
je  	.51C
.51D:
add	sp,#..FFEE-..FFF0
br 	.FFEE
!BCC_EOS
! 3628       else goto int13_success_noah;
jmp .51E
.51C:
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3629       break;
.51E:
br 	.517
!BCC_EOS
! 3630     case 0x02:
! 3631     case 0x03:
.51F:
! 3632     case 0x04:
.520:
! 3633       count = ( AX & 0x00ff );
.521:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3634       cylinder = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3635       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
shl	ax,*1
shl	ax,*1
! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
and	ax,#$300
! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
or	ax,-$C[bp]
mov	-$C[bp],ax
!BCC_EOS
! 3636       sector = (( CX & 0x00ff ) & 0x3f);
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 3637       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 3638       segment = ES;
! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
mov	ax,8[bp]
mov	-$12[bp],ax
!BCC_EOS
! 3639       offset = BX;
! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
mov	ax,$12[bp]
mov	-$14[bp],ax
!BCC_EOS
! 3640       if ((count > 128) || (count == 0) || (sector == 0)) {
! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
cmp	ax,#$80
ja  	.523
.525:
! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
test	ax,ax
je  	.523
.524:
! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
test	ax,ax
jne 	.522
.523:
! 3641         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .526+0 (used reg = )
mov	bx,#.526
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3642         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3643       }
! 3644       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.522:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3645       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3646       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3647       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-$1C[bp]
jae 	.528
.52A:
! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-$1E[bp]
jae 	.528
.529:
! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$20[bp]
jbe 	.527
.528:
! 3648         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", ( AX >> 8 ), cylinder, head, sector);
! Debug: list unsigned short sector = [S+$28-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$2A-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$2C-$E] (used reg = )
push	-$C[bp]
! Debug: sr int = const 8 to unsigned short AX = [S+$2E+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .52B+0 (used reg = )
mov	bx,#.52B
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$C
!BCC_EOS
! 3649         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3650         }
! 3651       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
.527:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.52C
.52D:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3652       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
.52C:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3653       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3654       if ( (nph != nlh) || (npspt != nlspt)) {
! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
cmp	ax,-$1E[bp]
jne 	.52F
.530:
! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	ax,-$1A[bp]
cmp	ax,-$20[bp]
je  	.52E
.52F:
! 3655         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lsubul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3656         lba_high = 0;
! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3657         sector = 0;
! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ax,ax
mov	-$10[bp],ax
!BCC_EOS
! 3658         }
! 3659       if ( ( AX >> 8 ) == 0x02 )
.52E:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
cmp	ax,*2
jne 	.531
.532:
! 3660         status=ata_cmd_data_in(device, 0x20, count,
! 3660  cylinder, head, sector, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3661       else
! 3662         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
jmp .533
.531:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3663       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
.533:
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3664       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.534
.535:
! 3665         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .536+0 (used reg = )
mov	bx,#.536
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3666         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3667         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3668         }
! 3669       goto int13_success;
.534:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3670       break;
br 	.517
!BCC_EOS
! 3671     case 0x05:
! 3672       bios_printf(4, "format disk track called\n");
.537:
! Debug: list * char = .538+0 (used reg = )
mov	bx,#.538
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3673       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3674       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3675       break;
br 	.517
!BCC_EOS
! 3676     case 0x08:
! 3677       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.539:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3678       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3679       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3680       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3681       nlc = nlc - 2;
! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
dec	ax
dec	ax
mov	-$1C[bp],ax
!BCC_EOS
! 3682       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3683       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	al,-$1C[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3684       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	al,-$20[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
mov	ax,-$1C[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3685       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	ax,-$1E[bp]
! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
dec	ax
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3686       DX = ((DX & 0xff00) | (count));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
or	ax,-$24[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3687       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3688       break;
br 	.517
!BCC_EOS
! 3689     case 0x10:
! 3690       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
.53A:
! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3691       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
and	al,#$C0
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.53B
.53C:
! 3692         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3693         }
! 3694       else {
jmp .53D
.53B:
! 3695         AX = ((AX & 0x00ff) | ((0xAA) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3696         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3697         }
! 3698       break;
.53D:
br 	.517
!BCC_EOS
! 3699     case 0x15:
! 3700       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.53E:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3701       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3702       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3703       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3704       CX = lba_low >> 16;
! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3705       DX = lba_low & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3706       AX = ((AX & 0x00ff) | ((3) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3707      
! 3707  goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3708       break;
br 	.517
!BCC_EOS
! 3709     case 0x41:
! 3710       BX=0xaa55;
.53F:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3711       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3712       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3713       goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3714       break;
br 	.517
!BCC_EOS
! 3715     case 0x42:
! 3716     case 0x43:
.540:
! 3717     case 0x44:
.541:
! 3718     case 0x47:
.542:
! 3719       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.543:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3720       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 3721       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 3722       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3723       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
lea	di,-8[bp]
call	lcmpul
jae 	.544
.545:
! 3724         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .546+0 (used reg = )
mov	bx,#.546
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3725         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3726         }
! 3727       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.544:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3728       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
! 3729           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
! Debug: expression subtree swapping
lea	di,-8[bp]
call	lcmpul
jne 	.547
.549:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
lea	di,-4[bp]
call	lcmpul
ja  	.547
.548:
! 3730         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .54A+0 (used reg = )
mov	bx,#.54A
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3731         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3732         }
! 3733       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
.547:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.54C
.54D:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.54B
.54C:
! 3734         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3735       if ( ( AX >> 8 ) == 0x42 )
.54B:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
cmp	ax,*$42
jne 	.54E
.54F:
! 3736         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3737       else
! 3738         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
jmp .550
.54E:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3739       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
.550:
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3740       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$28-$26] (used reg = )
push	-$24[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3741       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.551
.552:
! 3742         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .553+0 (used reg = )
mov	bx,#.553
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3743         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3744         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3745         }
! 3746       goto int13_success;
.551:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3747       break;
br 	.517
!BCC_EOS
! 3748     case 0x45:
! 3749     case 0x49:
.554:
! 3750       goto int13_success;
.555:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3751       break;
br 	.517
!BCC_EOS
! 3752     case 0x46:
! 3753       AX = ((AX & 0x00ff) | ((0xb2) << 8));
.556:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4E00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3754       goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3755       break;
br 	.517
!BCC_EOS
! 3756     case 0x48:
! 3757       size=read_word(
.557:
! 3757 DS,SI+(Bit16u)&((dpt_t *) 0)->size);
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
mov	-$22[bp],ax
!BCC_EOS
! 3758       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
jae 	.558
.559:
! 3759         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3760       if(size >= 0x1a) {
.558:
! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
blo 	.55A
.55B:
! 3761         Bit16u blksize;
!BCC_EOS
! 3762         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	-$16[bp],ax
!BCC_EOS
! 3763         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3764         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3765         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3766         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3767         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 3768         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3769         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
mov	ax,-8[bp]
mov	bx,-6[bp]
call	ltstl
jne 	.55D
.55E:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-6+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$3FFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lcmpul
jbe	.55F
mov	al,*1
jmp	.560
.55F:
xor	al,al
.560:
add	sp,*8
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
je  	.55C
.55D:
! 3770         {
! 3771           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3772           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
! Debug: list int = const $3FFF (used reg = )
mov	ax,#$3FFF
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*6
!BCC_EOS
! 3773         }
! 3774         else
! 3775         {
jmp .562
.55C:
! 3776           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3777           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	ax,-$16[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3778         }
! 3779         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
.562:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3780         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3781         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3782         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3783         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3784         }
! 3785       if(size >= 0x1e) {
.55A:
! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1E
blo 	.563
.564:
! 3786         Bit8u channel, dev, irq, mode, checksum, i, translation;
!BCC_EOS
! 3787         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 3788         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3789         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
push	-$A[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3790         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3791         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3792         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
mov	-$30[bp],ax
!BCC_EOS
! 3793         iobase2 = read_word(ebda_seg, &((ebda
! 3793 _data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	-$32[bp],ax
!BCC_EOS
! 3794         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3795         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	-$2A[bp],al
!BCC_EOS
! 3796         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 3797         options = (translation==0?0:1)<<3;
! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
test	al,al
jne 	.565
.566:
xor	al,al
jmp .567
.565:
mov	al,*1
.567:
! Debug: sl int = const 3 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*3
shl	ax,cl
! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
mov	-$34[bp],ax
!BCC_EOS
! 3798         options |= (1<<4);
! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
mov	ax,-$34[bp]
or	al,*$10
mov	-$34[bp],ax
!BCC_EOS
! 3799         options |= (mode==0x01?1:0)<<7;
! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*1
jne 	.568
.569:
mov	al,*1
jmp .56A
.568:
xor	al,al
.56A:
! Debug: sl int = const 7 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*7
shl	ax,cl
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3800         options |= (translation==1?1:0)<<9;
! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*1
jne 	.56B
.56C:
mov	al,*1
jmp .56D
.56B:
xor	al,al
.56D:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3801         options |= (translation==3?3:0)<<9;
! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*3
jne 	.56E
.56F:
mov	al,*3
jmp .570
.56E:
xor	al,al
.570:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3802         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
push	-$30[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3803         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	ax,-$32[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3804         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3805         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3806         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3807         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3808         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3809         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3810         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
! Debug: list unsigned short options = [S+$36-$36] (used reg = )
push	-$34[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3811         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3812         if (size >=0x42)
! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
jb  	.571
.572:
! 3813           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3814         else
! 3815           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
jmp .573
.571:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3816         checksum=0;
.573:
! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	al,al
mov	-$2B[bp],al
!BCC_EOS
! 3817         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
xor	al,al
mov	-$2C[bp],al
!BCC_EOS
!BCC_EOS
jmp .576
.577:
! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
mov	al,-$2C[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	ah,ah
add	al,-$2B[bp]
adc	ah,*0
mov	-$2B[bp],al
!BCC_EOS
! 3818         checksum = ~checksum;
.575:
! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
inc	ax
mov	-$2C[bp],al
.576:
! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
cmp	al,*$F
jb 	.577
.578:
.574:
! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
mov	-$2B[bp],al
!BCC_EOS
! 3819         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3820         }
! 3821       if(size >= 0x42) {
.563:
! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
blo 	.579
.57A:
! 3822         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 3823         Bit16u iobase1;
!BCC_EOS
! 3824         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3825         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	-$28[bp],al
!BCC_EOS
! 3826         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
mov	-$2C[bp],ax
!BCC_EOS
! 3827         write_wor
! 3827 d(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3828         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3829         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3830         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3831         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3832         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.57B
.57C:
! 3833           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3834           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3835           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3836           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3837           }
! 3838         else {
jmp .57D
.57B:
! 3839           }
! 3840         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.57D:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3841         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3842         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3843         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3844         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.57E
.57F:
! 3845           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3846           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3847           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3848           }
! 3849         else {
jmp .580
.57E:
! 3850           }
! 3851         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.580:
! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3852         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3853         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3854         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3855         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	al,al
mov	-$29[bp],al
!BCC_EOS
! 3856         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,*$1E
mov	-$2A[bp],al
!BCC_EOS
!BCC_EOS
jmp .583
.584:
! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$2A[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	ah,ah
add	al,-$29[bp]
adc	ah,*0
mov	-$29[bp],al
!BCC_EOS
! 3857         checksum = ~checksum;
.582:
! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
inc	ax
mov	-$2A[bp],al
.583:
! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*$40
jb 	.584
.585:
.581:
! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3858         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3859         }
! 3860       goto int13_success;
.579:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3861       break;
br 	.517
!BCC_EOS
! 3862     case 0x4e:
! 3863       switch (( AX & 0x00ff )) {
.586:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
jmp .589
! 3864         case 0x01:
! 3865         case 0x03:
.58A:
! 3866         case 0x04:
.58B:
! 3867         case 0x06:
.58C:
! 3868           goto int13_success;
.58D:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3869           break;
jmp .587
!BCC_EOS
! 3870         default :
! 3871           goto int13_fail;
.58E:
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3872         }
! 3873       break;
jmp .587
.589:
sub	al,*1
je 	.58A
sub	al,*2
je 	.58B
sub	al,*1
je 	.58C
sub	al,*2
je 	.58D
jmp	.58E
.587:
br 	.517
!BCC_EOS
! 3874     case 0x09:
! 3875     case 0x0c:
.58F:
! 3876     case 0x0d:
.590:
! 3877     case 0x11:
.591:
! 3878  
! 3878    case 0x14:
.592:
! 3879       bios_printf(4, "int13_harddisk: function %02xh unimplemented, returns success\n", ( AX >> 8 ));
.593:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .594+0 (used reg = )
mov	bx,#.594
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3880       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3881       break;
br 	.517
!BCC_EOS
! 3882     case 0x0a:
! 3883     case 0x0b:
.595:
! 3884     case 0x18:
.596:
! 3885     case 0x50:
.597:
! 3886     default:
.598:
! 3887       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", ( AX >> 8 ));
.599:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .59A+0 (used reg = )
mov	bx,#.59A
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3888       goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3889       break;
br 	.517
!BCC_EOS
! 3890     }
! 3891 int13_fail:
jmp .517
.519:
add	sp,*-$E
sub	ax,*0
jl 	.599
cmp	ax,*$18
ja  	.59B
shl	ax,*1
mov	bx,ax
seg	cs
br	.59C[bx]
.59C:
.word	.51A
.word	.51B
.word	.51F
.word	.520
.word	.521
.word	.537
.word	.599
.word	.599
.word	.539
.word	.58F
.word	.595
.word	.596
.word	.590
.word	.591
.word	.599
.word	.599
.word	.53A
.word	.592
.word	.599
.word	.599
.word	.593
.word	.53E
.word	.599
.word	.599
.word	.597
.59B:
sub	ax,*$41
jb 	.599
cmp	ax,*$F
ja  	.59D
shl	ax,*1
mov	bx,ax
seg	cs
br	.59E[bx]
.59E:
.word	.53F
.word	.540
.word	.541
.word	.542
.word	.554
.word	.556
.word	.543
.word	.557
.word	.555
.word	.599
.word	.599
.word	.599
.word	.599
.word	.586
.word	.599
.word	.598
.59D:
br 	.599
.517:
..FFF0	=	-$36
add	sp,*$E
.FFF1:
..FFF1	=	-$28
! 3892     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3893 int13_fail_noah:
.FFEC:
..FFEC	=	-$28
! 3894     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3895 int13_fail_nostatus:
.FFEE:
..FFEE	=	-$28
! 3896     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 3897     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3898 int13_success:
.FFEF:
..FFEF	=	-$28
! 3899     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 3900 int13_success_noah:
.FFED:
..FFED	=	-$28
! 3901     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3902     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 3903     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3904 }
! 3905   void
! Register BX used in function int13_harddisk
! 3906 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3907   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_cdrom
_int13_cdrom:
!BCC_EOS
! 3908 {
! 3909   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3910   Bit8u device, status, locks;
!BCC_EOS
! 3911   Bit8u atacmd[12];
!BCC_EOS
! 3912   Bit32u lba;
!BCC_EOS
! 3913   Bit16u count, segment, offset, i, size;
!BCC_EOS
! 3914   ;
add	sp,*-$1E
!BCC_EOS
! 3915   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3916   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
cmp	al,#$E0
jb  	.5A0
.5A1:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
cmp	al,#$E8
jb  	.59F
.5A0:
! 3917     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .5A2+0 (used reg = )
mov	bx,#.5A2
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3918     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3919     }
! 3920   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
.59F:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
add	ax,#-$E0
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3921   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
mov	al,-3[bp]
cmp	al,*8
jb  	.5A3
.5A4:
! 3922     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .5A5+0 (used reg = )
mov	bx,#.5A5
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3923     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3924     }
! 3925   switch (( AX >> 8 )) {
.5A3:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.5A8
! 3926     case 0x00:
! 3927     case 0x09:
.5A9:
! 3928     case 0x0c:
.5AA:
! 3929     case 0x0d:
.5AB:
! 3930     case 0x10:
.5AC:
! 3931     case 0x11:
.5AD:
! 3932     case 0x14:
.5AE:
! 3933     case 0x16:
.5AF:
! 3934       goto int13_success;
.5B0:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3935       break;
br 	.5A6
!BCC_EOS
! 3936     case 0x03:
! 3937     case 0x05:
.5B1:
! 3938     case 0x43:
.5B2:
! 3939       AX = ((AX & 0x00ff) | ((0x03) << 8));
.5B3:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3940       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3941       break;
br 	.5A6
!BCC_EOS
! 3942     case 0x01:
! 3943       status = read_byte(0x0040, 0x0074);
.5B4:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3944       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3945       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3946       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.5B5
.5B6:
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 3947       else goto int13_success_noah;
jmp .5B7
.5B5:
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3948       break;
.5B7:
br 	.5A6
!BCC_EOS
! 3949    
! 3949  case 0x15:
! 3950       AX = ((AX & 0x00ff) | ((0x02) << 8));
.5B8:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3951       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3952       break;
br 	.5A6
!BCC_EOS
! 3953     case 0x41:
! 3954       BX=0xaa55;
.5B9:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3955       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3956       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3957       goto int13_success_noah;
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3958       break;
br 	.5A6
!BCC_EOS
! 3959     case 0x42:
! 3960     case 0x44:
.5BA:
! 3961     case 0x47:
.5BB:
! 3962       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.5BC:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3963       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3964       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3965       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 3966       if (lba != 0L) {
! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFEA[bp]
call	lcmpul
lea	sp,2+..FFEA[bp]
je  	.5BD
.5BE:
! 3967         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .5BF+0 (used reg = )
mov	bx,#.5BF
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3968         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 3969         }
! 3970       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.5BD:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 3971       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.5C1
.5C2:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.5C0
.5C1:
! 3972         goto int13_success;
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3973       memsetb(get_SS(),atacmd,0,12);
.5C0:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 3974       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
mov	al,*$28
mov	-$11[bp],al
!BCC_EOS
! 3975       atacmd[7]=(count & 0xff00) >> 8;
! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
mov	ax,-$18[bp]
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 3976       atacmd[8]=(count & 0x00ff);
! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
mov	al,-$18[bp]
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 3977       atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 3978       atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
mov	-$E[bp],al
!BCC_EOS
! 3979       atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 3980       atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 3981       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
push	-$1C[bp]
! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
push	-$1A[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFEA[bp]
mov	bx,-6+..FFEA[bp]
lea	di,-$C+..FFEA[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$34-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3982       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3983       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
push	-$18[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3984       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.5C3
.5C4:
! 3985         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .5C5+0 (used reg = )
mov	bx,#.5C5
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 3986         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3987         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3988         }
! 3989       goto int13_success;
.5C3:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3990       break;
br 	.5A6
!BCC_EOS
! 3991     case 0x45:
! 3992       if (( AX & 0x00ff ) > 2) goto int13_fail;
.5C6:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
cmp	al,*2
jbe 	.5C7
.5C8:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 3993       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.5C7:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3994       switch (( AX & 0x00ff )) {
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
br 	.5CB
! 3995         case 0 :
! 3996           if (locks == 0xff) {
.5CC:
! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FF
jne 	.5CD
.5CE:
! 3997             AX = ((AX & 0x00ff) | ((0xb4) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3998             AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3999             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4000             }
! 4001           write_byte(ebda_seg, &((e
.5CD:
! 4001 bda_data_t *) 0)->ata.devices[device].lock, ++locks);
! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4002           AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4003           break;
br 	.5C9
!BCC_EOS
! 4004         case 1 :
! 4005           if (locks == 0x00) {
.5CF:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5D0
.5D1:
! 4006             AX = ((AX & 0x00ff) | ((0xb0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4007             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4008             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4009             }
! 4010           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
.5D0:
! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4011           AX = ((AX & 0xff00) | (locks==0?0:1));
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5D2
.5D3:
xor	al,al
jmp .5D4
.5D2:
mov	al,*1
.5D4:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4012           break;
jmp .5C9
!BCC_EOS
! 4013         case 2 :
! 4014           AX = ((AX & 0xff00) | (locks==0?0:1));
.5D5:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5D6
.5D7:
xor	al,al
jmp .5D8
.5D6:
mov	al,*1
.5D8:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4015           break;
jmp .5C9
!BCC_EOS
! 4016         }
! 4017       goto int13_success;
jmp .5C9
.5CB:
sub	al,*0
beq 	.5CC
sub	al,*1
beq 	.5CF
sub	al,*1
je 	.5D5
.5C9:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4018       break;
br 	.5A6
!BCC_EOS
! 4019     case 0x46:
! 4020       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.5D9:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4021       if (locks != 0) {
! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
je  	.5DA
.5DB:
! 4022         AX = ((AX & 0x00ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4023         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4024         }
! 4025 #asm
.5DA:
!BCC_EOS
!BCC_ASM
_int13_cdrom.BP	set	$2E
.int13_cdrom.BP	set	$E
_int13_cdrom.EHBX	set	$24
.int13_cdrom.EHBX	set	4
_int13_cdrom.CS	set	$3C
.int13_cdrom.CS	set	$1C
_int13_cdrom.count	set	8
.int13_cdrom.count	set	-$18
_int13_cdrom.CX	set	$36
.int13_cdrom.CX	set	$16
_int13_cdrom.segment	set	6
.int13_cdrom.segment	set	-$1A
_int13_cdrom.DI	set	$2A
.int13_cdrom.DI	set	$A
_int13_cdrom.FLAGS	set	$3E
.int13_cdrom.FLAGS	set	$1E
_int13_cdrom.DS	set	$26
.int13_cdrom.DS	set	6
_int13_cdrom.ELDX	set	$30
.int13_cdrom.ELDX	set	$10
_int13_cdrom.DX	set	$34
.int13_cdrom.DX	set	$14
_int13_cdrom.size	set	0
.int13_cdrom.size	set	-$20
_int13_cdrom.i	set	2
.int13_cdrom.i	set	-$1E
_int13_cdrom.device	set	$1D
.int13_cdrom.device	set	-3
_int13_cdrom.ES	set	$28
.int13_cdrom.ES	set	8
_int13_cdrom.ebda_seg	set	$1E
.int13_cdrom.ebda_seg	set	-2
_int13_cdrom.SI	set	$2C
.int13_cdrom.SI	set	$C
_int13_cdrom.IP	set	$3A
.int13_cdrom.IP	set	$1A
_int13_cdrom.lba	set	$A
.int13_cdrom.lba	set	-$16
_int13_cdrom.status	set	$1C
.int13_cdrom.status	set	-4
_int13_cdrom.atacmd	set	$F
.int13_cdrom.atacmd	set	-$11
_int13_cdrom.AX	set	$38
.int13_cdrom.AX	set	$18
_int13_cdrom.offset	set	4
.int13_cdrom.offset	set	-$1C
_int13_cdrom.BX	set	$32
.int13_cdrom.BX	set	$12
_int13_cdrom.locks	set	$1B
.int13_cdrom.locks	set	-5
        push bp
        mov bp, sp
        mov ah, #0x52
        int #0x15
        mov _int13_cdrom.status + 2[bp], ah
        jnc int13_cdrom_rme_end
        mov _int13_cdrom.status, #1
int13_cdrom_rme_end:
        pop bp
! 4035 endasm
!BCC_ENDASM
!BCC_EOS
! 4036       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.5DC
.5DD:
! 4037         AX = ((AX & 0x00ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4038         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4039       }
! 4040       goto int13_success;
.5DC:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4041       break;
br 	.5A6
!BCC_EOS
! 4042     case 0x48:
! 4043       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
.5DE:
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 4044       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
jae 	.5DF
.5E0:
! 4045         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4046       if(size >= 0x1a) {
.5DF:
! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
blo 	.5E1
.5E2:
! 4047         Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 4048         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4049         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4050         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4051         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4052         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4053         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4054         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4055         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4056         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4057         }
! 4058       
! 4058 if(size >= 0x1e) {
.5E1:
! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1E
blo 	.5E3
.5E4:
! 4059         Bit8u channel, dev, irq, mode, checksum, i;
!BCC_EOS
! 4060         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 4061         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4062         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
push	-2[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4063         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4064         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4065         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4066         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 4067         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4068         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	-$24[bp],al
!BCC_EOS
! 4069         options = (1<<4);
! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,*$10
mov	-$2C[bp],ax
!BCC_EOS
! 4070         options |= (1<<5);
! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$20
mov	-$2C[bp],ax
!BCC_EOS
! 4071         options |= (1<<6);
! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$40
mov	-$2C[bp],ax
!BCC_EOS
! 4072         options |= (mode==0x01?1:0<<7);
! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*1
jne 	.5E5
.5E6:
mov	al,*1
jmp .5E7
.5E5:
xor	al,al
.5E7:
! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
xor	ah,ah
or	ax,-$2C[bp]
mov	-$2C[bp],ax
!BCC_EOS
! 4073         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
push	-$28[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4074         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	ax,-$2A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4075         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4076         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4077         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4078         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4079         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4080         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4081         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4082         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4083         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4084         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	al,al
mov	-$25[bp],al
!BCC_EOS
! 4085         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
xor	al,al
mov	-$26[bp],al
!BCC_EOS
!BCC_EOS
jmp .5EA
.5EB:
! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
mov	al,-$26[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	ah,ah
add	al,-$25[bp]
adc	ah,*0
mov	-$25[bp],al
!BCC_EOS
! 4086         checksum = ~checksum;
.5E9:
! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
inc	ax
mov	-$26[bp],al
.5EA:
! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*$F
jb 	.5EB
.5EC:
.5E8:
! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 4087         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4088         }
! 4089       if(size >= 0x42) {
.5E3:
! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$42
blo 	.5ED
.5EE:
! 4090         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 4091         Bit16u iobase1;
!BCC_EOS
! 4092         
! 4092 channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4093         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	-$22[bp],al
!BCC_EOS
! 4094         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4095         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4096         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4097         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4098         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4099         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4100         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5EF
.5F0:
! 4101           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4102           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4103           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4104           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4105           }
! 4106         else {
jmp .5F1
.5EF:
! 4107           }
! 4108         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.5F1:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4109         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4110         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4111         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4112         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5F2
.5F3:
! 4113           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
push	-$26[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4114           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4115           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4116           }
! 4117         else {
jmp .5F4
.5F2:
! 4118           }
! 4119         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.5F4:
! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4120         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4121         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4122         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4123         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	al,al
mov	-$23[bp],al
!BCC_EOS
! 4124         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
mov	al,*$1E
mov	-$24[bp],al
!BCC_EOS
!BCC_EOS
jmp .5F7
.5F8:
! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$24[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	ah,ah
add	al,-$23[bp]
adc	ah,*0
mov	-$23[bp],al
!BCC_EOS
! 4125         checksum = ~checksum;
.5F6:
! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
inc	ax
mov	-$24[bp],al
.5F7:
! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*$40
jb 	.5F8
.5F9:
.5F5:
! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4126         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4127         }
! 4128       goto int13_success;
.5ED:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4129       break;
br 	.5A6
!BCC_EOS
! 4130     case 0x49:
! 4131       AX = ((AX & 0x00ff) | ((06) << 8));
.5FA:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4132       goto int13_fail_no
! 4132 status;
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 4133       break;
br 	.5A6
!BCC_EOS
! 4134     case 0x4e:
! 4135       switch (( AX & 0x00ff )) {
.5FB:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
jmp .5FE
! 4136         case 0x01:
! 4137         case 0x03:
.5FF:
! 4138         case 0x04:
.600:
! 4139         case 0x06:
.601:
! 4140           goto int13_success;
.602:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4141           break;
jmp .5FC
!BCC_EOS
! 4142         default :
! 4143           goto int13_fail;
.603:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4144         }
! 4145       break;
jmp .5FC
.5FE:
sub	al,*1
je 	.5FF
sub	al,*2
je 	.600
sub	al,*1
je 	.601
sub	al,*2
je 	.602
jmp	.603
.5FC:
br 	.5A6
!BCC_EOS
! 4146     case 0x02:
! 4147     case 0x04:
.604:
! 4148     case 0x08:
.605:
! 4149     case 0x0a:
.606:
! 4150     case 0x0b:
.607:
! 4151     case 0x18:
.608:
! 4152     case 0x50:
.609:
! 4153     default:
.60A:
! 4154       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", ( AX >> 8 ));
.60B:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .60C+0 (used reg = )
mov	bx,#.60C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4155       goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4156       break;
br 	.5A6
!BCC_EOS
! 4157     }
! 4158 int13_fail:
jmp .5A6
.5A8:
add	sp,*-$C
sub	ax,*0
jl 	.60B
cmp	ax,*$18
ja  	.60D
shl	ax,*1
mov	bx,ax
seg	cs
br	.60E[bx]
.60E:
.word	.5A9
.word	.5B4
.word	.604
.word	.5B1
.word	.605
.word	.5B2
.word	.60B
.word	.60B
.word	.606
.word	.5AA
.word	.607
.word	.608
.word	.5AB
.word	.5AC
.word	.60B
.word	.60B
.word	.5AD
.word	.5AE
.word	.60B
.word	.60B
.word	.5AF
.word	.5B8
.word	.5B0
.word	.60B
.word	.609
.60D:
sub	ax,*$41
jb 	.60B
cmp	ax,*$F
ja  	.60F
shl	ax,*1
mov	bx,ax
seg	cs
br	.610[bx]
.610:
.word	.5B9
.word	.5BA
.word	.5B3
.word	.5BB
.word	.5C6
.word	.5D9
.word	.5BC
.word	.5DE
.word	.5FA
.word	.60B
.word	.60B
.word	.60B
.word	.60B
.word	.5FB
.word	.60B
.word	.60A
.60F:
br 	.60B
.5A6:
..FFEA	=	-$2E
add	sp,*$C
.FFEB:
..FFEB	=	-$22
! 4159     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4160 int13_fail_noah:
.FFE8:
..FFE8	=	-$22
! 4161     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4162 int13_fail_nostatus:
.FFE7:
..FFE7	=	-$22
! 4163     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 4164     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4165 int13_success:
.FFE9:
..FFE9	=	-$22
! 4166     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 4167 int13_success_noah:
.FFE6:
..FFE6	=	-$22
! 4168     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4169     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 4170     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4171 }
! 4172   void
! Register BX used in function int13_cdrom
! 4173 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4174   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_eltorito
_int13_eltorito:
!BCC_EOS
! 4175 {
! 4176   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4177   ;
!BCC_EOS
! 4178   switch (( AX >> 8 )) {
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.613
! 4179     case 0x4a:
! 4180     case 0x4c:
.614:
! 4181     case 0x4d:
.615:
! 4182       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
.616:
! Debug: list unsigned short AX = [S+4+$14] (used reg = )
push	$16[bp]
! Debug: list * char = .617+0 (used reg = )
mov	bx,#.617
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4183       goto int13_fail;
add	sp,#..FFE4-..FFE5
br 	.FFE4
!BCC_EOS
! 4184       break;
br 	.611
!BCC_EOS
! 4185     case 0x4b:
! 4186       write_byte(DS,SI+0x00,0x13);
.618:
! Debug: list int = const $13 (used reg = )
mov	ax,*$13
push	ax
! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4187       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4188       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4189       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4190       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4191       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4192       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4193       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4194       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4195       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vde
! 4195 vice.cylinders));
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4196       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$11 (used reg = )
add	ax,*$11
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4197       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4198       if(( AX & 0x00ff ) == 0x00) {
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.619
.61A:
! 4199         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4200         }
! 4201       goto int13_success;
.619:
add	sp,#..FFE3-..FFE5
jmp .FFE3
!BCC_EOS
! 4202       break;
jmp .611
!BCC_EOS
! 4203     default:
! 4204       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", ( AX >> 8 ));
.61B:
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .61C+0 (used reg = )
mov	bx,#.61C
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4205       goto int13_fail;
add	sp,#..FFE4-..FFE5
jmp .FFE4
!BCC_EOS
! 4206       break;
jmp .611
!BCC_EOS
! 4207     }
! 4208 int13_fail:
jmp .611
.613:
sub	ax,*$4A
beq 	.614
sub	ax,*1
beq 	.618
sub	ax,*1
beq 	.615
sub	ax,*1
beq 	.616
jmp	.61B
.611:
..FFE5	=	-4
.FFE4:
..FFE4	=	-4
! 4209     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4210     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4211     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4212     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4213 int13_success:
.FFE3:
..FFE3	=	-4
! 4214     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4215     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4216     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4217     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4218 }
! 4219   void
! Register BX used in function int13_eltorito
! 4220 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4221   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_cdemu
_int13_cdemu:
!BCC_EOS
! 4222 {
! 4223   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4224   Bit8u device, status;
!BCC_EOS
! 4225   Bit16u vheads, vspt, vcylinders;
!BCC_EOS
! 4226   Bit16u head, sector, cylinder, nbsectors;
!BCC_EOS
! 4227   Bit32u vlba, ilba, slba, elba;
!BCC_EOS
! 4228   Bit16u before, segment, offset;
!BCC_EOS
! 4229   Bit8u atacmd[12];
!BCC_EOS
! 4230   ;
add	sp,*-$32
!BCC_EOS
! 4231   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4232   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
xor	ah,ah
add	al,-3[bp]
adc	ah,*0
mov	-3[bp],al
!BCC_EOS
! 4233   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4234   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
! 4235    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.61E
.61F:
! Debug: expression subtree swapping
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
cmp	al,-$36[bp]
lea	sp,-$34[bp]
je  	.61D
.61E:
! 4236     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", ( AX >> 8 ), ( DX & 0x00ff ));
! Debug: and int = const $FF to unsigned short DX = [S+$36+$10] (used reg = )
mov	al,$12[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .620+0 (used reg = )
mov	bx,#.620
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 4237     goto int13_fail;
add	sp,#..FFE2+$36
br 	.FFE2
!BCC_EOS
! 4238     }
! 4239   switch (( AX >> 8 )) {
.61D:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.623
! 4240     case 0x00:
! 4241     case 0x09:
.624:
! 4242     case 0x0c:
.625:
! 4243     case 0x0d:
.626:
! 4244     case 0x10:
.627:
! 4245     case 0x11:
.628:
! 4246     case 0x14:
.629:
! 4247     case 0x16:
.62A:
! 4248       goto int13_success;
.62B:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4249       break;
br 	.621
!BCC_EOS
! 4250     case 0x03:
! 4251     case 0x05:
.62C:
! 4252       AX = ((AX & 0x00ff) | ((0x03) << 8));
.62D:
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4253       goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4254       break;
br 	.621
!BCC_EOS
! 4255     case 0x01:
! 4256       status=read_byte(0x0040, 0x0074);
.62E:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4257       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4258       write_byte(0x0040, 
! 4258 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4259       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.62F
.630:
add	sp,#..FFDE-..FFE1
br 	.FFDE
!BCC_EOS
! 4260       else goto int13_success_noah;
jmp .631
.62F:
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4261       break;
.631:
br 	.621
!BCC_EOS
! 4262     case 0x02:
! 4263     case 0x04:
.632:
! 4264       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.633:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4265       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 4266       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 4267       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	-$1A[bp],ax
mov	-$18[bp],bx
!BCC_EOS
! 4268       sector = ( CX & 0x00ff ) & 0x003f;
! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 4269       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
and	al,#$C0
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 4270       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4271       nbsectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
xor	ah,ah
mov	-$12[bp],ax
!BCC_EOS
! 4272       segment = ES;
! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
mov	ax,6[bp]
mov	-$26[bp],ax
!BCC_EOS
! 4273       offset = BX;
! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
mov	ax,$10[bp]
mov	-$28[bp],ax
!BCC_EOS
! 4274       if(nbsectors==0) goto int13_success;
! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
test	ax,ax
jne 	.634
.635:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4275       if ((sector > vspt)
.634:
! 4276        || (cylinder >= vcylinders)
! 4277        || (head >= vheads)) {
! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-8[bp]
ja  	.637
.639:
! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$A[bp]
jae 	.637
.638:
! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-6[bp]
jb  	.636
.637:
! 4278         goto int13_fail;
add	sp,#..FFE2-..FFE1
br 	.FFE2
!BCC_EOS
! 4279         }
! 4280       if (( AX >> 8 ) == 0x04) goto int13_success;
.636:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.63A
.63B:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4281       segment = ES+(BX / 16);
.63A:
! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
mov	cl,*4
shr	ax,cl
! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
! Debug: expression subtree swapping
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4282       offset = BX % 16;
! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
xor	ah,ah
mov	-$28[bp],ax
!BCC_EOS
! 4283       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
mov	ax,-6[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 4284       AX = ((AX & 0xff00) | (nbsectors));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
or	ax,-$12[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4285       slba = (Bit32u)vlba/4;
! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFE1[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
mov	-$1E[bp],ax
mov	-$1C[bp],bx
!BCC_EOS
! 4286       before= (Bit16u)vlba%4;
! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
mov	ax,-$16[bp]
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 4287       elba = (Bit32u)(vlba+nbsectors-1)/4;
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
! Debug: expression subtree swapping
lea	di,-$16[bp]
call	laddul
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	lsubul
add	sp,*8
! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	ldivul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
mov	-$22[bp],ax
mov	-$20[bp],bx
!BCC_EOS
! 4288       memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 4289       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
mov	al,*$28
mov	-$34[bp],al
!BCC_EOS
! 4290       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 4291       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
mov	-$2C[bp],al
!BCC_EOS
! 4292       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF00
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
mov	-$32[bp],al
!BCC_EOS
! 4293       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
mov	-$31[bp],al
!BCC_EOS
! 4294       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF00
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
mov	-$30[bp],al
!BCC_EOS
! 4295       atacmd[5]=(ilba+slba & 0x000000ff);
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
mov	-$2F[bp],al
!BCC_EOS
! 4296       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
push	-$28[bp]
! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
push	-$26[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFE1[bp]
mov	bx,-6+..FFE1[bp]
lea	di,-$C+..FFE1[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
mov	ax,-$24[bp]
mov	cx,#$200
imul	cx
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$48-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.63C
.63D:
! 4297         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",( AX >> 8 ),status);
! Debug: list unsigned char status = [S+$36-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .63E+0 (used reg = )
mov	bx,#.63E
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 4298         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4299         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4300         goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4301         }
! 4302       goto int13_success;
.63C:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4303       break;
br 	.621
!BCC_EOS
! 4304     case 0x08:
! 4305       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.63F:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4306       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylind
! 4306 ers) - 1;
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4307       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
! 4308       AX = ((AX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4309       BX = ((BX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4310       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	al,-$A[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4311       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
mov	al,-8[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4312       DX = ((DX & 0x00ff) | ((vheads) << 8));
! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
mov	ax,-6[bp]
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4313       DX = ((DX & 0xff00) | (0x02));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4314       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
jmp .642
! 4315         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
.643:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .640
!BCC_EOS
! 4316         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
.644:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
or	al,*4
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .640
!BCC_EOS
! 4317         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
.645:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
or	al,*6
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .640
!BCC_EOS
! 4318         }
! 4319 #asm
jmp .640
.642:
sub	al,*1
je 	.643
sub	al,*1
je 	.644
sub	al,*1
je 	.645
.640:
!BCC_EOS
!BCC_ASM
_int13_cdemu.BP	set	$40
.int13_cdemu.BP	set	$C
_int13_cdemu.CS	set	$4E
.int13_cdemu.CS	set	$1A
_int13_cdemu.nbsectors	set	$22
.int13_cdemu.nbsectors	set	-$12
_int13_cdemu.CX	set	$48
.int13_cdemu.CX	set	$14
_int13_cdemu.elba	set	$12
.int13_cdemu.elba	set	-$22
_int13_cdemu.segment	set	$E
.int13_cdemu.segment	set	-$26
_int13_cdemu.DI	set	$3C
.int13_cdemu.DI	set	8
_int13_cdemu.FLAGS	set	$50
.int13_cdemu.FLAGS	set	$1C
_int13_cdemu.vcylinders	set	$2A
.int13_cdemu.vcylinders	set	-$A
_int13_cdemu.sector	set	$26
.int13_cdemu.sector	set	-$E
_int13_cdemu.DS	set	$38
.int13_cdemu.DS	set	4
_int13_cdemu.head	set	$28
.int13_cdemu.head	set	-$C
_int13_cdemu.cylinder	set	$24
.int13_cdemu.cylinder	set	-$10
_int13_cdemu.DX	set	$46
.int13_cdemu.DX	set	$12
_int13_cdemu.device	set	$31
.int13_cdemu.device	set	-3
_int13_cdemu.ES	set	$3A
.int13_cdemu.ES	set	6
_int13_cdemu.vspt	set	$2C
.int13_cdemu.vspt	set	-8
_int13_cdemu.vlba	set	$1E
.int13_cdemu.vlba	set	-$16
_int13_cdemu.ebda_seg	set	$32
.int13_cdemu.ebda_seg	set	-2
_int13_cdemu.SI	set	$3E
.int13_cdemu.SI	set	$A
_int13_cdemu.IP	set	$4C
.int13_cdemu.IP	set	$18
_int13_cdemu.status	set	$30
.int13_cdemu.status	set	-4
_int13_cdemu.atacmd	set	0
.int13_cdemu.atacmd	set	-$34
_int13_cdemu.AX	set	$4A
.int13_cdemu.AX	set	$16
_int13_cdemu.ilba	set	$1A
.int13_cdemu.ilba	set	-$1A
_int13_cdemu.before	set	$10
.int13_cdemu.before	set	-$24
_int13_cdemu.offset	set	$C
.int13_cdemu.offset	set	-$28
_int13_cdemu.slba	set	$16
.int13_cdemu.slba	set	-$1E
_int13_cdemu.SP	set	$42
.int13_cdemu.SP	set	$E
_int13_cdemu.vheads	set	$2E
.int13_cdemu.vheads	set	-6
_int13_cdemu.BX	set	$44
.int13_cdemu.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_cdemu.DI+2[bp], ax
      mov _int13_cdemu.ES+2[bp], cs
      pop bp
! 4326 endasm
!BCC_ENDASM
!BCC_EOS
! 4327       goto int13_success;
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4328       break;
br 	.621
!BCC_EOS
! 4329     case 0x15:
! 4330       AX = ((AX & 0x00ff) | ((0x03) << 8));
.646:
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4331       goto int13_success_noah;
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4332       break;
br 	.621
!BCC_EOS
! 4333     case 0x0a:
! 4334     case 0x0b:
.647:
! 4335     case 0x18:
.648:
! 4336     case 0x41:
.649:
! 4337     case 0x42:
.64A:
! 4338     case 0x43:
.64B:
! 4339     case 0x44:
.64C:
! 4340     case 0x45:
.64D:
! 4341     case 0x46:
.64E:
! 4342     case 0x47:
.64F:
! 4343     case 0x48:
.650:
! 4344     case 0x49:
.651:
! 4345     case 0x4e:
.652:
! 4346     case 0x50:
.653:
! 4347     default:
.654:
! 4348       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", ( AX >> 8 ));
.655:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .656+0 (used reg = )
mov	bx,#.656
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4349       goto int13_fail;
add	sp,#..FFE2-..FFE1
jmp .FFE2
!BCC_EOS
! 4350       break;
jmp .621
!BCC_EOS
! 4351     }
! 4352 int13_fail:
jmp .621
.623:
sub	ax,*0
jl 	.655
cmp	ax,*$18
ja  	.657
shl	ax,*1
mov	bx,ax
seg	cs
br	.658[bx]
.658:
.word	.624
.word	.62E
.word	.632
.word	.62C
.word	.633
.word	.62D
.word	.655
.word	.655
.word	.63F
.word	.625
.word	.647
.word	.648
.word	.626
.word	.627
.word	.655
.word	.655
.word	.628
.word	.629
.word	.655
.word	.655
.word	.62A
.word	.646
.word	.62B
.word	.655
.word	.649
.657:
sub	ax,*$41
jb 	.655
cmp	ax,*$F
ja  	.659
shl	ax,*1
mov	bx,ax
seg	cs
br	.65A[bx]
.65A:
.word	.64A
.word	.64B
.word	.64C
.word	.64D
.word	.64E
.word	.64F
.word	.650
.word	.651
.word	.652
.word	.655
.word	.655
.word	.655
.word	.655
.word	.653
.word	.655
.word	.654
.659:
br 	.655
.621:
..FFE1	=	-$36
.FFE2:
..FFE2	=	-$36
! 4353     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4354 int13_fail_noah:
.FFDF:
..FFDF	=	-$36
! 4355     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4356 int13_fail_nostatus:
.FFDE:
..FFDE	=	-$36
! 4357     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4358     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4359 int13_success:
.FFE0:
..FFE0	=	-$36
! 4360     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4361 int13_success_noah:
.FFDD:
..FFDD	=	-$36
! 4362     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4363     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4364     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4365 }
! 4366 void floppy_reset_controller()
! Register BX used in function int13_cdemu
! 4367 {
export	_floppy_reset_controller
_floppy_reset_controller:
! 4368   Bit8u val8;
!BCC_EOS
! 4369   val8 = inb(0x03f2);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4370   outb(0x03f2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4371   outb(0x03f2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4372   do {
.65D:
! 4373     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4374   } while ( (val8 & 0xc0) != 0x80 );
.65C:
! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.65D
.65E:
!BCC_EOS
! 4375 }
.65B:
mov	sp,bp
pop	bp
ret
! 4376 void floppy_prepare_controller(drive)
! 4377   Bit16u drive;
export	_floppy_prepare_controller
_floppy_prepare_controller:
!BCC_EOS
! 4378 {
! 4379   Bit8u val8, dor, prev_reset;
!BCC_EOS
! 4380   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4381   val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4382   write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4383   prev_reset = inb(0x03f2) & 0x04;
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
and	al,*4
! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4384   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.65F
.660:
! 4385     dor
! 4385  = 0x20;
! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$20
mov	-2[bp],al
!BCC_EOS
! 4386   else
! 4387     dor = 0x10;
jmp .661
.65F:
! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$10
mov	-2[bp],al
!BCC_EOS
! 4388   dor |= 0x0c;
.661:
! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
or	al,*$C
mov	-2[bp],al
!BCC_EOS
! 4389   dor |= drive;
! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
mov	ax,4[bp]
or	al,-2[bp]
mov	-2[bp],al
!BCC_EOS
! 4390   outb(0x03f2, dor);
! Debug: list unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4391   write_byte(0x40,0x40, 37);
! Debug: list int = const $25 (used reg = )
mov	ax,*$25
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4392   do {
.664:
! 4393     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4394   } while ( (val8 & 0xc0) != 0x80 );
.663:
! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.664
.665:
!BCC_EOS
! 4395   if (prev_reset == 0) {
.662:
! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	al,-3[bp]
test	al,al
jne 	.666
.667:
! 4396 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    sti
! 4398 endasm
!BCC_ENDASM
!BCC_EOS
! 4399     do {
.66A:
! 4400       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4401     } while ( (val8 & 0x80) == 0 );
.669:
! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.66A
.66B:
!BCC_EOS
! 4402     val8 &= 0x7f;
.668:
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4403 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    cli
! 4405 endasm
!BCC_ENDASM
!BCC_EOS
! 4406     write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4407   }
! 4408 }
.666:
mov	sp,bp
pop	bp
ret
! 4409   bx_bool
! 4410 floppy_media_known(drive)
! 4411   Bit16u drive;
export	_floppy_media_known
_floppy_media_known:
!BCC_EOS
! 4412 {
! 4413   Bit8u val8;
!BCC_EOS
! 4414   Bit16u media_state_offset;
!BCC_EOS
! 4415   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4416   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.66C
.66D:
! 4417     val8 >>= 1;
! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
shr	ax,*1
mov	-1[bp],al
!BCC_EOS
! 4418   val8 &= 0x01;
.66C:
! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*1
mov	-1[bp],al
!BCC_EOS
! 4419   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.66E
.66F:
! 4420     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4421   media_state_offset = 0x0090;
.66E:
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4422   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.670
.671:
! 4423     media_state_offset += 1;
! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,-4[bp]
inc	ax
mov	-4[bp],ax
!BCC_EOS
! 4424   val8 = read_byte(0x0040, media_state_offset);
.670:
! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4425   val8 = (val8 >> 4) & 0x01;
! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4426   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.672
.673:
! 4427     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4428   return(1);
.672:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4429 }
! 4430   bx_bool
! 4431 floppy_media_sense(drive)
! 4432   Bit16u drive;
export	_floppy_media_sense
_floppy_media_sense:
!BCC_EOS
! 4433 {
! 4434   bx_bool retval;
!BCC_EOS
! 4435   Bit16u media_state_offset;
!BCC_EOS
! 4436   Bit8u drive_type, config_data, media_state;
!BCC_EOS
! 4437   if (floppy_drive_recal(drive) == 0) {
push	bp
mov	bp,sp
add	sp,*-8
! Debug: list unsigned short drive = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
call	_floppy_drive_recal
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.674
.675:
! 4438     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4439     }
! 4440   drive_type = inb_cmos(0x10);
.674:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4441   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.676
.677:
! 4442     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-5[bp],al
!BCC_EOS
! 4443   else
! 4444     drive_type &= 0x0f;
jmp .678
.676:
! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
and	al,*$F
mov	-5[bp],al
!BCC_EOS
! 4445   if ( drive_type == 1 ) {
.678:
! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
jne 	.679
.67A:
! 4446     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4447     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4448     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4449     }
! 4450   else if ( drive_type == 2 ) {
br 	.67B
.679:
! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*2
jne 	.67C
.67D:
! 4451     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4452     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4453     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4454     }
! 4455   else if ( drive_type == 3 ) {
br 	.67E
.67C:
! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*3
jne 	.67F
.680:
! 4456     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4457     media_state = 0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4458     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4459     }
! 4460   else if ( drive_type == 4 ) {
br 	.681
.67F:
! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*4
jne 	.682
.683:
! 4461     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4462     media_state = 0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4463     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4464     }
! 4465   else if ( drive_type == 5 ) {
br 	.684
.682:
! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*5
jne 	.685
.686:
! 4466     config_data = 0xCC;
! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
mov	al,#$CC
mov	-6[bp],al
!BCC_EOS
! 4467     media_state = 0xD7;
! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,#$D7
mov	-7[bp],al
!BCC_EOS
! 4468     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4469     }
! 4470   else if ( drive_type == 6 ) {
jmp .687
.685:
! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*6
jne 	.688
.689:
! 4471     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4472     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4473     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4474     }
! 4475   else if ( drive_type == 7 ) {
jmp .68A
.688:
! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*7
jne 	.68B
.68C:
! 4476     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4477     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4478     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4479     }
! 4480   else if ( drive_type == 8 ) {
jmp .68D
.68B:
! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
jne 	.68E
.68F:
! 4481     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4482     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4483     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4484     }
! 4485   else {
jmp .690
.68E:
! 4486     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4487     media_state = 0x00;
! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 4488     retval = 0;
! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
xor	ax,ax
mov	-2[bp],ax
!BCC_EOS
! 4489     }
! 4490   if (drive == 0)
.690:
.68D:
.68A:
.687:
.684:
.681:
.67E:
.67B:
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.691
.692:
! 4491     media_state_offset = 0x90
! 4491 ;
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4492   else
! 4493     media_state_offset = 0x91;
jmp .693
.691:
! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$91
mov	-4[bp],ax
!BCC_EOS
! 4494   write_byte(0x0040, 0x008B, config_data);
.693:
! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $8B (used reg = )
mov	ax,#$8B
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4495   write_byte(0x0040, media_state_offset, media_state);
! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4496   return(retval);
mov	ax,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4497 }
! 4498   bx_bool
! 4499 floppy_drive_recal(drive)
! 4500   Bit16u drive;
export	_floppy_drive_recal
_floppy_drive_recal:
!BCC_EOS
! 4501 {
! 4502   Bit8u val8;
!BCC_EOS
! 4503   Bit16u curr_cyl_offset;
!BCC_EOS
! 4504   floppy_prepare_controller(drive);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4505   outb(0x03f5, 0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4506   outb(0x03f5, drive);
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4507 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  sti
! 4509 endasm
!BCC_ENDASM
!BCC_EOS
! 4510   do {
.696:
! 4511     val8 = (read_byte(0x0040, 0x003e) & 0x80);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4512   } while ( val8 == 0 );
.695:
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
je 	.696
.697:
!BCC_EOS
! 4513   val8 = 0;
.694:
! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
xor	al,al
mov	-1[bp],al
!BCC_EOS
! 4514 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  cli
! 4516 endasm
!BCC_ENDASM
!BCC_EOS
! 4517   val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4518   val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4519   if (drive) {
mov	ax,4[bp]
test	ax,ax
je  	.698
.699:
! 4520     val8 |= 0x02;
! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 4521     curr_cyl_offset = 0x0095;
! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$95
mov	-4[bp],ax
!BCC_EOS
! 4522   } else {
jmp .69A
.698:
! 4523     val8 |= 0x01;
! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*1
mov	-1[bp],al
!BCC_EOS
! 4524     curr_cyl_offset = 0x0094;
! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$94
mov	-4[bp],ax
!BCC_EOS
! 4525   }
! 4526   write_byte(0x0040, 0x003e, val8);
.69A:
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4527   write_byte(0x0040, curr_cyl_offset, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4528   return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4529 }
! 4530   bx_bool
! 4531 floppy_drive_exists(drive)
! 4532   Bit16u drive;
export	_floppy_drive_exists
_floppy_drive_exists:
!BCC_EOS
! 4533 {
! 4534   Bit8u drive_type;
!BCC_EOS
! 4535   drive_type = inb_cmos(0x10);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4536   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.69B
.69C:
! 4537     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-1[bp],al
!BCC_EOS
! 4538   else
! 4539     drive_type &= 0x0f;
jmp .69D
.69B:
! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$F
mov	-1[bp],al
!BCC_EOS
! 4540   if ( drive_type == 0 )
.69D:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.69E
.69F:
! 4541     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4542   else
! 4543     return(1);
jmp .6A0
.69E:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4544 }
.6A0:
mov	sp,bp
pop	bp
ret
! 4545   void
! 4546 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 4547   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_diskette_function
_int13_diskette_function:
!BCC_EOS
! 4548 {
! 4549   Bit8u drive, num_sectors, track, sector, head, status;
!BCC_EOS
! 4550   Bit16u base_address, base_count, base_es;
!BCC_EOS
! 4551   Bit8u page, mode_register, val8, dor;
!BCC_EOS
! 4552   Bit8u return_status[7];
!BCC_EOS
! 4553   Bit8u drive_type, num_floppies, ah;
!BCC_EOS
! 4554   Bit16u es, last_addr;
!BCC_EOS
! 4555   ;
push	bp
mov	bp,sp
add	sp,*-$1E
!BCC_EOS
! 4556   ah = ( AX >> 8 );
! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	-$1A[bp],al
!BCC_EOS
! 4557   switch ( ah ) {
mov	al,-$1A[bp]
br 	.6A3
! 4558     case 0x00:
! 4559 ;
.6A4:
!BCC_EOS
! 4560       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4561       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.6A5
.6A6:
! 4562         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4563         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4564         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4565         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4566       }
! 4567       drive_type = inb_cmos(0x10);
.6A5:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4568       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.6A7
.6A8:
! 4569         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4570       else
! 4571         drive_type &= 0x0f;
jmp .6A9
.6A7:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4572       if (drive_type == 0) {
.6A9:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.6AA
.6AB:
! 4573         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4574         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4575         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4576         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4577       }
! 4578       AX = ((AX & 0x00ff) | ((0) << 8));
.6AA:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4579       set_diskette_ret_status(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4580       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4581       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4582       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4583     cas
! 4583 e 0x01:
! 4584       FLAGS &= 0xfffe;
.6AC:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4585       val8 = read_byte(0x0000, 0x0441);
! Debug: list int = const $441 (used reg = )
mov	ax,#$441
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4586       AX = ((AX & 0x00ff) | ((val8) << 8));
! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFDC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4587       if (val8) {
mov	al,-$F[bp]
test	al,al
je  	.6AD
.6AE:
! 4588         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4589       }
! 4590       return;
.6AD:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4591     case 0x02:
! 4592     case 0x03:
.6AF:
! 4593     case 0x04:
.6B0:
! 4594       num_sectors = ( AX & 0x00ff );
.6B1:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4595       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4596       sector = ( CX & 0x00ff );
! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
mov	al,$14[bp]
! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4597       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4598       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4599       if ((drive > 1) || (head > 1) || (sector == 0) ||
! 4600           (num_sectors == 0) || (num_sectors > 72)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.6B3
.6B7:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.6B3
.6B6:
! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.6B3
.6B5:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.6B3
.6B4:
! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$48
jbe 	.6B2
.6B3:
! 4601         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
! Debug: list * char = .6B8+0 (used reg = )
mov	bx,#.6B8
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4602         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4603         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4604         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4605         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4606         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4607       }
! 4608       if (floppy_drive_exists(drive) == 0) {
.6B2:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6B9
.6BA:
! 4609         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4610         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4611         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4612         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4613         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4614       }
! 4615       if (floppy_media_known(drive) == 0) {
.6B9:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6BB
.6BC:
! 4616         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6BD
.6BE:
! 4617           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4618           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4619           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4620           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4621           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4622         }
! 4623       }
.6BD:
! 4624       if (ah == 0x02) {
.6BB:
! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*2
bne 	.6BF
.6C0:
! 4625         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4626         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4627         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4628         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6C1
.6C2:
! 4629           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4630         }
! 4631         base_count = (num_sectors * 512) - 1;
.6C1:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4632         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4633         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6C3
.6C4:
! 4634           AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4635           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4636           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4637           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4638           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4639         }
! 4640         ;
.6C3:
!BCC_EOS
! 4641         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4642   ;
!BCC_EOS
! 4643         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4644         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4645         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4646   ;
!BCC_EOS
! 4647         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4648         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4649         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4650         mode_register = 0x46;
! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$46
mov	-$E[bp],al
!BCC_EOS
! 4651   ;
!BCC_EOS
! 4652         outb(0x000b, mode_regi
! 4652 ster);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4653   ;
!BCC_EOS
! 4654         outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4655   ;
!BCC_EOS
! 4656         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4657         ;
!BCC_EOS
! 4658         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4659         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4660         outb(0x03f5, 0xe6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4661         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4662         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4663         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4664         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4665         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4666         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4667         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4668         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4669 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4671 endasm
!BCC_ENDASM
!BCC_EOS
! 4672         do {
.6C7:
! 4673           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4674           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6C8
.6C9:
! 4675             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4676             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4677             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4678             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4679             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4680             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4681           }
! 4682           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6C8:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4683         } while ( val8 == 0 );
.6C6:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6C7
.6CA:
!BCC_EOS
! 4684         val8 = 0;
.6C5:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4685 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4687 endasm
!BCC_ENDASM
!BCC_EOS
! 4688         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4689         val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4690         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4691         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4692         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6CB
.6CC:
! 4693           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6CD+0 (used reg = )
mov	bx,#.6CD
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4694         return_status[0] = inb(0x3f5);
.6CB:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4695         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4696         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4697         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4698         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4699         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4700         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4701         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4702         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4703         write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4704         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4705         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4706         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4707         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4708         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6CE
.6CF:
! 4709           AX = ((AX & 0x00ff) | ((0x20) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$2000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4710           set_diskette_ret_status(0x20);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4711           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4712           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4713           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4714         }
! 4715         set_diskette_
! 4715 current_cyl(drive, track);
.6CE:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4716         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4717         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4718         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4719       } else if (ah == 0x03) {
br 	.6D0
.6BF:
! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*3
bne 	.6D1
.6D2:
! 4720         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4721         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4722         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4723         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6D3
.6D4:
! 4724           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4725         }
! 4726         base_count = (num_sectors * 512) - 1;
.6D3:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4727         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4728         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6D5
.6D6:
! 4729           AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4730           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4731           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4732           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4733           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4734         }
! 4735         ;
.6D5:
!BCC_EOS
! 4736         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4737         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4738         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4739         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4740         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4741         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4742         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4743         mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4744         outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4745         outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4746         ;
!BCC_EOS
! 4747         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4748         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4749         outb(0x03f5, 0xc5);
! Debug: list int = const $C5 (used reg = )
mov	ax,#$C5
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4750         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4751         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4752         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4753         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4754         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4755         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4756         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4757         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4758 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4760 endasm
!BCC_ENDASM
!BCC_EOS
! 4761         do {
.6D9:
! 4762           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4763           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6DA
.6DB:
! 4764             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4765             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4766             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4767             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4768             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4769             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4770           }
! 4771           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6DA:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4772         } while ( val8 == 0 );
.6D8:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6D9
.6DC:
!BCC_EOS
! 4773         val8 = 0;
.6D7:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4774 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4776 endasm
!BCC_ENDASM
!BCC_EOS
! 4777         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4778         val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4779         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4780         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4781         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6DD
.6DE:
! 4782           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6DF+0 (used reg = )
mov	bx,#.6DF
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4783         return_st
! 4783 atus[0] = inb(0x3f5);
.6DD:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4784         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4785         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4786         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4787         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4788         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4789         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4790         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4791         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4792         write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4793         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4794         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4795         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4796         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4797         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6E0
.6E1:
! 4798           if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6E2
.6E3:
! 4799             AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4800             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4801             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4802           } else {
jmp .6E4
.6E2:
! 4803             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
! Debug: list * char = .6E5+0 (used reg = )
mov	bx,#.6E5
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4804           }
! 4805         }
.6E4:
! 4806         set_diskette_current_cyl(drive, track);
.6E0:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4807         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4808         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4809         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4810       } else {
jmp .6E6
.6D1:
! 4811         set_diskette_current_cyl(drive, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4812         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4813         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4814         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4815       }
! 4816       break;
.6E6:
.6D0:
br 	.6A1
!BCC_EOS
! 4817     case 0x05:
! 4818 ;
.6E7:
!BCC_EOS
! 4819       num_sectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4820       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4821       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4822       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4823       if ((drive > 1) || (head > 1) || (track > 79) ||
! 4824           (num_sectors == 0) || (num_sectors > 18)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.6E9
.6ED:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.6E9
.6EC:
! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
cmp	al,*$4F
ja  	.6E9
.6EB:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.6E9
.6EA:
! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$12
jbe 	.6E8
.6E9:
! 4825         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4826         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4827         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4828       }
! 4829       if (floppy_drive_exists(drive) == 0) {
.6E8:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6EE
.6EF:
! 4830         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4831         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4832         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4833         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4834       }
! 4835       if (floppy_media_known(drive) == 0) {
.6EE:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6F0
.6F1:
! 4836         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6F2
.6F3:
! 4837           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4838           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4839           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4840           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4841           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4842         }
! 4843     
! 4843   }
.6F2:
! 4844       page = (ES >> 12);
.6F0:
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4845       base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4846       base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4847       if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6F4
.6F5:
! 4848         page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4849       }
! 4850       base_count = (num_sectors * 4) - 1;
.6F4:
! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4851       last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4852       if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6F6
.6F7:
! 4853         AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4854         set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4855         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4856         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4857         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4858       }
! 4859       outb(0x000a, 0x06);
.6F6:
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4860       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4861       outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4862       outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4863       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4864       outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4865       outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4866       mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4867       outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4868       outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4869       outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4870       floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4871       outb(0x03f5, 0x4d);
! Debug: list int = const $4D (used reg = )
mov	ax,*$4D
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4872       outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4873       outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4874       outb(0x03f5, num_sectors);
! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4875       outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4876       outb(0x03f5, 0xf6);
! Debug: list int = const $F6 (used reg = )
mov	ax,#$F6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4877 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      sti
! 4879 endasm
!BCC_ENDASM
!BCC_EOS
! 4880       do {
.6FA:
! 4881         val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4882         if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6FB
.6FC:
! 4883           floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4884           AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4885           set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4886           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4887           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4888         }
! 4889         val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6FB:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4890       } while ( val8 == 0 );
.6F9:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6FA
.6FD:
!BCC_EOS
! 4891       val8 = 0;
.6F8:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4892 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      cli
! 4894 endasm
!BCC_ENDASM
!BCC_EOS
! 4895       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4896       val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4897       write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4898       val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4899       if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6FE
.6FF:
! 4900         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .700+0 (used reg = )
mov	bx,#.700
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4901       return_status[0] = inb(0x3f5);
.6FE:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4902       return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4903       return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4904       return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4905       return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4906       return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4907       return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4908       write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4909       write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4910       write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4911       write
! 4911 _byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4912       write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4913       write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4914       write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4915       if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.701
.702:
! 4916         if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.703
.704:
! 4917           AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4918           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4919           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4920         } else {
jmp .705
.703:
! 4921           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
! Debug: list * char = .706+0 (used reg = )
mov	bx,#.706
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4922         }
! 4923       }
.705:
! 4924       AX = ((AX & 0x00ff) | ((0) << 8));
.701:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4925       set_diskette_ret_status(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4926       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4927       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4928       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4929     case 0x08:
! 4930 ;
.707:
!BCC_EOS
! 4931       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4932       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.708
.709:
! 4933         AX = 0;
! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ax,ax
mov	$16[bp],ax
!BCC_EOS
! 4934         BX = 0;
! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ax,ax
mov	$10[bp],ax
!BCC_EOS
! 4935         CX = 0;
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4936         DX = 0;
! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 4937         ES = 0;
! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 4938         DI = 0;
! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
xor	ax,ax
mov	8[bp],ax
!BCC_EOS
! 4939         DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4940         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4941         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4942         }
! 4943       drive_type = inb_cmos(0x10);
.708:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4944       num_floppies = 0;
! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
xor	al,al
mov	-$19[bp],al
!BCC_EOS
! 4945       if (drive_type & 0xf0)
! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,#$F0
test	al,al
je  	.70A
.70B:
! 4946         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4947       if (drive_type & 0x0f)
.70A:
! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
test	al,al
je  	.70C
.70D:
! 4948         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4949       if (drive == 0)
.70C:
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.70E
.70F:
! 4950         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4951       else
! 4952         drive_type &= 0x0f;
jmp .710
.70E:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4953       BX = ((BX & 0x00ff) | ((0) << 8));
.710:
! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
mov	al,$10[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ah,ah
mov	$10[bp],ax
!BCC_EOS
! 4954       BX = ((BX & 0xff00) | (drive_type));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
or	al,-$18[bp]
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4955       AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4956       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4957       DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4958       switch (drive_type) {
mov	al,-$18[bp]
br 	.713
! 4959         case 0:
! 4960           CX = 0;
.714:
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4961           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4962           break;
br 	.711
!BCC_EOS
! 4963         case 1:
! 4964           CX = 0x2709;
.715:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 4965           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4966           break;
br 	.711
!BCC_EOS
! 4967         case 2:
! 4968           CX = 0x4f0f;
.716:
! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F0F
mov	$14[bp],ax
!BCC_EOS
! 4969           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4970           break;
br 	.711
!BCC_EOS
! 4971         case 3:
! 4972           CX = 0x4f09;
.717:
! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F09
mov	$14[bp],ax
!BCC_EOS
! 4973           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4974           break;
br 	.711
!BCC_EOS
! 4975         case 4:
! 4976           CX = 0x4f12;
.718:
! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F12
mov	$14[bp],ax
!BCC_EOS
! 4977           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4978           break;
br 	.711
!BCC_EOS
! 4979         case 5:
! 4980           CX = 0x4f24;
.719:
! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F24
mov	$14[bp],ax
!BCC_EOS
! 4981           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4982           break;
jmp .711
!BCC_EOS
! 4983         case 6:
! 4984           CX = 0x2708;
.71A:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 4985           DX = ((DX & 0x00ff) |
! 4985  ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4986           break;
jmp .711
!BCC_EOS
! 4987         case 7:
! 4988           CX = 0x2709;
.71B:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 4989           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4990           break;
jmp .711
!BCC_EOS
! 4991         case 8:
! 4992           CX = 0x2708;
.71C:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 4993           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4994           break;
jmp .711
!BCC_EOS
! 4995         default:
! 4996           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
.71D:
! Debug: list * char = .71E+0 (used reg = )
mov	bx,#.71E
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4997         }
! 4998 #asm
jmp .711
.713:
sub	al,*0
jb 	.71D
cmp	al,*8
ja  	.71F
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.720[bx]
.720:
.word	.714
.word	.715
.word	.716
.word	.717
.word	.718
.word	.719
.word	.71A
.word	.71B
.word	.71C
.71F:
jmp	.71D
.711:
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_diskette_function.DI+2[bp], ax
      mov _int13_diskette_function.ES+2[bp], cs
      pop bp
! 5005 endasm
!BCC_ENDASM
!BCC_EOS
! 5006       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 5007       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5008     case 0x15:
! 5009 ;
.721:
!BCC_EOS
! 5010       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5011       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.722
.723:
! 5012         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 5013         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5014         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5015         }
! 5016       drive_type = inb_cmos(0x10);
.722:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 5017       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.724
.725:
! 5018         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 5019       else
! 5020         drive_type &= 0x0f;
jmp .726
.724:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 5021       FLAGS &= 0xfffe;
.726:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 5022       if (drive_type==0) {
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.727
.728:
! 5023         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 5024         }
! 5025       else {
jmp .729
.727:
! 5026         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5027         }
! 5028       return;
.729:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5029     case 0x16:
! 5030 ;
.72A:
!BCC_EOS
! 5031       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5032       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.72B
.72C:
! 5033         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5034         set_diskette_ret_status(0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5035         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5036         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5037         }
! 5038       AX = ((AX & 0x00ff) | ((0x06) << 8));
.72B:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5039       set_diskette_ret_status(0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5040       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5041       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5042     case 0x17:
! 5043 ;
.72D:
!BCC_EOS
! 5044       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5045       set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5046       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5047       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5048     case 0x18:
! 5049 ;
.72E:
!BCC_EOS
! 5050       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5051       set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5052       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5053       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5054     default:
! 5055         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", ( AX >> 8 ));
.72F:
! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .730+0 (used reg = )
mov	bx,#.730
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5056         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5057         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5058         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5059         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5060     }
! 5061 }
jmp .6A1
.6A3:
sub	al,*0
jb 	.72F
cmp	al,*8
ja  	.731
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.732[bx]
.732:
.word	.6A4
.word	.6AC
.word	.6AF
.word	.6B0
.word	.6B1
.word	.6E7
.word	.72F
.word	.72F
.word	.707
.731:
sub	al,*$15
beq 	.721
sub	al,*1
beq 	.72A
sub	al,*1
beq 	.72D
sub	al,*1
beq 	.72E
jmp	.72F
.6A1:
..FFDC	=	-$20
mov	sp,bp
pop	bp
ret
! 5062  void
! Register BX used in function int13_diskette_function
! 5063 set_diskette_ret_status(value)
! 5064   Bit8u value;
export	_set_diskette_ret_status
_set_diskette_ret_status:
!BCC_EOS
! 5065 {
! 5066   write_byte(0x0040, 0x0041, value);
push	bp
mov	bp,sp
! Debug: list unsigned char value = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5067 }
pop	bp
ret
! 5068   void
! 5069 set_diskette_current_cyl(drive, cyl)
! 5070   Bit8u drive;
export	_set_diskette_current_cyl
_set_diskette_current_cyl:
!BCC_EOS
! 5071   Bit8u cyl;
!BCC_EOS
! 5072 {
! 5073   if (drive > 1)
push	bp
mov	bp,sp
! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jbe 	.733
.734:
! 5074     bios_printf((2 |
! 5074  4 | 1), "set_diskette_current_cyl(): drive > 1\n");
! Debug: list * char = .735+0 (used reg = )
mov	bx,#.735
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 5075   write_byte(0x0040, 0x0094+drive, cyl);
.733:
! Debug: list unsigned char cyl = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
! Debug: expression subtree swapping
mov	al,4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$94 (used reg = )
add	ax,#$94
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5076 }
pop	bp
ret
! 5077   void
! Register BX used in function set_diskette_current_cyl
! 5078 determine_floppy_media(drive)
! 5079   Bit16u drive;
export	_determine_floppy_media
_determine_floppy_media:
!BCC_EOS
! 5080 {
! 5081 }
ret
! 5082   void
! 5083 int17_function(regs, ds, iret_addr)
! 5084   pusha_regs_t regs;
export	_int17_function
_int17_function:
!BCC_EOS
! 5085   Bit16u ds;
!BCC_EOS
! 5086   iret_addr_t iret_addr;
!BCC_EOS
! 5087 {
! 5088   Bit16u addr,timeout;
!BCC_EOS
! 5089   Bit8u val8;
!BCC_EOS
! 5090 #asm
push	bp
mov	bp,sp
add	sp,*-6
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
  sti
! 5092 endasm
!BCC_ENDASM
!BCC_EOS
! 5093   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5094   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*3
bhis	.736
.739:
! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*3
bhis	.736
.738:
! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.736
.737:
! 5095     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$78 (used reg = )
add	ax,*$78
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 5096     if (regs.u.r8.ah == 0) {
! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
test	al,al
jne 	.73A
.73B:
! 5097       outb(addr, regs.u.r8.al);
! Debug: list unsigned char regs = [S+8+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5098       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5099       outb(addr+2, val8 | 0x01);
! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5100 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5102 endasm
!BCC_ENDASM
!BCC_EOS
! 5103       outb(addr+2, val8 & ~0x01);
! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5104       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
jmp .73D
.73E:
! 5105         timeout--;
! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5106       }
! 5107     }
.73D:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
and	al,*$40
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.73F
.740:
mov	ax,-4[bp]
test	ax,ax
jne	.73E
.73F:
.73C:
! 5108     if (regs.u.r8.ah == 1) {
.73A:
! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*1
jne 	.741
.742:
! 5109       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5110       outb(addr+2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5111 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5113 endasm
!BCC_ENDASM
!BCC_EOS
! 5114       outb(addr+2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5115     }
! 5116     val8 = inb(addr+1);
.741:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5117     regs.u.r8.ah = (val8 ^ 0x48);
! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	al,*$48
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 5118     if (!timeout) regs.u.r8.ah |= 0x01;
mov	ax,-4[bp]
test	ax,ax
jne 	.743
.744:
! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
or	al,*1
mov	$13[bp],al
!BCC_EOS
! 5119     iret_addr.flags.u.r8.flagsl &= 0xfe;
.743:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5120   } else {
jmp .745
.736:
! 5121     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5122   }
! 5123 }
.745:
mov	sp,bp
pop	bp
ret
! 5124 void
! 5125 int18_function(seq_nr)
! 5126 Bit16u seq_nr;
export	_int18_function
_int18_function:
!BCC_EOS
! 5127 {
! 5128   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5129   Bit16u bootdev;
!BCC_EOS
! 5130   Bit8u bootdrv;
!BCC_EOS
! 5131   Bit8u bootchk;
!BCC_EOS
! 5132   Bit16u bootseg;
!BCC_EOS
! 5133   Bit16u bootip;
!BCC_EOS
! 5134   Bit16u status;
!BCC_EOS
! 5135   Bit16u bootfirst;
!BCC_EOS
! 5136   ipl_entry_t e;
!BCC_EOS
! 5137   bootdev = inb_cmos(0x3d);
add	sp,*-$1C
! Debug: list int = const $3D (used reg = )
mov	ax,*$3D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5138   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
and	al,#$F0
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
or	ax,-4[bp]
mov	-4[bp],ax
!BCC_EOS
! 5139   bootdev >>= 4 * seq_nr;
! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,4[bp]
shl	ax,*1
shl	ax,*1
! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	bx,ax
mov	ax,-4[bp]
mov	cx,bx
shr	ax,cl
mov	-4[bp],ax
!BCC_EOS
! 5140   bootdev &= 0xf;
! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
mov	al,-4[bp]
and	al,*$F
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5141   bootfirst = read_word(ebda_seg, 0x0384);
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5142   if (bootfirst != 0xFFFF) {
! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,#$FFFF
je  	.746
.747:
! 5143     bootdev = bootfirst;
! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-$E[bp]
mov	-4[bp],ax
!BCC_EOS
! 5144     write_word(ebda_seg, 0x0384, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5145     write_word(ebda_seg, 0x0382, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $382 (used reg = )
mov	ax,#$382
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5146   } else if (bootdev == 0) {
jmp .748
.746:
! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
test	ax,ax
jne 	.749
.74A:
! 5147     bios_printf(2, "\nNo bootable device.\n");
! Debug: list * char = .74B+0 (used reg = )
mov	bx,#.74B
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5148     bios_printf(2, "Powering off in 30 seconds.\n");
! Debug: list * char = .74C+0 (used reg = )
mov	bx,#.74C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5149 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    sti
    mov cx, #0x01c9
    mov dx, #0xc380
    mov ah, #0x86 ;; INT 15/86: wait CX:DX usec.
    int #0x15
! 5155 endasm
!BCC_ENDASM
!BCC_EOS
! 5156     bios_printf(1, "");
! Debug: list * char = .74D+0 (used reg = )
mov	bx,#.74D
push	bx
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5157   }
! 5158   bootdev -= 1;
.749:
.748:
! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5159   if (get_boot_vector(bootdev, &e) == 0) {
! Debug: list * struct  e = S+$20-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
call	_get_boot_vector
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.74E
.74F:
! 5160     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list * char = .750+0 (used reg = )
mov	bx,#.750
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5161     ret
! 5161 urn;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5162   }
! 5163   print_boot_device(e.type, e.description);
.74E:
! Debug: list unsigned long e = [S+$20-$18] (used reg = )
push	-$14[bp]
push	-$16[bp]
! Debug: list unsigned short e = [S+$24-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_device+0 (used reg = )
call	_print_boot_device
add	sp,*6
!BCC_EOS
! 5164   switch(e.type) {
mov	ax,-$1E[bp]
br 	.753
! 5165   case 0x01:
! 5166   case 0x02:
.754:
! 5167     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
.755:
! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*2
jne 	.756
.757:
mov	al,#$80
jmp .758
.756:
xor	al,al
.758:
! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5168     bootseg = 0x07c0;
! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,#$7C0
mov	-8[bp],ax
!BCC_EOS
! 5169     status = 0;
! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 5170 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    push bp
    mov bp, sp
    push ax
    push bx
    push cx
    push dx
    mov dl, _int18_function.bootdrv + 2[bp]
    mov ax, _int18_function.bootseg + 2[bp]
    mov es, ax ;; segment
    xor bx, bx ;; offset
    mov ah, #0x02 ;; function 2, read diskette sector
    mov al, #0x01 ;; read 1 sector
    mov ch, #0x00 ;; track 0
    mov cl, #0x01 ;; sector 1
    mov dh, #0x00 ;; head 0
    int #0x13 ;; read sector
    jnc int19_load_done
    mov ax, #0x0001
    mov _int18_function.status + 2[bp], ax
int19_load_done:
    pop dx
    pop cx
    pop bx
    pop ax
    pop bp
! 5196 endasm
!BCC_ENDASM
!BCC_EOS
! 5197     if (status != 0) {
! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.759
.75A:
! 5198       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5199       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5200     }
! 5201     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
.759:
! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*1
jne 	.75C
.75D:
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
jne 	.75B
.75C:
! 5202       if (read_word(bootseg,0x1fe) != 0xaa55) {
! Debug: list int = const $1FE (used reg = )
mov	ax,#$1FE
push	ax
! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
push	-8[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
cmp	ax,#$AA55
je  	.75E
.75F:
! 5203         print_boot_failure(e.type, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5204         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5205       }
! 5206     }
.75E:
! 5207     bootip = (bootseg & 0x0fff) << 4;
.75B:
! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$FFF
! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5208     bootseg &= 0xf000;
! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$F000
mov	-8[bp],ax
!BCC_EOS
! 5209   break;
br 	.751
!BCC_EOS
! 5210   case 0x03:
! 5211     status = cdrom_boot();
.760:
! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
call	_cdrom_boot
! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5212     if ( (status & 0x00ff) !=0 ) {
! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
mov	al,-$C[bp]
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.761
.762:
! 5213       print_cdromboot_failure(status);
! Debug: list unsigned short status = [S+$20-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = print_cdromboot_failure+0 (used reg = )
call	_print_cdromboot_failure
inc	sp
inc	sp
!BCC_EOS
! 5214       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5215       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5216     }
! 5217     bootdrv = (Bit8u)(status>>8);
.761:
! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
mov	al,ah
xor	ah,ah
! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5218     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5219     bootip = (bootseg & 0x0fff) << 4;
! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$FFF
! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5220     bootseg &= 0xf000;
! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$F000
mov	-8[bp],ax
!BCC_EOS
! 5221     break;
jmp .751
!BCC_EOS
! 5222   case 0x80:
! 5223     bootseg = e.vector >> 16;
.763:
! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5224     bootip = e.vector & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-$1A[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5225     break;
jmp .751
!BCC_EOS
! 5226   default: return;
.764:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5227   }
! 5228   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
jmp .751
.753:
sub	ax,*1
beq 	.754
sub	ax,*1
beq 	.755
sub	ax,*1
beq 	.760
sub	ax,*$7D
je 	.763
jmp	.764
.751:
..FFDB	=	-$20
! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
push	-8[bp]
! Debug: list * char = .765+0 (used reg = )
mov	bx,#.765
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 5229 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    mov bp, sp
    push cs
    push #int18_handler
    ;; Build an iret stack frame that will take us to the boot vector.
    ;; iret pops ip, then cs, then flags, so push them in the opposite order.
    pushf
    mov ax, _int18_function.bootseg + 0[bp]
    push ax
    mov ax, _int18_function.bootip + 0[bp]
    push ax
    ;; Set the magic number in ax and the boot drive in dl.
    mov ax, #0xaa55
    mov dl, _int18_function.bootdrv + 0[bp]
    ;; Zero some of the other registers.
    xor bx, bx
    mov ds, bx
    mov es, bx
    mov bp, bx
    ;; Go!
    iret
! 5250 endasm
!BCC_ENDASM
!BCC_EOS
! 5251 }
mov	sp,bp
pop	bp
ret
! 5252   void
! Register BX used in function int18_function
! 5253 int1a_function(regs, ds, iret_addr)
! 5254   pusha_regs_t regs;
export	_int1a_function
_int1a_function:
!BCC_EOS
! 5255   Bit16u ds;
!BCC_EOS
! 5256   iret_addr_t iret_addr;
!BCC_EOS
! 5257 {
! 5258   Bit8u val8;
!BCC_EOS
! 5259   ;
push	bp
mov	bp,sp
dec	sp
dec	sp
!BCC_EOS
! 5260 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
  sti
! 5262 endasm
!BCC_ENDASM
!BCC_EOS
! 5263   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.768
! 5264     case 0:
! 5265 #asm
.769:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5267 endasm
!BCC_ENDASM
!BCC_EOS
! 5268       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
mov	ax,[$46E]
mov	$10[bp],ax
!BCC_EOS
! 5269       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
mov	ax,[$46C]
mov	$E[bp],ax
!BCC_EOS
! 5270       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,[$470]
mov	$12[bp],al
!BCC_EOS
! 5271       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5272 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5274 endasm
!BCC_ENDASM
!BCC_EOS
! 5275       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5276       break;
br 	.766
!BCC_EOS
! 5277     case 1:
! 5278 #asm
.76A:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5280 endasm
!BCC_ENDASM
!BCC_EOS
! 5281       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
mov	ax,$10[bp]
mov	[$46E],ax
!BCC_EOS
! 5282       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
mov	ax,$E[bp]
mov	[$46C],ax
!BCC_EOS
! 5283       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5284 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5286 endasm
!BCC_ENDASM
!BCC_EOS
! 5287       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5288       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5289       break;
br 	.766
!BCC_EOS
! 5290     case 2:
! 5291       if (rtc_updating()) {
.76B:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.76C
.76D:
! 5292         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5293         break;
br 	.766
!BCC_EOS
! 5294         }
! 5295       regs.u.r8.dh = inb_cmos(0x00);
.76C:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5296       regs.u.r8.cl = inb_cmos(0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5297       regs.u.r8.ch = inb_cmos(0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5298       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5299       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5300       regs.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5301       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5302       break;
br 	.766
!BCC_EOS
! 5303     case 3:
! 5304       if (rtc_updating()) {
.76E:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.76F
.770:
! 5305         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5306         }
! 5307       outb_cmos(0x00, regs.u.r8.dh);
.76F:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5308       outb_cmos(0x02, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5309       outb_cmos(0x04, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5310       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
! Debug: expression subtree swapping
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
or	al,*2
push	ax
! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
mov	al,$E[bp]
and	al,*1
! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
or	al,0+..FFDA[bp]
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5311       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5312       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5313       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5314       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5315       break;
br 	.766
!BCC_EOS
! 5316     case 4:
! 5317       regs.u.r8.ah = 0;
.771:
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5318       if (rtc_updating()) {
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.772
.773:
! 5319         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5320         break;
br 	.766
!BCC_EOS
! 5321         }
! 5322       regs.u.r8.cl = inb_cmos(0x09);
.772:
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5323       regs.u.r8.dh = inb_cmos(0x08);
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5324       regs.u.r8.dl = inb_cmos(0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5325       regs.u.r8.ch = inb_cmos(0x32);
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5326       regs.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5327       iret_addr.flags.u.r8.
! 5327 flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5328       break;
br 	.766
!BCC_EOS
! 5329     case 5:
! 5330       if (rtc_updating()) {
.774:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.775
.776:
! 5331         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5332         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5333         break;
br 	.766
!BCC_EOS
! 5334         }
! 5335       outb_cmos(0x09, regs.u.r8.cl);
.775:
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5336       outb_cmos(0x08, regs.u.r8.dh);
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5337       outb_cmos(0x07, regs.u.r8.dl);
! Debug: list unsigned char regs = [S+4+$C] (used reg = )
mov	al,$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5338       outb_cmos(0x32, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5339       val8 = inb_cmos(0x0b) & 0x7f;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
and	al,*$7F
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5340       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5341       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5342       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5343       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5344       break;
br 	.766
!BCC_EOS
! 5345     case 6:
! 5346       val8 = inb_cmos(0x0b);
.777:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5347       regs.u.r16.ax = 0;
! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 5348       if (val8 & 0x20) {
! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$20
test	al,al
je  	.778
.779:
! 5349         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5350         break;
br 	.766
!BCC_EOS
! 5351         }
! 5352       if (rtc_updating()) {
.778:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.77A
.77B:
! 5353         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5354         }
! 5355       outb_cmos(0x01, regs.u.r8.dh);
.77A:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5356       outb_cmos(0x03, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5357       outb_cmos(0x05, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5358       outb(0xa1, inb(0xa1) & 0xfe);
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5359       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
or	al,*$20
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5360       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5361       break;
br 	.766
!BCC_EOS
! 5362     case 7:
! 5363       val8 = inb_cmos(0x0b);
.77C:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5364       outb_cmos(0x0b, val8 & 0x57);
! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$57
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5365       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5366       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5367       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5368       break;
br 	.766
!BCC_EOS
! 5369     case 0xb1:
! 5370       if (regs.u.r8.bl == 0xff) {
.77D:
! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$FF
jne 	.77E
.77F:
! 5371         bios_printf(4, "PCI BIOS: PCI not present\n");
! Debug: list * char = .780+0 (used reg = )
mov	bx,#.780
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5372       } else if (regs.u.r8.bl == 0x81) {
br 	.781
.77E:
! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$81
jne 	.782
.783:
! 5373         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
! Debug: list unsigned char regs = [S+4+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list * char = .784+0 (used reg = )
mov	bx,#.784
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5374       } else if (regs.u.r8.bl == 0x83) {
jmp .785
.782:
! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$83
jne 	.786
.787:
! 5375         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
! Debug: list unsigned short regs = [S+4+$C] (used reg = )
push	$E[bp]
! Debug: list * char = .788+0 (used reg = )
mov	bx,#.788
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 5376       } else if (regs.u.r8.bl == 0x86) {
jmp .789
.786:
! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$86
jne 	.78A
.78B:
! 5377         if (regs.u.r8.al == 0x02) {
! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.78C
.78D:
! 5378           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
! Debug: list unsigned short regs = [S+4+4] (used reg = )
push	6[bp]
! Debug: list unsigned short regs = [S+6+$E] (used reg = )
push	$10[bp]
! Debug: list unsigned short regs = [S+8+$C] (used reg = )
push	$E[bp]
! Debug: list * char = .78E+0 (used reg = )
mov	bx,#.78E
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 5379         } else {
jmp .78F
.78C:
! 5380           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
! Debug: list unsigned short regs = [S+4+4] (used reg = )
push	6[bp]
! Debug: list unsigned short regs = [S+6+$C] (used reg = )
push	$E[bp]
! Debug: list unsigned char regs = [S+8+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list * char = .790+0 (used reg = )
mov	bx,#.790
push	bx
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*$A
!BCC_EOS
! 5381         }
! 5382       }
.78F:
! 5383       regs.u.r8.ah = regs.u.r8.bl;
.78A:
.789:
.785:
.781:
! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
mov	al,$C[bp]
mov	$13[bp],al
!BCC_EOS
! 5384       iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5385       break;
jmp .766
!BCC_EOS
! 5386     default:
! 5387       iret_addr.flags.u.r8.flagsl |= 0x01;
.791:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5388     }
! 5389 }
jmp .766
.768:
sub	al,*0
jb 	.791
cmp	al,*7
ja  	.792
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.793[bx]
.793:
.word	.769
.word	.76A
.word	.76B
.word	.76E
.word	.771
.word	.774
.word	.777
.word	.77C
.792:
sub	al,#$B1
beq 	.77D
jmp	.791
.766:
..FFDA	=	-4
mov	sp,bp
pop	bp
ret
! 5390   void
! Register BX used in function int1a_function
! 5391 int70_function(regs, ds, iret_addr)
! 5392   pusha_regs_t regs;
export	_int70_function
_int70_function:
!BCC_EOS
! 5393  
! 5393  Bit16u ds;
!BCC_EOS
! 5394   iret_addr_t iret_addr;
!BCC_EOS
! 5395 {
! 5396   Bit8u registerB = 0, registerC = 0;
push	bp
mov	bp,sp
dec	sp
! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
xor	al,al
mov	-1[bp],al
dec	sp
! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 5397   registerB = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5398   registerC = inb_cmos( 0xC );
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 5399   if( ( registerB & 0x60 ) != 0 ) {
! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$60
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.794
.795:
! 5400     if( ( registerC & 0x20 ) != 0 ) {
! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$20
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.796
.797:
! 5401 #asm
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
      sti
      int #0x4a
      cli
! 5405 endasm
!BCC_ENDASM
!BCC_EOS
! 5406     }
! 5407     if( ( registerC & 0x40 ) != 0 ) {
.796:
! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$40
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.798
.799:
! 5408       if( read_byte( 0x40, 0xA0 ) != 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.79A
.79B:
! 5409         Bit32u time, toggle;
!BCC_EOS
! 5410         time = read_dword( 0x40, 0x9C );
add	sp,*-8
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
mov	-6[bp],ax
mov	-4[bp],bx
!BCC_EOS
! 5411         if( time < 0x3D1 ) {
! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
lea	di,-6[bp]
call	lcmpul
jbe 	.79C
.79D:
! 5412           Bit16u segment, offset;
!BCC_EOS
! 5413           segment = read_word( 0x40, 0x98 );
add	sp,*-4
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5414           offset = read_word( 0x40, 0x9A );
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5415           write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5416           outb_cmos( 0xB, registerB & 0x37 );
! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
mov	al,-1[bp]
and	al,*$37
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5417           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5418         } else {
add	sp,*4
jmp .79E
.79C:
! 5419           time -= 0x3D1;
! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
push	bx
push	ax
mov	ax,-6[bp]
mov	bx,-4[bp]
lea	di,-$E[bp]
call	lsubul
mov	-6[bp],ax
mov	-4[bp],bx
add	sp,*4
!BCC_EOS
! 5420           write_dword( 0x40, 0x9C, time );
! Debug: list unsigned long time = [S+$C-8] (used reg = )
push	-4[bp]
push	-6[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 5421         }
! 5422       }
.79E:
add	sp,*8
! 5423     }
.79A:
! 5424   }
.798:
! 5425 #asm
.794:
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
  call eoi_both_pics
! 5427 endasm
!BCC_ENDASM
!BCC_EOS
! 5428 }
mov	sp,bp
pop	bp
ret
! 5429 #asm
!BCC_ASM
_int70_function.ds	set	$12
_int70_function.iret_addr	set	$14
_int70_function.regs	set	2
;------------------------------------------
;- INT74h : PS/2 mouse hardware interrupt -
;------------------------------------------
int74_handler:
  sti
  pusha
  push ds ;; save DS
  push #0x00 ;; placeholder for status
  push #0x00 ;; placeholder for X
  push #0x00 ;; placeholder for Y
  push #0x00 ;; placeholder for Z
  push #0x00 ;; placeholder for make_far_call boolean
  call _int74_function
  pop cx ;; remove make_far_call from stack
  jcxz int74_done
  ;; make far call to EBDA:0022
  push #0x00
  pop ds
  push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
  pop ds
  call far ptr[0x22]
int74_done:
  cli
  call eoi_both_pics
  add sp, #8 ;; pop status, x, y, z
  pop ds ;; restore DS
  popa
  iret
;; This will perform an IRET, but will retain value of current CF
;; by altering flags on stack. Better than RETF #02.
iret_modify_cf:
  jc carry_set
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xfe
  pop bp
  iret
carry_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x01
  pop bp
  iret
;----------------------
;- INT13h (relocated) -
;----------------------
;
; int13_relocated is a little bit messed up since I played with it
; I have to rewrite it:
; - call a function that detect which function to call
; - make all called C function get the same parameters list
;
int13_relocated:
  ;; check for an eltorito function
  cmp ah,#0x4a
  jb int13_not_eltorito
  cmp ah,#0x4d
  ja int13_not_eltorito
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_eltorito ;; ELDX not used
int13_not_eltorito:
  push ax
  push bx
  push cx
  push dx
  ;; check if emulation active
  call _cdemu_isactive
  cmp al,#0x00
  je int13_cdemu_inactive
  ;; check if access to the emulated drive
  call _cdemu_emulated_drive
  pop dx
  push dx
  cmp al,dl ;; int13 on emulated drive
  jne int13_nocdemu
  pop dx
  pop cx
  pop bx
  pop ax
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_cdemu ;; ELDX not used
int13_nocdemu:
  and dl,#0xE0 ;; mask to get device class, including cdroms
  cmp al,dl ;; al is 0x00 or 0x80
  jne int13_cdemu_inactive ;; inactive for device class
  pop dx
  pop cx
  pop bx
  pop ax
  push ax
  push cx
  push dx
  push bx
  dec dl ;; real drive is dl - 1
  jmp int13_legacy
int13_cdemu_inactive:
  pop dx
  pop cx
  pop bx
  pop ax
int13_noeltorito:
  push ax
  push cx
  push dx
  push bx
int13_legacy:
  push dx ;; push eltorito value of dx instead of sp
  push bp
  push si
  push di
  push es
  push ds
  push ss
  pop ds
  ;; now the 16-bit registers can be restored with:
  ;; pop ds; pop es; popa; iret
  ;; arguments passed to functions should be
  ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
  test dl, #0x80
  jnz int13_notfloppy
  push #int13_out
  jmp _int13_diskette_function
int13_notfloppy:
  cmp dl, #0xE0
  jb int13_notcdrom
  shr ebx, #16
  push bx
  call _int13_cdrom
  pop bx
  shl ebx, #16
  jmp int13_out
int13_notcdrom:
int13_disk:
  ;; int13_harddisk modifies high word of EAX
  shr eax, #16
  push ax
  call _int13_harddisk
  pop ax
  shl eax, #16
int13_out:
  pop ds
  pop es
  popa
  iret
;----------
;- INT18h -
;----------
int18_handler: ;; Boot Failure recovery: try the next device.
  ;; Reset SP and SS
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  ;; The first time we do this it will have been set to -1 so
  ;; we will start from device 0.
  xor ax, ax
  mov ds, ax
  mov bx, word ptr [0x40E] ;; EBDA segment
  mov ds, bx ;; Set segment
  mov bx, 0x0382 ;; BX is now the sequence number
  inc bx ;; ++
  mov 0x0382, bx ;; Write it back
  mov ds, ax ;; and reset the segment to zero.
  ;; Call the C code for the next boot device
  push bx
  call _int18_function
  ;; Boot failed: invoke the boot recovery function...
  int #0x18
;----------
;- INT19h -
;----------
int19_relocated: ;; Boot function, relocated
  ;;
  ;; *** Warning: INT 19h resets the whole machine ***
  ;;
  ;; Because PV drivers in HVM guests detach some of the emulated devices,
  ;; it is not safe to do a soft reboot by just dropping to real mode and
  ;; invoking INT 19h -- the boot drives might have disappeared!
  ;; If the user asks for a soft reboot, the only thing we can do is
  ;; reset the whole machine. When it comes back up, the normal BIOS
  ;; boot sequence will start, which is more or less the required behaviour.
  ;;
  ;; Reset SP and SS
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  call _machine_reset
;----------
;- INT1Ch -
;----------
int1c_handler: ;; User Timer Tick
  iret
;----------------------
;- POST: Floppy Drive -
;----------------------
floppy_drive_post:
  xor ax, ax
  mov ds, ax
  mov al, #0x00
  mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
  mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
  mov 0x0440, al ;; diskette motor timeout counter: not active
  mov 0x0441, al ;; diskette controller status return code
  mov 0x0442, al ;; disk & diskette controller status register 0
  mov 0x0443, al ;; diskette controller status register 1
  mov 0x0444, al ;; diskette controller status register 2
  mov 0x0445, al ;; diskette controller cylinder number
  mov 0x0446, al ;; diskette controller head number
  mov 0x0447, al ;; diskette controller sector number
  mov 0x0448, al ;; diskette controller bytes written
  mov 0x048b, al ;; diskette configuration data
  ;; -----------------------------------------------------------------
  ;; (048F) diskette controller information
  ;;
  mov al, #0x10 ;; get CMOS diskette drive type
  out 0x70, AL
  in AL, 0x71
  mov ah, al ;; save byte to AH
look_drive0:
  shr al, #4 ;; look at top 4 bits for drive 0
  jz f0_missing ;; jump if no drive0
  mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
  jmp look_drive1
f0_missing:
  mov bl, #0x00 ;; no drive0
look_drive1:
  mov al, ah ;; restore from AH
  and al, #0x0f ;; look at bottom 4 bits for drive 1
  jz f1_missing ;; jump if no drive1
  or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
f1_missing:
                   ;; leave high bits in BL zerod
  mov 0x048f, bl ;; put new val in BDA (diskette controller information)
  ;; -----------------------------------------------------------------
  mov al, #0x00
  mov 0x0490, al ;; diskette 0 media state
  mov 0x0491, al ;; diskette 1 media state
                   ;; diskette 0,1 operational starting state
                   ;; drive type has not been determined,
                   ;; has no changed detection line
  mov 0x0492, al
  mov 0x0493, al
  mov 0x0494, al ;; diskette 0 current cylinder
  mov 0x0495, al ;; diskette 1 current cylinder
  mov al, #0x02
  out #0x0a, al ;; clear DMA-1 channel 2 mask bit
  SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
  SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
  SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
  ret
;--------------------
;- POST: HARD DRIVE -
;--------------------
; relocated here because the primary POST area isnt big enough.
hard_drive_post:
  mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
  mov dx, #0x03f6
  out dx, al
  xor ax, ax
  mov ds, ax
  mov 0x0474, al
  mov 0x0477, al
  mov 0x048c, al
  mov 0x048d, al
  mov 0x048e, al
  mov al, #0x01
  mov 0x0475, al
  mov al, #0xc0
  mov 0x0476, al
  SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
  SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
  ;; INT 41h: hard disk 0 configuration pointer
  ;; INT 46h: hard disk 1 configuration pointer
  SET_INT_VECTOR(0x41, word ptr [0x40E], #0x003D)
  SET_INT_VECTOR(0x46, word ptr [0x40E], #0x004D)
  ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0xf0
  cmp al, #0xf0
  je post_d0_extended
  jmp check_for_hd1
post_d0_extended:
  mov al, #0x19
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d0_type47
  HALT(9038)
post_d0_type47:
  ;; CMOS purpose param table offset
  ;; 1b cylinders low 0
  ;; 1c cylinders high 1
  ;; 1d heads 2
  ;; 1e write pre-comp low 5
  ;; 1f write pre-comp high 6
  ;; 20 retries/bad map/heads>8 8
  ;; 21 landing zone low C
  ;; 22 landing zone high D
  ;; 23 sectors/track E
  xor ax, ax
  mov ds, ax
  mov ax, word ptr [0x40E] ;; EBDA segment
  mov ds, ax
  ;;; Filling EBDA table for hard disk 0.
  mov al, #0x1f
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x1e
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x05), ax ;; write precomp word
  mov al, #0x20
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x08), al ;; drive control byte
  mov al, #0x22
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x21
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x0C), ax ;; landing zone word
  mov al, #0x1c ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x1b
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x1d
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x23
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd0_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  mov (0x003d + 0x0E), dl ;; number of physical sectors
  jmp check_for_hd1
hd0_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x09), bx ;; number of physical cylinders
  mov (0x003d + 0x0b), cl ;; number of physical heads
  mov (0x003d + 0x04), dl ;; number of physical sectors
  mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd0_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd0_post_store_logical
hd0_post_above_2048:
  cmp bx, #4096
  jnbe hd0_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd0_post_store_logical
hd0_post_above_4096:
  cmp bx, #8192
  jnbe hd0_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd0_post_store_logical
hd0_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd0_post_store_logical:
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x003d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd0_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd0_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 0.
check_for_hd1:
  ;; is there really a second hard disk? if not, return now
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0x0f
  jnz post_d1_exists
  ret
post_d1_exists:
  ;; check that the hd type is really 0x0f.
  cmp al, #0x0f
  jz post_d1_extended
  HALT(9177)
post_d1_extended:
  ;; check that the extended type is 47 - user definable
  mov al, #0x1a
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d1_type47
  HALT(9185)
post_d1_type47:
  ;; Table for disk1.
  ;; CMOS purpose param table offset
  ;; 0x24 cylinders low 0
  ;; 0x25 cylinders high 1
  ;; 0x26 heads 2
  ;; 0x27 write pre-comp low 5
  ;; 0x28 write pre-comp high 6
  ;; 0x29 heads>8 8
  ;; 0x2a landing zone low C
  ;; 0x2b landing zone high D
  ;; 0x2c sectors/track E
;;; Fill EBDA table for hard disk 1.
  xor ax, ax
  mov ds, ax
  mov ax, word ptr [0x40E] ;; EBDA segment
  mov ds, ax
  mov al, #0x28
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x27
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x05), ax ;; write precomp word
  mov al, #0x29
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x08), al ;; drive control byte
  mov al, #0x2b
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x2a
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x0C), ax ;; landing zone word
  mov al, #0x25 ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x24
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x26
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x2c
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd1_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  mov (0x004d + 0x0E), dl ;; number of physical sectors
  ret
hd1_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x09), bx ;; number of physical cylinders
  mov (0x004d + 0x0b), cl ;; number of physical heads
  mov (0x004d + 0x04), dl ;; number of physical sectors
  mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd1_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd1_post_store_logical
hd1_post_above_2048:
  cmp bx, #4096
  jnbe hd1_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd1_post_store_logical
hd1_post_above_4096:
  cmp bx, #8192
  jnbe hd1_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd1_post_store_logical
hd1_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd1_post_store_logical:
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x004d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd1_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd1_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 1.
  ret
;--------------------
;- POST: EBDA segment
;--------------------
; relocated here because the primary POST area isnt big enough.
ebda_post:
  mov ax, #0x9FC0
  mov ds, ax
  mov byte ptr [0x0], #1
  xor ax, ax ; mov EBDA seg into 40E
  mov ds, ax
  mov word ptr [0x40E], #0x9FC0
  ret;;
;--------------------
;- POST: EOI + jmp via [0x40:67)
;--------------------
; relocated here because the primary POST area isnt big enough.
eoi_jmp_post:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
jmp_post_0x467:
  xor ax, ax
  mov ds, ax
  jmp far ptr [0x467]
iret_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  iret
retf_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  retf
s3_post:
  call _s3_resume
  mov bl, #0x00
  and ax, ax
  jz normal_post
  call _s3_resume_panic
;--------------------
eoi_both_pics:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
eoi_master_pic:
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
  ret
;--------------------
BcdToBin:
  ;; in: AL in BCD format
  ;; out: AL in binary format, AH will always be 0
  ;; trashes BX
  mov bl, al
  and bl, #0x0f ;; bl has low digit
  shr al, #4 ;; al has high digit
  mov bh, #10
  mul al, bh ;; multiply high digit by 10 (result in AX)
  add al, bl ;; then add low digit
  ret
;--------------------
timer_tick_post:
  ;; Setup the Timer Ticks Count (0x46C:dword) and
  ;; Timer Ticks Roller Flag (0x470:byte)
  ;; The Timer Ticks Count needs to be set according to
  ;; the current CMOS time, as if ticks have been occurring
  ;; at 18.2hz since midnight up to this point. Calculating
  ;; this is a little complicated. Here are the factors I gather
  ;; regarding this. 14,318,180 hz was the original clock speed,
  ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
  ;; at the time, or 4 to drive the CGA video adapter. The div3
  ;; source was divided again by 4 to feed a 1.193Mhz signal to
  ;; the timer. With a maximum 16bit timer count, this is again
  ;; divided down by 65536 to 18.2hz.
  ;;
  ;; 14,318,180 Hz clock
  ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
  ;; /4 = 1,193,181 Hz fed to timer
  ;; /65536 (maximum timer count) = 18.20650736 ticks/second
  ;; 1 second = 18.20650736 ticks
  ;; 1 minute = 1092.390442 ticks
  ;; 1 hour = 65543.42651 ticks
  ;;
  ;; Given the values in the CMOS clock, one could calculate
  ;; the number of ticks by the following:
  ;; ticks = (BcdToBin(seconds) * 18.206507) +
  ;; (BcdToBin(minutes) * 1092.3904)
  ;; (BcdToBin(hours) * 65543.427)
  ;; To get a little more accuracy, since Im using integer
  ;; arithmatic, I use:
  ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
  ;; (BcdToBin(minutes) * 10923904) / 10000 +
  ;; (BcdToBin(hours) * 65543427) / 1000
  ;; assuming DS=0000
  ;; get CMOS seconds
  xor eax, eax ;; clear EAX
  mov al, #0x00
  out #0x70, al
  in al, #0x71 ;; AL has CMOS seconds in BCD
  call BcdToBin ;; EAX now has seconds in binary
  mov edx, #18206507
  mul eax, edx
  mov ebx, #1000000
  xor edx, edx
  div eax, ebx
  mov ecx, eax ;; ECX will accumulate total ticks
  ;; get CMOS minutes
  xor eax, eax ;; clear EAX
  mov al, #0x02
  out #0x70, al
  in al, #0x71 ;; AL has CMOS minutes in BCD
  call BcdToBin ;; EAX now has minutes in binary
  mov edx, #10923904
  mul eax, edx
  mov ebx, #10000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  ;; get CMOS hours
  xor eax, eax ;; clear EAX
  mov al, #0x04
  out #0x70, al
  in al, #0x71 ;; AL has CMOS hours in BCD
  call BcdToBin ;; EAX now has hours in binary
  mov edx, #65543427
  mul eax, edx
  mov ebx, #1000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  mov 0x46C, ecx ;; Timer Ticks Count
  xor al, al
  mov 0x470, al ;; Timer Ticks Rollover Flag
  ret
;--------------------
int76_handler:
  ;; record completion in BIOS task complete flag
  push ax
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov 0x008E, #0xff
  call eoi_both_pics
  pop ds
  pop ax
  iret
;--------------------
use32 386
apm32_out_str:
  push eax
  push ebx
  mov ebx, eax
apm32_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm32_out_str2
  outb dx, al
  inc ebx
  jmp apm32_out_str1
apm32_out_str2:
  pop ebx
  pop eax
  ret
apm32_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm32_07_suspend_str:
  .ascii "Suspend"
  db 0
apm32_07_standby_str:
  .ascii "Standby"
  db 0
_apm32_entry:
  pushf
;-----------------
; APM interface disconnect
apm32_04:
  cmp al, #0x04
  jne apm32_05
  jmp apm32_ok
;-----------------
; APM cpu idle
apm32_05:
  cmp al, #0x05
  jne apm32_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apm32_ok
;-----------------
; APM Set Power State
apm32_07:
  cmp al, #0x07
  jne apm32_08
  cmp bx, #1
  jne apm32_ok
  cmp cx, #3
  je apm32_07_poweroff
  cmp cx, #2
  je apm32_07_suspend
  cmp cx, #1
  je apm32_07_standby
  jne apm32_ok
apm32_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm32_07_poweroff_str
  call apm32_out_str
apm32_07_1:
  hlt
  jmp apm32_07_1
apm32_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_suspend_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
apm32_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_standby_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
;-----------------
; APM Enable / Disable
apm32_08:
  cmp al, #0x08
  jne apm32_0a
  jmp apm32_ok
;-----------------
; Get Power Status
apm32_0a:
  cmp al, #0x0a
  jne apm32_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm32_ok
;-----------------
; Get PM Event
apm32_0b:
  cmp al, #0x0b
  jne apm32_0e
  mov ah, #0x80
  jmp apm32_error
;-----------------
; APM Driver Version
apm32_0e:
  cmp al, #0x0e
  jne apm32_0f
  mov ah, #1
  mov al, #2
  jmp apm32_ok
;-----------------
; APM Engage / Disengage
apm32_0f:
  cmp al, #0x0f
  jne apm32_10
  jmp apm32_ok
;-----------------
; APM Get Capabilities
apm32_10:
  cmp al, #0x10
  jne apm32_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm32_ok
;-----------------
apm32_ok:
  popf
  clc
  retf
apm32_unimplemented:
apm32_error:
  popf
  stc
  retf
use16 386
apm16_out_str:
  push eax
  push ebx
  mov ebx, eax
apm16_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm16_out_str2
  outb dx, al
  inc ebx
  jmp apm16_out_str1
apm16_out_str2:
  pop ebx
  pop eax
  ret
apm16_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm16_07_suspend_str:
  .ascii "Suspend"
  db 0
apm16_07_standby_str:
  .ascii "Standby"
  db 0
_apm16_entry:
  pushf
;-----------------
; APM interface disconnect
apm16_04:
  cmp al, #0x04
  jne apm16_05
  jmp apm16_ok
;-----------------
; APM cpu idle
apm16_05:
  cmp al, #0x05
  jne apm16_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apm16_ok
;-----------------
; APM Set Power State
apm16_07:
  cmp al, #0x07
  jne apm16_08
  cmp bx, #1
  jne apm16_ok
  cmp cx, #3
  je apm16_07_poweroff
  cmp cx, #2
  je apm16_07_suspend
  cmp cx, #1
  je apm16_07_standby
  jne apm16_ok
apm16_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm16_07_poweroff_str
  call apm16_out_str
apm16_07_1:
  hlt
  jmp apm16_07_1
apm16_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_suspend_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
apm16_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_standby_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
;-----------------
; APM Enable / Disable
apm16_08:
  cmp al, #0x08
  jne apm16_0a
  jmp apm16_ok
;-----------------
; Get Power Status
apm16_0a:
  cmp al, #0x0a
  jne apm16_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm16_ok
;-----------------
; Get PM Event
apm16_0b:
  cmp al, #0x0b
  jne apm16_0e
  mov ah, #0x80
  jmp apm16_error
;-----------------
; APM Driver Version
apm16_0e:
  cmp al, #0x0e
  jne apm16_0f
  mov ah, #1
  mov al, #2
  jmp apm16_ok
;-----------------
; APM Engage / Disengage
apm16_0f:
  cmp al, #0x0f
  jne apm16_10
  jmp apm16_ok
;-----------------
; APM Get Capabilities
apm16_10:
  cmp al, #0x10
  jne apm16_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm16_ok
;-----------------
apm16_ok:
  popf
  clc
  retf
apm16_unimplemented:
apm16_error:
  popf
  stc
  retf
apmreal_out_str:
  push eax
  push ebx
  mov ebx, eax
apmreal_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apmreal_out_str2
  outb dx, al
  inc ebx
  jmp apmreal_out_str1
apmreal_out_str2:
  pop ebx
  pop eax
  ret
apmreal_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apmreal_07_suspend_str:
  .ascii "Suspend"
  db 0
apmreal_07_standby_str:
  .ascii "Standby"
  db 0
  pushf
_apmreal_entry:
;-----------------
; APM installation check
apmreal_00:
  cmp al, #0x00
  jne apmreal_01
  mov ah, #1
  mov al, #2
  mov bh, #0x50
  mov bl, #0x4d
  mov cx, #0x3
  jmp apmreal_ok
;-----------------
; APM real mode interface connect
apmreal_01:
  cmp al, #0x01
  jne apmreal_02
  jmp apmreal_ok
;-----------------
; APM 16 bit protected mode interface connect
apmreal_02:
  cmp al, #0x02
  jne apmreal_03
  mov bx, #_apm16_entry
  mov ax, #0xf000
  mov si, #0xfff0
  mov cx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM 32 bit protected mode interface connect
apmreal_03:
  cmp al, #0x03
  jne apmreal_04
  mov ax, #0xf000
  mov ebx, #_apm32_entry
  mov cx, #0xf000
  mov esi, #0xfff0fff0
  mov dx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM interface disconnect
apmreal_04:
  cmp al, #0x04
  jne apmreal_05
  jmp apmreal_ok
;-----------------
; APM cpu idle
apmreal_05:
  cmp al, #0x05
  jne apmreal_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apmreal_ok
;-----------------
; APM Set Power State
apmreal_07:
  cmp al, #0x07
  jne apmreal_08
  cmp bx, #1
  jne apmreal_ok
  cmp cx, #3
  je apmreal_07_poweroff
  cmp cx, #2
  je apmreal_07_suspend
  cmp cx, #1
  je apmreal_07_standby
  jne apmreal_ok
apmreal_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apmreal_07_poweroff_str
  call apmreal_out_str
apmreal_07_1:
  hlt
  jmp apmreal_07_1
apmreal_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_suspend_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
apmreal_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_standby_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
;-----------------
; APM Enable / Disable
apmreal_08:
  cmp al, #0x08
  jne apmreal_0a
  jmp apmreal_ok
;-----------------
; Get Power Status
apmreal_0a:
  cmp al, #0x0a
  jne apmreal_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apmreal_ok
;-----------------
; Get PM Event
apmreal_0b:
  cmp al, #0x0b
  jne apmreal_0e
  mov ah, #0x80
  jmp apmreal_error
;-----------------
; APM Driver Version
apmreal_0e:
  cmp al, #0x0e
  jne apmreal_0f
  mov ah, #1
  mov al, #2
  jmp apmreal_ok
;-----------------
; APM Engage / Disengage
apmreal_0f:
  cmp al, #0x0f
  jne apmreal_10
  jmp apmreal_ok
;-----------------
; APM Get Capabilities
apmreal_10:
  cmp al, #0x10
  jne apmreal_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apmreal_ok
;-----------------
apmreal_ok:
  popf
  clc
  jmp iret_modify_cf
apmreal_unimplemented:
apmreal_error:
  popf
  stc
  jmp iret_modify_cf
    .align 16
gdt_base:
    .word 0,0
    .byte 0,0,0,0
gdt_entry_pm_32bit_cs:
    .word 0xffff, 0x0000
    .byte 0x00, 0x9b, 0xcf, 0x00
gdt_entry_pm_16bit_cs:
    .word 0xffff, 0x0000
    .byte 0xf0000 >> 16, 0x9b, 0x8f, 0x0
gdt_entry_pm_32bit_ds:
    .word 0xffff, 0x0000
    .byte 0x0, 0x93, 0xcf, 0x0
gdt_entry_pm_16bit_ds:
    .word 0xffff, 0x0000
    .byte 0x0, 0x93, 0x8f, 0x0
gdt_entry_end:
protmode_gdtdesc:
    .word (gdt_entry_end - gdt_base) - 1
    .long gdt_base | 0xf0000
realmode_gdtdesc:
    .word 0xffff
    .long 0x0
Upcall:
    ; Do an upcall into 32 bit space
    ;
    ; Input:
    ; bx: index of function to call
    ; Ouput:
    ; dx, ax: 32 bit result of call (even if 'void' is expected)
    ; Save caller state, stack frame offsets listed below
    pushf
    cli
    push ds
    push es
    push ss
    push esp
    ; Calculate protected-mode esp from ss:sp
    and esp, #0xffff
    xor eax, eax
    mov ax, ss
    shl eax, #4
    add esp, eax
    ; Switch to protected mode
    seg cs
    lgdt protmode_gdtdesc
    mov eax, cr0
    or al, #0x1 ; protected mode on
    mov cr0, eax
    jmpf DWORD (0xf0000|upcall1), #(gdt_entry_pm_32bit_cs - gdt_base)
upcall1:
    USE32
    mov ax, #(gdt_entry_pm_32bit_ds - gdt_base)
    mov ds, ax
    mov es, ax
    mov ss, ax
    ; Marshal arguments and call 32-bit function
    mov ecx, #32/4
upcall2:
    push 32 -4+14[esp]
    loop upcall2
    mov eax, [0x000EA000 + 20]
    call eax
    add esp, #32
    mov ecx, eax ; Result in ecx
    ; Restore real-mode stack pointer
    xor eax, eax
    mov ax, 4[esp]
    mov bx, ax ; Real-mode ss in bx
    shl eax, 4
    sub esp, eax
    ; Return to real mode
    jmpf upcall3, #(gdt_entry_pm_16bit_cs - gdt_base)
upcall3:
    USE16
    mov ax, #(gdt_entry_pm_16bit_ds - gdt_base)
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov eax, cr0
    and al, #0xfe ; protected mode off
    mov cr0, eax
    jmpf upcall4, #0xf0000>>4
upcall4:
    seg cs
    lgdt realmode_gdtdesc
    ; Restore real-mode ss
    mov ss, bx
    ; Convert result into dx:ax format
    mov eax, ecx
    ror eax, #16
    mov dx, ax
    ror eax, #16
    ; Restore caller state and return
    pop esp
    pop bx ; skip ss
    pop es
    pop ds
    popf
    ret
MACRO DoUpcall
    mov bx, #?1
    jmp Upcall
MEND
_TCGInterruptHandler: DoUpcall(0)
_tcpa_acpi_init: DoUpcall(1)
_tcpa_extend_acpi_log: DoUpcall(2)
_tcpa_calling_int19h: DoUpcall(3)
_tcpa_returned_int19h: DoUpcall(4)
_tcpa_add_event_separators: DoUpcall(5)
_tcpa_wake_event: DoUpcall(6)
_tcpa_add_bootdevice: DoUpcall(7)
_tcpa_start_option_rom_scan: DoUpcall(8)
_tcpa_option_rom: DoUpcall(9)
_tcpa_ipl: DoUpcall(10)
_tcpa_measure_post: DoUpcall(11)
_tcpa_initialize_tpm: DoUpcall(12)
_get_s3_waking_vector: DoUpcall(13)
_pmm: DoUpcall(14)
! 6691 endasm
!BCC_ENDASM
! 6692 #asm
!BCC_ASM
_int70_function.ds	set	$12
_int70_function.iret_addr	set	$14
_int70_function.regs	set	2
MACRO POST_MEASURE
 push word #0x000f
 push #?2
 push word #0x000f
 push #?1
 call _tcpa_measure_post
 add sp, #8
MEND
! 6701 endasm
!BCC_ENDASM
! 6702 void
! Register BX used in function int70_function
! 6703 tcpa_do_measure_POSTs()
! 6704 {
export	_tcpa_do_measure_POSTs
_tcpa_do_measure_POSTs:
! 6705 #asm
!BCC_ASM
 POST_MEASURE(post, nmi)
 POST_MEASURE(floppy_drive_post, hard_drive_post)
 POST_MEASURE(hard_drive_post, ebda_post)
 POST_MEASURE(ebda_post, eoi_jmp_post)
 POST_MEASURE(eoi_jmp_post, timer_tick_post)
 POST_MEASURE(timer_tick_post, int76_handler)
 ret
! 6713 endasm
!BCC_ENDASM
! 6714 }
ret
! 6715   void
! 6716 int1a_function32(regs, ES, DS, FLAGS)
! 6717   pushad_regs_t regs;
export	_int1a_function32
_int1a_function32:
!BCC_EOS
! 6718   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 6719 {
! 6720  Bit16u rc;
!BCC_EOS
! 6721  ;
push	bp
mov	bp,sp
dec	sp
dec	sp
!BCC_EOS
! 6722  switch (regs.u.r8.ah) {
mov	al,$21[bp]
br 	.7A1
! 6723  case 0xbb:
! 6724   if (regs.u.r8.al != 0 &&
.7A2:
! 6725       regs.u.r32.ebx != 0x41504354L) {
! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
mov	al,$20[bp]
test	al,al
je  	.7A3
.7A5:
! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$4354
mov	bx,#$4150
push	bx
push	ax
mov	ax,$14[bp]
mov	bx,$16[bp]
lea	di,-2+..FFD9[bp]
call	lcmpul
lea	sp,2+..FFD9[bp]
je  	.7A3
.7A4:
! 6726       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6727       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 6728   }
! 6729   switch(regs.u.r8.al) {
.7A3:
mov	al,$20[bp]
jmp .7A8
! 6730   case 0x00:
! 6731   case 0x01:
.7A9:
! 6732   case 0x02:
.7AA:
! 6733   case 0x03:
.7AB:
! 6734   case 0x04:
.7AC:
! 6735   case 0x05:
.7AD:
! 6736   case 0x06:
.7AE:
! 6737   case 0x07:
.7AF:
! 6738    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
.7B0:
! 6739                        ES, DS,
! 6740                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
! Debug: expression subtree swapping
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
xor	bx,bx
! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
mov	di,*4
call	lslul
push	bx
push	ax
! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
mov	ax,bp
add	ax,*$28
xor	bx,bx
! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFD9[bp]
call	laddul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short DS = [S+8+$24] (used reg = )
push	$26[bp]
! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
push	$24[bp]
! Debug: expression subtree swapping
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
xor	bx,bx
! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
mov	di,*4
call	lslul
push	bx
push	ax
! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
mov	ax,bp
add	ax,*4
xor	bx,bx
! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFD9[bp]
call	laddul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
call	_TCGInterruptHandler
mov	bx,dx
add	sp,*$C
!BCC_EOS
! 6741    break;
jmp .7A6
!BCC_EOS
! 6742   default:
! 6743    FLAGS |= 0x0001;
.7B1:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6744   }
! 6745   break;
jmp .7A6
.7A8:
sub	al,*0
jb 	.7B1
cmp	al,*7
ja  	.7B2
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.7B3[bx]
.7B3:
.word	.7A9
.word	.7AA
.word	.7AB
.word	.7AC
.word	.7AD
.word	.7AE
.word	.7AF
.word	.7B0
.7B2:
jmp	.7B1
.7A6:
jmp .79F
!BCC_EOS
! 6746  default:
! 6747   FLAGS |= 0x0001;
.7B4:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6748   break;
jmp .79F
!BCC_EOS
! 6749  }
! 6750  ;
jmp .79F
.7A1:
sub	al,#$BB
beq 	.7A2
jmp	.7B4
.79F:
..FFD9	=	-4
!BCC_EOS
! 6751 }
mov	sp,bp
pop	bp
ret
! 6752 #asm
!BCC_ASM
_int1a_function32.FLAGS	set	$26
_int1a_function32.DS	set	$24
_int1a_function32.ES	set	$22
_int1a_function32.regs	set	2
;--------------------
use32 386
.align 16
bios32_structure:
  db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
  dw bios32_entry_point, 0xf ;; 32 bit physical address
  db 0 ;; revision level
  ;; length in paragraphs and checksum stored in a word to prevent errors
  dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
  db 0,0,0,0,0 ;; reserved
.align 16
bios32_entry_point:
  pushfd
  cmp eax, #0x49435024 ;; "$PCI"
  jne unknown_service
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, #0x12378086 ;; i440FX PCI bridge
  jne unknown_service
  mov ebx, #0x000f0000
  mov ecx, #0
  mov edx, #pcibios_protected
  xor al, al
  jmp bios32_end
unknown_service:
  mov al, #0x80
bios32_end:
  popfd
  retf
.align 16
pcibios_protected:
  pushfd
  cli
  push esi
  push edi
  cmp al, #0x01 ;; installation check
  jne pci_pro_f02
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov al, #0x01
  jmp pci_pro_ok
pci_pro_f02: ;; find pci device
  cmp al, #0x02
  jne pci_pro_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_pro_devloop:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_pro_nextdev
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f03: ;; find class code
  cmp al, #0x03
  jne pci_pro_f08
  xor bx, bx
  mov di, #0x08
pci_pro_devloop2:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_pro_nextdev2
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop2
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_pro_f09
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop edx
  mov cl, al
  jmp pci_pro_ok
pci_pro_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_pro_f0a
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop edx
  mov cx, ax
  jmp pci_pro_ok
pci_pro_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_pro_f0b
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  in eax, dx
  pop edx
  mov ecx, eax
  jmp pci_pro_ok
pci_pro_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_pro_f0c
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop edx
  jmp pci_pro_ok
pci_pro_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_pro_f0d
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop edx
  jmp pci_pro_ok
pci_pro_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_pro_unknown
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop edx
  jmp pci_pro_ok
pci_pro_unknown:
  mov ah, #0x81
pci_pro_fail:
  pop edi
  pop esi
  popfd
  stc
  retf
pci_pro_ok:
  xor ah, ah
  pop edi
  pop esi
  popfd
  clc
  retf
pci_pro_select_reg:
  push edx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop edx
  ret
use16 386
pcibios_real:
  push eax
  push dx
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, #0x12378086 ;; i440FX PCI bridge
  je pci_present
  pop dx
  pop eax
  mov ah, #0xff
  stc
  ret
pci_present:
  pop dx
  pop eax
  cmp al, #0x01 ;; installation check
  jne pci_real_f02
  mov ax, #0x0001
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov edi, #0xf0000
  mov di, #pcibios_protected
  clc
  ret
pci_real_f02: ;; find pci device
  push esi
  push edi
  cmp al, #0x02
  jne pci_real_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_real_devloop:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_real_nextdev
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8602
  jmp pci_real_fail
pci_real_f03: ;; find class code
  cmp al, #0x03
  jne pci_real_f08
  xor bx, bx
  mov di, #0x08
pci_real_devloop2:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_real_nextdev2
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop2
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8603
  jmp pci_real_fail
pci_real_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_real_f09
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop dx
  mov cl, al
  jmp pci_real_ok
pci_real_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_real_f0a
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop dx
  mov cx, ax
  jmp pci_real_ok
pci_real_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_real_f0b
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  in eax, dx
  pop dx
  mov ecx, eax
  jmp pci_real_ok
pci_real_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_real_f0c
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop dx
  jmp pci_real_ok
pci_real_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_real_f0d
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop dx
  jmp pci_real_ok
pci_real_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_real_f0e
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop dx
  jmp pci_real_ok
pci_real_f0e: ;; get irq routing options
  cmp al, #0x0e
  jne pci_real_unknown
  SEG ES
  cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  jb pci_real_too_small
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  pushf
  push ds
  push es
  push cx
  push si
  push di
  cld
  mov si, #pci_routing_table_structure_start
  push cs
  pop ds
  SEG ES
  mov cx, [di+2]
  SEG ES
  mov es, [di+4]
  mov di, cx
  mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
  rep
      movsb
  pop di
  pop si
  pop cx
  pop es
  pop ds
  popf
  mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
  jmp pci_real_ok
pci_real_too_small:
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  mov ah, #0x89
  jmp pci_real_fail
pci_real_unknown:
  mov ah, #0x81
pci_real_fail:
  pop edi
  pop esi
  stc
  ret
pci_real_ok:
  xor ah, ah
  pop edi
  pop esi
  clc
  ret
pci_real_select_reg:
  push dx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop dx
  ret
.align 16
pci_routing_table_structure:
  db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
  db 0, 1 ;; version
  dw 32 + (6 * 16) ;; table size
  db 0 ;; PCI interrupt router bus
  db 0x08 ;; PCI interrupt router DevFunc
  dw 0x0000 ;; PCI exclusive IRQs
  dw 0x8086 ;; compatible PCI interrupt router vendor ID
  dw 0x122e ;; compatible PCI interrupt router device ID
  dw 0,0 ;; Miniport data
  db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
  db 0x37 ;; checksum
pci_routing_table_structure_start:
  ;; first slot entry PCI-to-ISA (embedded)
  db 0 ;; pci bus number
  db 0x08 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 0 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; second slot entry: 1st PCI slot
  db 0 ;; pci bus number
  db 0x10 ;; pci device number (bit 7-3)
  db 0x62 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x63 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x60 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x61 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 1 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; third slot entry: 2nd PCI slot
  db 0 ;; pci bus number
  db 0x18 ;; pci device number (bit 7-3)
  db 0x63 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x60 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x61 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x62 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 2 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 4th slot entry: 3rd PCI slot
  db 0 ;; pci bus number
  db 0x20 ;; pci device number (bit 7-3)
  db 0x60 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x61 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x62 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x63 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 3 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 5th slot entry: 4rd PCI slot
  db 0 ;; pci bus number
  db 0x28 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 4 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 6th slot entry: 5rd PCI slot
  db 0 ;; pci bus number
  db 0x30 ;; pci device number (bit 7-3)
  db 0x62 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x63 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x60 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x61 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 5 ;; physical slot (0 = embedded)
  db 0 ;; reserved
pci_routing_table_structure_end:
; according to POST Memory Manager Specification Version 1.01
.align 16
pmm_structure:
  db 0x24,0x50,0x4d,0x4d ;; "$PMM" signature
  db 0x01 ;; revision
  db 16 ;; length
  db (-((pmm_entry_point>>8)+pmm_entry_point+0x20f))&0xff;; checksum
  dw pmm_entry_point,0xf000 ;; far call entrypoint
  db 0,0,0,0,0 ;; reserved
pmm_entry_point:
  pushf
  pushad
; Calculate protected-mode address of PMM function args
  xor eax, eax
  mov ax, sp
  xor ebx, ebx
  mov bx, ss
  shl ebx, 4
  lea ebx, [eax+ebx+38] ;; ebx=(ss<<4)+sp+4(far call)+2(pushf)+32(pushad)
  push ebx
;
; Stack layout at this point:
;
; : +0x0 +0x2 +0x4 +0x6 +0x8 +0xa +0xc +0xe
; -----------------------------------------------------------------------
; sp : [&arg1 ][edi ][esi ][ebp ]
; sp+0x10: [esp ][ebx ][edx ][ecx ]
; sp+0x20: [eax ][flags ][ip ][cs ][arg1 ][arg2, ...
;
  call _pmm
  mov bx, sp
SEG SS
  mov [bx+0x20], ax
SEG SS
  mov [bx+0x18], dx
  pop ebx
  popad
  popf
  retf
; parallel port detection: base address in DX, index in BX, timeout in CL
detect_parport:
  push dx
  add dx, #2
  in al, dx
  and al, #0xdf ; clear input mode
  out dx, al
  pop dx
  mov al, #0xaa
  out dx, al
  in al, dx
  cmp al, #0xaa
  jne no_parport
  push bx
  shl bx, #1
  mov [bx+0x408], dx ; Parallel I/O address
  pop bx
  mov [bx+0x478], cl ; Parallel printer timeout
  inc bx
no_parport:
  ret
; serial port detection: base address in DX, index in BX, timeout in CL
detect_serial:
  push dx
  inc dx
  mov al, #0x02
  out dx, al
  in al, dx
  cmp al, #0x02
  jne no_serial
  inc dx
  in al, dx
  cmp al, #0x02
  jne no_serial
  dec dx
  xor al, al
  out dx, al
  pop dx
  push bx
  shl bx, #1
  mov [bx+0x400], dx ; Serial I/O address
  pop bx
  mov [bx+0x47c], cl ; Serial timeout
  inc bx
  ret
no_serial:
  pop dx
  ret
rom_checksum:
  pusha
  push ds
  xor ax, ax
  xor bx, bx
  xor cx, cx
  xor dx, dx
  mov ch, [2]
  shl cx, #1
  jnc checksum_loop
  jz checksum_loop
  xchg dx, cx
  dec cx
checksum_loop:
  add al, [bx]
  inc bx
  loop checksum_loop
  test dx, dx
  je checksum_out
  add al, [bx]
  mov cx, dx
  mov dx, ds
  add dh, #0x10
  mov ds, dx
  xor dx, dx
  xor bx, bx
  jmp checksum_loop
checksum_out:
  and al, #0xff
  pop ds
  popa
  ret
;; We need a copy of this string, but we are not actually a PnP BIOS,
;; so make sure it is *not* aligned, so OSes will not see it if they scan.
.align 16
  db 0
pnp_string:
  .ascii "$PnP"
rom_scan:
  ;; Scan for existence of valid expansion ROMS.
  ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
  ;; General ROM: from 0xC8000..0xE9FFF in 2k increments
  ;; System ROM: only 0xF0000
  ;;
  ;; Header:
  ;; Offset Value
  ;; 0 0x55
  ;; 1 0xAA
  ;; 2 ROM length in 512-byte blocks
  ;; 3 ROM initialization entry point (FAR CALL)
rom_scan_loop:
  push ax ;; Save AX
  mov ds, cx
  mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
  cmp [0], #0xAA55 ;; look for signature
  jne rom_scan_increment
  call rom_checksum
  jnz rom_scan_increment
  mov al, [2] ;; change increment to ROM length in 512-byte blocks
  ;; We want our increment in 512-byte quantities, rounded to
  ;; the nearest 2k quantity, since we only scan at 2k intervals.
  test al, #0x03
  jz block_count_rounded
  and al, #0xfc ;; needs rounding up
  add al, #0x04
block_count_rounded:
  push ax ;; Save AX
  push di ;; Save DI
  ;; Push addr of ROM entry point
  push cx ;; Push seg
  push #0x0003 ;; Push offset
  ;; Get the BDF into ax before invoking the option ROM
  mov bl, [2]
  mov al, bl
  shr al, #7
  cmp al, #1
  jne fetch_bdf
  mov ax, ds ;; Increment the DS since rom size larger than an segment
  add ax, #0x1000
  mov ds, ax
fetch_bdf:
  shl bx, #9
  xor ax, ax
  mov al, [bx]
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  ;; That should stop it grabbing INT 19h; we will use its BEV instead.
  mov bx, #0xf000
  mov es, bx
  lea di, pnp_string
  xor bx, bx ;; Restore DS back to 0000:
  mov ds, bx
  mov bp, sp ;; Call ROM init routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
  ;; to init all the ROMs and then go back and build an IPL table of
  ;; all the bootable devices, but we can get away with one pass.
  mov ds, cx ;; ROM base
  mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
  mov ax, [bx] ;; the offset of PnP expansion header, where...
  cmp ax, #0x5024 ;; we look for signature "$PnP"
  jne no_bev
  mov ax, 2[bx]
  cmp ax, #0x506e
  jne no_bev
  mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
  cmp ax, #0x0000
  je no_bcv
  ;; Option ROM has BCV. Run it now.
  push cx ;; Push seg
  push ax ;; Push offset
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  mov bx, #0xf000
  mov es, bx
  lea di, pnp_string
  mov bp, sp ;; Call ROM BCV routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  jmp no_bev
no_bcv:
  mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
  cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
  je no_bev
  ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
  mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
  xor bx, bx
  mov ds, bx
  mov bx, word ptr [0x40E] ;; EBDA segment
  mov ds, bx ;; Go to the segment where the IPL table lives
  mov bx, 0x0380 ;; Read the number of entries so far
  cmp bx, #8
  je no_bev ;; Get out if the table is full
  shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
  mov 0x0300 +0[bx], #0x80 ;; This entry is a BEV device
  mov 0x0300 +6[bx], cx ;; Build a far pointer from the segment...
  mov 0x0300 +4[bx], ax ;; and the offset
  cmp di, #0x0000
  je no_prod_str
  mov 0xA[bx], cx ;; Build a far pointer from the segment...
  mov 8[bx], di ;; and the offset
no_prod_str:
  shr bx, #0x4 ;; Turn the offset back into a count
  inc bx ;; We have one more entry now
  mov 0x0380, bx ;; Remember that.
no_bev:
  pop di ;; Restore DI
  pop ax ;; Restore AX
rom_scan_increment:
  shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
                ;; because the segment selector is shifted left 4 bits.
  add cx, ax
  pop ax ;; Restore AX
  cmp cx, ax
  jbe rom_scan_loop
  xor ax, ax ;; Restore DS back to 0000:
  mov ds, ax
  ret
; Copy the SMBIOS entry point from where hvmloader left it.
; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
; but the tables themselves can be elsewhere.
smbios_init:
  push ax
  push cx
  push es
  push ds
  push di
  push si
  mov cx, #0x001f ; 0x1f bytes to copy
  mov ax, #0xf000
  mov es, ax ; destination segment is 0xf0000
  mov di, #smbios_entry_point ; destination offset
  mov ax, #(0x000EB000>>4)
  mov ds, ax
  mov si, #(0x000EB000&15)
  cld
  rep
    movsb
  pop si
  pop di
  pop ds
  pop es
  pop cx
  pop ax
  ret
post_init_pic:
  mov al, #0x11 ; send initialisation commands
  out 0x20, al
  out 0xa0, al
  mov al, #0x08
  out 0x21, al
  mov al, #0x70
  out 0xa1, al
  mov al, #0x04
  out 0x21, al
  mov al, #0x02
  out 0xa1, al
  mov al, #0x01
  out 0x21, al
  out 0xa1, al
  mov al, #0xb8
  out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
  mov al, #0x8f
  out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
  ret
  .align 16
smbios_entry_point:
  db 0,0,0,0,0,0,0,0 ; 8 bytes
  db 0,0,0,0,0,0,0,0 ; 16 bytes
  db 0,0,0,0,0,0,0,0 ; 24 bytes
  db 0,0,0,0,0,0,0 ; 31 bytes
;; the following area can be used to write dynamically generated tables
  .align 16
bios_table_area_start:
  db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
  dd bios_table_area_end - bios_table_area_start
;--------
;- POST -
;--------
.org 0xe05b ; POST Entry Point
post:
  xor ax, ax
  ;; first reset the DMA controllers
  out 0x0d,al
  out 0xda,al
  ;; then initialize the DMA controllers
  mov al, #0xC0
  out 0xD6, al ; cascade mode of channel 4 enabled
  mov al, #0x00
  out 0xD4, al ; unmask channel 4
  ;; Examine CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL
  in AL, 0x71
  ;; backup status
  mov bl, al
  ;; Reset CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL ; select CMOS register Fh
  mov AL, #0x00
  out 0x71, AL ; set shutdown action to normal
  ;; Examine CMOS shutdown status.
  mov al, bl
  ;; 0x00, 0x09, 0x0D+ = normal startup
  cmp AL, #0x00
  jz normal_post
  cmp AL, #0x0d
  jae normal_post
  cmp AL, #0x09
  je normal_post
  ;; 0x05 = eoi + jmp via [0x40:0x67] jump
  cmp al, #0x05
  je eoi_jmp_post
  ;; 0x0A = jmp via [0x40:0x67] jump
  cmp al, #0x0a
  je jmp_post_0x467
  ;; 0x0B = iret via [0x40:0x67]
  cmp al, #0x0b
  je iret_post_0x467
  ;; 0x0C = retf via [0x40:0x67]
  cmp al, #0x0c
  je retf_post_0x467
  ;; Examine CMOS shutdown status.
  ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08 = Unimplemented shutdown status.
  push bx
  call _shutdown_status_panic
normal_post:
  ; case 0: normal startup
  cli
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  ;; Save shutdown status
  mov 0x04b0, bl
  cmp bl, #0xfe
  jz s3_post
  ;; zero out BIOS data area (40:00..40:ff)
  mov es, ax
  mov cx, #0x0080 ;; 128 words
  mov di, #0x0400
  cld
  rep
    stosw
  call _log_bios_start
  ;; set all interrupts to default handler
  xor bx, bx ;; offset index
  mov cx, #0x0100 ;; counter (256 interrupts)
  mov ax, #dummy_iret_handler
  mov dx, #0xF000
post_default_ints:
  mov [bx], ax
  add bx, #2
  mov [bx], dx
  add bx, #2
  loop post_default_ints
  ;; set vector 0x79 to zero
  ;; this is used by 'gardian angel' protection system
  SET_INT_VECTOR(0x79, #0, #0)
  ;; base memory in K 40:13 (word)
  mov ax, #(640 - 1)
  mov 0x0413, ax
  ;; Manufacturing Test 40:12
  ;; zerod out above
  ;; Warm Boot Flag 0040:0072
  ;; value of 1234h = skip memory checks
  ;; zerod out above
  ;; Printer Services vector
  SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
  ;; Bootstrap failure vector
  SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
  ;; Bootstrap Loader vector
  SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
  ;; User Timer Tick vector
  SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
  ;; Memory Size Check vector
  SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
  ;; Equipment Configuration Check vector
  SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
  ;; System Services
  SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
  ;; EBDA setup
  call ebda_post
  ;; PIT setup
  SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
  ;; int 1C already points at dummy_iret_handler (above)
  mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
  out 0x43, al
  mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
  out 0x40, al ; lsb
  mov al, #0xe9
  out 0x40, al ; msb
  ;; Keyboard
  SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
  SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
  xor ax, ax
  mov ds, ax
  mov 0x0417, al
  mov 0x0418, al
  mov 0x0419, al
  mov 0x0471, al
  mov 0x0497, al
  mov al, #0x10
  mov 0x0496, al
  mov bx, #0x001E
  mov 0x041A, bx
  mov 0x041C, bx
  mov bx, #0x001E
  mov 0x0480, bx
  mov bx, #0x003E
  mov 0x0482, bx
  call _keyboard_init
  ;; mov CMOS Equipment Byte to BDA Equipment Word
  mov ax, 0x0410
  mov al, #0x14
  out 0x70, al
  in al, 0x71
  mov 0x0410, ax
  ;; Parallel setup
  SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
  xor ax, ax
  mov ds, ax
  xor bx, bx
  mov cl, #0x14 ; timeout value
  mov dx, #0x378 ; Parallel I/O address, port 1
  call detect_parport
  mov dx, #0x278 ; Parallel I/O address, port 2
  call detect_parport
  shl bx, #0x0e
  mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
  and ax, #0x3fff
  or ax, bx ; set number of parallel ports
  mov 0x410, ax
  ;; Serial setup
  SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
  xor bx, bx
  mov cl, #0x0a ; timeout value
  mov dx, #0x03f8 ; Serial I/O address, port 1
  call detect_serial
  mov dx, #0x02f8 ; Serial I/O address, port 2
  call detect_serial
  mov dx, #0x03e8 ; Serial I/O address, port 3
  call detect_serial
  mov dx, #0x02e8 ; Serial I/O address, port 4
  call detect_serial
  shl bx, #0x09
  mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
  and ax, #0xf1ff
  or ax, bx ; set number of serial port
  mov 0x410, ax
  ;; CMOS RTC
  SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
  SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
  ;; BIOS DATA AREA 0x4CE ???
  call timer_tick_post
  ;; PS/2 mouse setup
  SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
  ;; IRQ13 (FPU exception) setup
  SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
  ;; Video setup
  SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
  ;; PIC
  call post_init_pic
  mov cx, #0xc000 ;; init vga bios
  mov ax, #0xc780
  call rom_scan
  call _print_bios_banner
  ;;
  ;; Floppy setup
  ;;
  call floppy_drive_post
  ;;
  ;; Hard Drive setup
  ;;
  call hard_drive_post
  ;;
  ;; ATA/ATAPI driver setup
  ;;
  call _ata_init
  call _ata_detect
  ;;
  ;;
  ;; eltorito floppy/harddisk emulation from cd
  ;;
  call _cdemu_init
  ;;
  call _enable_rom_write_access
  call _clobber_entry_point
  call _fixup_base_mem_in_k
  call smbios_init
  call _init_boot_vectors
  mov cx, #(0x000C8000 >> 4) ;; init option roms
  mov ax, #(0x000EA000 >> 4)
  call rom_scan
  call _disable_rom_write_access
  call _interactive_bootkey
  sti ;; enable interrupts
  ;; Start the boot sequence. See the comments in int19_relocated
  ;; for why we use INT 18h instead of INT 19h here.
  int #0x18
.org 0xe2c3 ; NMI Handler Entry Point
nmi:
  ;; FIXME the NMI handler should not panic
  ;; but iret when called from int75 (fpu exception)
  call _nmi_handler_msg
  iret
int75_handler:
  out 0xf0, al
  call eoi_both_pics
  int 2
  iret
;-------------------------------------------
;- INT 13h Fixed Disk Services Entry Point -
;-------------------------------------------
.org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
int13_handler:
  jmp int13_relocated
.org 0xe401 ; Fixed Disk Parameter Table
;----------
;- INT19h -
;----------
.org 0xe6f2 ; INT 19h Boot Load Service Entry Point
int19_handler:
  jmp int19_relocated
;-------------------------------------------
;- System BIOS Configuration Data Table
;-------------------------------------------
.org 0xe6f5
db 0x08 ; Table size (bytes) -Lo
db 0x00 ; Table size (bytes) -Hi
db 0xFC
db 0x00
db 1
; Feature byte 1
; b7: 1=DMA channel 3 used by hard disk
; b6: 1=2 interrupt controllers present
; b5: 1=RTC present
; b4: 1=BIOS calls int 15h/4Fh every key
; b3: 1=wait for extern event supported (Int 15h/41h)
; b2: 1=extended BIOS data area used
; b1: 0=AT or ESDI bus, 1=MicroChannel
; b0: 1=Dual bus (MicroChannel + ISA)
db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
; Feature byte 2
; b7: 1=32-bit DMA supported
; b6: 1=int16h, function 9 supported
; b5: 1=int15h/C6h (get POS data) supported
; b4: 1=int15h/C7h (get mem map info) supported
; b3: 1=int15h/C8h (en/dis CPU) supported
; b2: 1=non-8042 kb controller
; b1: 1=data streaming supported
; b0: reserved
db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
; Feature byte 3
; b7: not used
; b6: reserved
; b5: reserved
; b4: POST supports ROM-to-RAM enable/disable
; b3: SCSI on system board
; b2: info panel installed
; b1: Initial Machine Load (IML) system - BIOS on disk
; b0: SCSI supported in IML
db 0x00
; Feature byte 4
; b7: IBM private
; b6: EEPROM present
; b5-3: ABIOS presence (011 = not supported)
; b2: private
; b1: memory split above 16Mb supported
; b0: POSTEXT directly supported by POST
db 0x00
; Feature byte 5 (IBM)
; b1: enhanced mouse
; b0: flash EPROM
db 0x00
.org 0xe729 ; Baud Rate Generator Table
;----------
;- INT14h -
;----------
.org 0xe739 ; INT 14h Serial Communications Service Entry Point
int14_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int14_function
  popa
  pop ds
  iret
;----------------------------------------
;- INT 16h Keyboard Service Entry Point -
;----------------------------------------
.org 0xe82e
int16_handler:
  sti
  push ds
  pushf
  pusha
  cmp ah, #0x00
  je int16_F00
  cmp ah, #0x10
  je int16_F00
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  jz int16_zero_set
int16_zero_clear:
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xbf
  pop bp
  iret
int16_zero_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x40
  pop bp
  iret
int16_F00:
  mov bx, #0x0040
  mov ds, bx
int16_wait_for_key:
  cli
  mov bx, 0x001a
  cmp bx, 0x001c
  jne int16_key_found
  sti
  hlt
  jmp int16_wait_for_key
int16_key_found:
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  iret
;-------------------------------------------------
;- INT09h : Keyboard Hardware Service Entry Point -
;-------------------------------------------------
.org 0xe987
int09_handler:
  cli
  push ax
  mov al, #0xAD ;;disable keyboard
  out #0x64, al
  mov al, #0x0B
  out #0x20, al
  in al, #0x20
  and al, #0x02
  jz int09_finish
  in al, #0x60 ;;read key from keyboard controller
  sti
  push ds
  pusha
  mov ah, #0x4f ;; allow for keyboard intercept
  stc
  int #0x15
  jnc int09_done
  ;; check for extended key
  cmp al, #0xe0
  jne int09_check_pause
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x02
  or al, #0x02
  mov BYTE [0x496], al
  jmp int09_done
int09_check_pause: ;; check for pause key
  cmp al, #0xe1
  jne int09_process_key
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x01
  or al, #0x01
  mov BYTE [0x496], al
  jmp int09_done
int09_process_key:
  mov bx, #0xf000
  mov ds, bx
  call _int09_function
int09_done:
  popa
  pop ds
  cli
  call eoi_master_pic
int09_finish:
  mov al, #0xAE ;;enable keyboard
  out #0x64, al
  pop ax
  iret
;----------------------------------------
;- INT 13h Diskette Service Entry Point -
;----------------------------------------
.org 0xec59
int13_diskette:
  jmp int13_noeltorito
;---------------------------------------------
;- INT 0Eh Diskette Hardware ISR Entry Point -
;---------------------------------------------
.org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
int0e_handler:
  push ax
  push dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_normal
  mov dx, #0x03f5
  mov al, #0x08 ; sense interrupt status
  out dx, al
int0e_loop1:
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  jne int0e_loop1
int0e_loop2:
  mov dx, #0x03f5
  in al, dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_loop2
int0e_normal:
  push ds
  xor ax, ax ;; segment 0000
  mov ds, ax
  call eoi_master_pic
  mov al, 0x043e
  or al, #0x80 ;; diskette interrupt has occurred
  mov 0x043e, al
  pop ds
  pop dx
  pop ax
  iret
.org 0xefc7 ; Diskette Controller Parameter Table
diskette_param_table:
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
;----------------------------------------
;- INT17h : Printer Service Entry Point -
;----------------------------------------
.org 0xefd2
int17_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int17_function
  popa
  pop ds
  iret
diskette_param_table2:
;; New diskette parameter table adding 3 parameters from IBM
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
db 79 ;; maximum track
db 0 ;; data transfer rate
db 4 ;; drive type in cmos
.org 0xf045 ; INT 10 Functions 0-Fh Entry Point
  HALT(11468)
  iret
;----------
;- INT10h -
;----------
.org 0xf065 ; INT 10h Video Support Service Entry Point
int10_handler:
  ;; dont do anything, since the VGA BIOS handles int10h requests
  iret
.org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
;----------
;- INT12h -
;----------
.org 0xf841 ; INT 12h Memory Size Service Entry Point
; ??? different for Pentium (machine check)?
int12_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0013
  pop ds
  iret
;----------
;- INT11h -
;----------
.org 0xf84d ; INT 11h Equipment List Service Entry Point
int11_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0010
  pop ds
  iret
;----------
;- INT15h -
;----------
.org 0xf859 ; INT 15h System Services Entry Point
int15_handler:
  pushf
  cmp ah, #0x53
  je apm_call
  push ds
  push es
  cmp ah, #0x86
  je int15_handler32
  cmp ah, #0xE8
  je int15_handler32
  pusha
  cmp ah, #0xC2
  je int15_handler_mouse
  call _int15_function
int15_handler_mouse_ret:
  popa
int15_handler32_ret:
  pop es
  pop ds
  popf
  jmp iret_modify_cf
apm_call:
  jmp _apmreal_entry
int15_handler_mouse:
  call _int15_function_mouse
  jmp int15_handler_mouse_ret
int15_handler32:
  pushad
  call _int15_function32
  popad
  jmp int15_handler32_ret
;; Protected mode IDT descriptor
;;
;; I just make the limit 0, so the machine will shutdown
;; if an exception occurs during protected mode memory
;; transfers.
;;
;; Set base to f0000 to correspond to beginning of BIOS,
;; in case I actually define an IDT later
;; Set limit to 0
pmode_IDT_info:
dw 0x0000 ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x0f ;; base 23:16
;; Real mode IDT descriptor
;;
;; Set to typical real-mode values.
;; base = 000000
;; limit = 03ff
rmode_IDT_info:
dw 0x03ff ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x00 ;; base 23:16
;----------
;- INT1Ah -
;----------
.org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
int1a_handler:
  cmp ah, #0xb1
  jne int1a_normal
  call pcibios_real
  jc pcibios_error
  retf 2
pcibios_error:
  mov bl, ah
  mov ah, #0xb1
  push ds
  pusha
  mov ax, ss ; set readable descriptor to ds, for calling pcibios
  mov ds, ax ; on 16bit protected mode.
  jmp int1a_callfunction
int1a_normal:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
int1a_callfunction:
  call _int1a_function
  popa
  pop ds
  iret
;;
;; int70h: IRQ8 - CMOS RTC
;;
int70_handler:
  push ds
  pushad
  xor ax, ax
  mov ds, ax
  call _int70_function
  popad
  pop ds
  iret
;---------
;- INT08 -
;---------
.org 0xfea5 ; INT 08h System Timer ISR Entry Point
int08_handler:
  sti
  push eax
  push ds
  xor ax, ax
  mov ds, ax
  ;; time to turn off drive(s)?
  mov al,0x0440
  or al,al
  jz int08_floppy_off
  dec al
  mov 0x0440,al
  jnz int08_floppy_off
  ;; turn motor(s) off
  push dx
  mov dx,#0x03f2
  in al,dx
  and al,#0xcf
  out dx,al
  pop dx
int08_floppy_off:
  mov eax, 0x046c ;; get ticks dword
  inc eax
  ;; compare eax to one days worth of timer ticks at 18.2 hz
  cmp eax, #0x001800B0
  jb int08_store_ticks
  ;; there has been a midnight rollover at this point
  xor eax, eax ;; zero out counter
  inc BYTE 0x0470 ;; increment rollover flag
int08_store_ticks:
  mov 0x046c, eax ;; store new ticks dword
  ;; chain to user timer tick INT #0x1c
  int #0x1c
  cli
  call eoi_master_pic
  pop ds
  pop eax
  iret
.org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
.org 0xff00
.ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
;------------------------------------------------
;- IRET Instruction for Dummy Interrupt Handler -
;------------------------------------------------
.org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
dummy_iret_handler:
  iret
.org 0xff54 ; INT 05h Print Screen Service Entry Point
  HALT(11702)
  iret
.org 0xfff0 ; Power-up Entry Point
   jmp 0xf000:post
.org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
.ascii "06/23/99"
.org 0xfffe ; System Model ID
db 0xFC
db 0x00 ; filler
.org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
! 8257 endasm
!BCC_ENDASM
! 8258 static Bit8u vgafont8[128*8]=
! Register BX used in function int1a_function32
! 8259 {
.data
_vgafont8:
! 8260  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8261  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
.byte	$7E
.byte	$81
.byte	$A5
.byte	$81
.byte	$BD
.byte	$99
.byte	$81
.byte	$7E
! 8262  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
.byte	$7E
.byte	$FF
.byte	$DB
.byte	$FF
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$7E
! 8263  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$6C
.byte	$FE
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8264  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8265  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$38
.byte	$7C
.byte	$38
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8266  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$10
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8267  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	0
.byte	$18
.byte	$3C
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8268  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
.byte	$FF
.byte	$FF
.byte	$E7
.byte	$C3
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$FF
! 8269  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
.byte	0
.byte	$3C
.byte	$66
.byte	$42
.byte	$42
.byte	$66
.byte	$3C
.byte	0
! 8270  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
.byte	$FF
.byte	$C3
.byte	$99
.byte	$BD
.byte	$BD
.byte	$99
.byte	$C3
.byte	$FF
! 8271  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
.byte	$F
.byte	7
.byte	$F
.byte	$7D
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
! 8272  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
.byte	$3C
.byte	$66
.byte	$66
.byte	$66
.byte	$3C
.byte	$18
.byte	$7E
.byte	$18
! 8273  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
.byte	$3F
.byte	$33
.byte	$3F
.byte	$30
.byte	$30
.byte	$70
.byte	$F0
.byte	$E0
! 8274  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 
.byte	$7F
.byte	$63
.byte	$7F
.byte	$63
.byte	$63
.byte	$67
! 8274 0xe6, 0xc0,
.byte	$E6
.byte	$C0
! 8275  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
.byte	$99
.byte	$5A
.byte	$3C
.byte	$E7
.byte	$E7
.byte	$3C
.byte	$5A
.byte	$99
! 8276  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
.byte	$80
.byte	$E0
.byte	$F8
.byte	$FE
.byte	$F8
.byte	$E0
.byte	$80
.byte	0
! 8277  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
.byte	2
.byte	$E
.byte	$3E
.byte	$FE
.byte	$3E
.byte	$E
.byte	2
.byte	0
! 8278  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
! 8279  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	0
.byte	$66
.byte	0
! 8280  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
.byte	$7F
.byte	$DB
.byte	$DB
.byte	$7B
.byte	$1B
.byte	$1B
.byte	$1B
.byte	0
! 8281  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
.byte	$3E
.byte	$63
.byte	$38
.byte	$6C
.byte	$6C
.byte	$38
.byte	$CC
.byte	$78
! 8282  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$7E
.byte	$7E
.byte	$7E
.byte	0
! 8283  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	$FF
! 8284  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8285  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
! 8286  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$C
.byte	$FE
.byte	$C
.byte	$18
.byte	0
.byte	0
! 8287  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$60
.byte	$FE
.byte	$60
.byte	$30
.byte	0
.byte	0
! 8288  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
.byte	0
.byte	0
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$FE
.byte	0
.byte	0
! 8289  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
.byte	0
.byte	$24
.byte	$66
.byte	$FF
.byte	$66
.byte	$24
.byte	0
.byte	0
! 8290  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$3C
.byte	$7E
.byte	$FF
.byte	$FF
.byte	0
.byte	0
! 8291  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	$FF
.byte	$FF
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8292  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8293  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
.byte	$30
.byte	$78
.byte	$78
.byte	$30
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8294  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$6C
.byte	$6C
.byte	$6C
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8295  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
.byte	$6C
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$6C
.byte	0
! 8296  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
.byte	$30
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	$30
.byte	0
! 8297  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
.byte	0
.byte	$C6
.byte	$CC
.byte	$18
.byte	$30
.byte	$66
.byte	$C6
.byte	0
! 8298  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
.byte	$38
.byte	$6C
.byte	$38
.byte	$76
.byte	$DC
.byte	$CC
.byte	$76
.byte	0
! 8299  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$60
.byte	$60
.byte	$C0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8300  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$60
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8301  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$18
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8302  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
.byte	0
.byte	$66
.byte	$3C
.byte	$FF
.byte	$3C
.byte	$66
.byte	0
.byte	0
! 8303  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$30
.byte	$FC
.byte	$30
.byte	$30
.byte	0
.byte	0
! 8304  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8305  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	0
.byte	0
! 8306  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8307  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
.byte	6
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$80
.byte	0
! 8308  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
.byte	$7C
.byte	$C6
.byte	$CE
.byte	$DE
.byte	$F6
.byte	$E6
.byte	$7C
.byte	0
! 8309  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
.byte	$30
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$FC
.byte	0
! 8310  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$60
.byte	$CC
.byte	$FC
.byte	0
! 8311  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8312  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
.byte	$1C
.byte	$3C
.byte	$6C
.byte	$CC
.byte	$FE
.byte	$C
.byte	$1E
.byte	0
! 8313  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
.byte	$FC
.byte	$C0
.byte	$F8
.byte	$C
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8314  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
.byte	$38
.byte	$60
.byte	$C0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8315  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
.byte	$FC
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	$30
.byte	$30
.byte	0
! 8316  0x78, 0xcc, 0xcc, 0x78, 0x
.byte	$78
.byte	$CC
.byte	$CC
.byte	$78
! 8316 cc, 0xcc, 0x78, 0x00,
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8317  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$18
.byte	$70
.byte	0
! 8318  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	$30
.byte	$30
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8319  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	$30
.byte	$30
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8320  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8321  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
! 8322  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8323  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8324  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
.byte	$7C
.byte	$C6
.byte	$DE
.byte	$DE
.byte	$DE
.byte	$C0
.byte	$78
.byte	0
! 8325  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
.byte	$30
.byte	$78
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
.byte	0
! 8326  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$66
.byte	$66
.byte	$FC
.byte	0
! 8327  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$66
.byte	$3C
.byte	0
! 8328  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
.byte	$F8
.byte	$6C
.byte	$66
.byte	$66
.byte	$66
.byte	$6C
.byte	$F8
.byte	0
! 8329  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$62
.byte	$FE
.byte	0
! 8330  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$60
.byte	$F0
.byte	0
! 8331  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$CE
.byte	$66
.byte	$3E
.byte	0
! 8332  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8333  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$78
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8334  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
.byte	$1E
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8335  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
.byte	$E6
.byte	$66
.byte	$6C
.byte	$78
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8336  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
.byte	$F0
.byte	$60
.byte	$60
.byte	$60
.byte	$62
.byte	$66
.byte	$FE
.byte	0
! 8337  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$EE
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	$C6
.byte	0
! 8338  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$E6
.byte	$F6
.byte	$DE
.byte	$CE
.byte	$C6
.byte	$C6
.byte	0
! 8339  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	0
! 8340  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8341  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$DC
.byte	$78
.byte	$1C
.byte	0
! 8342  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8343  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$E0
.byte	$70
.byte	$1C
.byte	$CC
.byte	$78
.byte	0
! 8344  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$FC
.byte	$B4
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8345  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	0
! 8346  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8347  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$EE
.byte	$C6
.byte	0
! 8348  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8349  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8350  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
.byte	$FE
.byte	$C6
.byte	$8C
.byte	$18
.byte	$32
.byte	$66
.byte	$FE
.byte	0
! 8351  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
.byte	$78
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$78
.byte	0
! 8352  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	6
.byte	2
.byte	0
! 8353  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
.byte	$78
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$78
.byte	0
! 8354  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
.byte	0
.byte	0
.byte	0
! 8355  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$FF
! 8356  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$30
.byte	$30
.byte	$18
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8357  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$C
.byte	$7C
.byte	$CC
.byte	$76
.byte	0
! 8358  0xe0, 0x60, 0x60
.byte	$E0
.byte	$60
! 8358 , 0x7c, 0x66, 0x66, 0xdc, 0x00,
.byte	$60
.byte	$7C
.byte	$66
.byte	$66
.byte	$DC
.byte	0
! 8359  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$C0
.byte	$CC
.byte	$78
.byte	0
! 8360  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
.byte	$1C
.byte	$C
.byte	$C
.byte	$7C
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8361  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$FC
.byte	$C0
.byte	$78
.byte	0
! 8362  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
.byte	$38
.byte	$6C
.byte	$60
.byte	$F0
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8363  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8364  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
.byte	$E0
.byte	$60
.byte	$6C
.byte	$76
.byte	$66
.byte	$66
.byte	$E6
.byte	0
! 8365  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$30
.byte	0
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8366  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
.byte	$C
.byte	0
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
! 8367  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
.byte	$E0
.byte	$60
.byte	$66
.byte	$6C
.byte	$78
.byte	$6C
.byte	$E6
.byte	0
! 8368  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8369  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	0
! 8370  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	0
.byte	0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8371  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8372  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
.byte	0
.byte	0
.byte	$DC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$F0
! 8373  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$1E
! 8374  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
.byte	0
.byte	0
.byte	$DC
.byte	$76
.byte	$66
.byte	$60
.byte	$F0
.byte	0
! 8375  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
.byte	0
.byte	0
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	0
! 8376  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
.byte	$10
.byte	$30
.byte	$7C
.byte	$30
.byte	$30
.byte	$34
.byte	$18
.byte	0
! 8377  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8378  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8379  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$FE
.byte	$6C
.byte	0
! 8380  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$6C
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8381  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8382  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	$98
.byte	$30
.byte	$64
.byte	$FC
.byte	0
! 8383  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	0
! 8384  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	0
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8385  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	0
! 8386  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$76
.byte	$DC
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8387  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
.byte	0
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$FE
.byte	0
! 8388 };
!BCC_EOS
! 8389 #asm
!BCC_ASM
.org 0xcff0
bios_table_area_end:
! 8392 endasm
!BCC_ENDASM
! 8393 
.790:
.7B5:
.ascii	"no PCI device with class code 0x%02x%04x"
.ascii	" found at index %d"
.byte	$A
.byte	0
.78E:
.7B6:
.ascii	"PCI device %04x:%04x not found at index "
.ascii	"%d"
.byte	$A
.byte	0
.788:
.7B7:
.ascii	"bad PCI vendor ID %04x"
.byte	$A
.byte	0
.784:
.7B8:
.ascii	"unsupported PCI BIOS function 0x%02x"
.byte	$A
.byte	0
.780:
.7B9:
.ascii	"PCI BIOS: PCI not present"
.byte	$A
.byte	0
.765:
.7BA:
.ascii	"Booting from %x:%x"
.byte	$A
.byte	0
.750:
.7BB:
.ascii	"Invalid boot device (0x%x)"
.byte	$A
.byte	0
.74D:
.7BC:
.byte	0
.74C:
.7BD:
.ascii	"Powering off in 30 seconds."
.byte	$A
.byte	0
.74B:
.7BE:
.byte	$A
.ascii	"No bootable device."
.byte	$A
.byte	0
.735:
.7BF:
.ascii	"set_diskette_current_cyl(): drive > 1"
.byte	$A
.byte	0
.730:
.7C0:
.ascii	"int13_diskette: unsupported AH=%02x"
.byte	$A
.byte	0
.71E:
.7C1:
.ascii	"floppy: int13: bad floppy type"
.byte	$A
.byte	0
.706:
.7C2:
.ascii	"int13_diskette_function: write error"
.byte	$A
.byte	0
.700:
.7C3:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6E5:
.7C4:
.ascii	"int13_diskette_function: read error"
.byte	$A
.byte	0
.6DF:
.7C5:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6CD:
.7C6:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6B8:
.7C7:
.ascii	"int13_diskette: read/write/verify: param"
.ascii	"eter out of range"
.byte	$A
.byte	0
.656:
.7C8:
.ascii	"int13_cdemu function AH=%02x unsupported"
.ascii	", returns fail"
.byte	$A
.byte	0
.63E:
.7C9:
.ascii	"int13_cdemu: function %02x, error %02x !"
.byte	$A
.byte	0
.620:
.7CA:
.ascii	"int13_cdemu: function %02x, emulation no"
.ascii	"t active for DL= %02x"
.byte	$A
.byte	0
.61C:
.7CB:
.ascii	"int13_eltorito: unsupported AH=%02x"
.byte	$A
.byte	0
.617:
.7CC:
.ascii	"Int13 eltorito call with AX=%04x. Please"
.ascii	" report"
.byte	$A
.byte	0
.60C:
.7CD:
.ascii	"int13_cdrom: unsupported AH=%02x"
.byte	$A
.byte	0
.5C5:
.7CE:
.ascii	"int13_cdrom: function %02x, status %02x "
.ascii	"!"
.byte	$A
.byte	0
.5BF:
.7CF:
.ascii	"int13_cdrom: function %02x. Can't use 64"
.ascii	"bits lba"
.byte	$A
.byte	0
.5A5:
.7D0:
.ascii	"int13_cdrom: function %02x, unmapped dev"
.ascii	"ice for ELDL=%02x"
.byte	$A
.byte	0
.5A2:
.7D1:
.ascii	"int13_cdrom: function %02x, ELDL out of "
.ascii	"range %02x"
.byte	$A
.byte	0
.59A:
.7D2:
.ascii	"int13_harddisk: function %02xh unsupport"
.ascii	"ed, returns fail"
.byte	$A
.byte	0
.594:
.7D3:
.ascii	"int13_harddisk: function %02xh unimpleme"
.ascii	"nted, returns success"
.byte	$A
.byte	0
.553:
.7D4:
.ascii	"int13_harddisk: function %02x, error %02"
.ascii	"x !"
.byte	$A
.byte	0
.54A:
.7D5:
.ascii	"int13_harddisk: function %02x. LBA out o"
.ascii	"f range"
.byte	$A
.byte	0
.546:
.7D6:
.ascii	"int13_harddisk: function %02x. LBA out o"
.ascii	"f range"
.byte	$A
.byte	0
.538:
.7D7:
.ascii	"format disk track called"
.byte	$A
.byte	0
.536:
.7D8:
.ascii	"int13_harddisk: function %02x, error %02"
.ascii	"x !"
.byte	$A
.byte	0
.52B:
.7D9:
.ascii	"int13_harddisk: function %02x, parameter"
.ascii	"s out of range %04x/%04x/%04x!"
.byte	$A
.byte	0
.526:
.7DA:
.ascii	"int13_harddisk: function %02x, parameter"
.ascii	" out of range!"
.byte	$A
.byte	0
.516:
.7DB:
.ascii	"int13_harddisk: function %02x, unmapped "
.ascii	"device for ELDL=%02x"
.byte	$A
.byte	0
.513:
.7DC:
.ascii	"int13_harddisk: function %02x, ELDL out "
.ascii	"of range %02x"
.byte	$A
.byte	0
.500:
.7DD:
.ascii	"KBD: int09h_handler(): scancode & asciic"
.ascii	"ode are zero?"
.byte	$A
.byte	0
.4E8:
.7DE:
.ascii	"KBD: int09h_handler(): unknown scancode "
.ascii	"read: 0x%02x!"
.byte	$A
.byte	0
.4BA:
.7DF:
.ascii	"KBD: int09 handler: AL=0"
.byte	$A
.byte	0
.4B7:
.7E0:
.ascii	"setkbdcomm"
.byte	0
.4B0:
.7E1:
.ascii	"sendmouse"
.byte	0
.4AD:
.7E2:
.ascii	"enabmouse"
.byte	0
.4A6:
.7E3:
.ascii	"enabmouse"
.byte	0
.4A3:
.7E4:
.ascii	"inhibmouse"
.byte	0
.49C:
.7E5:
.ascii	"inhibmouse"
.byte	0
.48F:
.7E6:
.ascii	"KBD: unsupported int 16h function %02x"
.byte	$A
.byte	0
.47E:
.7E7:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.450:
.7E8:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.43D:
.7E9:
.ascii	"*** int 15h function AX=%04x, BX=%04x no"
.ascii	"t yet supported!"
.byte	$A
.byte	0
.40C:
.7EA:
.ascii	"*** int 15h function AX=%04x, BX=%04x no"
.ascii	"t yet supported!"
.byte	$A
.byte	0
.400:
.7EB:
.ascii	"INT 15h C2 AL=6, BH=%02x"
.byte	$A
.byte	0
.3EA:
.7EC:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3DA:
.7ED:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3D7:
.7EE:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3B5:
.7EF:
.ascii	"Mouse reset returned %02x (should be ack"
.ascii	")"
.byte	$A
.byte	0
.38E:
.7F0:
.ascii	"*** int 15h function AX=%04x, BX=%04x no"
.ascii	"t yet supported!"
.byte	$A
.byte	0
.38C:
.7F1:
.ascii	"EISA BIOS not present"
.byte	$A
.byte	0
.388:
.7F2:
.ascii	"*** int 15h function AH=bf not yet suppo"
.ascii	"rted!"
.byte	$A
.byte	0
.371:
.7F3:
.ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
.ascii	" control not supported"
.byte	$A
.byte	0
.30A:
.7F4:
.ascii	"ata_is_ready returned %d"
.byte	$A
.byte	0
.2F4:
.7F5:
.ascii	"%dMB medium detected"
.byte	$A
.byte	0
.2EF:
.7F6:
.ascii	"Unsupported sector size %u"
.byte	$A
.byte	0
.2EA:
.7F7:
.ascii	"Waiting for device to detect medium... "
.byte	0
.2DC:
.7F8:
.ascii	"not implemented for non-ATAPI device"
.byte	$A
.byte	0
.2A2:
.7F9:
.ascii	"ata_cmd_packet: DATA_OUT not supported y"
.ascii	"et"
.byte	$A
.byte	0
.252:
.7FA:
.byte	$A
.byte	0
.24D:
.7FB:
.ascii	"master"
.byte	0
.24C:
.7FC:
.ascii	" slave"
.byte	0
.24B:
.7FD:
.ascii	"ata%d %s: Unknown device"
.byte	$A
.byte	0
.249:
.7FE:
.ascii	" ATAPI-%d Device"
.byte	$A
.byte	0
.247:
.7FF:
.ascii	" ATAPI-%d CD-Rom/DVD-Rom"
.byte	$A
.byte	0
.243:
.800:
.ascii	"%c"
.byte	0
.23C:
.801:
.ascii	"master"
.byte	0
.23B:
.802:
.ascii	" slave"
.byte	0
.23A:
.803:
.ascii	"ata%d %s: "
.byte	0
.238:
.804:
.ascii	" ATA-%d Hard-Disk (%4u GBytes)"
.byte	$A
.byte	0
.236:
.805:
.ascii	" ATA-%d Hard-Disk (%4u MBytes)"
.byte	$A
.byte	0
.232:
.806:
.ascii	"%c"
.byte	0
.22B:
.807:
.ascii	"master"
.byte	0
.22A:
.808:
.ascii	" slave"
.byte	0
.229:
.809:
.ascii	"ata%d %s: "
.byte	0
.1FE:
.80A:
.ascii	"ata-detect: Failed to detect ATAPI devic"
.ascii	"e"
.byte	$A
.byte	0
.1F9:
.80B:
.ascii	" LCHS=%d/%d/%d"
.byte	$A
.byte	0
.1D9:
.80C:
.ascii	"r-echs"
.byte	0
.1D7:
.80D:
.ascii	"large"
.byte	0
.1D5:
.80E:
.ascii	"lba"
.byte	0
.1D3:
.80F:
.ascii	"none"
.byte	0
.1C9:
.810:
.ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
.byte	0
.1BF:
.811:
.ascii	"ata-detect: Failed to detect ATA device"
.byte	$A
.byte	0
.19E:
.812:
.ascii	"IDE time out"
.byte	$A
.byte	0
.162:
.813:
.ascii	"S3 resume jump to %x:%x"
.byte	$A
.byte	0
.15E:
.814:
.ascii	"S3 resume called %x 0x%lx"
.byte	$A
.byte	0
.158:
.815:
.ascii	"%s"
.byte	$A
.byte	0
.157:
.816:
.ascii	"INT18: BOOT FAILURE"
.byte	$A
.byte	0
.156:
.817:
.ascii	"NMI Handler called"
.byte	$A
.byte	0
.155:
.818:
.ascii	"CDROM boot failure code : %04x"
.byte	$A
.byte	0
.154:
.819:
.byte	$A,$A
.byte	0
.153:
.81A:
.ascii	": could not read the boot disk"
.byte	0
.151:
.81B:
.ascii	": not a bootable disk"
.byte	0
.14C:
.81C:
.ascii	"Boot from %s failed"
.byte	0
.14B:
.81D:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.147:
.81E:
.ascii	"..."
.byte	$A
.byte	0
.146:
.81F:
.ascii	" [%S]"
.byte	0
.142:
.820:
.ascii	"Booting from %s"
.byte	0
.141:
.821:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.13A:
.822:
.byte	$A
.byte	0
.12E:
.823:
.byte	$A
.byte	0
.12D:
.824:
.ascii	" [%S]"
.byte	0
.12A:
.825:
.ascii	"%s"
.byte	0
.128:
.826:
.ascii	"%s"
.byte	$A
.byte	0
.121:
.827:
.ascii	"%d. "
.byte	0
.11C:
.828:
.ascii	"Select boot device:"
.byte	$A,$A
.byte	0
.112:
.829:
.byte	$A,$A
.ascii	"Press F12 for boot menu."
.byte	$A,$A
.byte	0
.10A:
.82A:
.ascii	"apmbios pcibios eltorito PMM "
.byte	$A,$A
.byte	0
.109:
.82B:
.ascii	"06/23/99"
.byte	0
.108:
.82C:
.ascii	"Bochs BIOS - build: %s"
.byte	$A
.ascii	"%s"
.byte	$A
.ascii	"Options: "
.byte	0
.107:
.82D:
.ascii	"Returned from s3_resume."
.byte	$A
.byte	0
.106:
.82E:
.ascii	"Unimplemented shutdown status: %02x"
.byte	$A
.byte	0
.105:
.82F:
.ascii	"Couldn't reset the machine"
.byte	$A
.byte	0
.104:
.830:
.ascii	"Keyboard error:%u"
.byte	$A
.byte	0
.8D:
.831:
.ascii	"bios_printf: unknown format"
.byte	$A
.byte	0
.41:
.832:
.ascii	"FATAL: "
.byte	0
.bss

! 0 errors detected
