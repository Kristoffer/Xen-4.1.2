00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 extern unsigned long pci_mem_start, pci_mem_end;
00004                                           !BCC_EOS
00005                                           ! 2 struct bios_info {
00006                                           ! 3     unsigned char com1_present:1;
00007                                           !BCC_EOS
00008                                           ! 4     unsigned char com2_present:1;
00009                                           !BCC_EOS
00010                                           ! 5     unsigned char lpt1_present:1;
00011                                           !BCC_EOS
00012                                           ! 6     unsigned char hpet_present:1;
00013                                           !BCC_EOS
00014                                           ! 7     unsigned long pci_min, pci_len;
00015                                           !BCC_EOS
00016                                           ! 8     unsigned long madt_csum_addr;
00017                                           !BCC_EOS
00018                                           ! 9     unsigned long madt_lapic0_addr;
00019                                           !BCC_EOS
00020                                           ! 10     unsigned long bios32_entry;
00021                                           !BCC_EOS
00022                                           ! 11 };
00023                                           !BCC_EOS
00024                                           ! 12 #asm
00025                                           !BCC_ASM
00026 0000                                      .rom
00027 0000                                      .org 0x0000
00028                                           use16 386
00029                                           MACRO HALT
00030                                             ;; the HALT macro is called with the line number of the HALT call.
00031                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00032                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00033                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00034                                             ;; However, users can choose to make panics non-fatal and continue.
00035                                             mov dx,#0x400
00036                                             mov ax,#?1
00037                                             out dx,ax
00038                                           MEND
00039                                           MACRO JMP_AP
00040                                             db 0xea
00041                                             dw ?2
00042                                             dw ?1
00043                                           MEND
00044                                           MACRO SET_INT_VECTOR
00045                                             mov ax, ?3
00046                                             mov ?1*4, ax
00047                                             mov ax, ?2
00048                                             mov ?1*4+2, ax
00049                                           MEND
00050                                           ! 37 endasm
00051                                           !BCC_ENDASM
00052                                           ! 38 typedef unsigned char Bit8u;
00053                                           !BCC_EOS
00054                                           ! 39 typedef unsigned short Bit16u;
00055                                           !BCC_EOS
00056                                           ! 40 typedef unsigned short bx_bool;
00057                                           !BCC_EOS
00058                                           ! 41 typedef unsigned long Bit32u;
00059                                           !BCC_EOS
00060                                           ! 42   void memsetb(seg,offset,value,count);
00061                                           !BCC_EOS
00062                                           ! 43   void memcpyb(dseg,doffset,sseg,soffset,count);
00063                                           !BCC_EOS
00064                                           ! 44   void memcpyd(dseg,doffset,sseg,soffset,count);
00065                                           !BCC_EOS
00066                                           ! 45     void
00067                                           ! 46   memsetb(seg,offset,value,count)
00068                                           ! 47     Bit16u seg;
00069                                           export	_memsetb
00070                       00000000            _memsetb:
00071                                           !BCC_EOS
00072                                           ! 48     Bit16u offset;
00073                                           !BCC_EOS
00074                                           ! 49     Bit16u value;
00075                                           !BCC_EOS
00076                                           ! 50     Bit16u count;
00077                                           !BCC_EOS
00078                                           ! 51   {
00079                                           ! 52 #asm
00080                                           !BCC_ASM
00081                       00000008            _memsetb.count	set	8
00082                       00000002            _memsetb.seg	set	2
00083                       00000006            _memsetb.value	set	6
00084                       00000004            _memsetb.offset	set	4
00085 0000           55                             push bp
00086 0001           89E5                           mov bp, sp
00087 0003           50                               push ax
00088 0004           51                               push cx
00089 0005           06                               push es
00090 0006           57                               push di
00091 0007           8B4E         0A                  mov cx, 10[bp] ; count
00092 000A           85C9                             test cx, cx
00093 000C           74           10                  je memsetb_end
00094 000E           8B46         04                  mov ax, 4[bp] ; segment
00095 0011           8EC0                             mov es, ax
00096 0013           8B46         06                  mov ax, 6[bp] ; offset
00097 0016           89C7                             mov di, ax
00098 0018           8A46         08                  mov al, 8[bp] ; value
00099 001B           FC                               cld
00100 001C           F3                               rep
00101 001D           AA                                stosb
00102                       0000001E              memsetb_end:
00103 001E           5F                               pop di
00104 001F           07                               pop es
00105 0020           59                               pop cx
00106 0021           58                               pop ax
00107 0022           5D                             pop bp
00108                                           ! 76 endasm
00109                                           !BCC_ENDASM
00110                                           ! 77   }
00111 0023           C3                         ret
00112                                           ! 78     void
00113                                           ! 79   memcpyb(dseg,doffset,sseg,soffset,count)
00114                                           ! 80     Bit16u dseg;
00115                                           export	_memcpyb
00116                       00000024            _memcpyb:
00117                                           !BCC_EOS
00118                                           ! 81     Bit16u doffset;
00119                                           !BCC_EOS
00120                                           ! 82     Bit16u sseg;
00121                                           !BCC_EOS
00122                                           ! 83     Bit16u soffset;
00123                                           !BCC_EOS
00124                                           ! 84     Bit16u count;
00125                                           !BCC_EOS
00126                                           ! 85   {
00127                                           ! 86 #asm
00128                                           !BCC_ASM
00129                       0000000A            _memcpyb.count	set	$A
00130                       00000006            _memcpyb.sseg	set	6
00131                       00000008            _memcpyb.soffset	set	8
00132                       00000002            _memcpyb.dseg	set	2
00133                       00000004            _memcpyb.doffset	set	4
00134 0024           55                             push bp
00135 0025           89E5                           mov bp, sp
00136 0027           50                               push ax
00137 0028           51                               push cx
00138 0029           06                               push es
00139 002A           57                               push di
00140 002B           1E                               push ds
00141 002C           56                               push si
00142 002D           8B4E         0C                  mov cx, 12[bp] ; count
00143 0030           85C9                             test cx, cx
00144 0032           74           17                  je memcpyb_end
00145 0034           8B46         04                  mov ax, 4[bp] ; dsegment
00146 0037           8EC0                             mov es, ax
00147 0039           8B46         06                  mov ax, 6[bp] ; doffset
00148 003C           89C7                             mov di, ax
00149 003E           8B46         08                  mov ax, 8[bp] ; ssegment
00150 0041           8ED8                             mov ds, ax
00151 0043           8B46         0A                  mov ax, 10[bp] ; soffset
00152 0046           89C6                             mov si, ax
00153 0048           FC                               cld
00154 0049           F3                               rep
00155 004A           A4                                movsb
00156                       0000004B              memcpyb_end:
00157 004B           5E                               pop si
00158 004C           1F                               pop ds
00159 004D           5F                               pop di
00160 004E           07                               pop es
00161 004F           59                               pop cx
00162 0050           58                               pop ax
00163 0051           5D                             pop bp
00164                                           ! 117 endasm
00165                                           !BCC_ENDASM
00166                                           ! 118   }
00167 0052           C3                         ret
00168                                           ! 119     void
00169                                           ! 120   memcpyd(dseg,doffset,sseg,soffset,count)
00170                                           ! 121     Bit16u dseg;
00171                                           export	_memcpyd
00172                       00000053            _memcpyd:
00173                                           !BCC_EOS
00174                                           ! 122     Bit16u doffset;
00175                                           !BCC_EOS
00176                                           ! 123     Bit16u sseg;
00177                                           !BCC_EOS
00178                                           ! 124     Bit16u soffset;
00179                                           !BCC_EOS
00180                                           ! 125     Bit16u count;
00181                                           !BCC_EOS
00182                                           ! 126   {
00183                                           ! 127 #asm
00184                                           !BCC_ASM
00185                       0000000A            _memcpyd.count	set	$A
00186                       00000006            _memcpyd.sseg	set	6
00187                       00000008            _memcpyd.soffset	set	8
00188                       00000002            _memcpyd.dseg	set	2
00189                       00000004            _memcpyd.doffset	set	4
00190 0053           55                             push bp
00191 0054           89E5                           mov bp, sp
00192 0056           50                               push ax
00193 0057           51                               push cx
00194 0058           06                               push es
00195 0059           57                               push di
00196 005A           1E                               push ds
00197 005B           56                               push si
00198 005C           8B4E         0C                  mov cx, 12[bp] ; count
00199 005F           85C9                             test cx, cx
00200 0061           74           18                  je memcpyd_end
00201 0063           8B46         04                  mov ax, 4[bp] ; dsegment
00202 0066           8EC0                             mov es, ax
00203 0068           8B46         06                  mov ax, 6[bp] ; doffset
00204 006B           89C7                             mov di, ax
00205 006D           8B46         08                  mov ax, 8[bp] ; ssegment
00206 0070           8ED8                             mov ds, ax
00207 0072           8B46         0A                  mov ax, 10[bp] ; soffset
00208 0075           89C6                             mov si, ax
00209 0077           FC                               cld
00210 0078           F3                               rep
00211 0079     66    A5                                movsd
00212                       0000007B              memcpyd_end:
00213 007B           5E                               pop si
00214 007C           1F                               pop ds
00215 007D           5F                               pop di
00216 007E           07                               pop es
00217 007F           59                               pop cx
00218 0080           58                               pop ax
00219 0081           5D                             pop bp
00220                                           ! 158 endasm
00221                                           !BCC_ENDASM
00222                                           ! 159   }
00223 0082           C3                         ret
00224                                           ! 160   static Bit32u read_dword();
00225                                           !BCC_EOS
00226                                           ! 161   static void write_dword();
00227                                           !BCC_EOS
00228                                           ! 162     Bit32u
00229                                           ! 163   read_dword(seg, offset)
00230                                           ! 164     Bit16u seg;
00231                                           export	_read_dword
00232                       00000083            _read_dword:
00233                                           !BCC_EOS
00234                                           ! 165     Bit16u offset;
00235                                           !BCC_EOS
00236                                           ! 166   {
00237                                           ! 167 #asm
00238                                           !BCC_ASM
00239                       00000002            _read_dword.seg	set	2
00240                       00000004            _read_dword.offset	set	4
00241 0083           55                             push bp
00242 0084           89E5                           mov bp, sp
00243 0086           53                               push bx
00244 0087           1E                               push ds
00245 0088           8B46         04                  mov ax, 4[bp] ; segment
00246 008B           8ED8                             mov ds, ax
00247 008D           8B5E         06                  mov bx, 6[bp] ; offset
00248 0090           8B07                             mov ax, [bx]
00249 0092           83C3                   02        add bx, #2
00250 0095           8B17                             mov dx, [bx]
00251                                                 ;; ax = return value (word)
00252                                                 ;; dx = return value (word)
00253 0097           1F                               pop ds
00254 0098           5B                               pop bx
00255 0099           5D                             pop bp
00256                                           ! 183 endasm
00257                                           !BCC_ENDASM
00258                                           ! 184   }
00259 009A           C3                         ret
00260                                           ! 185     void
00261                                           ! 186   write_dword(seg, offset, data)
00262                                           ! 187     Bit16u seg;
00263                                           export	_write_dword
00264                       0000009B            _write_dword:
00265                                           !BCC_EOS
00266                                           ! 188     Bit16u offset;
00267                                           !BCC_EOS
00268                                           ! 189     Bit32u data;
00269                                           !BCC_EOS
00270                                           ! 190   {
00271                                           ! 191 #asm
00272                                           !BCC_ASM
00273                       00000002            _write_dword.seg	set	2
00274                       00000006            _write_dword.data	set	6
00275                       00000004            _write_dword.offset	set	4
00276 009B           55                             push bp
00277 009C           89E5                           mov bp, sp
00278 009E           50                               push ax
00279 009F           53                               push bx
00280 00A0           1E                               push ds
00281 00A1           8B46         04                  mov ax, 4[bp] ; segment
00282 00A4           8ED8                             mov ds, ax
00283 00A6           8B5E         06                  mov bx, 6[bp] ; offset
00284 00A9           8B46         08                  mov ax, 8[bp] ; data word
00285 00AC           8907                             mov [bx], ax ; write data word
00286 00AE           83C3                   02        add bx, #2
00287 00B1           8B46         0A                  mov ax, 10[bp] ; data word
00288 00B4           8907                             mov [bx], ax ; write data word
00289 00B6           1F                               pop ds
00290 00B7           5B                               pop bx
00291 00B8           58                               pop ax
00292 00B9           5D                             pop bp
00293                                           ! 209 endasm
00294                                           !BCC_ENDASM
00295                                           ! 210   }
00296 00BA           C3                         ret
00297                                           ! 211 #asm
00298                                           !BCC_ASM
00299                       00000002            _write_dword.seg	set	2
00300                       00000006            _write_dword.data	set	6
00301                       00000004            _write_dword.offset	set	4
00302                                             ;; and function
00303                       000000BB              landl:
00304                       000000BB              landul:
00305 00BB           36                             SEG SS
00306 00BC           2305                             and ax,[di]
00307 00BE           36                             SEG SS
00308 00BF           235D         02                  and bx,2[di]
00309 00C2           C3                             ret
00310                                             ;; add function
00311                       000000C3              laddl:
00312                       000000C3              laddul:
00313 00C3           36                             SEG SS
00314 00C4           0305                             add ax,[di]
00315 00C6           36                             SEG SS
00316 00C7           135D         02                  adc bx,2[di]
00317 00CA           C3                             ret
00318                                             ;; cmp function
00319                       000000CB              lcmpl:
00320                       000000CB              lcmpul:
00321 00CB     66    25               0000FFFF      and eax, #0x0000FFFF
00322 00D1     66    C1E3                   10      shl ebx, #16
00323 00D5     66    09D8                           or eax, ebx
00324 00D8     66    C1EB                   10      shr ebx, #16
00325 00DC           36                             SEG SS
00326 00DD     66    3B05                             cmp eax, dword ptr [di]
00327 00E0           C3                             ret
00328                                             ;; sub function
00329                       000000E1              lsubl:
00330                       000000E1              lsubul:
00331 00E1           36                             SEG SS
00332 00E2           2B05                           sub ax,[di]
00333 00E4           36                             SEG SS
00334 00E5           1B5D         02                sbb bx,2[di]
00335 00E8           C3                             ret
00336                                             ;; mul function
00337                       000000E9              lmull:
00338                       000000E9              lmulul:
00339 00E9     66    25               0000FFFF      and eax, #0x0000FFFF
00340 00EF     66    C1E3                   10      shl ebx, #16
00341 00F3     66    09D8                           or eax, ebx
00342 00F6           36                             SEG SS
00343 00F7     66    F725                           mul eax, dword ptr [di]
00344 00FA     66    89C3                           mov ebx, eax
00345 00FD     66    C1EB                   10      shr ebx, #16
00346 0101           C3                             ret
00347                                             ;; dec function
00348                       00000102              ldecl:
00349                       00000102              ldecul:
00350 0102           36                             SEG SS
00351 0103     66    FF0F                           dec dword ptr [bx]
00352 0106           C3                             ret
00353                                             ;; or function
00354                       00000107              lorl:
00355                       00000107              lorul:
00356 0107           36                             SEG SS
00357 0108           0B05                           or ax,[di]
00358 010A           36                             SEG SS
00359 010B           0B5D         02                or bx,2[di]
00360 010E           C3                             ret
00361                                             ;; inc function
00362                       0000010F              lincl:
00363                       0000010F              lincul:
00364 010F           36                             SEG SS
00365 0110     66    FF07                           inc dword ptr [bx]
00366 0113           C3                             ret
00367                                             ;; tst function
00368                       00000114              ltstl:
00369                       00000114              ltstul:
00370 0114     66    25               0000FFFF      and eax, #0x0000FFFF
00371 011A     66    C1E3                   10      shl ebx, #16
00372 011E     66    09D8                           or eax, ebx
00373 0121     66    C1EB                   10      shr ebx, #16
00374 0125     66    85C0                           test eax, eax
00375 0128           C3                             ret
00376                                             ;; sr function
00377                       00000129              lsrul:
00378 0129           89F9                           mov cx,di
00379 012B           E3           19                jcxz lsr_exit
00380 012D     66    25               0000FFFF      and eax, #0x0000FFFF
00381 0133     66    C1E3                   10      shl ebx, #16
00382 0137     66    09D8                           or eax, ebx
00383                       0000013A              lsr_loop:
00384 013A     66    D1E8                           shr eax, #1
00385 013D           E2           FB                loop lsr_loop
00386 013F     66    89C3                           mov ebx, eax
00387 0142     66    C1EB                   10      shr ebx, #16
00388                       00000146              lsr_exit:
00389 0146           C3                             ret
00390                                             ;; sl function
00391                       00000147              lsll:
00392                       00000147              lslul:
00393 0147           89F9                           mov cx,di
00394 0149           E3           19                jcxz lsl_exit
00395 014B     66    25               0000FFFF      and eax, #0x0000FFFF
00396 0151     66    C1E3                   10      shl ebx, #16
00397 0155     66    09D8                           or eax, ebx
00398                       00000158              lsl_loop:
00399 0158     66    D1E0                           shl eax, #1
00400 015B           E2           FB                loop lsl_loop
00401 015D     66    89C3                           mov ebx, eax
00402 0160     66    C1EB                   10      shr ebx, #16
00403                       00000164              lsl_exit:
00404 0164           C3                             ret
00405                       00000165              idiv_:
00406 0165           99                             cwd
00407 0166           F7FB                           idiv bx
00408 0168           C3                             ret
00409                       00000169              idiv_u:
00410 0169           31D2                           xor dx,dx
00411 016B           F7F3                           div bx
00412 016D           C3                             ret
00413                       0000016E              ldivul:
00414 016E     66    25               0000FFFF      and eax, #0x0000FFFF
00415 0174     66    C1E3                   10      shl ebx, #16
00416 0178     66    09D8                           or eax, ebx
00417 017B     66    31D2                           xor edx, edx
00418 017E           36                             SEG SS
00419 017F           8B5D         02                mov bx, 2[di]
00420 0182     66    C1E3                   10      shl ebx, #16
00421 0186           36                             SEG SS
00422 0187           8B1D                           mov bx, [di]
00423 0189     66    F7F3                           div ebx
00424 018C     66    89C3                           mov ebx, eax
00425 018F     66    C1EB                   10      shr ebx, #16
00426 0193           C3                             ret
00427                                           ! 337 endasm
00428                                           !BCC_ENDASM
00429                                           ! 338 typedef struct {
00430                                           ! 339   unsigned char filler1[0x400];
00431                                           !BCC_EOS
00432                                           ! 340   unsigned char filler2[0x6c];
00433                                           !BCC_EOS
00434                                           ! 341   Bit16u ticks_low;
00435                                           !BCC_EOS
00436                                           ! 342   Bit16u ticks_high;
00437                                           !BCC_EOS
00438                                           ! 343   Bit8u midnight_flag;
00439                                           !BCC_EOS
00440                                           ! 344   } bios_data_t;
00441                                           !BCC_EOS
00442                                           ! 345   typedef struct {
00443                                           ! 346     Bit16u heads;
00444                                           !BCC_EOS
00445                                           ! 347     Bit16u cylinders;
00446                                           !BCC_EOS
00447                                           ! 348     Bit16u spt;
00448                                           !BCC_EOS
00449                                           ! 349     } chs_t;
00450                                           !BCC_EOS
00451                                           ! 350   typedef struct {
00452                                           ! 351     Bit16u iobase1;
00453                                           !BCC_EOS
00454                                           ! 352     Bit16u iobase2;
00455                                           !BCC_EOS
00456                                           ! 353     Bit8u prefix;
00457                                           !BCC_EOS
00458                                           ! 354     Bit8u unused;
00459                                           !BCC_EOS
00460                                           ! 355     Bit8u irq;
00461                                           !BCC_EOS
00462                                           ! 356     Bit8u blkcount;
00463                                           !BCC_EOS
00464                                           ! 357     Bit8u dma;
00465                                           !BCC_EOS
00466                                           ! 358     
00467                                           ! 358 Bit8u pio;
00468                                           !BCC_EOS
00469                                           ! 359     Bit16u options;
00470                                           !BCC_EOS
00471                                           ! 360     Bit16u reserved;
00472                                           !BCC_EOS
00473                                           ! 361     Bit8u revision;
00474                                           !BCC_EOS
00475                                           ! 362     Bit8u checksum;
00476                                           !BCC_EOS
00477                                           ! 363     } dpte_t;
00478                                           !BCC_EOS
00479                                           ! 364   typedef struct {
00480                                           ! 365     Bit8u iface;
00481                                           !BCC_EOS
00482                                           ! 366     Bit16u iobase1;
00483                                           !BCC_EOS
00484                                           ! 367     Bit16u iobase2;
00485                                           !BCC_EOS
00486                                           ! 368     Bit8u irq;
00487                                           !BCC_EOS
00488                                           ! 369     } ata_channel_t;
00489                                           !BCC_EOS
00490                                           ! 370   typedef struct {
00491                                           ! 371     Bit8u type;
00492                                           !BCC_EOS
00493                                           ! 372     Bit8u device;
00494                                           !BCC_EOS
00495                                           ! 373     Bit8u removable;
00496                                           !BCC_EOS
00497                                           ! 374     Bit8u lock;
00498                                           !BCC_EOS
00499                                           ! 375     Bit8u mode;
00500                                           !BCC_EOS
00501                                           ! 376     Bit16u blksize;
00502                                           !BCC_EOS
00503                                           ! 377     Bit8u translation;
00504                                           !BCC_EOS
00505                                           ! 378     chs_t lchs;
00506                                           !BCC_EOS
00507                                           ! 379     chs_t pchs;
00508                                           !BCC_EOS
00509                                           ! 380     Bit32u sectors_low;
00510                                           !BCC_EOS
00511                                           ! 381     Bit32u sectors_high;
00512                                           !BCC_EOS
00513                                           ! 382     } ata_device_t;
00514                                           !BCC_EOS
00515                                           ! 383   typedef struct {
00516                                           ! 384     ata_channel_t channels[4];
00517                                           !BCC_EOS
00518                                           ! 385     ata_device_t devices[(4*2)];
00519                                           !BCC_EOS
00520                                           ! 386     Bit8u hdcount, hdidmap[(4*2)];
00521                                           !BCC_EOS
00522                                           ! 387     Bit8u cdcount, cdidmap[(4*2)];
00523                                           !BCC_EOS
00524                                           ! 388     dpte_t dpte;
00525                                           !BCC_EOS
00526                                           ! 389     Bit16u trsfsectors;
00527                                           !BCC_EOS
00528                                           ! 390     Bit32u trsfbytes;
00529                                           !BCC_EOS
00530                                           ! 391     } ata_t;
00531                                           !BCC_EOS
00532                                           ! 392   typedef struct {
00533                                           ! 393     Bit8u active;
00534                                           !BCC_EOS
00535                                           ! 394     Bit8u media;
00536                                           !BCC_EOS
00537                                           ! 395     Bit8u emulated_drive;
00538                                           !BCC_EOS
00539                                           ! 396     Bit8u controller_index;
00540                                           !BCC_EOS
00541                                           ! 397     Bit16u device_spec;
00542                                           !BCC_EOS
00543                                           ! 398     Bit32u ilba;
00544                                           !BCC_EOS
00545                                           ! 399     Bit16u buffer_segment;
00546                                           !BCC_EOS
00547                                           ! 400     Bit16u load_segment;
00548                                           !BCC_EOS
00549                                           ! 401     Bit16u sector_count;
00550                                           !BCC_EOS
00551                                           ! 402     chs_t vdevice;
00552                                           !BCC_EOS
00553                                           ! 403     } cdemu_t;
00554                                           !BCC_EOS
00555                                           ! 404 Bit32u TCGInterruptHandler ();
00556                                           !BCC_EOS
00557                                           ! 405 void tcpa_acpi_init ();
00558                                           !BCC_EOS
00559                                           ! 406 Bit32u tcpa_extend_acpi_log ();
00560                                           !BCC_EOS
00561                                           ! 407 void tcpa_calling_int19h ();
00562                                           !BCC_EOS
00563                                           ! 408 void tcpa_returned_int19h ();
00564                                           !BCC_EOS
00565                                           ! 409 void tcpa_add_event_separators ();
00566                                           !BCC_EOS
00567                                           ! 410 void tcpa_wake_event ();
00568                                           !BCC_EOS
00569                                           ! 411 void tcpa_add_bootdevice ();
00570                                           !BCC_EOS
00571                                           ! 412 void tcpa_start_option_rom_scan ();
00572                                           !BCC_EOS
00573                                           ! 413 void tcpa_option_rom ();
00574                                           !BCC_EOS
00575                                           ! 414 void tcpa_ipl ();
00576                                           !BCC_EOS
00577                                           ! 415 void tcpa_measure_post ();
00578                                           !BCC_EOS
00579                                           ! 416 Bit32u tcpa_initialize_tpm ();
00580                                           !BCC_EOS
00581                                           ! 417 Bit32u get_s3_waking_vector ();
00582                                           !BCC_EOS
00583                                           ! 418 Bit32u pmm ();
00584                                           !BCC_EOS
00585                                           ! 419   typedef struct {
00586                                           ! 420     unsigned char ebda_size;
00587                                           !BCC_EOS
00588                                           ! 421     unsigned char cmos_shutdown_status;
00589                                           !BCC_EOS
00590                                           ! 422     unsigned char filler1[0x3B];
00591                                           !BCC_EOS
00592                                           ! 423     unsigned char fdpt0[0x10];
00593                                           !BCC_EOS
00594                                           ! 424     unsigned char fdpt1[0x10];
00595                                           !BCC_EOS
00596                                           ! 425     unsigned char filler2[0xC4];
00597                                           !BCC_EOS
00598                                           ! 426     ata_t ata;
00599                                           !BCC_EOS
00600                                           ! 427     cdemu_t cdemu;
00601                                           !BCC_EOS
00602                                           ! 428     } ebda_data_t;
00603                                           !BCC_EOS
00604                                           ! 429   typedef struct {
00605                                           ! 430     Bit8u size;
00606                                           !BCC_EOS
00607                                           ! 431     Bit8u reserved;
00608                                           !BCC_EOS
00609                                           ! 432     Bit16u count;
00610                                           !BCC_EOS
00611                                           ! 433     Bit16u offset;
00612                                           !BCC_EOS
00613                                           ! 434     Bit16u segment;
00614                                           !BCC_EOS
00615                                           ! 435     Bit32u lba1;
00616                                           !BCC_EOS
00617                                           ! 436     Bit32u lba2;
00618                                           !BCC_EOS
00619                                           ! 437     } int13ext_t;
00620                                           !BCC_EOS
00621                                           ! 438   typedef struct {
00622                                           ! 439     Bit16u size;
00623                                           !BCC_EOS
00624                                           ! 440     Bit16u infos;
00625                                           !BCC_EOS
00626                                           ! 441     Bit32u cylinders;
00627                                           !BCC_EOS
00628                                           ! 442     Bit32u heads;
00629                                           !BCC_EOS
00630                                           ! 443     Bit32u spt;
00631                                           !BCC_EOS
00632                                           ! 444     Bit32u sector_count1;
00633                                           !BCC_EOS
00634                                           ! 445     Bit32u sector_count2;
00635                                           !BCC_EOS
00636                                           ! 446     Bit16u blksize;
00637                                           !BCC_EOS
00638                                           ! 447     Bit16u dpte_offset;
00639                                           !BCC_EOS
00640                                           ! 448     Bit16u dpte_segment;
00641                                           !BCC_EOS
00642                                           ! 449     Bit1
00643                                           ! 449 6u key;
00644                                           !BCC_EOS
00645                                           ! 450     Bit8u dpi_length;
00646                                           !BCC_EOS
00647                                           ! 451     Bit8u reserved1;
00648                                           !BCC_EOS
00649                                           ! 452     Bit16u reserved2;
00650                                           !BCC_EOS
00651                                           ! 453     Bit8u host_bus[4];
00652                                           !BCC_EOS
00653                                           ! 454     Bit8u iface_type[8];
00654                                           !BCC_EOS
00655                                           ! 455     Bit8u iface_path[8];
00656                                           !BCC_EOS
00657                                           ! 456     Bit8u device_path[8];
00658                                           !BCC_EOS
00659                                           ! 457     Bit8u reserved3;
00660                                           !BCC_EOS
00661                                           ! 458     Bit8u checksum;
00662                                           !BCC_EOS
00663                                           ! 459     } dpt_t;
00664                                           !BCC_EOS
00665                                           ! 460 typedef struct {
00666                                           ! 461   union {
00667                                           ! 462     struct {
00668                                           ! 463       Bit16u di, si, bp, sp;
00669                                           !BCC_EOS
00670                                           ! 464       Bit16u bx, dx, cx, ax;
00671                                           !BCC_EOS
00672                                           ! 465       } r16;
00673                                           !BCC_EOS
00674                                           ! 466     struct {
00675                                           ! 467       Bit16u filler[4];
00676                                           !BCC_EOS
00677                                           ! 468       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00678                                           !BCC_EOS
00679                                           ! 469       } r8;
00680                                           !BCC_EOS
00681                                           ! 470     } u;
00682                                           !BCC_EOS
00683                                           ! 471   } pusha_regs_t;
00684                                           !BCC_EOS
00685                                           ! 472 typedef struct {
00686                                           ! 473  union {
00687                                           ! 474   struct {
00688                                           ! 475     Bit32u edi, esi, ebp, esp;
00689                                           !BCC_EOS
00690                                           ! 476     Bit32u ebx, edx, ecx, eax;
00691                                           !BCC_EOS
00692                                           ! 477     } r32;
00693                                           !BCC_EOS
00694                                           ! 478   struct {
00695                                           ! 479     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00696                                           !BCC_EOS
00697                                           ! 480     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00698                                           !BCC_EOS
00699                                           ! 481     } r16;
00700                                           !BCC_EOS
00701                                           ! 482   struct {
00702                                           ! 483     Bit32u filler[4];
00703                                           !BCC_EOS
00704                                           ! 484     Bit8u bl, bh;
00705                                           !BCC_EOS
00706                                           ! 485     Bit16u filler1;
00707                                           !BCC_EOS
00708                                           ! 486     Bit8u dl, dh;
00709                                           !BCC_EOS
00710                                           ! 487     Bit16u filler2;
00711                                           !BCC_EOS
00712                                           ! 488     Bit8u cl, ch;
00713                                           !BCC_EOS
00714                                           ! 489     Bit16u filler3;
00715                                           !BCC_EOS
00716                                           ! 490     Bit8u al, ah;
00717                                           !BCC_EOS
00718                                           ! 491     Bit16u filler4;
00719                                           !BCC_EOS
00720                                           ! 492     } r8;
00721                                           !BCC_EOS
00722                                           ! 493   } u;
00723                                           !BCC_EOS
00724                                           ! 494 } pushad_regs_t;
00725                                           !BCC_EOS
00726                                           ! 495 typedef struct {
00727                                           ! 496   union {
00728                                           ! 497     struct {
00729                                           ! 498       Bit16u flags;
00730                                           !BCC_EOS
00731                                           ! 499       } r16;
00732                                           !BCC_EOS
00733                                           ! 500     struct {
00734                                           ! 501       Bit8u flagsl;
00735                                           !BCC_EOS
00736                                           ! 502       Bit8u flagsh;
00737                                           !BCC_EOS
00738                                           ! 503       } r8;
00739                                           !BCC_EOS
00740                                           ! 504     } u;
00741                                           !BCC_EOS
00742                                           ! 505   } flags_t;
00743                                           !BCC_EOS
00744                                           ! 506 typedef struct {
00745                                           ! 507   Bit16u ip;
00746                                           !BCC_EOS
00747                                           ! 508   Bit16u cs;
00748                                           !BCC_EOS
00749                                           ! 509   flags_t flags;
00750                                           !BCC_EOS
00751                                           ! 510   } iret_addr_t;
00752                                           !BCC_EOS
00753                                           ! 511 typedef struct {
00754                                           ! 512   Bit16u type;
00755                                           !BCC_EOS
00756                                           ! 513   Bit16u flags;
00757                                           !BCC_EOS
00758                                           ! 514   Bit32u vector;
00759                                           !BCC_EOS
00760                                           ! 515   Bit32u description;
00761                                           !BCC_EOS
00762                                           ! 516   Bit32u reserved;
00763                                           !BCC_EOS
00764                                           ! 517   } ipl_entry_t;
00765                                           !BCC_EOS
00766                                           ! 518 static Bit8u inb();
00767                                           !BCC_EOS
00768                                           ! 519 static Bit8u inb_cmos();
00769                                           !BCC_EOS
00770                                           ! 520 static void outb();
00771                                           !BCC_EOS
00772                                           ! 521 static void outb_cmos();
00773                                           !BCC_EOS
00774                                           ! 522 static Bit16u inw();
00775                                           !BCC_EOS
00776                                           ! 523 static void outw();
00777                                           !BCC_EOS
00778                                           ! 524 static void init_rtc();
00779                                           !BCC_EOS
00780                                           ! 525 static bx_bool rtc_updating();
00781                                           !BCC_EOS
00782                                           ! 526 static Bit8u read_byte();
00783                                           !BCC_EOS
00784                                           ! 527 static Bit16u read_word();
00785                                           !BCC_EOS
00786                                           ! 528 static void write_byte();
00787                                           !BCC_EOS
00788                                           ! 529 static void write_word();
00789                                           !BCC_EOS
00790                                           ! 530 static void bios_printf();
00791                                           !BCC_EOS
00792                                           ! 531 static Bit8u inhibit_mouse_int_and_events();
00793                                           !BCC_EOS
00794                                           ! 532 static void enable_mouse_int_and_events();
00795                                           !BCC_EOS
00796                                           ! 533 static Bit8u send_to_mouse_ctrl();
00797                                           !BCC_EOS
00798                                           ! 534 static Bit8u get_mouse_data();
00799                                           !BCC_EOS
00800                                           ! 535 static void set_kbd_command_byte();
00801                                           !BCC_EOS
00802                                           ! 536 static void int09_function();
00803                                           !BCC_EOS
00804                                           ! 537 static void int13_harddisk();
00805                                           !BCC_EOS
00806                                           ! 538 static void int13_cdrom();
00807                                           !BCC_EOS
00808                                           ! 539 static void int13_cdemu();
00809                                           !BCC_EOS
00810                                           ! 540 static void int13_eltorito();
00811                                           !BCC_EOS
00812                                           ! 541 static void int13_diskette_function();
00813                                           !BCC_EOS
00814                                           ! 542 static void int14_function();
00815                                           !BCC_EOS
00816                                           ! 543 static void int15_function();
00817                                           !BCC_EOS
00818                                           ! 544 sta
00819                                           ! 544 tic void int16_function();
00820                                           !BCC_EOS
00821                                           ! 545 static void int17_function();
00822                                           !BCC_EOS
00823                                           ! 546 static void int18_function();
00824                                           !BCC_EOS
00825                                           ! 547 static void int1a_function();
00826                                           !BCC_EOS
00827                                           ! 548 static void int70_function();
00828                                           !BCC_EOS
00829                                           ! 549 static void int74_function();
00830                                           !BCC_EOS
00831                                           ! 550 static Bit16u get_CS();
00832                                           !BCC_EOS
00833                                           ! 551 static Bit16u get_SS();
00834                                           !BCC_EOS
00835                                           ! 552 static unsigned int enqueue_key();
00836                                           !BCC_EOS
00837                                           ! 553 static unsigned int dequeue_key();
00838                                           !BCC_EOS
00839                                           ! 554 static void get_hd_geometry();
00840                                           !BCC_EOS
00841                                           ! 555 static void set_diskette_ret_status();
00842                                           !BCC_EOS
00843                                           ! 556 static void set_diskette_current_cyl();
00844                                           !BCC_EOS
00845                                           ! 557 static void determine_floppy_media();
00846                                           !BCC_EOS
00847                                           ! 558 static bx_bool floppy_drive_exists();
00848                                           !BCC_EOS
00849                                           ! 559 static bx_bool floppy_drive_recal();
00850                                           !BCC_EOS
00851                                           ! 560 static bx_bool floppy_media_known();
00852                                           !BCC_EOS
00853                                           ! 561 static bx_bool floppy_media_sense();
00854                                           !BCC_EOS
00855                                           ! 562 static bx_bool set_enable_a20();
00856                                           !BCC_EOS
00857                                           ! 563 static void debugger_on();
00858                                           !BCC_EOS
00859                                           ! 564 static void debugger_off();
00860                                           !BCC_EOS
00861                                           ! 565 static void keyboard_init();
00862                                           !BCC_EOS
00863                                           ! 566 static void keyboard_panic();
00864                                           !BCC_EOS
00865                                           ! 567 static void shutdown_status_panic();
00866                                           !BCC_EOS
00867                                           ! 568 static void nmi_handler_msg();
00868                                           !BCC_EOS
00869                                           ! 569 static void delay_ticks();
00870                                           !BCC_EOS
00871                                           ! 570 static void delay_ticks_and_check_for_keystroke();
00872                                           !BCC_EOS
00873                                           ! 571 static void interactive_bootkey();
00874                                           !BCC_EOS
00875                                           ! 572 static void print_bios_banner();
00876                                           !BCC_EOS
00877                                           ! 573 static void print_boot_device();
00878                                           !BCC_EOS
00879                                           ! 574 static void print_boot_failure();
00880                                           !BCC_EOS
00881                                           ! 575 static void print_cdromboot_failure();
00882                                           !BCC_EOS
00883                                           ! 576 void ata_init();
00884                                           !BCC_EOS
00885                                           ! 577 void ata_detect();
00886                                           !BCC_EOS
00887                                           ! 578 void ata_reset();
00888                                           !BCC_EOS
00889                                           ! 579 Bit16u ata_cmd_non_data();
00890                                           !BCC_EOS
00891                                           ! 580 Bit16u ata_cmd_data_in();
00892                                           !BCC_EOS
00893                                           ! 581 Bit16u ata_cmd_data_out();
00894                                           !BCC_EOS
00895                                           ! 582 Bit16u ata_cmd_packet();
00896                                           !BCC_EOS
00897                                           ! 583 Bit16u atapi_get_sense();
00898                                           !BCC_EOS
00899                                           ! 584 Bit16u atapi_is_ready();
00900                                           !BCC_EOS
00901                                           ! 585 Bit16u atapi_is_cdrom();
00902                                           !BCC_EOS
00903                                           ! 586 void cdemu_init();
00904                                           !BCC_EOS
00905                                           ! 587 Bit8u cdemu_isactive();
00906                                           !BCC_EOS
00907                                           ! 588 Bit8u cdemu_emulated_drive();
00908                                           !BCC_EOS
00909                                           ! 589 Bit16u cdrom_boot();
00910                                           !BCC_EOS
00911                                           ! 590 static char bios_cvs_version_string[] = "$Revision: 1.221 $ $Date: 2008/12/07 17:32:29 $";
00912                                           
00913                       00000194            _bios_cvs_version_string:
00914                       00000194            .1:
00915 0194                        24            .ascii	"$Revision: 1.221 $ $Date: 2008/12/07 17:"
00916 01BC                        33            .ascii	"32:29 $"
00917 01C3                        00            .byte	0
00918                                           !BCC_EOS
00919                                           ! 591 static struct {
00920                                           ! 592   Bit16u normal;
00921                                           !BCC_EOS
00922                                           ! 593   Bit16u shift;
00923                                           !BCC_EOS
00924                                           ! 594   Bit16u control;
00925                                           !BCC_EOS
00926                                           ! 595   Bit16u alt;
00927                                           !BCC_EOS
00928                                           ! 596   Bit8u lock_flags;
00929                                           !BCC_EOS
00930                                           ! 597   } scan_to_scanascii[0x58 + 1] = {
00931                       000001C4            _scan_to_scanascii:
00932                                           ! 598       { 0, 0, 0, 0, 0 },
00933 01C4                      0000            .word	0
00934 01C6                      0000            .word	0
00935 01C8                      0000            .word	0
00936 01CA                      0000            .word	0
00937 01CC                        00            .byte	0
00938 01CD                  00000001            .blkb	1
00939                                           ! 599       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00940 01CE                      011B            .word	$11B
00941 01D0                      011B            .word	$11B
00942 01D2                      011B            .word	$11B
00943 01D4                      0100            .word	$100
00944 01D6                        00            .byte	0
00945 01D7                  00000001            .blkb	1
00946                                           ! 600       { 0x0231, 0x0221, 0, 0x7800, 0 },
00947 01D8                      0231            .word	$231
00948 01DA                      0221            .word	$221
00949 01DC                      0000            .word	0
00950 01DE                      7800            .word	$7800
00951 01E0                        00            .byte	0
00952 01E1                  00000001            .blkb	1
00953                                           ! 601       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00954 01E2                      0332            .word	$332
00955 01E4                      0340            .word	$340
00956 01E6                      0300            .word	$300
00957 01E8                      7900            .word	$7900
00958 01EA                        00            .byte	0
00959 01EB                  00000001            .blkb	1
00960                                           ! 602       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00961 01EC                      0433            .word	$433
00962 01EE                      0423            .word	$423
00963 01F0                      0000            .word	0
00964 01F2                      7A00            .word	$7A00
00965 01F4                        00            .byte	0
00966 01F5                  00000001            .blkb	1
00967                                           ! 603       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00968 01F6                      0534            .word	$534
00969 01F8                      0524            .word	$524
00970 01FA                      0000            .word	0
00971 01FC                      7B00            .word	$7B00
00972 01FE                        00            .byte	0
00973 01FF                  00000001            .blkb	1
00974                                           ! 604       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00975 0200                      0635            .word	$635
00976 0202                      0625            .word	$625
00977 0204                      0000            .word	0
00978 0206                      7C00            .word	$7C00
00979 0208                        00            .byte	0
00980 0209                  00000001            .blkb	1
00981                                           ! 605       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00982 020A                      0736            .word	$736
00983 020C                      075E            .word	$75E
00984 020E                      071E            .word	$71E
00985 0210                      7D00            .word	$7D00
00986 0212                        00            .byte	0
00987 0213                  00000001            .blkb	1
00988                                           ! 606       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00989 0214                      0837            .word	$837
00990 0216                      0826            .word	$826
00991 0218                      0000            .word	0
00992 021A                      7E00            .word	$7E00
00993 021C                        00            .byte	0
00994 021D                  00000001            .blkb	1
00995                                           ! 607       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00996 021E                      0938            .word	$938
00997 0220                      092A            .word	$92A
00998 0222                      0000            .word	0
00999 0224                      7F00            .word	$7F00
01000 0226                        00            .byte	0
01001 0227                  00000001            .blkb	1
01002                                           ! 608       { 0x0a39, 0x0a28, 0, 0x800
01003 0228                      0A39            .word	$A39
01004 022A                      0A28            .word	$A28
01005 022C                      0000            .word	0
01006                                           ! 608 0, 0 },
01007 022E                      8000            .word	$8000
01008 0230                        00            .byte	0
01009 0231                  00000001            .blkb	1
01010                                           ! 609       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
01011 0232                      0B30            .word	$B30
01012 0234                      0B29            .word	$B29
01013 0236                      0000            .word	0
01014 0238                      8100            .word	$8100
01015 023A                        00            .byte	0
01016 023B                  00000001            .blkb	1
01017                                           ! 610       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01018 023C                      0C2D            .word	$C2D
01019 023E                      0C5F            .word	$C5F
01020 0240                      0C1F            .word	$C1F
01021 0242                      8200            .word	$8200
01022 0244                        00            .byte	0
01023 0245                  00000001            .blkb	1
01024                                           ! 611       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01025 0246                      0D3D            .word	$D3D
01026 0248                      0D2B            .word	$D2B
01027 024A                      0000            .word	0
01028 024C                      8300            .word	$8300
01029 024E                        00            .byte	0
01030 024F                  00000001            .blkb	1
01031                                           ! 612       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01032 0250                      0E08            .word	$E08
01033 0252                      0E08            .word	$E08
01034 0254                      0E7F            .word	$E7F
01035 0256                      0000            .word	0
01036 0258                        00            .byte	0
01037 0259                  00000001            .blkb	1
01038                                           ! 613       { 0x0f09, 0x0f00, 0, 0, 0 },
01039 025A                      0F09            .word	$F09
01040 025C                      0F00            .word	$F00
01041 025E                      0000            .word	0
01042 0260                      0000            .word	0
01043 0262                        00            .byte	0
01044 0263                  00000001            .blkb	1
01045                                           ! 614       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01046 0264                      1071            .word	$1071
01047 0266                      1051            .word	$1051
01048 0268                      1011            .word	$1011
01049 026A                      1000            .word	$1000
01050 026C                        40            .byte	$40
01051 026D                  00000001            .blkb	1
01052                                           ! 615       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
01053 026E                      1177            .word	$1177
01054 0270                      1157            .word	$1157
01055 0272                      1117            .word	$1117
01056 0274                      1100            .word	$1100
01057 0276                        40            .byte	$40
01058 0277                  00000001            .blkb	1
01059                                           ! 616       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01060 0278                      1265            .word	$1265
01061 027A                      1245            .word	$1245
01062 027C                      1205            .word	$1205
01063 027E                      1200            .word	$1200
01064 0280                        40            .byte	$40
01065 0281                  00000001            .blkb	1
01066                                           ! 617       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01067 0282                      1372            .word	$1372
01068 0284                      1352            .word	$1352
01069 0286                      1312            .word	$1312
01070 0288                      1300            .word	$1300
01071 028A                        40            .byte	$40
01072 028B                  00000001            .blkb	1
01073                                           ! 618       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01074 028C                      1474            .word	$1474
01075 028E                      1454            .word	$1454
01076 0290                      1414            .word	$1414
01077 0292                      1400            .word	$1400
01078 0294                        40            .byte	$40
01079 0295                  00000001            .blkb	1
01080                                           ! 619       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01081 0296                      1579            .word	$1579
01082 0298                      1559            .word	$1559
01083 029A                      1519            .word	$1519
01084 029C                      1500            .word	$1500
01085 029E                        40            .byte	$40
01086 029F                  00000001            .blkb	1
01087                                           ! 620       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01088 02A0                      1675            .word	$1675
01089 02A2                      1655            .word	$1655
01090 02A4                      1615            .word	$1615
01091 02A6                      1600            .word	$1600
01092 02A8                        40            .byte	$40
01093 02A9                  00000001            .blkb	1
01094                                           ! 621       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01095 02AA                      1769            .word	$1769
01096 02AC                      1749            .word	$1749
01097 02AE                      1709            .word	$1709
01098 02B0                      1700            .word	$1700
01099 02B2                        40            .byte	$40
01100 02B3                  00000001            .blkb	1
01101                                           ! 622       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01102 02B4                      186F            .word	$186F
01103 02B6                      184F            .word	$184F
01104 02B8                      180F            .word	$180F
01105 02BA                      1800            .word	$1800
01106 02BC                        40            .byte	$40
01107 02BD                  00000001            .blkb	1
01108                                           ! 623       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01109 02BE                      1970            .word	$1970
01110 02C0                      1950            .word	$1950
01111 02C2                      1910            .word	$1910
01112 02C4                      1900            .word	$1900
01113 02C6                        40            .byte	$40
01114 02C7                  00000001            .blkb	1
01115                                           ! 624       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01116 02C8                      1A5B            .word	$1A5B
01117 02CA                      1A7B            .word	$1A7B
01118 02CC                      1A1B            .word	$1A1B
01119 02CE                      0000            .word	0
01120 02D0                        00            .byte	0
01121 02D1                  00000001            .blkb	1
01122                                           ! 625       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01123 02D2                      1B5D            .word	$1B5D
01124 02D4                      1B7D            .word	$1B7D
01125 02D6                      1B1D            .word	$1B1D
01126 02D8                      0000            .word	0
01127 02DA                        00            .byte	0
01128 02DB                  00000001            .blkb	1
01129                                           ! 626       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01130 02DC                      1C0D            .word	$1C0D
01131 02DE                      1C0D            .word	$1C0D
01132 02E0                      1C0A            .word	$1C0A
01133 02E2                      0000            .word	0
01134 02E4                        00            .byte	0
01135 02E5                  00000001            .blkb	1
01136                                           ! 627       { 0, 0, 0, 0, 0 },
01137 02E6                      0000            .word	0
01138 02E8                      0000            .word	0
01139 02EA                      0000            .word	0
01140 02EC                      0000            .word	0
01141 02EE                        00            .byte	0
01142 02EF                  00000001            .blkb	1
01143                                           ! 628       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01144 02F0                      1E61            .word	$1E61
01145 02F2                      1E41            .word	$1E41
01146 02F4                      1E01            .word	$1E01
01147 02F6                      1E00            .word	$1E00
01148 02F8                        40            .byte	$40
01149 02F9                  00000001            .blkb	1
01150                                           ! 629       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01151 02FA                      1F73            .word	$1F73
01152 02FC                      1F53            .word	$1F53
01153 02FE                      1F13            .word	$1F13
01154 0300                      1F00            .word	$1F00
01155 0302                        40            .byte	$40
01156 0303                  00000001            .blkb	1
01157                                           ! 630       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01158 0304                      2064            .word	$2064
01159 0306                      2044            .word	$2044
01160 0308                      2004            .word	$2004
01161 030A                      2000            .word	$2000
01162 030C                        40            .byte	$40
01163 030D                  00000001            .blkb	1
01164                                           ! 631       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01165 030E                      2166            .word	$2166
01166 0310                      2146            .word	$2146
01167 0312                      2106            .word	$2106
01168 0314                      2100            .word	$2100
01169 0316                        40            .byte	$40
01170 0317                  00000001            .blkb	1
01171                                           ! 632       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01172 0318                      2267            .word	$2267
01173 031A                      2247            .word	$2247
01174 031C                      2207            .word	$2207
01175 031E                      2200            .word	$2200
01176 0320                        40            .byte	$40
01177 0321                  00000001            .blkb	1
01178                                           ! 633       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01179 0322                      2368            .word	$2368
01180 0324                      2348            .word	$2348
01181 0326                      2308            .word	$2308
01182 0328                      2300            .word	$2300
01183 032A                        40            .byte	$40
01184 032B                  00000001            .blkb	1
01185                                           ! 634       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01186 032C                      246A            .word	$246A
01187 032E                      244A            .word	$244A
01188 0330                      240A            .word	$240A
01189 0332                      2400            .word	$2400
01190 0334                        40            .byte	$40
01191 0335                  00000001            .blkb	1
01192                                           ! 635       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01193 0336                      256B            .word	$256B
01194 0338                      254B            .word	$254B
01195 033A                      250B            .word	$250B
01196 033C                      2500            .word	$2500
01197 033E                        40            .byte	$40
01198 033F                  00000001            .blkb	1
01199                                           ! 636       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01200 0340                      266C            .word	$266C
01201 0342                      264C            .word	$264C
01202 0344                      260C            .word	$260C
01203 0346                      2600            .word	$2600
01204 0348                        40            .byte	$40
01205 0349                  00000001            .blkb	1
01206                                           ! 637       { 0x273b, 0x273a, 0, 0, 0 },
01207 034A                      273B            .word	$273B
01208 034C                      273A            .word	$273A
01209 034E                      0000            .word	0
01210 0350                      0000            .word	0
01211 0352                        00            .byte	0
01212 0353                  00000001            .blkb	1
01213                                           ! 638       { 0x2827, 0x2822, 0, 0, 0 },
01214 0354                      2827            .word	$2827
01215 0356                      2822            .word	$2822
01216 0358                      0000            .word	0
01217 035A                      0000            .word	0
01218 035C                        00            .byte	0
01219 035D                  00000001            .blkb	1
01220                                           ! 639       { 0x2960, 0x297e, 0, 0, 0 },
01221 035E                      2960            .word	$2960
01222 0360                      297E            .word	$297E
01223 0362                      0000            .word	0
01224 0364                      0000            .word	0
01225 0366                        00            .byte	0
01226 0367                  00000001            .blkb	1
01227                                           ! 640       { 0, 0, 0, 0, 0 },
01228 0368                      0000            .word	0
01229 036A                      0000            .word	0
01230 036C                      0000            .word	0
01231 036E                      0000            .word	0
01232 0370                        00            .byte	0
01233 0371                  00000001            .blkb	1
01234                                           ! 641       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01235 0372                      2B5C            .word	$2B5C
01236 0374                      2B7C            .word	$2B7C
01237 0376                      2B1C            .word	$2B1C
01238 0378                      0000            .word	0
01239 037A                        00            .byte	0
01240 037B                  00000001            .blkb	1
01241                                           ! 642       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01242 037C                      2C7A            .word	$2C7A
01243 037E                      2C5A            .word	$2C5A
01244 0380                      2C1A            .word	$2C1A
01245 0382                      2C00            .word	$2C00
01246 0384                        40            .byte	$40
01247 0385                  00000001            .blkb	1
01248                                           ! 643       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01249 0386                      2D78            .word	$2D78
01250 0388                      2D58            .word	$2D58
01251 038A                      2D18            .word	$2D18
01252 038C                      2D00            .word	$2D00
01253 038E                        40            .byte	$40
01254 038F                  00000001            .blkb	1
01255                                           ! 644       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01256 0390                      2E63            .word	$2E63
01257 0392                      2E43            .word	$2E43
01258 0394                      2E03            .word	$2E03
01259 0396                      2E00            .word	$2E00
01260 0398                        40            .byte	$40
01261 0399                  00000001            .blkb	1
01262                                           ! 645       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01263 039A                      2F76            .word	$2F76
01264 039C                      2F56            .word	$2F56
01265 039E                      2F16            .word	$2F16
01266 03A0                      2F00            .word	$2F00
01267 03A2                        40            .byte	$40
01268 03A3                  00000001            .blkb	1
01269                                           ! 646       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01270 03A4                      3062            .word	$3062
01271 03A6                      3042            .word	$3042
01272 03A8                      3002            .word	$3002
01273 03AA                      3000            .word	$3000
01274 03AC                        40            .byte	$40
01275 03AD                  00000001            .blkb	1
01276                                           ! 647       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01277 03AE                      316E            .word	$316E
01278 03B0                      314E            .word	$314E
01279 03B2                      310E            .word	$310E
01280 03B4                      3100            .word	$3100
01281 03B6                        40            .byte	$40
01282 03B7                  00000001            .blkb	1
01283                                           ! 648       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01284 03B8                      326D            .word	$326D
01285 03BA                      324D            .word	$324D
01286 03BC                      320D            .word	$320D
01287 03BE                      3200            .word	$3200
01288 03C0                        40            .byte	$40
01289 03C1                  00000001            .blkb	1
01290                                           ! 649       { 0x332c, 0x333c, 0, 0, 0 },
01291 03C2                      332C            .word	$332C
01292 03C4                      333C            .word	$333C
01293 03C6                      0000            .word	0
01294 03C8                      0000            .word	0
01295 03CA                        00            .byte	0
01296 03CB                  00000001            .blkb	1
01297                                           ! 650       { 0x342e, 0x343e, 0, 0, 0 },
01298 03CC                      342E            .word	$342E
01299 03CE                      343E            .word	$343E
01300 03D0                      0000            .word	0
01301 03D2                      0000            .word	0
01302 03D4                        00            .byte	0
01303 03D5                  00000001            .blkb	1
01304                                           ! 651       { 0x352f, 0x353f, 0, 0, 0 },
01305 03D6                      352F            .word	$352F
01306 03D8                      353F            .word	$353F
01307 03DA                      0000            .word	0
01308 03DC                      0000            .word	0
01309 03DE                        00            .byte	0
01310 03DF                  00000001            .blkb	1
01311                                           ! 652       { 0, 0, 0, 0, 0 },
01312 03E0                      0000            .word	0
01313 03E2                      0000            .word	0
01314 03E4                      0000            .word	0
01315 03E6                      0000            .word	0
01316 03E8                        00            .byte	0
01317 03E9                  00000001            .blkb	1
01318                                           ! 653       { 0x372a, 0x372a, 0, 0, 0 },
01319 03EA                      372A            .word	$372A
01320 03EC                      372A            .word	$372A
01321 03EE                      0000            .word	0
01322 03F0                      0000            .word	0
01323 03F2                        00            .byte	0
01324 03F3                  00000001            .blkb	1
01325                                           ! 654       { 0, 0, 0, 0, 0 },
01326 03F4                      0000            .word	0
01327 03F6                      0000            .word	0
01328 03F8                      0000            .word	0
01329 03FA                      0000            .word	0
01330 03FC                        00            .byte	0
01331 03FD                  00000001            .blkb	1
01332                                           ! 655       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01333 03FE                      3920            .word	$3920
01334 0400                      3920            .word	$3920
01335 0402                      3920            .word	$3920
01336 0404                      3920            .word	$3920
01337 0406                        00            .byte	0
01338 0407                  00000001            .blkb	1
01339                                           ! 656       { 0, 0, 0, 0, 0 },
01340 0408                      0000            .word	0
01341 040A                      0000            .word	0
01342 040C                      0000            .word	0
01343 040E                      0000            .word	0
01344 0410                        00            .byte	0
01345 0411                  00000001            .blkb	1
01346                                           ! 657       { 0x3b00, 0
01347 0412                      3B00            .word	$3B00
01348                                           ! 657 x5400, 0x5e00, 0x6800, 0 },
01349 0414                      5400            .word	$5400
01350 0416                      5E00            .word	$5E00
01351 0418                      6800            .word	$6800
01352 041A                        00            .byte	0
01353 041B                  00000001            .blkb	1
01354                                           ! 658       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01355 041C                      3C00            .word	$3C00
01356 041E                      5500            .word	$5500
01357 0420                      5F00            .word	$5F00
01358 0422                      6900            .word	$6900
01359 0424                        00            .byte	0
01360 0425                  00000001            .blkb	1
01361                                           ! 659       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01362 0426                      3D00            .word	$3D00
01363 0428                      5600            .word	$5600
01364 042A                      6000            .word	$6000
01365 042C                      6A00            .word	$6A00
01366 042E                        00            .byte	0
01367 042F                  00000001            .blkb	1
01368                                           ! 660       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01369 0430                      3E00            .word	$3E00
01370 0432                      5700            .word	$5700
01371 0434                      6100            .word	$6100
01372 0436                      6B00            .word	$6B00
01373 0438                        00            .byte	0
01374 0439                  00000001            .blkb	1
01375                                           ! 661       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01376 043A                      3F00            .word	$3F00
01377 043C                      5800            .word	$5800
01378 043E                      6200            .word	$6200
01379 0440                      6C00            .word	$6C00
01380 0442                        00            .byte	0
01381 0443                  00000001            .blkb	1
01382                                           ! 662       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01383 0444                      4000            .word	$4000
01384 0446                      5900            .word	$5900
01385 0448                      6300            .word	$6300
01386 044A                      6D00            .word	$6D00
01387 044C                        00            .byte	0
01388 044D                  00000001            .blkb	1
01389                                           ! 663       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01390 044E                      4100            .word	$4100
01391 0450                      5A00            .word	$5A00
01392 0452                      6400            .word	$6400
01393 0454                      6E00            .word	$6E00
01394 0456                        00            .byte	0
01395 0457                  00000001            .blkb	1
01396                                           ! 664       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01397 0458                      4200            .word	$4200
01398 045A                      5B00            .word	$5B00
01399 045C                      6500            .word	$6500
01400 045E                      6F00            .word	$6F00
01401 0460                        00            .byte	0
01402 0461                  00000001            .blkb	1
01403                                           ! 665       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01404 0462                      4300            .word	$4300
01405 0464                      5C00            .word	$5C00
01406 0466                      6600            .word	$6600
01407 0468                      7000            .word	$7000
01408 046A                        00            .byte	0
01409 046B                  00000001            .blkb	1
01410                                           ! 666       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01411 046C                      4400            .word	$4400
01412 046E                      5D00            .word	$5D00
01413 0470                      6700            .word	$6700
01414 0472                      7100            .word	$7100
01415 0474                        00            .byte	0
01416 0475                  00000001            .blkb	1
01417                                           ! 667       { 0, 0, 0, 0, 0 },
01418 0476                      0000            .word	0
01419 0478                      0000            .word	0
01420 047A                      0000            .word	0
01421 047C                      0000            .word	0
01422 047E                        00            .byte	0
01423 047F                  00000001            .blkb	1
01424                                           ! 668       { 0, 0, 0, 0, 0 },
01425 0480                      0000            .word	0
01426 0482                      0000            .word	0
01427 0484                      0000            .word	0
01428 0486                      0000            .word	0
01429 0488                        00            .byte	0
01430 0489                  00000001            .blkb	1
01431                                           ! 669       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01432 048A                      4700            .word	$4700
01433 048C                      4737            .word	$4737
01434 048E                      7700            .word	$7700
01435 0490                      0000            .word	0
01436 0492                        20            .byte	$20
01437 0493                  00000001            .blkb	1
01438                                           ! 670       { 0x4800, 0x4838, 0, 0, 0x20 },
01439 0494                      4800            .word	$4800
01440 0496                      4838            .word	$4838
01441 0498                      0000            .word	0
01442 049A                      0000            .word	0
01443 049C                        20            .byte	$20
01444 049D                  00000001            .blkb	1
01445                                           ! 671       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01446 049E                      4900            .word	$4900
01447 04A0                      4939            .word	$4939
01448 04A2                      8400            .word	$8400
01449 04A4                      0000            .word	0
01450 04A6                        20            .byte	$20
01451 04A7                  00000001            .blkb	1
01452                                           ! 672       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01453 04A8                      4A2D            .word	$4A2D
01454 04AA                      4A2D            .word	$4A2D
01455 04AC                      0000            .word	0
01456 04AE                      0000            .word	0
01457 04B0                        00            .byte	0
01458 04B1                  00000001            .blkb	1
01459                                           ! 673       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01460 04B2                      4B00            .word	$4B00
01461 04B4                      4B34            .word	$4B34
01462 04B6                      7300            .word	$7300
01463 04B8                      0000            .word	0
01464 04BA                        20            .byte	$20
01465 04BB                  00000001            .blkb	1
01466                                           ! 674       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01467 04BC                      4C00            .word	$4C00
01468 04BE                      4C35            .word	$4C35
01469 04C0                      0000            .word	0
01470 04C2                      0000            .word	0
01471 04C4                        20            .byte	$20
01472 04C5                  00000001            .blkb	1
01473                                           ! 675       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01474 04C6                      4D00            .word	$4D00
01475 04C8                      4D36            .word	$4D36
01476 04CA                      7400            .word	$7400
01477 04CC                      0000            .word	0
01478 04CE                        20            .byte	$20
01479 04CF                  00000001            .blkb	1
01480                                           ! 676       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01481 04D0                      4E2B            .word	$4E2B
01482 04D2                      4E2B            .word	$4E2B
01483 04D4                      0000            .word	0
01484 04D6                      0000            .word	0
01485 04D8                        00            .byte	0
01486 04D9                  00000001            .blkb	1
01487                                           ! 677       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01488 04DA                      4F00            .word	$4F00
01489 04DC                      4F31            .word	$4F31
01490 04DE                      7500            .word	$7500
01491 04E0                      0000            .word	0
01492 04E2                        20            .byte	$20
01493 04E3                  00000001            .blkb	1
01494                                           ! 678       { 0x5000, 0x5032, 0, 0, 0x20 },
01495 04E4                      5000            .word	$5000
01496 04E6                      5032            .word	$5032
01497 04E8                      0000            .word	0
01498 04EA                      0000            .word	0
01499 04EC                        20            .byte	$20
01500 04ED                  00000001            .blkb	1
01501                                           ! 679       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01502 04EE                      5100            .word	$5100
01503 04F0                      5133            .word	$5133
01504 04F2                      7600            .word	$7600
01505 04F4                      0000            .word	0
01506 04F6                        20            .byte	$20
01507 04F7                  00000001            .blkb	1
01508                                           ! 680       { 0x5200, 0x5230, 0, 0, 0x20 },
01509 04F8                      5200            .word	$5200
01510 04FA                      5230            .word	$5230
01511 04FC                      0000            .word	0
01512 04FE                      0000            .word	0
01513 0500                        20            .byte	$20
01514 0501                  00000001            .blkb	1
01515                                           ! 681       { 0x5300, 0x532e, 0, 0, 0x20 },
01516 0502                      5300            .word	$5300
01517 0504                      532E            .word	$532E
01518 0506                      0000            .word	0
01519 0508                      0000            .word	0
01520 050A                        20            .byte	$20
01521 050B                  00000001            .blkb	1
01522                                           ! 682       { 0, 0, 0, 0, 0 },
01523 050C                      0000            .word	0
01524 050E                      0000            .word	0
01525 0510                      0000            .word	0
01526 0512                      0000            .word	0
01527 0514                        00            .byte	0
01528 0515                  00000001            .blkb	1
01529                                           ! 683       { 0, 0, 0, 0, 0 },
01530 0516                      0000            .word	0
01531 0518                      0000            .word	0
01532 051A                      0000            .word	0
01533 051C                      0000            .word	0
01534 051E                        00            .byte	0
01535 051F                  00000001            .blkb	1
01536                                           ! 684       { 0x565c, 0x567c, 0, 0, 0 },
01537 0520                      565C            .word	$565C
01538 0522                      567C            .word	$567C
01539 0524                      0000            .word	0
01540 0526                      0000            .word	0
01541 0528                        00            .byte	0
01542 0529                  00000001            .blkb	1
01543                                           ! 685       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01544 052A                      8500            .word	$8500
01545 052C                      8700            .word	$8700
01546 052E                      8900            .word	$8900
01547 0530                      8B00            .word	$8B00
01548 0532                        00            .byte	0
01549 0533                  00000001            .blkb	1
01550                                           ! 686       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01551 0534                      8600            .word	$8600
01552 0536                      8800            .word	$8800
01553 0538                      8A00            .word	$8A00
01554 053A                      8C00            .word	$8C00
01555 053C                        00            .byte	0
01556 053D                  00000001            .blkb	1
01557                                           ! 687       };
01558                                           !BCC_EOS
01559                                           ! 688   Bit8u
01560                                           ! 689 inb(port)
01561                                           ! 690   Bit16u port;
01562                                           
01563                                           export	_inb
01564                       0000053E            _inb:
01565                                           !BCC_EOS
01566                                           ! 691 {
01567                                           ! 692 #asm
01568                                           !BCC_ASM
01569                       00000002            _inb.port	set	2
01570 053E           55                           push bp
01571 053F           89E5                         mov bp, sp
01572 0541           52                             push dx
01573 0542           8B56         04                mov dx, 4[bp]
01574 0545           EC                             in al, dx
01575 0546           5A                             pop dx
01576 0547           5D                           pop bp
01577                                           ! 700 endasm
01578                                           !BCC_ENDASM
01579                                           ! 701 }
01580 0548           C3                         ret
01581                                           ! 702   Bit16u
01582                                           ! 703 inw(port)
01583                                           ! 704   Bit16u port;
01584                                           export	_inw
01585                       00000549            _inw:
01586                                           !BCC_EOS
01587                                           ! 705 {
01588                                           ! 706 #asm
01589                                           !BCC_ASM
01590                       00000002            _inw.port	set	2
01591 0549           55                           push bp
01592 054A           89E5                         mov bp, sp
01593 054C           52                             push dx
01594 054D           8B56         04                mov dx, 4[bp]
01595 0550           ED                             in ax, dx
01596 0551           5A                             pop dx
01597 0552           5D                           pop bp
01598                                           ! 714 endasm
01599                                           !BCC_ENDASM
01600                                           ! 715 }
01601 0553           C3                         ret
01602                                           ! 716   void
01603                                           ! 717 outb(port, val)
01604                                           ! 718   Bit16u port;
01605                                           export	_outb
01606                       00000554            _outb:
01607                                           !BCC_EOS
01608                                           ! 719   Bit8u val;
01609                                           !BCC_EOS
01610                                           ! 720 {
01611                                           ! 721 #asm
01612                                           !BCC_ASM
01613                       00000004            _outb.val	set	4
01614                       00000002            _outb.port	set	2
01615 0554           55                           push bp
01616 0555           89E5                         mov bp, sp
01617 0557           50                             push ax
01618 0558           52                             push dx
01619 0559           8B56         04                mov dx, 4[bp]
01620 055C           8A46         06                mov al, 6[bp]
01621 055F           EE                             out dx, al
01622 0560           5A                             pop dx
01623 0561           58                             pop ax
01624 0562           5D                           pop bp
01625                                           ! 732 endasm
01626                                           !BCC_ENDASM
01627                                           ! 733 }
01628 0563           C3                         ret
01629                                           ! 734   void
01630                                           ! 735 outw(port, val)
01631                                           ! 736   Bit16u port;
01632                                           export	_outw
01633                       00000564            _outw:
01634                                           !BCC_EOS
01635                                           ! 737   Bit16u val;
01636                                           !BCC_EOS
01637                                           ! 738 {
01638                                           ! 739 #asm
01639                                           !BCC_ASM
01640                       00000004            _outw.val	set	4
01641                       00000002            _outw.port	set	2
01642 0564           55                           push bp
01643 0565           89E5                         mov bp, sp
01644 0567           50                             push ax
01645 0568           52                             push dx
01646 0569           8B56         04                mov dx, 4[bp]
01647 056C           8B46         06                mov ax, 6[bp]
01648 056F           EF                             out dx, ax
01649 0570           5A                             pop dx
01650 0571           58                             pop ax
01651 0572           5D                           pop bp
01652                                           ! 750 endasm
01653                                           !BCC_ENDASM
01654                                           ! 751 }
01655 0573           C3                         ret
01656                                           ! 752   void
01657                                           ! 753 outb_cmos(cmos_reg, val)
01658                                           ! 754   Bit8u cmos_reg;
01659                                           export	_outb_cmos
01660                       00000574            _outb_cmos:
01661                                           !BCC_EOS
01662                                           ! 755   Bit8u val;
01663                                           !BCC_EOS
01664                                           ! 756 {
01665                                           ! 757 #asm
01666                                           !BCC_ASM
01667                       00000002            _outb_cmos.cmos_reg	set	2
01668                       00000004            _outb_cmos.val	set	4
01669 0574           55                           push bp
01670 0575           89E5                         mov bp, sp
01671 0577           8A46         04                mov al, 4[bp] ;; cmos_reg
01672 057A           E6                     70      out 0x70, al
01673 057C           8A46         06                mov al, 6[bp] ;; val
01674 057F           E6                     71      out 0x71, al
01675 0581           5D                           pop bp
01676                                           ! 765 e
01677                                           !BCC_ENDASM
01678                                           ! 766 }
01679 0582           C3                         ret
01680                                           ! 767   Bit8u
01681                                           ! 768 inb_cmos(cmos_reg)
01682                                           ! 769   Bit8u cmos_reg;
01683                                           export	_inb_cmos
01684                       00000583            _inb_cmos:
01685                                           !BCC_EOS
01686                                           ! 770 {
01687                                           ! 771 #asm
01688                                           !BCC_ASM
01689                       00000002            _inb_cmos.cmos_reg	set	2
01690 0583           55                           push bp
01691 0584           89E5                         mov bp, sp
01692 0586           8A46         04                mov al, 4[bp] ;; cmos_reg
01693 0589           E6                     70      out 0x70, al
01694 058B           E4                     71      in al, 0x71
01695 058D           5D                           pop bp
01696                                           ! 778 endasm
01697                                           !BCC_ENDASM
01698                                           ! 779 }
01699 058E           C3                         ret
01700                                           ! 780   void
01701                                           ! 781 init_rtc()
01702                                           ! 782 {
01703                                           export	_init_rtc
01704                       0000058F            _init_rtc:
01705                                           ! 783   outb_cmos(0x0a, 0x26);
01706 058F           55                         push	bp
01707 0590           89E5                       mov	bp,sp
01708                                           ! Debug: list int = const $26 (used reg = )
01709 0592           B8                   0026  mov	ax,*$26
01710 0595           50                         push	ax
01711                                           ! Debug: list int = const $A (used reg = )
01712 0596           B8                   000A  mov	ax,*$A
01713 0599           50                         push	ax
01714                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01715 059A           E8         FFD7            call	_outb_cmos
01716 059D           89EC                       mov	sp,bp
01717                                           !BCC_EOS
01718                                           ! 784   outb_cmos(0x0b, 0x02);
01719                                           ! Debug: list int = const 2 (used reg = )
01720 059F           B8                   0002  mov	ax,*2
01721 05A2           50                         push	ax
01722                                           ! Debug: list int = const $B (used reg = )
01723 05A3           B8                   000B  mov	ax,*$B
01724 05A6           50                         push	ax
01725                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01726 05A7           E8         FFCA            call	_outb_cmos
01727 05AA           89EC                       mov	sp,bp
01728                                           !BCC_EOS
01729                                           ! 785   inb_cmos(0x0c);
01730                                           ! Debug: list int = const $C (used reg = )
01731 05AC           B8                   000C  mov	ax,*$C
01732 05AF           50                         push	ax
01733                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01734 05B0           E8         FFD0            call	_inb_cmos
01735 05B3           89EC                       mov	sp,bp
01736                                           !BCC_EOS
01737                                           ! 786   inb_cmos(0x0d);
01738                                           ! Debug: list int = const $D (used reg = )
01739 05B5           B8                   000D  mov	ax,*$D
01740 05B8           50                         push	ax
01741                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01742 05B9           E8         FFC7            call	_inb_cmos
01743 05BC           89EC                       mov	sp,bp
01744                                           !BCC_EOS
01745                                           ! 787 }
01746 05BE           5D                         pop	bp
01747 05BF           C3                         ret
01748                                           ! 788   bx_bool
01749                                           ! 789 rtc_updating()
01750                                           ! 790 {
01751                                           export	_rtc_updating
01752                       000005C0            _rtc_updating:
01753                                           ! 791   Bit16u count;
01754                                           !BCC_EOS
01755                                           ! 792   count = 25000;
01756 05C0           55                         push	bp
01757 05C1           89E5                       mov	bp,sp
01758 05C3           4C                         dec	sp
01759 05C4           4C                         dec	sp
01760                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01761 05C5           B8                   61A8  mov	ax,#$61A8
01762 05C8           8946         FE            mov	-2[bp],ax
01763                                           !BCC_EOS
01764                                           ! 793   while (--count != 0) {
01765 05CB           EB           15            jmp .3
01766                       000005CD            .4:
01767                                           ! 794     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01768                                           ! Debug: list int = const $A (used reg = )
01769 05CD           B8                   000A  mov	ax,*$A
01770 05D0           50                         push	ax
01771                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01772 05D1           E8         FFAF            call	_inb_cmos
01773 05D4           44                         inc	sp
01774 05D5           44                         inc	sp
01775                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01776 05D6           24                     80  and	al,#$80
01777                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01778 05D8           84C0                       test	al,al
01779 05DA           75           06            jne 	.5
01780                       000005DC            .6:
01781                                           ! 795       return(0);
01782 05DC           31C0                       xor	ax,ax
01783 05DE           89EC                       mov	sp,bp
01784 05E0           5D                         pop	bp
01785 05E1           C3                         ret
01786                                           !BCC_EOS
01787                                           ! 796     }
01788                       000005E2            .5:
01789                                           ! 797   return(1);
01790                       000005E2            .3:
01791                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01792 05E2           8B46         FE            mov	ax,-2[bp]
01793 05E5           48                         dec	ax
01794 05E6           8946         FE            mov	-2[bp],ax
01795                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01796 05E9           85C0                       test	ax,ax
01797 05EB           75           E0            jne	.4
01798                       000005ED            .7:
01799                       000005ED            .2:
01800 05ED           B8                   0001  mov	ax,*1
01801 05F0           89EC                       mov	sp,bp
01802 05F2           5D                         pop	bp
01803 05F3           C3                         ret
01804                                           !BCC_EOS
01805                                           ! 798 }
01806                                           ! 799   Bit8u
01807                                           ! 800 read_byte(seg, offset)
01808                                           ! 801   Bit16u seg;
01809                                           export	_read_byte
01810                       000005F4            _read_byte:
01811                                           !BCC_EOS
01812                                           ! 802   Bit16u offset;
01813                                           !BCC_EOS
01814                                           ! 803 {
01815                                           ! 804 #asm
01816                                           !BCC_ASM
01817                       00000002            _read_byte.seg	set	2
01818                       00000004            _read_byte.offset	set	4
01819 05F4           55                           push bp
01820 05F5           89E5                         mov bp, sp
01821 05F7           53                             push bx
01822 05F8           1E                             push ds
01823 05F9           8B46         04                mov ax, 4[bp] ; segment
01824 05FC           8ED8                           mov ds, ax
01825 05FE           8B5E         06                mov bx, 6[bp] ; offset
01826 0601           8A07                           mov al, [bx]
01827                                               ;; al = return value (byte)
01828 0603           1F                             pop ds
01829 0604           5B                             pop bx
01830 0605           5D                           pop bp
01831                                           ! 817 endasm
01832                                           !BCC_ENDASM
01833                                           ! 818 }
01834 0606           C3                         ret
01835                                           ! 819   Bit16u
01836                                           ! 820 read_word(seg, offset)
01837                                           ! 821   Bit16u seg;
01838                                           export	_read_word
01839                       00000607            _read_word:
01840                                           !BCC_EOS
01841                                           ! 822   Bit16u offset;
01842                                           !BCC_EOS
01843                                           ! 823 {
01844                                           ! 824 #asm
01845                                           !BCC_ASM
01846                       00000002            _read_word.seg	set	2
01847                       00000004            _read_word.offset	set	4
01848 0607           55                           push bp
01849 0608           89E5                         mov bp, sp
01850 060A           53                             push bx
01851 060B           1E                             push ds
01852 060C           8B46         04                mov ax, 4[bp] ; segment
01853 060F           8ED8                           mov ds, ax
01854 0611           8B5E         06                mov bx, 6[bp] ; offset
01855 0614           8B07                           mov ax, [bx]
01856                                               ;; ax = return value (word)
01857 0616           1F                             pop ds
01858 0617           5B                             pop bx
01859 0618           5D                           pop bp
01860                                           ! 837 endasm
01861                                           !BCC_ENDASM
01862                                           ! 838 }
01863 0619           C3                         ret
01864                                           ! 839   void
01865                                           ! 840 write_byte(seg, offset, data)
01866                                           ! 841   Bit16u seg;
01867                                           export	_write_byte
01868                       0000061A            _write_byte:
01869                                           !BCC_EOS
01870                                           ! 842   Bit16u offset;
01871                                           !BCC_EOS
01872                                           ! 843   Bit8u data;
01873                                           !BCC_EOS
01874                                           ! 844 {
01875                                           ! 845 #asm
01876                                           !BCC_ASM
01877                       00000002            _write_byte.seg	set	2
01878                       00000006            _write_byte.data	set	6
01879                       00000004            _write_byte.offset	set	4
01880 061A           55                           push bp
01881 061B           89E5                         mov bp, sp
01882 061D           50                             push ax
01883 061E           53                             push bx
01884 061F           1E                             push ds
01885 0620           8B46         04                mov ax, 4[bp] ; segment
01886 0623           8ED8                           mov ds, ax
01887 0625           8B5E         06                mov bx, 6[bp] ; offset
01888 0628           8A46         08                mov al, 8[bp] ; data byte
01889 062B           8807                           mov [bx], al ; write data byte
01890 062D           1F                             pop ds
01891 062E           5B                             pop bx
01892 062F           58                             pop ax
01893 0630           5D                           pop bp
01894                                           ! 860 endasm
01895                                           !BCC_ENDASM
01896                                           ! 861 }
01897 0631           C3                         ret
01898                                           ! 862   void
01899                                           ! 863 write_word(seg, offset, data)
01900                                           ! 864   Bit16u seg;
01901                                           export	_write_word
01902                       00000632            _write_word:
01903                                           !BCC_EOS
01904                                           ! 865   Bit16u offset;
01905                                           !BCC_EOS
01906                                           ! 866   Bit16u data;
01907                                           !BCC_EOS
01908                                           ! 867 {
01909                                           ! 868 #asm
01910                                           !BCC_ASM
01911                       00000002            _write_word.seg	set	2
01912                       00000006            _write_word.data	set	6
01913                       00000004            _write_word.offset	set	4
01914 0632           55                           push bp
01915 0633           89E5                         mov bp, sp
01916 0635           50                             push ax
01917 0636           53                             push bx
01918 0637           1E                             push ds
01919 0638           8B46         04                mov ax, 4[bp] ; segment
01920 063B           8ED8                           mov ds, ax
01921 063D           8B5E         06                mov bx, 6[bp] ; offset
01922 0640           8B46         08                mov ax, 8[bp] ; data word
01923 0643           8907                           mov [bx], ax ; write data word
01924 0645           1F                             pop ds
01925 0646           5B                             pop bx
01926 0647           58                             pop ax
01927 0648           5D                           pop bp
01928                                           ! 883 endasm
01929                                           !BCC_ENDASM
01930                                           ! 884 }
01931 0649           C3                         ret
01932                                           ! 885   Bit16u
01933                                           ! 886 get_CS()
01934                                           ! 887 {
01935                                           export	_get_CS
01936                       0000064A            _get_CS:
01937                                           ! 888 #asm
01938                                           !BCC_ASM
01939 064A           8CC8                         mov ax, cs
01940                                           ! 890 endasm
01941                                           !BCC_ENDASM
01942                                           ! 891 }
01943 064C           C3                         ret
01944                                           ! 892   Bit16u
01945                                           ! 893 get_SS()
01946                                           ! 894 {
01947                                           export	_get_SS
01948                       0000064D            _get_SS:
01949                                           ! 895 #asm
01950                                           !BCC_ASM
01951 064D           8CD0                         mov ax, ss
01952                                           ! 897 endasm
01953                                           !BCC_ENDASM
01954                                           ! 898 }
01955 064F           C3                         ret
01956                                           ! 899 void
01957                                           ! 900 fixup_base_mem_in_k()
01958                                           ! 901 {
01959                                           export	_fixup_base_mem_in_k
01960                       00000650            _fixup_base_mem_in_k:
01961                                           ! 902   Bit32u base_mem = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 8);
01962 0650           55                         push	bp
01963 0651           89E5                       mov	bp,sp
01964 0653           83C4                   FC  add	sp,*-4
01965                                           ! Debug: list int = const $10 (used reg = )
01966 0656           B8                   0010  mov	ax,*$10
01967 0659           50                         push	ax
01968                                           ! Debug: list unsigned short = const $EA10 (used reg = )
01969 065A           B8                   EA10  mov	ax,#$EA10
01970 065D           50                         push	ax
01971                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
01972 065E           E8         FA22            call	_read_dword
01973 0661           89D3                       mov	bx,dx
01974 0663           83C4                   04  add	sp,*4
01975                                           ! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+6-6] (used reg = )
01976 0666           8946         FC            mov	-4[bp],ax
01977 0669           895E         FE            mov	-2[bp],bx
01978                                           !BCC_EOS
01979                                           ! 903   write_word(0x40, 0x13, base_mem >> 10);
01980                                           ! Debug: sr int = const $A to unsigned long base_mem = [S+6-6] (used reg = )
01981 066C           8B46         FC            mov	ax,-4[bp]
01982 066F           8B5E         FE            mov	bx,-2[bp]
01983 0672           88E0                       mov	al,ah
01984 0674           88DC                       mov	ah,bl
01985 0676           88FB                       mov	bl,bh
01986 0678           28FF                       sub	bh,bh
01987 067A           BF                   0002  mov	di,*2
01988 067D           E8         FAA9            call	lsrul
01989                                           ! Debug: list unsigned long = bx+0 (used reg = )
01990 0680           53                         push	bx
01991 0681           50                         push	ax
01992                                           ! Debug: list int = const $13 (used reg = )
01993 0682           B8                   0013  mov	ax,*$13
01994 0685           50                         push	ax
01995                                           ! Debug: list int = const $40 (used reg = )
01996 0686           B8                   0040  mov	ax,*$40
01997 0689           50                         push	ax
01998                                           ! Debug: func () void = write_word+0 (used reg = )
01999 068A           E8         FFA5            call	_write_word
02000 068D           83C4                   08  add	sp,*8
02001                                           !BCC_EOS
02002                                           ! 904 }
02003 0690           89EC                       mov	sp,bp
02004 0692           5D                         pop	bp
02005 0693           C3                         ret
02006                                           ! 905 void enable_rom_write_access()
02007                                           ! Register BX used in function fixup_base_mem_in_k
02008                                           ! 906 {
02009                                           export	_enable_rom_write_access
02010                       00000694            _enable_rom_write_access:
02011                                           ! 907     outb(0x10, 0);
02012 0694           55                         push	bp
02013 0695           89E5                       mov	bp,sp
02014                                           ! Debug: list int = const 0 (used reg = )
02015 0697           31C0                       xor	ax,ax
02016 0699           50                         push	ax
02017                                           ! Debug: list int = const $10 (used reg = )
02018 069A           B8                   0010  mov	ax,*$10
02019 069D           50                         push	ax
02020                                           ! Debug: func () void = outb+0 (used reg = )
02021 069E           E8         FEB3            call	_outb
02022 06A1           89EC                       mov	sp,bp
02023                                           !BCC_EOS
02024                                           ! 908 }
02025 06A3           5D                         pop	bp
02026 06A4           C3                         ret
02027                                           ! 909 void disable_rom_write_access()
02028                                           ! 910 {
02029                                           export	_disable_rom_write_access
02030                       000006A5            _disable_rom_write_access:
02031                                           ! 911     outb(0x10, 1);
02032 06A5           55                         push	bp
02033 06A6           89E5                       mov	bp,sp
02034                                           ! Debug: list int = const 1 (used reg = )
02035 06A8           B8                   0001  mov	ax,*1
02036 06AB           50                         push	ax
02037                                           ! Debug: list int = const $10 (used reg = )
02038 06AC           B8                   0010  mov	ax,*$10
02039 06AF           50                         push	ax
02040                                           ! Debug: func () void = outb+0 (used reg = )
02041 06B0           E8         FEA1            call	_outb
02042 06B3           89EC                       mov	sp,bp
02043                                           !BCC_EOS
02044                                           ! 912 }
02045 06B5           5D                         pop	bp
02046 06B6           C3                         ret
02047                                           ! 913   void
02048                                           ! 914 wrch(c)
02049                                           ! 915   Bit8u c;
02050                                           export	_wrch
02051                       000006B7            _wrch:
02052                                           !BCC_EOS
02053                                           ! 916 {
02054                                           ! 917 #asm
02055                                           !BCC_ASM
02056                       00000002            _wrch.c	set	2
02057 06B7           55                           push bp
02058 06B8           89E5                         mov bp, sp
02059 06BA           53                           push bx
02060 06BB           B4                     0E    mov ah, #0x0e
02061 06BD           8A46         04              mov al, 4[bp]
02062 06C0           31DB                         xor bx,bx
02063 06C2           CD                     10    int #0x10
02064 06C4           5B                           pop bx
02065 06C5           5D                           pop bp
02066                                           ! 927 endasm
02067                                           !BCC_ENDASM
02068                                           ! 928 }
02069 06C6           C3                         ret
02070                                           ! 929   void
02071                                           ! 930 send(action, c)
02072                                           ! 931   Bit16u action;
02073                                           export	_send
02074                       000006C7            _send:
02075                                           !BCC_EOS
02076                                           ! 932   Bit8u c;
02077                                           !BCC_EOS
02078                                           ! 933 {
02079                                           ! 934   outb(0xE9, c);
02080 06C7           55                         push	bp
02081 06C8           89E5                       mov	bp,sp
02082                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02083 06CA           8A46         06            mov	al,6[bp]
02084 06CD           30E4                       xor	ah,ah
02085 06CF           50                         push	ax
02086                                           ! Debug: list int = const $E9 (used reg = )
02087 06D0           B8                   00E9  mov	ax,#$E9
02088 06D3           50                         push	ax
02089                                           ! Debug: func () void = outb+0 (used reg = )
02090 06D4           E8         FE7D            call	_outb
02091 06D7           89EC                       mov	sp,bp
02092                                           !BCC_EOS
02093                                           ! 935   if (action & 8) outb(0x403, c);
02094                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02095 06D9           8A46         04            mov	al,4[bp]
02096 06DC           24                     08  and	al,*8
02097 06DE           84C0                       test	al,al
02098 06E0           74           0F            je  	.8
02099                       000006E2            .9:
02100                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02101 06E2           8A46         06            mov	al,6[bp]
02102 06E5           30E4                       xor	ah,ah
02103 06E7           50                         push	ax
02104                                           ! Debug: list int = const $403 (used reg = )
02105 06E8           B8                   0403  mov	ax,#$403
02106 06EB           50                         push	ax
02107                                           ! Debug: func () void = outb+0 (used reg = )
02108 06EC           E8         FE65            call	_outb
02109 06EF           89EC                       mov	sp,bp
02110                                           !BCC_EOS
02111                                           ! 936   if (action & 4) outb(0x402, c);
02112                       000006F1            .8:
02113                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02114 06F1           8A46         04            mov	al,4[bp]
02115 06F4           24                     04  and	al,*4
02116 06F6           84C0                       test	al,al
02117 06F8           74           0F            je  	.A
02118                       000006FA            .B:
02119                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02120 06FA           8A46         06            mov	al,6[bp]
02121 06FD           30E4                       xor	ah,ah
02122 06FF           50                         push	ax
02123                                           ! Debug: list int = const $402 (used reg = )
02124 0700           B8                   0402  mov	ax,#$402
02125 0703           50                         push	ax
02126                                           ! Debug: func () void = outb+0 (used reg = )
02127 0704           E8         FE4D            call	_outb
02128 0707           89EC                       mov	sp,bp
02129                                           !BCC_EOS
02130                                           ! 937   if (action & 2) {
02131                       00000709            .A:
02132                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02133 0709           8A46         04            mov	al,4[bp]
02134 070C           24                     02  and	al,*2
02135 070E           84C0                       test	al,al
02136 0710           74           1B            je  	.C
02137                       00000712            .D:
02138                                           ! 938     if (c == '\n') wrch('\r');
02139                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02140 0712           8A46         06            mov	al,6[bp]
02141 0715           3C                     0A  cmp	al,*$A
02142 0717           75           09            jne 	.E
02143                       00000719            .F:
02144                                           ! Debug: list int = const $D (used reg = )
02145 0719           B8                   000D  mov	ax,*$D
02146 071C           50                         push	ax
02147                                           ! Debug: func () void = wrch+0 (used reg = )
02148 071D           E8         FF97            call	_wrch
02149 0720           89EC                       mov	sp,bp
02150                                           !BCC_EOS
02151                                           ! 939     wrch(c);
02152                       00000722            .E:
02153                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02154 0722           8A46         06            mov	al,6[bp]
02155 0725           30E4                       xor	ah,ah
02156 0727           50                         push	ax
02157                                           ! Debug: func () void = wrch+0 (used reg = )
02158 0728           E8         FF8C            call	_wrch
02159 072B           89EC                       mov	sp,bp
02160                                           !BCC_EOS
02161                                           ! 940   }
02162                                           ! 941 }
02163                       0000072D            .C:
02164 072D           5D                         pop	bp
02165 072E           C3                         ret
02166                                           ! 942   void
02167                                           ! 943 put_int(action, val, width, neg)
02168                                           ! 944   Bit16u action;
02169                                           export	_put_int
02170                       0000072F            _put_int:
02171                                           !BCC_EOS
02172                                           ! 945   short val, width;
02173                                           !BCC_EOS
02174                                           ! 946   bx_bool neg;
02175                                           !BCC_EOS
02176                                           ! 947 {
02177                                           ! 948   short nval = val / 10;
02178 072F           55                         push	bp
02179 0730           89E5                       mov	bp,sp
02180 0732           4C                         dec	sp
02181 0733           4C                         dec	sp
02182                                           ! Debug: div int = const $A to short val = [S+4+4] (used reg = )
02183 0734           8B46         06            mov	ax,6[bp]
02184 0737           BB                   000A  mov	bx,*$A
02185 073A           99                         cwd
02186 073B           F7FB                       idiv	bx
02187                                           ! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
02188 073D           8946         FE            mov	-2[bp],ax
02189                                           !BCC_EOS
02190                                           ! 949   if (nval)
02191 0740           8B46         FE            mov	ax,-2[bp]
02192 0743           85C0                       test	ax,ax
02193 0745           74           16            je  	.10
02194                       00000747            .11:
02195                                           ! 950     put_int(action, nval, width - 1, neg);
02196                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02197 0747           FF76         0A            push	$A[bp]
02198                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02199 074A           8B46         08            mov	ax,8[bp]
02200                                           ! Debug: list int = ax-1 (used reg = )
02201 074D           48                         dec	ax
02202 074E           50                         push	ax
02203                                           ! Debug: list short nval = [S+8-4] (used reg = )
02204 074F           FF76         FE            push	-2[bp]
02205                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02206 0752           FF76         04            push	4[bp]
02207                                           ! Debug: func () void = put_int+0 (used reg = )
02208 0755           E8         FFD7            call	_put_int
02209 0758           83C4                   08  add	sp,*8
02210                                           !BCC_EOS
02211                                           ! 951   else {
02212 075B           EB           2E            jmp .12
02213                       0000075D            .10:
02214                                           ! 952     while (--width > 0) send(action, ' ');
02215 075D           EB           0D            jmp .14
02216                       0000075F            .15:
02217                                           ! Debug: list int = const $20 (used reg = )
02218 075F           B8                   0020  mov	ax,*$20
02219 0762           50                         push	ax
02220                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02221 0763           FF76         04            push	4[bp]
02222                                           ! Debug: func () void = send+0 (used reg = )
02223 0766           E8         FF5E            call	_send
02224 0769           83C4                   04  add	sp,*4
02225                                           !BCC_EOS
02226                                           ! 953     if (neg) send(action, '-');
02227                       0000076C            .14:
02228                                           ! Debug: predec short width = [S+4+6] (used reg = )
02229 076C           8B46         08            mov	ax,8[bp]
02230 076F           48                         dec	ax
02231 0770           8946         08            mov	8[bp],ax
02232                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02233 0773           85C0                       test	ax,ax
02234 0775           7F           E8            jg 	.15
02235                       00000777            .16:
02236                       00000777            .13:
02237 0777           8B46         0A            mov	ax,$A[bp]
02238 077A           85C0                       test	ax,ax
02239 077C           74           0D            je  	.17
02240                       0000077E            .18:
02241                                           ! Debug: list int = const $2D (used reg = )
02242 077E           B8                   002D  mov	ax,*$2D
02243 0781           50                         push	ax
02244                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02245 0782           FF76         04            push	4[bp]
02246                                           ! Debug: func () void = send+0 (used reg = )
02247 0785           E8         FF3F            call	_send
02248 0788           83C4                   04  add	sp,*4
02249                                           !BCC_EOS
02250                                           ! 954   }
02251                       0000078B            .17:
02252                                           ! 955   send(action, val - (nval * 10) + '0');
02253                       0000078B            .12:
02254                                           ! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
02255 078B           8B46         FE            mov	ax,-2[bp]
02256 078E           89C2                       mov	dx,ax
02257 0790           D1E0                       shl	ax,*1
02258 0792           D1E0                       shl	ax,*1
02259 0794           01D0                       add	ax,dx
02260 0796           D1E0                       shl	ax,*1
02261                                           ! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
02262 0798           50                         push	ax
02263 0799           8B46         06            mov	ax,6[bp]
02264 079C           2B46         FC            sub	ax,-4[bp]
02265 079F           44                         inc	sp
02266 07A0           44                         inc	sp
02267                                           ! Debug: add int = const $30 to int = ax+0 (used reg = )
02268                                           ! Debug: list int = ax+$30 (used reg = )
02269 07A1           05                   0030  add	ax,*$30
02270 07A4           50                         push	ax
02271                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02272 07A5           FF76         04            push	4[bp]
02273                                           ! Debug: func () void = send+0 (used reg = )
02274 07A8           E8         FF1C            call	_send
02275 07AB           83C4                   04  add	sp,*4
02276                                           !BCC_EOS
02277                                           ! 956 }
02278 07AE           89EC                       mov	sp,bp
02279 07B0           5D                         pop	bp
02280 07B1           C3                         ret
02281                                           ! 957   void
02282                                           ! Register BX used in function put_int
02283                                           ! 958 put_uint(action, val, width, neg)
02284                                           ! 959   Bit16u action;
02285                                           export	_put_uint
02286                       000007B2            _put_uint:
02287                                           !BCC_EOS
02288                                           ! 960   unsigned short val;
02289                                           !BCC_EOS
02290                                           ! 961   short width;
02291                                           !BCC_EOS
02292                                           ! 962   bx_bool neg;
02293                                           !BCC_EOS
02294                                           ! 963 {
02295                                           ! 964   unsigned short nval = val / 10;
02296 07B2           55                         push	bp
02297 07B3           89E5                       mov	bp,sp
02298 07B5           4C                         dec	sp
02299 07B6           4C                         dec	sp
02300                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02301 07B7           8B46         06            mov	ax,6[bp]
02302 07BA           BB                   000A  mov	bx,*$A
02303 07BD           E8         F9A9            call	idiv_u
02304                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02305 07C0           8946         FE            mov	-2[bp],ax
02306                                           !BCC_EOS
02307                                           ! 965   if (nval)
02308 07C3           8B46         FE            mov	ax,-2[bp]
02309 07C6           85C0                       test	ax,ax
02310 07C8           74           16            je  	.19
02311                       000007CA            .1A:
02312                                           ! 966     put_uint(action, nval, width - 1, neg);
02313                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02314 07CA           FF76         0A            push	$A[bp]
02315                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02316 07CD           8B46         08            mov	ax,8[bp]
02317                                           ! Debug: list int = ax-1 (used reg = )
02318 07D0           48                         dec	ax
02319 07D1           50                         push	ax
02320                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02321 07D2           FF76         FE            push	-2[bp]
02322                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02323 07D5           FF76         04            push	4[bp]
02324                                           ! Debug: func () void = put_uint+0 (used reg = )
02325 07D8           E8         FFD7            call	_put_uint
02326 07DB           83C4                   08  add	sp,*8
02327                                           !BCC_EOS
02328                                           ! 967   else {
02329 07DE           EB           2E            jmp .1B
02330                       000007E0            .19:
02331                                           ! 968     while (--width > 0) send(action, ' ');
02332 07E0           EB           0D            jmp .1D
02333                       000007E2            .1E:
02334                                           ! Debug: list int = const $20 (used reg = )
02335 07E2           B8                   0020  mov	ax,*$20
02336 07E5           50                         push	ax
02337                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02338 07E6           FF76         04            push	4[bp]
02339                                           ! Debug: func () void = send+0 (used reg = )
02340 07E9           E8         FEDB            call	_send
02341 07EC           83C4                   04  add	sp,*4
02342                                           !BCC_EOS
02343                                           ! 969     if (neg) send(action, '-');
02344                       000007EF            .1D:
02345                                           ! Debug: predec short width = [S+4+6] (used reg = )
02346 07EF           8B46         08            mov	ax,8[bp]
02347 07F2           48                         dec	ax
02348 07F3           8946         08            mov	8[bp],ax
02349                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02350 07F6           85C0                       test	ax,ax
02351 07F8           7F           E8            jg 	.1E
02352                       000007FA            .1F:
02353                       000007FA            .1C:
02354 07FA           8B46         0A            mov	ax,$A[bp]
02355 07FD           85C0                       test	ax,ax
02356 07FF           74           0D            je  	.20
02357                       00000801            .21:
02358                                           ! Debug: list int = const $2D (used reg = )
02359 0801           B8                   002D  mov	ax,*$2D
02360 0804           50                         push	ax
02361                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02362 0805           FF76         04            push	4[bp]
02363                                           ! Debug: func () void = send+0 (used reg = )
02364 0808           E8         FEBC            call	_send
02365 080B           83C4                   04  add	sp,*4
02366                                           !BCC_EOS
02367                                           ! 970   }
02368                       0000080E            .20:
02369                                           ! 971   send(action, val - (nval * 10) + '0');
02370                       0000080E            .1B:
02371                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02372 080E           8B46         FE            mov	ax,-2[bp]
02373 0811           89C2                       mov	dx,ax
02374 0813           D1E0                       shl	ax,*1
02375 0815           D1E0                       shl	ax,*1
02376 0817           01D0                       add	ax,dx
02377 0819           D1E0                       shl	ax,*1
02378                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02379 081B           50                         push	ax
02380 081C           8B46         06            mov	ax,6[bp]
02381 081F           2B46         FC            sub	ax,-4[bp]
02382 0822           44                         inc	sp
02383 0823           44                         inc	sp
02384                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02385                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02386 0824           05                   0030  add	ax,*$30
02387 0827           50                         push	ax
02388                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02389 0828           FF76         04            push	4[bp]
02390                                           ! Debug: func () void = send+0 (used reg = )
02391 082B           E8         FE99            call	_send
02392 082E           83C4                   04  add	sp,*4
02393                                           !BCC_EOS
02394                                           ! 972 }
02395 0831           89EC                       mov	sp,bp
02396 0833           5D                         pop	bp
02397 0834           C3                         ret
02398                                           ! 973   void
02399                                           ! Register BX used in function put_uint
02400                                           ! 974 put_luint(action, val, width, neg)
02401                                           ! 975   Bit16u action;
02402                                           export	_put_luint
02403                       00000835            _put_luint:
02404                                           !BCC_EOS
02405                                           ! 976   unsigned long val;
02406                                           !BCC_EOS
02407                                           ! 977   short width;
02408                                           !BCC_EOS
02409                                           ! 978   bx_bool neg;
02410                                           !BCC_EOS
02411                                           ! 979 {
02412                                           ! 980   unsigned long nval = val / 10;
02413 0835           55                         push	bp
02414 0836           89E5                       mov	bp,sp
02415 0838           83C4                   FC  add	sp,*-4
02416                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02417 083B           B8                   000A  mov	ax,*$A
02418 083E           31DB                       xor	bx,bx
02419 0840           53                         push	bx
02420 0841           50                         push	ax
02421 0842           8B46         06            mov	ax,6[bp]
02422 0845           8B5E         08            mov	bx,8[bp]
02423 0848           8D7E         F8            lea	di,-8[bp]
02424 084B           E8         F920            call	ldivul
02425 084E           83C4                   04  add	sp,*4
02426                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02427 0851           8946         FC            mov	-4[bp],ax
02428 0854           895E         FE            mov	-2[bp],bx
02429                                           !BCC_EOS
02430                                           ! 981   if (nval)
02431 0857           8B46         FC            mov	ax,-4[bp]
02432 085A           8B5E         FE            mov	bx,-2[bp]
02433 085D           E8         F8B4            call	ltstl
02434 0860           74           19            je  	.22
02435                       00000862            .23:
02436                                           ! 982     put_luint(action, nval, width - 1, neg);
02437                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02438 0862           FF76         0C            push	$C[bp]
02439                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02440 0865           8B46         0A            mov	ax,$A[bp]
02441                                           ! Debug: list int = ax-1 (used reg = )
02442 0868           48                         dec	ax
02443 0869           50                         push	ax
02444                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02445 086A           FF76         FE            push	-2[bp]
02446 086D           FF76         FC            push	-4[bp]
02447                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02448 0870           FF76         04            push	4[bp]
02449                                           ! Debug: func () void = put_luint+0 (used reg = )
02450 0873           E8         FFBF            call	_put_luint
02451 0876           83C4                   0A  add	sp,*$A
02452                                           !BCC_EOS
02453                                           ! 983   else {
02454 0879           EB           2E            jmp .24
02455                       0000087B            .22:
02456                                           ! 984     while (--width > 0) send(action, ' ');
02457 087B           EB           0D            jmp .26
02458                       0000087D            .27:
02459                                           ! Debug: list int = const $20 (used reg = )
02460 087D           B8                   0020  mov	ax,*$20
02461 0880           50                         push	ax
02462                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02463 0881           FF76         04            push	4[bp]
02464                                           ! Debug: func () void = send+0 (used reg = )
02465 0884           E8         FE40            call	_send
02466 0887           83C4                   04  add	sp,*4
02467                                           !BCC_EOS
02468                                           ! 985     if (neg) send(action, '-');
02469                       0000088A            .26:
02470                                           ! Debug: predec short width = [S+6+8] (used reg = )
02471 088A           8B46         0A            mov	ax,$A[bp]
02472 088D           48                         dec	ax
02473 088E           8946         0A            mov	$A[bp],ax
02474                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02475 0891           85C0                       test	ax,ax
02476 0893           7F           E8            jg 	.27
02477                       00000895            .28:
02478                       00000895            .25:
02479 0895           8B46         0C            mov	ax,$C[bp]
02480 0898           85C0                       test	ax,ax
02481 089A           74           0D            je  	.29
02482                       0000089C            .2A:
02483                                           ! Debug: list int = const $2D (used reg = )
02484 089C           B8                   002D  mov	ax,*$2D
02485 089F           50                         push	ax
02486                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02487 08A0           FF76         04            push	4[bp]
02488                                           ! Debug: func () void = send+0 (used reg = )
02489 08A3           E8         FE21            call	_send
02490 08A6           83C4                   04  add	sp,*4
02491                                           !BCC_EOS
02492                                           ! 986   }
02493                       000008A9            .29:
02494                                           ! 987   send(action, val - (nval * 10) + '0');
02495                       000008A9            .24:
02496                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02497                                           ! Debug: expression subtree swapping
02498 08A9           B8                   000A  mov	ax,*$A
02499 08AC           31DB                       xor	bx,bx
02500 08AE           8D7E         FC            lea	di,-4[bp]
02501 08B1           E8         F835            call	lmulul
02502                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02503 08B4           53                         push	bx
02504 08B5           50                         push	ax
02505 08B6           8B46         06            mov	ax,6[bp]
02506 08B9           8B5E         08            mov	bx,8[bp]
02507 08BC           8D7E         F8            lea	di,-8[bp]
02508 08BF           E8         F81F            call	lsubul
02509 08C2           83C4                   04  add	sp,*4
02510                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02511 08C5           53                         push	bx
02512 08C6           50                         push	ax
02513 08C7           B8                   0030  mov	ax,*$30
02514 08CA           31DB                       xor	bx,bx
02515 08CC           53                         push	bx
02516 08CD           50                         push	ax
02517 08CE           8B46         F8            mov	ax,-8[bp]
02518 08D1           8B5E         FA            mov	bx,-6[bp]
02519 08D4           8D7E         F4            lea	di,-$C[bp]
02520 08D7           E8         F7E9            call	laddul
02521 08DA           83C4                   08  add	sp,*8
02522                                           ! Debug: list unsigned long = bx+0 (used reg = )
02523 08DD           53                         push	bx
02524 08DE           50                         push	ax
02525                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02526 08DF           FF76         04            push	4[bp]
02527                                           ! Debug: func () void = send+0 (used reg = )
02528 08E2           E8         FDE2            call	_send
02529 08E5           83C4                   06  add	sp,*6
02530                                           !BCC_EOS
02531                                           ! 988 }
02532 08E8           89EC                       mov	sp,bp
02533 08EA           5D                         pop	bp
02534 08EB           C3                         ret
02535                                           ! 989 void put_str(action, segment, offset)
02536                                           ! Register BX used in function put_luint
02537                                           ! 990   Bit16u action;
02538                                           export	_put_str
02539                       000008EC            _put_str:
02540                                           !BCC_EOS
02541                                           ! 991   Bit16u segment;
02542                                           !BCC_EOS
02543                                           ! 992   Bit16u offset;
02544                                           !BCC_EOS
02545                                           ! 993 {
02546                                           ! 994   Bit8u c;
02547                                           !BCC_EOS
02548                                           ! 995   while (c = read_byte(segment, offset)) {
02549 08EC           55                         push	bp
02550 08ED           89E5                       mov	bp,sp
02551 08EF           4C                         dec	sp
02552 08F0           4C                         dec	sp
02553 08F1           EB           16            jmp .2C
02554                       000008F3            .2D:
02555                                           ! 996     send(action, c);
02556                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02557 08F3           8A46         FF            mov	al,-1[bp]
02558 08F6           30E4                       xor	ah,ah
02559 08F8           50                         push	ax
02560                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02561 08F9           FF76         04            push	4[bp]
02562                                           ! Debug: func () void = send+0 (used reg = )
02563 08FC           E8         FDC8            call	_send
02564 08FF           83C4                   04  add	sp,*4
02565                                           !BCC_EOS
02566                                           ! 997     offset++;
02567                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02568 0902           8B46         08            mov	ax,8[bp]
02569 0905           40                         inc	ax
02570 0906           8946         08            mov	8[bp],ax
02571                                           !BCC_EOS
02572                                           ! 998   }
02573                                           ! 999 }
02574                       00000909            .2C:
02575                                           ! Debug: list unsigned short offset = [S+4+6] (used reg = )
02576 0909           FF76         08            push	8[bp]
02577                                           ! Debug: list unsigned short segment = [S+6+4] (used reg = )
02578 090C           FF76         06            push	6[bp]
02579                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
02580 090F           E8         FCE2            call	_read_byte
02581 0912           83C4                   04  add	sp,*4
02582                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02583 0915           8846         FF            mov	-1[bp],al
02584 0918           84C0                       test	al,al
02585 091A           75           D7            jne	.2D
02586                       0000091C            .2E:
02587                       0000091C            .2B:
02588 091C           89EC                       mov	sp,bp
02589 091E           5D                         pop	bp
02590 091F           C3                         ret
02591                                           ! 1000   void
02592                                           ! 1001 delay_ticks(ticks)
02593                                           ! 1002   Bit16u ticks;
02594                                           export	_delay_ticks
02595                       00000920            _delay_ticks:
02596                                           !BCC_EOS
02597                                           ! 1003 {
02598                                           ! 1004   long ticks_to_wait, delta;
02599                                           !BCC_EOS
02600                                           ! 1005   Bit32u prev_ticks, t;
02601                                           !BCC_EOS
02602                                           ! 1006 #asm
02603 0920           55                         push	bp
02604 0921           89E5                       mov	bp,sp
02605 0923           83C4                   F0  add	sp,*-$10
02606                                           !BCC_EOS
02607                                           !BCC_ASM
02608                       00000014            _delay_ticks.ticks	set	$14
02609                       00000004            .delay_ticks.ticks	set	4
02610                       00000000            _delay_ticks.t	set	0
02611                       FFFFFFF0            .delay_ticks.t	set	-$10
02612                       00000004            _delay_ticks.prev_ticks	set	4
02613                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02614                       00000008            _delay_ticks.delta	set	8
02615                       FFFFFFF8            .delay_ticks.delta	set	-8
02616                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02617                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02618 0926           9C                           pushf
02619 0927           FB                           sti
02620                                           ! 1009 endasm
02621                                           !BCC_ENDASM
02622                                           !BCC_EOS
02623                                           ! 1010   ticks_to_wait = ticks;
02624                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02625 0928           8B46         04            mov	ax,4[bp]
02626 092B           31DB                       xor	bx,bx
02627 092D           8946         FC            mov	-4[bp],ax
02628 0930           895E         FE            mov	-2[bp],bx
02629                                           !BCC_EOS
02630                                           ! 1011   prev_ticks = read_dword(0x0, 0x46c);
02631                                           ! Debug: list int = const $46C (used reg = )
02632 0933           B8                   046C  mov	ax,#$46C
02633 0936           50                         push	ax
02634                                           ! Debug: list int = const 0 (used reg = )
02635 0937           31C0                       xor	ax,ax
02636 0939           50                         push	ax
02637                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02638 093A           E8         F746            call	_read_dword
02639 093D           89D3                       mov	bx,dx
02640 093F           83C4                   04  add	sp,*4
02641                                           ! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02642 0942           8946         F4            mov	-$C[bp],ax
02643 0945           895E         F6            mov	-$A[bp],bx
02644                                           !BCC_EOS
02645                                           ! 1012   do
02646                                           ! 1013   {
02647                       00000948            .31:
02648                                           ! 1014 #asm
02649                                           !BCC_EOS
02650                                           !BCC_ASM
02651                       00000014            _delay_ticks.ticks	set	$14
02652                       00000004            .delay_ticks.ticks	set	4
02653                       00000000            _delay_ticks.t	set	0
02654                       FFFFFFF0            .delay_ticks.t	set	-$10
02655                       00000004            _delay_ticks.prev_ticks	set	4
02656                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02657                       00000008            _delay_ticks.delta	set	8
02658                       FFFFFFF8            .delay_ticks.delta	set	-8
02659                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02660                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02661 0948           F4                             hlt
02662                                           ! 1016 endasm
02663                                           !BCC_ENDASM
02664                                           !BCC_EOS
02665                                           ! 1017     t = read_dword(0x0, 0x46c);
02666                                           ! Debug: list int = const $46C (used reg = )
02667 0949           B8                   046C  mov	ax,#$46C
02668 094C           50                         push	ax
02669                                           ! Debug: list int = const 0 (used reg = )
02670 094D           31C0                       xor	ax,ax
02671 094F           50                         push	ax
02672                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02673 0950           E8         F730            call	_read_dword
02674 0953           89D3                       mov	bx,dx
02675 0955           83C4                   04  add	sp,*4
02676                                           ! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
02677 0958           8946         F0            mov	-$10[bp],ax
02678 095B           895E         F2            mov	-$E[bp],bx
02679                                           !BCC_EOS
02680                                           ! 1018     if (t > prev_ticks)
02681                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02682 095E           8B46         F4            mov	ax,-$C[bp]
02683 0961           8B5E         F6            mov	bx,-$A[bp]
02684 0964           8D7E         F0            lea	di,-$10[bp]
02685 0967           E8         F761            call	lcmpul
02686 096A           73           26            jae 	.32
02687                       0000096C            .33:
02688                                           ! 1019     {
02689                                           ! 1020       delta = t - prev_ticks;
02690                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02691 096C           8B46         F0            mov	ax,-$10[bp]
02692 096F           8B5E         F2            mov	bx,-$E[bp]
02693 0972           8D7E         F4            lea	di,-$C[bp]
02694 0975           E8         F769            call	lsubul
02695                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02696 0978           8946         F8            mov	-8[bp],ax
02697 097B           895E         FA            mov	-6[bp],bx
02698                                           !BCC_EOS
02699                                           ! 1021       ticks_to_wait -= delta;
02700                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02701 097E           8B46         FC            mov	ax,-4[bp]
02702 0981           8B5E         FE            mov	bx,-2[bp]
02703 0984           8D7E         F8            lea	di,-8[bp]
02704 0987           E8         F757            call	lsubl
02705 098A           8946         FC            mov	-4[bp],ax
02706 098D           895E         FE            mov	-2[bp],bx
02707                                           !BCC_EOS
02708                                           ! 1022     }
02709                                           ! 1023     else if (t < prev_ticks)
02710 0990           EB           20            jmp .34
02711                       00000992            .32:
02712                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02713 0992           8B46         F4            mov	ax,-$C[bp]
02714 0995           8B5E         F6            mov	bx,-$A[bp]
02715 0998           8D7E         F0            lea	di,-$10[bp]
02716 099B           E8         F72D            call	lcmpul
02717 099E           76           12            jbe 	.35
02718                       000009A0            .36:
02719                                           ! 1024     {
02720                                           ! 1025       ticks_to_wait -= t;
02721                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02722 09A0           8B46         FC            mov	ax,-4[bp]
02723 09A3           8B5E         FE            mov	bx,-2[bp]
02724 09A6           8D7E         F0            lea	di,-$10[bp]
02725 09A9           E8         F735            call	lsubul
02726 09AC           8946         FC            mov	-4[bp],ax
02727 09AF           895E         FE            mov	-2[bp],bx
02728                                           !BCC_EOS
02729                                           ! 1026     }
02730                                           ! 1027     prev_ticks = t;
02731                       000009B2            .35:
02732                       000009B2            .34:
02733                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02734 09B2           8B46         F0            mov	ax,-$10[bp]
02735 09B5           8B5E         F2            mov	bx,-$E[bp]
02736 09B8           8946         F4            mov	-$C[bp],ax
02737 09BB           895E         F6            mov	-$A[bp],bx
02738                                           !BCC_EOS
02739                                           ! 1028   } while (ticks_to_wait > 0);
02740                       000009BE            .30:
02741                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02742 09BE           31C0                       xor	ax,ax
02743 09C0           31DB                       xor	bx,bx
02744 09C2           8D7E         FC            lea	di,-4[bp]
02745 09C5           E8         F703            call	lcmpl
02746 09C8         0F8C         FF7C            blt 	.31
02747                       000009CC            .37:
02748                                           !BCC_EOS
02749                                           ! 1029 #asm
02750                       000009CC            .2F:
02751                                           !BCC_EOS
02752                                           !BCC_ASM
02753                       00000014            _delay_ticks.ticks	set	$14
02754                       00000004            .delay_ticks.ticks	set	4
02755                       00000000            _delay_ticks.t	set	0
02756                       FFFFFFF0            .delay_ticks.t	set	-$10
02757                       00000004            _delay_ticks.prev_ticks	set	4
02758                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02759                       00000008            _delay_ticks.delta	set	8
02760                       FFFFFFF8            .delay_ticks.delta	set	-8
02761                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02762                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02763 09CC           FA                           cli
02764 09CD           9D                           popf
02765                                           ! 1032 endasm
02766                                           !BCC_ENDASM
02767                                           !BCC_EOS
02768                                           ! 1033 }
02769 09CE           89EC                       mov	sp,bp
02770 09D0           5D                         pop	bp
02771 09D1           C3                         ret
02772                                           ! 1034   Bit8u
02773                                           ! Register BX used in function delay_ticks
02774                                           ! 1035 check_for_keystroke()
02775                                           ! 1036 {
02776                                           export	_check_for_keystroke
02777                       000009D2            _check_for_keystroke:
02778                                           ! 1037 #asm
02779                                           !BCC_ASM
02780 09D2           B8                   0100    mov ax, #0x100
02781 09D5           CD                     16    int #0x16
02782 09D7           74           04              jz no_key
02783 09D9           B0                     01    mov al, #1
02784 09DB           EB           02              jmp done
02785                       000009DD            no_key:
02786 09DD           30C0                         xor al, al
02787                       000009DF            done:
02788                                           ! 1046 endasm
02789                                           !BCC_ENDASM
02790                                           ! 1047 }
02791 09DF           C3                         ret
02792                                           ! 1048   Bit8u
02793                                           ! 1049 get_keystroke()
02794                                           ! 1050 {
02795                                           export	_get_keystroke
02796                       000009E0            _get_keystroke:
02797                                           ! 1051 #asm
02798                                           !BCC_ASM
02799 09E0           B8                   0000    mov ax, #0x0
02800 09E3           CD                     16    int #0x16
02801 09E5           86C4                         xchg ah, al
02802                                           ! 1055 endasm
02803                                           !BCC_ENDASM
02804                                           ! 1056 }
02805 09E7           C3                         ret
02806                                           ! 1057   void
02807                                           ! 1058 delay_ticks_and_check_for_keystroke(ticks, count)
02808                                           ! 1059   Bit16u ticks, count;
02809                                           export	_delay_ticks_and_check_for_keystroke
02810                       000009E8            _delay_ticks_and_check_for_keystroke:
02811                                           !BCC_EOS
02812                                           ! 1060 {
02813                                           ! 1061   Bit16u i;
02814                                           !BCC_EOS
02815                                           ! 1062   for (i = 1; i <= count; i++) {
02816 09E8           55                         push	bp
02817 09E9           89E5                       mov	bp,sp
02818 09EB           4C                         dec	sp
02819 09EC           4C                         dec	sp
02820                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02821 09ED           B8                   0001  mov	ax,*1
02822 09F0           8946         FE            mov	-2[bp],ax
02823                                           !BCC_EOS
02824                                           !BCC_EOS
02825 09F3           EB           18            jmp .3A
02826                       000009F5            .3B:
02827                                           ! 1063     delay_ticks(ticks);
02828                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02829 09F5           FF76         04            push	4[bp]
02830                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02831 09F8           E8         FF25            call	_delay_ticks
02832 09FB           44                         inc	sp
02833 09FC           44                         inc	sp
02834                                           !BCC_EOS
02835                                           ! 1064     if (check_for_keystroke())
02836                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02837 09FD           E8         FFD2            call	_check_for_keystroke
02838 0A00           84C0                       test	al,al
02839 0A02           74           02            je  	.3C
02840                       00000A04            .3D:
02841                                           ! 1065       break;
02842 0A04           EB           0F            jmp .38
02843                                           !BCC_EOS
02844                                           ! 1066   }
02845                       00000A06            .3C:
02846                                           ! 1067 }
02847                       00000A06            .39:
02848                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02849 0A06           8B46         FE            mov	ax,-2[bp]
02850 0A09           40                         inc	ax
02851 0A0A           8946         FE            mov	-2[bp],ax
02852                       00000A0D            .3A:
02853                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02854 0A0D           8B46         FE            mov	ax,-2[bp]
02855 0A10           3B46         06            cmp	ax,6[bp]
02856 0A13           76           E0            jbe	.3B
02857                       00000A15            .3E:
02858                       00000A15            .38:
02859 0A15           89EC                       mov	sp,bp
02860 0A17           5D                         pop	bp
02861 0A18           C3                         ret
02862                                           ! 1068   void
02863                                           ! 1069 bios_printf(action, s)
02864                                           ! 1070   Bit16u action;
02865                                           export	_bios_printf
02866                       00000A19            _bios_printf:
02867                                           !BCC_EOS
02868                                           ! 1071   Bit8u *s;
02869                                           !BCC_EOS
02870                                           ! 1072 {
02871                                           ! 1073   Bit8u c, format_char;
02872                                           !BCC_EOS
02873                                           ! 1074   bx_bool in_format;
02874                                           !BCC_EOS
02875                                           ! 1075   short i;
02876                                           !BCC_EOS
02877                                           ! 1076   Bit16u *arg_ptr;
02878                                           !BCC_EOS
02879                                           ! 1077   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
02880                                           !BCC_EOS
02881                                           ! 1078   arg_ptr = &s;
02882 0A19           55                         push	bp
02883 0A1A           89E5                       mov	bp,sp
02884 0A1C           83C4                   EA  add	sp,*-$16
02885                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02886 0A1F           8D5E         06            lea	bx,6[bp]
02887 0A22           895E         F8            mov	-8[bp],bx
02888                                           !BCC_EOS
02889                                           ! 1079   arg_seg = get_SS();
02890                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
02891 0A25           E8         FC25            call	_get_SS
02892                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
02893 0A28           8946         F6            mov	-$A[bp],ax
02894                                           !BCC_EOS
02895                                           ! 1080   in_format = 0;
02896                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02897 0A2B           31C0                       xor	ax,ax
02898 0A2D           8946         FC            mov	-4[bp],ax
02899                                           !BCC_EOS
02900                                           ! 1081   format_width = 0;
02901                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02902 0A30           31C0                       xor	ax,ax
02903 0A32           8946         EC            mov	-$14[bp],ax
02904                                           !BCC_EOS
02905                                           ! 1082   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02906                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02907 0A35           8A46         04            mov	al,4[bp]
02908 0A38           24                     07  and	al,*7
02909                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02910 0A3A           3C                     07  cmp	al,*7
02911 0A3C           75           1B            jne 	.3F
02912                       00000A3E            .40:
02913                                           ! 1083     outb(0x401, 0x00);
02914                                           ! Debug: list int = const 0 (used reg = )
02915 0A3E           31C0                       xor	ax,ax
02916 0A40           50                         push	ax
02917                                           ! Debug: list int = const $401 (used reg = )
02918 0A41           B8                   0401  mov	ax,#$401
02919 0A44           50                         push	ax
02920                                           ! Debug: func () void = outb+0 (used reg = )
02921 0A45           E8         FB0C            call	_outb
02922 0A48           83C4                   04  add	sp,*4
02923                                           !BCC_EOS
02924                                           ! 1084     bios_printf (2, "FATAL: ");
02925                                           ! Debug: list * char = .41+0 (used reg = )
02926 0A4B           BB                   DE2E  mov	bx,#.41
02927 0A4E           53                         push	bx
02928                                           ! Debug: list int = const 2 (used reg = )
02929 0A4F           B8                   0002  mov	ax,*2
02930 0A52           50                         push	ax
02931                                           ! Debug: func () void = bios_printf+0 (used reg = )
02932 0A53           E8         FFC3            call	_bios_printf
02933 0A56           83C4                   04  add	sp,*4
02934                                           !BCC_EOS
02935                                           ! 1085   }
02936                                           ! 1086   while (c = read_byte(get_CS(), s)) {
02937                       00000A59            .3F:
02938 0A59           E9         0369            br 	.43
02939                       00000A5C            .44:
02940                                           ! 1087     if ( c == '%' ) {
02941                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02942 0A5C           8A46         FF            mov	al,-1[bp]
02943 0A5F           3C                     25  cmp	al,*$25
02944 0A61           75           0E            jne 	.45
02945                       00000A63            .46:
02946                                           ! 1088       in_format = 1;
02947                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02948 0A63           B8                   0001  mov	ax,*1
02949 0A66           8946         FC            mov	-4[bp],ax
02950                                           !BCC_EOS
02951                                           ! 1089       format_width = 0;
02952                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02953 0A69           31C0                       xor	ax,ax
02954 0A6B           8946         EC            mov	-$14[bp],ax
02955                                           !BCC_EOS
02956                                           ! 1090       }
02957                                           ! 1091     else if (in_format) {
02958 0A6E           E9         034D            br 	.47
02959                       00000A71            .45:
02960 0A71           8B46         FC            mov	ax,-4[bp]
02961 0A74           85C0                       test	ax,ax
02962 0A76         0F84         0335            beq 	.48
02963                       00000A7A            .49:
02964                                           ! 1092       if ( (c>='0') && (c<='9') ) {
02965                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02966 0A7A           8A46         FF            mov	al,-1[bp]
02967 0A7D           3C                     30  cmp	al,*$30
02968 0A7F           72           28            jb  	.4A
02969                       00000A81            .4C:
02970                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02971 0A81           8A46         FF            mov	al,-1[bp]
02972 0A84           3C                     39  cmp	al,*$39
02973 0A86           77           21            ja  	.4A
02974                       00000A88            .4B:
02975                                           ! 1093         format_width = (format_width * 10) + (c - '0');
02976                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02977 0A88           8A46         FF            mov	al,-1[bp]
02978 0A8B           30E4                       xor	ah,ah
02979 0A8D           05                   FFD0  add	ax,*-$30
02980 0A90           50                         push	ax
02981                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
02982 0A91           8B46         EC            mov	ax,-$14[bp]
02983 0A94           89C2                       mov	dx,ax
02984 0A96           D1E0                       shl	ax,*1
02985 0A98           D1E0                       shl	ax,*1
02986 0A9A           01D0                       add	ax,dx
02987 0A9C           D1E0                       shl	ax,*1
02988                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02989 0A9E           0346         E8            add	ax,-$18[bp]
02990 0AA1           44                         inc	sp
02991 0AA2           44                         inc	sp
02992                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
02993 0AA3           8946         EC            mov	-$14[bp],ax
02994                                           !BCC_EOS
02995                                           ! 1094         }
02996                                           ! 1095       else {
02997 0AA6           E9         0304            br 	.4D
02998                       00000AA9            .4A:
02999                                           ! 1096         arg_ptr++;
03000                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03001 0AA9           8B5E         F8            mov	bx,-8[bp]
03002 0AAC           43                         inc	bx
03003 0AAD           43                         inc	bx
03004 0AAE           895E         F8            mov	-8[bp],bx
03005                                           !BCC_EOS
03006                                           ! 1097         arg = read_word(arg_seg, arg_ptr);
03007                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03008 0AB1           FF76         F8            push	-8[bp]
03009                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03010 0AB4           FF76         F6            push	-$A[bp]
03011                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03012 0AB7           E8         FB4D            call	_read_word
03013 0ABA           83C4                   04  add	sp,*4
03014                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03015 0ABD           8946         F4            mov	-$C[bp],ax
03016                                           !BCC_EOS
03017                                           ! 1098         if (c == 'x' || c == 'X') {
03018                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03019 0AC0           8A46         FF            mov	al,-1[bp]
03020 0AC3           3C                     78  cmp	al,*$78
03021 0AC5           74           09            je  	.4F
03022                       00000AC7            .50:
03023                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03024 0AC7           8A46         FF            mov	al,-1[bp]
03025 0ACA           3C                     58  cmp	al,*$58
03026 0ACC         0F85         0076            bne 	.4E
03027                       00000AD0            .4F:
03028                                           ! 1099           if (format_width == 0)
03029                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03030 0AD0           8B46         EC            mov	ax,-$14[bp]
03031 0AD3           85C0                       test	ax,ax
03032 0AD5           75           06            jne 	.51
03033                       00000AD7            .52:
03034                                           ! 1100             format_width = 4;
03035                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
03036 0AD7           B8                   0004  mov	ax,*4
03037 0ADA           8946         EC            mov	-$14[bp],ax
03038                                           !BCC_EOS
03039                                           ! 1101           if (c == 'x')
03040                       00000ADD            .51:
03041                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03042 0ADD           8A46         FF            mov	al,-1[bp]
03043 0AE0           3C                     78  cmp	al,*$78
03044 0AE2           75           08            jne 	.53
03045                       00000AE4            .54:
03046                                           ! 1102             hexadd = 'a';
03047                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03048 0AE4           B8                   0061  mov	ax,*$61
03049 0AE7           8946         EA            mov	-$16[bp],ax
03050                                           !BCC_EOS
03051                                           ! 1103           else
03052                                           ! 1104             hexadd = 'A';
03053 0AEA           EB           06            jmp .55
03054                       00000AEC            .53:
03055                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03056 0AEC           B8                   0041  mov	ax,*$41
03057 0AEF           8946         EA            mov	-$16[bp],ax
03058                                           !BCC_EOS
03059                                           ! 1105           for (i=format_width-1; i>=0; i--) {
03060                       00000AF2            .55:
03061                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03062 0AF2           8B46         EC            mov	ax,-$14[bp]
03063                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03064 0AF5           48                         dec	ax
03065 0AF6           8946         FA            mov	-6[bp],ax
03066                                           !BCC_EOS
03067                                           !BCC_EOS
03068 0AF9           EB           41            jmp .58
03069                       00000AFB            .59:
03070                                           ! 1106             nibble = (arg >> (4 * i)) & 0x000f;
03071                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03072                                           ! Debug: expression subtree swapping
03073 0AFB           8B46         FA            mov	ax,-6[bp]
03074 0AFE           D1E0                       shl	ax,*1
03075 0B00           D1E0                       shl	ax,*1
03076                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03077 0B02           89C3                       mov	bx,ax
03078 0B04           8B46         F4            mov	ax,-$C[bp]
03079 0B07           89D9                       mov	cx,bx
03080 0B09           D3E8                       shr	ax,cl
03081                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
03082 0B0B           24                     0F  and	al,*$F
03083                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03084 0B0D           30E4                       xor	ah,ah
03085 0B0F           8946         F2            mov	-$E[bp],ax
03086                                           !BCC_EOS
03087                                           ! 1107             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03088                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03089 0B12           8B46         F2            mov	ax,-$E[bp]
03090 0B15           3D                   0009  cmp	ax,*9
03091 0B18           77           08            ja  	.5A
03092                       00000B1A            .5B:
03093                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03094 0B1A           8B46         F2            mov	ax,-$E[bp]
03095 0B1D           05                   0030  add	ax,*$30
03096 0B20           EB           09            jmp .5C
03097                       00000B22            .5A:
03098                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03099 0B22           8B46         F2            mov	ax,-$E[bp]
03100                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03101 0B25           05                   FFF6  add	ax,*-$A
03102 0B28           0346         EA            add	ax,-$16[bp]
03103                       00000B2B            .5C:
03104                                           ! Debug: list unsigned int = ax+0 (used reg = )
03105 0B2B           50                         push	ax
03106                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03107 0B2C           FF76         04            push	4[bp]
03108                                           ! Debug: func () void = send+0 (used reg = )
03109 0B2F           E8         FB95            call	_send
03110 0B32           83C4                   04  add	sp,*4
03111                                           !BCC_EOS
03112                                           ! 1108             }
03113                                           ! 1109           }
03114                       00000B35            .57:
03115                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03116 0B35           8B46         FA            mov	ax,-6[bp]
03117 0B38           48                         dec	ax
03118 0B39           8946         FA            mov	-6[bp],ax
03119                       00000B3C            .58:
03120                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03121 0B3C           8B46         FA            mov	ax,-6[bp]
03122 0B3F           85C0                       test	ax,ax
03123 0B41           7D           B8            jge	.59
03124                       00000B43            .5D:
03125                       00000B43            .56:
03126                                           ! 1110         else if (c == 'u') {
03127 0B43           E9         0262            br 	.5E
03128                       00000B46            .4E:
03129                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03130 0B46           8A46         FF            mov	al,-1[bp]
03131 0B49           3C                     75  cmp	al,*$75
03132 0B4B           75           15            jne 	.5F
03133                       00000B4D            .60:
03134                                           ! 1111           put_uint(action, arg, format_width, 0);
03135                                           ! Debug: list int = const 0 (used reg = )
03136 0B4D           31C0                       xor	ax,ax
03137 0B4F           50                         push	ax
03138                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03139 0B50           FF76         EC            push	-$14[bp]
03140                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03141 0B53           FF76         F4            push	-$C[bp]
03142                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03143 0B56           FF76         04            push	4[bp]
03144                                           ! Debug: func () void = put_uint+0 (used reg = )
03145 0B59           E8         FC56            call	_put_uint
03146 0B5C           83C4                   08  add	sp,*8
03147                                           !BCC_EOS
03148                                           ! 1112           }
03149                                           ! 1113         else if (c == 'l') {
03150 0B5F           E9         0246            br 	.61
03151                       00000B62            .5F:
03152                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03153 0B62           8A46         FF            mov	al,-1[bp]
03154 0B65           3C                     6C  cmp	al,*$6C
03155 0B67         0F85         018D            bne 	.62
03156                       00000B6B            .63:
03157                                           ! 1114           s++;
03158                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03159 0B6B           8B5E         06            mov	bx,6[bp]
03160 0B6E           43                         inc	bx
03161 0B6F           895E         06            mov	6[bp],bx
03162                                           !BCC_EOS
03163                                           ! 1115           c = read_byte(get_CS(), s);
03164                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03165 0B72           FF76         06            push	6[bp]
03166                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03167 0B75           E8         FAD2            call	_get_CS
03168                                           ! Debug: list unsigned short = ax+0 (used reg = )
03169 0B78           50                         push	ax
03170                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03171 0B79           E8         FA78            call	_read_byte
03172 0B7C           83C4                   04  add	sp,*4
03173                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03174 0B7F           8846         FF            mov	-1[bp],al
03175                                           !BCC_EOS
03176                                           ! 1116           arg_ptr++;
03177                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03178 0B82           8B5E         F8            mov	bx,-8[bp]
03179 0B85           43                         inc	bx
03180 0B86           43                         inc	bx
03181 0B87           895E         F8            mov	-8[bp],bx
03182                                           !BCC_EOS
03183                                           ! 1117           hibyte = read_word(arg_seg, arg_ptr);
03184                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03185 0B8A           FF76         F8            push	-8[bp]
03186                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03187 0B8D           FF76         F6            push	-$A[bp]
03188                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03189 0B90           E8         FA74            call	_read_word
03190 0B93           83C4                   04  add	sp,*4
03191                                           ! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
03192 0B96           8946         F0            mov	-$10[bp],ax
03193                                           !BCC_EOS
03194                                           ! 1118           if (c == 'd') {
03195                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03196 0B99           8A46         FF            mov	al,-1[bp]
03197 0B9C           3C                     64  cmp	al,*$64
03198 0B9E           75           73            jne 	.64
03199                       00000BA0            .65:
03200                                           ! 1119             if (hibyte & 0x8000)
03201                                           ! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
03202 0BA0           8B46         F0            mov	ax,-$10[bp]
03203 0BA3           25                   8000  and	ax,#$8000
03204 0BA6           85C0                       test	ax,ax
03205 0BA8           74           3D            je  	.66
03206                       00000BAA            .67:
03207                                           ! 1120               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
03208                                           ! Debug: list int = const 1 (used reg = )
03209 0BAA           B8                   0001  mov	ax,*1
03210 0BAD           50                         push	ax
03211                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03212 0BAE           8B46         EC            mov	ax,-$14[bp]
03213                                           ! Debug: list unsigned int = ax-1 (used reg = )
03214 0BB1           48                         dec	ax
03215 0BB2           50                         push	ax
03216                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03217 0BB3           8B46         F4            mov	ax,-$C[bp]
03218 0BB6           31DB                       xor	bx,bx
03219 0BB8           53                         push	bx
03220 0BB9           50                         push	ax
03221                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03222 0BBA           8B46         F0            mov	ax,-$10[bp]
03223 0BBD           31DB                       xor	bx,bx
03224                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03225 0BBF           93                         xchg	bx,ax
03226 0BC0           31C0                       xor	ax,ax
03227                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03228 0BC2           8D7E         E2            lea	di,-$1E[bp]
03229 0BC5           E8         F53F            call	lorul
03230 0BC8           83C4                   04  add	sp,*4
03231                                           ! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
03232 0BCB           53                         push	bx
03233 0BCC           50                         push	ax
03234 0BCD           31C0                       xor	ax,ax
03235 0BCF           31DB                       xor	bx,bx
03236 0BD1           8D7E         E2            lea	di,-$1E[bp]
03237 0BD4           E8         F50A            call	lsubul
03238 0BD7           83C4                   04  add	sp,*4
03239                                           ! Debug: list unsigned long = bx+0 (used reg = )
03240 0BDA           53                         push	bx
03241 0BDB           50                         push	ax
03242                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03243 0BDC           FF76         04            push	4[bp]
03244                                           ! Debug: func () void = put_luint+0 (used reg = )
03245 0BDF           E8         FC53            call	_put_luint
03246 0BE2           83C4                   0A  add	sp,*$A
03247                                           !BCC_EOS
03248                                           ! 1121             else
03249                                           ! 1122               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03250 0BE5           EB           29            jmp .68
03251                       00000BE7            .66:
03252                                           ! Debug: list int = const 0 (used reg = )
03253 0BE7           31C0                       xor	ax,ax
03254 0BE9           50                         push	ax
03255                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03256 0BEA           FF76         EC            push	-$14[bp]
03257                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03258 0BED           8B46         F4            mov	ax,-$C[bp]
03259 0BF0           31DB                       xor	bx,bx
03260 0BF2           53                         push	bx
03261 0BF3           50                         push	ax
03262                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03263 0BF4           8B46         F0            mov	ax,-$10[bp]
03264 0BF7           31DB                       xor	bx,bx
03265                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03266 0BF9           93                         xchg	bx,ax
03267 0BFA           31C0                       xor	ax,ax
03268                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03269 0BFC           8D7E         E2            lea	di,-$1E[bp]
03270 0BFF           E8         F505            call	lorul
03271 0C02           83C4                   04  add	sp,*4
03272                                           ! Debug: list unsigned long = bx+0 (used reg = )
03273 0C05           53                         push	bx
03274 0C06           50                         push	ax
03275                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03276 0C07           FF76         04            push	4[bp]
03277                                           ! Debug: func () void = put_luint+0 (used reg = )
03278 0C0A           E8         FC28            call	_put_luint
03279 0C0D           83C4                   0A  add	sp,*$A
03280                                           !BCC_EOS
03281                                           ! 1123            }
03282                       00000C10            .68:
03283                                           ! 1124           else if (c == 'u') {
03284 0C10           E9         00E2            br 	.69
03285                       00000C13            .64:
03286                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03287 0C13           8A46         FF            mov	al,-1[bp]
03288 0C16           3C                     75  cmp	al,*$75
03289 0C18           75           2C            jne 	.6A
03290                       00000C1A            .6B:
03291                                           ! 1125             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03292                                           ! Debug: list int = const 0 (used reg = )
03293 0C1A           31C0                       xor	ax,ax
03294 0C1C           50                         push	ax
03295                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03296 0C1D           FF76         EC            push	-$14[bp]
03297                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03298 0C20           8B46         F4            mov	ax,-$C[bp]
03299 0C23           31DB                       xor	bx,bx
03300 0C25           53                         push	bx
03301 0C26           50                         push	ax
03302                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03303 0C27           8B46         F0            mov	ax,-$10[bp]
03304 0C2A           31DB                       xor	bx,bx
03305                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03306 0C2C           93                         xchg	bx,ax
03307 0C2D           31C0                       xor	ax,ax
03308                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03309 0C2F           8D7E         E2            lea	di,-$1E[bp]
03310 0C32           E8         F4D2            call	lorul
03311 0C35           83C4                   04  add	sp,*4
03312                                           ! Debug: list unsigned long = bx+0 (used reg = )
03313 0C38           53                         push	bx
03314 0C39           50                         push	ax
03315                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03316 0C3A           FF76         04            push	4[bp]
03317                                           ! Debug: func () void = put_luint+0 (used reg = )
03318 0C3D           E8         FBF5            call	_put_luint
03319 0C40           83C4                   0A  add	sp,*$A
03320                                           !BCC_EOS
03321                                           ! 1126      
03322                                           ! 1126       }
03323                                           ! 1127           else if (c == 'x' || c == 'X')
03324 0C43           E9         00AF            br 	.6C
03325                       00000C46            .6A:
03326                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03327 0C46           8A46         FF            mov	al,-1[bp]
03328 0C49           3C                     78  cmp	al,*$78
03329 0C4B           74           09            je  	.6E
03330                       00000C4D            .6F:
03331                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03332 0C4D           8A46         FF            mov	al,-1[bp]
03333 0C50           3C                     58  cmp	al,*$58
03334 0C52         0F85         009F            bne 	.6D
03335                       00000C56            .6E:
03336                                           ! 1128            {
03337                                           ! 1129             if (format_width == 0)
03338                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03339 0C56           8B46         EC            mov	ax,-$14[bp]
03340 0C59           85C0                       test	ax,ax
03341 0C5B           75           06            jne 	.70
03342                       00000C5D            .71:
03343                                           ! 1130               format_width = 8;
03344                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
03345 0C5D           B8                   0008  mov	ax,*8
03346 0C60           8946         EC            mov	-$14[bp],ax
03347                                           !BCC_EOS
03348                                           ! 1131             if (c == 'x')
03349                       00000C63            .70:
03350                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03351 0C63           8A46         FF            mov	al,-1[bp]
03352 0C66           3C                     78  cmp	al,*$78
03353 0C68           75           08            jne 	.72
03354                       00000C6A            .73:
03355                                           ! 1132               hexadd = 'a';
03356                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03357 0C6A           B8                   0061  mov	ax,*$61
03358 0C6D           8946         EA            mov	-$16[bp],ax
03359                                           !BCC_EOS
03360                                           ! 1133             else
03361                                           ! 1134               hexadd = 'A';
03362 0C70           EB           06            jmp .74
03363                       00000C72            .72:
03364                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03365 0C72           B8                   0041  mov	ax,*$41
03366 0C75           8946         EA            mov	-$16[bp],ax
03367                                           !BCC_EOS
03368                                           ! 1135             for (i=format_width-1; i>=0; i--) {
03369                       00000C78            .74:
03370                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03371 0C78           8B46         EC            mov	ax,-$14[bp]
03372                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03373 0C7B           48                         dec	ax
03374 0C7C           8946         FA            mov	-6[bp],ax
03375                                           !BCC_EOS
03376                                           !BCC_EOS
03377 0C7F           EB           6D            jmp .77
03378                       00000C81            .78:
03379                                           ! 1136               nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
03380                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03381                                           ! Debug: expression subtree swapping
03382 0C81           8B46         FA            mov	ax,-6[bp]
03383 0C84           D1E0                       shl	ax,*1
03384 0C86           D1E0                       shl	ax,*1
03385 0C88           50                         push	ax
03386                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
03387 0C89           8B46         F4            mov	ax,-$C[bp]
03388 0C8C           31DB                       xor	bx,bx
03389 0C8E           53                         push	bx
03390 0C8F           50                         push	ax
03391                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
03392 0C90           8B46         F0            mov	ax,-$10[bp]
03393 0C93           31DB                       xor	bx,bx
03394                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03395 0C95           93                         xchg	bx,ax
03396 0C96           31C0                       xor	ax,ax
03397                                           ! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
03398 0C98           8D7E         E4            lea	di,-$1C[bp]
03399 0C9B           E8         F469            call	lorul
03400 0C9E           83C4                   04  add	sp,*4
03401                                           ! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
03402 0CA1           8B7E         E8            mov	di,-$18[bp]
03403 0CA4           E8         F482            call	lsrul
03404 0CA7           44                         inc	sp
03405 0CA8           44                         inc	sp
03406                                           ! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
03407 0CA9           53                         push	bx
03408 0CAA           50                         push	ax
03409 0CAB           B8                   000F  mov	ax,*$F
03410 0CAE           31DB                       xor	bx,bx
03411 0CB0           53                         push	bx
03412 0CB1           50                         push	ax
03413 0CB2           8B46         E6            mov	ax,-$1A[bp]
03414 0CB5           8B5E         E8            mov	bx,-$18[bp]
03415 0CB8           8D7E         E2            lea	di,-$1E[bp]
03416 0CBB           E8         F3FD            call	landul
03417 0CBE           83C4                   08  add	sp,*8
03418                                           ! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03419 0CC1           8946         F2            mov	-$E[bp],ax
03420                                           !BCC_EOS
03421                                           ! 1137               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03422                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03423 0CC4           8B46         F2            mov	ax,-$E[bp]
03424 0CC7           3D                   0009  cmp	ax,*9
03425 0CCA           77           08            ja  	.79
03426                       00000CCC            .7A:
03427                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03428 0CCC           8B46         F2            mov	ax,-$E[bp]
03429 0CCF           05                   0030  add	ax,*$30
03430 0CD2           EB           09            jmp .7B
03431                       00000CD4            .79:
03432                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03433 0CD4           8B46         F2            mov	ax,-$E[bp]
03434                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03435 0CD7           05                   FFF6  add	ax,*-$A
03436 0CDA           0346         EA            add	ax,-$16[bp]
03437                       00000CDD            .7B:
03438                                           ! Debug: list unsigned int = ax+0 (used reg = )
03439 0CDD           50                         push	ax
03440                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03441 0CDE           FF76         04            push	4[bp]
03442                                           ! Debug: func () void = send+0 (used reg = )
03443 0CE1           E8         F9E3            call	_send
03444 0CE4           83C4                   04  add	sp,*4
03445                                           !BCC_EOS
03446                                           ! 1138               }
03447                                           ! 1139            }
03448                       00000CE7            .76:
03449                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03450 0CE7           8B46         FA            mov	ax,-6[bp]
03451 0CEA           48                         dec	ax
03452 0CEB           8946         FA            mov	-6[bp],ax
03453                       00000CEE            .77:
03454                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03455 0CEE           8B46         FA            mov	ax,-6[bp]
03456 0CF1           85C0                       test	ax,ax
03457 0CF3           7D           8C            jge	.78
03458                       00000CF5            .7C:
03459                       00000CF5            .75:
03460                                           ! 1140           }
03461                       00000CF5            .6D:
03462                       00000CF5            .6C:
03463                       00000CF5            .69:
03464                                           ! 1141         else if (c == 'd') {
03465 0CF5           E9         00B0            br 	.7D
03466                       00000CF8            .62:
03467                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03468 0CF8           8A46         FF            mov	al,-1[bp]
03469 0CFB           3C                     64  cmp	al,*$64
03470 0CFD           75           38            jne 	.7E
03471                       00000CFF            .7F:
03472                                           ! 1142           if (arg & 0x8000)
03473                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
03474 0CFF           8B46         F4            mov	ax,-$C[bp]
03475 0D02           25                   8000  and	ax,#$8000
03476 0D05           85C0                       test	ax,ax
03477 0D07           74           1A            je  	.80
03478                       00000D09            .81:
03479                                           ! 1143             put_int(action, -arg, format_width - 1, 1);
03480                                           ! Debug: list int = const 1 (used reg = )
03481 0D09           B8                   0001  mov	ax,*1
03482 0D0C           50                         push	ax
03483                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03484 0D0D           8B46         EC            mov	ax,-$14[bp]
03485                                           ! Debug: list unsigned int = ax-1 (used reg = )
03486 0D10           48                         dec	ax
03487 0D11           50                         push	ax
03488                                           ! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
03489 0D12           31C0                       xor	ax,ax
03490 0D14           2B46         F4            sub	ax,-$C[bp]
03491                                           ! Debug: list unsigned int = ax+0 (used reg = )
03492 0D17           50                         push	ax
03493                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03494 0D18           FF76         04            push	4[bp]
03495                                           ! Debug: func () void = put_int+0 (used reg = )
03496 0D1B           E8         FA11            call	_put_int
03497 0D1E           83C4                   08  add	sp,*8
03498                                           !BCC_EOS
03499                                           ! 1144           else
03500                                           ! 1145             put_int(action, arg, format_width, 0);
03501 0D21           EB           12            jmp .82
03502                       00000D23            .80:
03503                                           ! Debug: list int = const 0 (used reg = )
03504 0D23           31C0                       xor	ax,ax
03505 0D25           50                         push	ax
03506                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03507 0D26           FF76         EC            push	-$14[bp]
03508                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03509 0D29           FF76         F4            push	-$C[bp]
03510                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03511 0D2C           FF76         04            push	4[bp]
03512                                           ! Debug: func () void = put_int+0 (used reg = )
03513 0D2F           E8         F9FD            call	_put_int
03514 0D32           83C4                   08  add	sp,*8
03515                                           !BCC_EOS
03516                                           ! 1146           }
03517                       00000D35            .82:
03518                                           ! 1147         else if (c == 's') {
03519 0D35           EB           71            jmp .83
03520                       00000D37            .7E:
03521                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03522 0D37           8A46         FF            mov	al,-1[bp]
03523 0D3A           3C                     73  cmp	al,*$73
03524 0D3C           75           12            jne 	.84
03525                       00000D3E            .85:
03526                                           ! 1148           put_str(action, get_CS(), arg);
03527                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03528 0D3E           FF76         F4            push	-$C[bp]
03529                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03530 0D41           E8         F906            call	_get_CS
03531                                           ! Debug: list unsigned short = ax+0 (used reg = )
03532 0D44           50                         push	ax
03533                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03534 0D45           FF76         04            push	4[bp]
03535                                           ! Debug: func () void = put_str+0 (used reg = )
03536 0D48           E8         FBA1            call	_put_str
03537 0D4B           83C4                   06  add	sp,*6
03538                                           !BCC_EOS
03539                                           ! 1149           }
03540                                           ! 1150         else if (c == 'S') {
03541 0D4E           EB           58            jmp .86
03542                       00000D50            .84:
03543                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03544 0D50           8A46         FF            mov	al,-1[bp]
03545 0D53           3C                     53  cmp	al,*$53
03546 0D55           75           2E            jne 	.87
03547                       00000D57            .88:
03548                                           ! 1151           hibyte = arg;
03549                                           ! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
03550 0D57           8B46         F4            mov	ax,-$C[bp]
03551 0D5A           8946         F0            mov	-$10[bp],ax
03552                                           !BCC_EOS
03553                                           ! 1152           arg_ptr++;
03554                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03555 0D5D           8B5E         F8            mov	bx,-8[bp]
03556 0D60           43                         inc	bx
03557 0D61           43                         inc	bx
03558 0D62           895E         F8            mov	-8[bp],bx
03559                                           !BCC_EOS
03560                                           ! 1153           arg = read_word(arg_seg, arg_ptr);
03561                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03562 0D65           FF76         F8            push	-8[bp]
03563                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03564 0D68           FF76         F6            push	-$A[bp]
03565                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03566 0D6B           E8         F899            call	_read_word
03567 0D6E           83C4                   04  add	sp,*4
03568                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03569 0D71           8946         F4            mov	-$C[bp],ax
03570                                           !BCC_EOS
03571                                           ! 1154           put_str(action, hibyte, arg);
03572                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03573 0D74           FF76         F4            push	-$C[bp]
03574                                           ! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
03575 0D77           FF76         F0            push	-$10[bp]
03576                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03577 0D7A           FF76         04            push	4[bp]
03578                                           ! Debug: func () void = put_str+0 (used reg = )
03579 0D7D           E8         FB6C            call	_put_str
03580 0D80           83C4                   06  add	sp,*6
03581                                           !BCC_EOS
03582                                           ! 1155           }
03583                                           ! 1156         else if (c == 'c') {
03584 0D83           EB           23            jmp .89
03585                       00000D85            .87:
03586                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03587 0D85           8A46         FF            mov	al,-1[bp]
03588 0D88           3C                     63  cmp	al,*$63
03589 0D8A           75           0E            jne 	.8A
03590                       00000D8C            .8B:
03591                                           ! 1157           send(action, arg);
03592                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03593 0D8C           FF76         F4            push	-$C[bp]
03594                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03595 0D8F           FF76         04            push	4[bp]
03596                                           ! Debug: func () void = send+0 (used reg = )
03597 0D92           E8         F932            call	_send
03598 0D95           83C4                   04  add	sp,*4
03599                                           !BCC_EOS
03600                                           ! 1158           }
03601                                           ! 1159         else
03602                                           ! 1160           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03603 0D98           EB           0E            jmp .8C
03604                       00000D9A            .8A:
03605                                           ! Debug: list * char = .8D+0 (used reg = )
03606 0D9A           BB                   DE11  mov	bx,#.8D
03607 0D9D           53                         push	bx
03608                                           ! Debug: list int = const 7 (used reg = )
03609 0D9E           B8                   0007  mov	ax,*7
03610 0DA1           50                         push	ax
03611                                           ! Debug: func () void = bios_printf+0 (used reg = )
03612 0DA2           E8         FC74            call	_bios_printf
03613 0DA5           83C4                   04  add	sp,*4
03614                                           !BCC_EOS
03615                                           ! 1161           in_format = 0;
03616                       00000DA8            .8C:
03617                       00000DA8            .89:
03618                       00000DA8            .86:
03619                       00000DA8            .83:
03620                       00000DA8            .7D:
03621                       00000DA8            .61:
03622                       00000DA8            .5E:
03623                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03624 0DA8           31C0                       xor	ax,ax
03625 0DAA           8946         FC            mov	-4[bp],ax
03626                                           !BCC_EOS
03627                                           ! 1162         }
03628                                           ! 1163       }
03629                       00000DAD            .4D:
03630                                           ! 1164     else {
03631 0DAD           EB           0F            jmp .8E
03632                       00000DAF            .48:
03633                                           ! 1165       send(action, c);
03634                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03635 0DAF           8A46         FF            mov	al,-1[bp]
03636 0DB2           30E4                       xor	ah,ah
03637 0DB4           50                         push	ax
03638                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03639 0DB5           FF76         04            push	4[bp]
03640                                           ! Debug: func () void = send+0 (used reg = )
03641 0DB8           E8         F90C            call	_send
03642 0DBB           83C4                   04  add	sp,*4
03643                                           !BCC_EOS
03644                                           ! 1166       }
03645                                           ! 1167     s ++;
03646                       00000DBE            .8E:
03647                       00000DBE            .47:
03648                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03649 0DBE           8B5E         06            mov	bx,6[bp]
03650 0DC1           43                         inc	bx
03651 0DC2           895E         06            mov	6[bp],bx
03652                                           !BCC_EOS
03653                                           ! 1168     }
03654                                           ! 1169   if (action & 1) {
03655                       00000DC5            .43:
03656                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03657 0DC5           FF76         06            push	6[bp]
03658                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03659 0DC8           E8         F87F            call	_get_CS
03660                                           ! Debug: list unsigned short = ax+0 (used reg = )
03661 0DCB           50                         push	ax
03662                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03663 0DCC           E8         F825            call	_read_byte
03664 0DCF           83C4                   04  add	sp,*4
03665                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03666 0DD2           8846         FF            mov	-1[bp],al
03667 0DD5           84C0                       test	al,al
03668 0DD7         0F85         FC81            bne 	.44
03669                       00000DDB            .8F:
03670                       00000DDB            .42:
03671                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03672 0DDB           8A46         04            mov	al,4[bp]
03673 0DDE           24                     01  and	al,*1
03674 0DE0           84C0                       test	al,al
03675 0DE2           74           04            je  	.90
03676                       00000DE4            .91:
03677                                           ! 1170 #asm
03678                                           !BCC_EOS
03679                                           !BCC_ASM
03680                       00000002            _bios_printf.format_width	set	2
03681                       FFFFFFEC            .bios_printf.format_width	set	-$14
03682                       00000014            _bios_printf.format_char	set	$14
03683                       FFFFFFFE            .bios_printf.format_char	set	-2
03684                       00000006            _bios_printf.hibyte	set	6
03685                       FFFFFFF0            .bios_printf.hibyte	set	-$10
03686                       0000000E            _bios_printf.arg_ptr	set	$E
03687                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03688                       0000001A            _bios_printf.action	set	$1A
03689                       00000004            .bios_printf.action	set	4
03690                       00000010            _bios_printf.i	set	$10
03691                       FFFFFFFA            .bios_printf.i	set	-6
03692                       0000000C            _bios_printf.arg_seg	set	$C
03693                       FFFFFFF6            .bios_printf.arg_seg	set	-$A
03694                       00000004            _bios_printf.shift_count	set	4
03695                       FFFFFFEE            .bios_printf.shift_count	set	-$12
03696                       00000012            _bios_printf.in_format	set	$12
03697                       FFFFFFFC            .bios_printf.in_format	set	-4
03698                       0000001C            _bios_printf.s	set	$1C
03699                       00000006            .bios_printf.s	set	6
03700                       00000008            _bios_printf.nibble	set	8
03701                       FFFFFFF2            .bios_printf.nibble	set	-$E
03702                       00000015            _bios_printf.c	set	$15
03703                       FFFFFFFF            .bios_printf.c	set	-1
03704                       00000000            _bios_printf.hexadd	set	0
03705                       FFFFFFEA            .bios_printf.hexadd	set	-$16
03706                       0000000A            _bios_printf.arg	set	$A
03707                       FFFFFFF4            .bios_printf.arg	set	-$C
03708 0DE4           FA                             cli
03709                       00000DE5             halt2_loop:
03710 0DE5           F4                             hlt
03711 0DE6           EB           FD                jmp halt2_loop
03712                                           ! 1175 endasm
03713                                           !BCC_ENDASM
03714                                           !BCC_EOS
03715                                           ! 1176     }
03716                                           ! 1177 }
03717                       00000DE8            .90:
03718 0DE8           89EC                       mov	sp,bp
03719 0DEA           5D                         pop	bp
03720 0DEB           C3                         ret
03721                                           ! 1178   void
03722                                           ! Register BX used in function bios_printf
03723                                           ! 1179 keyboard_init()
03724                                           ! 1180 {
03725                                           export	_keyboard_init
03726                       00000DEC            _keyboard_init:
03727                                           ! 1181     Bit16u max;
03728                                           !BCC_EOS
03729                                           ! 1182     max=0xffff;
03730 0DEC           55                         push	bp
03731 0DED           89E5                       mov	bp,sp
03732 0DEF           4C                         dec	sp
03733 0DF0           4C                         dec	sp
03734                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03735 0DF1           B8                   FFFF  mov	ax,#$FFFF
03736 0DF4           8946         FE            mov	-2[bp],ax
03737                                           !BCC_EOS
03738                                           ! 1183     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03739 0DF7           EB           0D            jmp .93
03740                       00000DF9            .94:
03741                                           ! Debug: list int = const 0 (used reg = )
03742 0DF9           31C0                       xor	ax,ax
03743 0DFB           50                         push	ax
03744                                           ! Debug: list int = const $80 (used reg = )
03745 0DFC           B8                   0080  mov	ax,#$80
03746 0DFF           50                         push	ax
03747                                           ! Debug: func () void = outb+0 (used reg = )
03748 0E00           E8         F751            call	_outb
03749 0E03           83C4                   04  add	sp,*4
03750                                           !BCC_EOS
03751                                           ! 1184     max=0x2000;
03752                       00000E06            .93:
03753                                           ! Debug: list int = const $64 (used reg = )
03754 0E06           B8                   0064  mov	ax,*$64
03755 0E09           50                         push	ax
03756                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03757 0E0A           E8         F731            call	_inb
03758 0E0D           44                         inc	sp
03759 0E0E           44                         inc	sp
03760                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03761 0E0F           24                     02  and	al,*2
03762 0E11           84C0                       test	al,al
03763 0E13           74           0B            je  	.95
03764                       00000E15            .96:
03765                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03766 0E15           8B46         FE            mov	ax,-2[bp]
03767 0E18           48                         dec	ax
03768 0E19           8946         FE            mov	-2[bp],ax
03769                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03770 0E1C           85C0                       test	ax,ax
03771 0E1E           75           D9            jne	.94
03772                       00000E20            .95:
03773                       00000E20            .92:
03774                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03775 0E20           B8                   2000  mov	ax,#$2000
03776 0E23           8946         FE            mov	-2[bp],ax
03777                                           !BCC_EOS
03778                                           ! 1185     while (--max > 0) {
03779 0E26           EB           2B            jmp .98
03780                       00000E28            .99:
03781                                           ! 1186         outb(0x80, 0x00);
03782                                           ! Debug: list int = const 0 (used reg = )
03783 0E28           31C0                       xor	ax,ax
03784 0E2A           50                         push	ax
03785                                           ! Debug: list int = const $80 (used reg = )
03786 0E2B           B8                   0080  mov	ax,#$80
03787 0E2E           50                         push	ax
03788                                           ! Debug: func () void = outb+0 (used reg = )
03789 0E2F           E8         F722            call	_outb
03790 0E32           83C4                   04  add	sp,*4
03791                                           !BCC_EOS
03792                                           ! 1187         if (inb(0x64) & 0x01) {
03793                                           ! Debug: list int = const $64 (used reg = )
03794 0E35           B8                   0064  mov	ax,*$64
03795 0E38           50                         push	ax
03796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03797 0E39           E8         F702            call	_inb
03798 0E3C           44                         inc	sp
03799 0E3D           44                         inc	sp
03800                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03801 0E3E           24                     01  and	al,*1
03802 0E40           84C0                       test	al,al
03803 0E42           74           0F            je  	.9A
03804                       00000E44            .9B:
03805                                           ! 1188             inb(0x60);
03806                                           ! Debug: list int = const $60 (used reg = )
03807 0E44           B8                   0060  mov	ax,*$60
03808 0E47           50                         push	ax
03809                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03810 0E48           E8         F6F3            call	_inb
03811 0E4B           44                         inc	sp
03812 0E4C           44                         inc	sp
03813                                           !BCC_EOS
03814                                           ! 1189             max = 0x2000;
03815                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03816 0E4D           B8                   2000  mov	ax,#$2000
03817 0E50           8946         FE            mov	-2[bp],ax
03818                                           !BCC_EOS
03819                                           ! 1190             }
03820                                           ! 1191         }
03821                       00000E53            .9A:
03822                                           ! 1192     outb(0x64, 0xaa);
03823                       00000E53            .98:
03824                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03825 0E53           8B46         FE            mov	ax,-2[bp]
03826 0E56           48                         dec	ax
03827 0E57           8946         FE            mov	-2[bp],ax
03828                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03829 0E5A           85C0                       test	ax,ax
03830 0E5C           75           CA            jne	.99
03831                       00000E5E            .9C:
03832                       00000E5E            .97:
03833                                           ! Debug: list int = const $AA (used reg = )
03834 0E5E           B8                   00AA  mov	ax,#$AA
03835 0E61           50                         push	ax
03836                                           ! Debug: list int = const $64 (used reg = )
03837 0E62           B8                   0064  mov	ax,*$64
03838 0E65           50                         push	ax
03839                                           ! Debug: func () void = outb+0 (used reg = )
03840 0E66           E8         F6EB            call	_outb
03841 0E69           83C4                   04  add	sp,*4
03842                                           !BCC_EOS
03843                                           ! 1193     max=0xffff;
03844                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03845 0E6C           B8                   FFFF  mov	ax,#$FFFF
03846 0E6F           8946         FE            mov	-2[bp],ax
03847                                           !BCC_EOS
03848                                           ! 1194     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03849 0E72           EB           0D            jmp .9E
03850                       00000E74            .9F:
03851                                           ! Debug: list int = const 0 (used reg = )
03852 0E74           31C0                       xor	ax,ax
03853 0E76           50                         push	ax
03854                                           ! Debug: list int = const $80 (used reg = )
03855 0E77           B8                   0080  mov	ax,#$80
03856 0E7A           50                         push	ax
03857                                           ! Debug: func () void = outb+0 (used reg = )
03858 0E7B           E8         F6D6            call	_outb
03859 0E7E           83C4                   04  add	sp,*4
03860                                           !BCC_EOS
03861                                           ! 1195     if (max==0x0) keyboard_panic(00);
03862                       00000E81            .9E:
03863                                           ! Debug: list int = const $64 (used reg = )
03864 0E81           B8                   0064  mov	ax,*$64
03865 0E84           50                         push	ax
03866                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03867 0E85           E8         F6B6            call	_inb
03868 0E88           44                         inc	sp
03869 0E89           44                         inc	sp
03870                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03871 0E8A           24                     02  and	al,*2
03872 0E8C           84C0                       test	al,al
03873 0E8E           74           0B            je  	.A0
03874                       00000E90            .A1:
03875                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03876 0E90           8B46         FE            mov	ax,-2[bp]
03877 0E93           48                         dec	ax
03878 0E94           8946         FE            mov	-2[bp],ax
03879                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03880 0E97           85C0                       test	ax,ax
03881 0E99           75           D9            jne	.9F
03882                       00000E9B            .A0:
03883                       00000E9B            .9D:
03884                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03885 0E9B           8B46         FE            mov	ax,-2[bp]
03886 0E9E           85C0                       test	ax,ax
03887 0EA0           75           08            jne 	.A2
03888                       00000EA2            .A3:
03889                                           ! Debug: list int = const 0 (used reg = )
03890 0EA2           31C0                       xor	ax,ax
03891 0EA4           50                         push	ax
03892                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03893 0EA5           E8         0408            call	_keyboard_panic
03894 0EA8           44                         inc	sp
03895 0EA9           44                         inc	sp
03896                                           !BCC_EOS
03897                                           ! 1196     max=0xffff;
03898                       00000EAA            .A2:
03899                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03900 0EAA           B8                   FFFF  mov	ax,#$FFFF
03901 0EAD           8946         FE            mov	-2[bp],ax
03902                                           !BCC_EOS
03903                                           ! 1197     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
03904 0EB0           EB           0E            jmp .A5
03905                       00000EB2            .A6:
03906                                           ! Debug: list int = const 1 (used reg = )
03907 0EB2           B8                   0001  mov	ax,*1
03908 0EB5           50                         push	ax
03909                                           ! Debug: list int = const $80 (used reg = )
03910 0EB6           B8                   0080  mov	ax,#$80
03911 0EB9           50                         push	ax
03912                                           ! Debug: func () void = outb+0 (used reg = )
03913 0EBA           E8         F697            call	_outb
03914 0EBD           83C4                   04  add	sp,*4
03915                                           !BCC_EOS
03916                                           ! 1198     if (max==0x0) keyboard_panic(01);
03917                       00000EC0            .A5:
03918                                           ! Debug: list int = const $64 (used reg = )
03919 0EC0           B8                   0064  mov	ax,*$64
03920 0EC3           50                         push	ax
03921                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03922 0EC4           E8         F677            call	_inb
03923 0EC7           44                         inc	sp
03924 0EC8           44                         inc	sp
03925                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03926 0EC9           24                     01  and	al,*1
03927                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03928 0ECB           84C0                       test	al,al
03929 0ECD           75           0B            jne 	.A7
03930                       00000ECF            .A8:
03931                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03932 0ECF           8B46         FE            mov	ax,-2[bp]
03933 0ED2           48                         dec	ax
03934 0ED3           8946         FE            mov	-2[bp],ax
03935                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03936 0ED6           85C0                       test	ax,ax
03937 0ED8           75           D8            jne	.A6
03938                       00000EDA            .A7:
03939                       00000EDA            .A4:
03940                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03941 0EDA           8B46         FE            mov	ax,-2[bp]
03942 0EDD           85C0                       test	ax,ax
03943 0EDF           75           09            jne 	.A9
03944                       00000EE1            .AA:
03945                                           ! Debug: list int = const 1 (used reg = )
03946 0EE1           B8                   0001  mov	ax,*1
03947 0EE4           50                         push	ax
03948                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03949 0EE5           E8         03C8            call	_keyboard_panic
03950 0EE8           44                         inc	sp
03951 0EE9           44                         inc	sp
03952                                           !BCC_EOS
03953                                           ! 1199     if ((inb(0x60) != 0x55)){
03954                       00000EEA            .A9:
03955                                           ! Debug: list int = const $60 (used reg = )
03956 0EEA           B8                   0060  mov	ax,*$60
03957 0EED           50                         push	ax
03958                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03959 0EEE           E8         F64D            call	_inb
03960 0EF1           44                         inc	sp
03961 0EF2           44                         inc	sp
03962                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03963 0EF3           3C                     55  cmp	al,*$55
03964 0EF5           74           09            je  	.AB
03965                       00000EF7            .AC:
03966                                           ! 1200         keyboard_panic(991);
03967                                           ! Debug: list int = const $3DF (used reg = )
03968 0EF7           B8                   03DF  mov	ax,#$3DF
03969 0EFA           50                         push	ax
03970                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03971 0EFB           E8         03B2            call	_keyboard_panic
03972 0EFE           44                         inc	sp
03973 0EFF           44                         inc	sp
03974                                           !BCC_EOS
03975                                           ! 1201     }
03976                                           ! 1202     outb(0x64,0xab);
03977                       00000F00            .AB:
03978                                           ! Debug: list int = const $AB (used reg = )
03979 0F00           B8                   00AB  mov	ax,#$AB
03980 0F03           50                         push	ax
03981                                           ! Debug: list int = const $64 (used reg = )
03982 0F04           B8                   0064  mov	ax,*$64
03983 0F07           50                         push	ax
03984                                           ! Debug: func () void = outb+0 (used reg = )
03985 0F08           E8         F649            call	_outb
03986 0F0B           83C4                   04  add	sp,*4
03987                                           !BCC_EOS
03988                                           ! 1203     max=0xffff;
03989                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03990 0F0E           B8                   FFFF  mov	ax,#$FFFF
03991 0F11           8946         FE            mov	-2[bp],ax
03992                                           !BCC_EOS
03993                                           ! 1204     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
03994 0F14           EB           0E            jmp .AE
03995                       00000F16            .AF:
03996                                           ! Debug: list int = const $10 (used reg = )
03997 0F16           B8                   0010  mov	ax,*$10
03998 0F19           50                         push	ax
03999                                           ! Debug: list int = const $80 (used reg = )
04000 0F1A           B8                   0080  mov	ax,#$80
04001 0F1D           50                         push	ax
04002                                           ! Debug: func () void = outb+0 (used reg = )
04003 0F1E           E8         F633            call	_outb
04004 0F21           83C4                   04  add	sp,*4
04005                                           !BCC_EOS
04006                                           ! 1205     if (max==0x0) keyboard_panic(10);
04007                       00000F24            .AE:
04008                                           ! Debug: list int = const $64 (used reg = )
04009 0F24           B8                   0064  mov	ax,*$64
04010 0F27           50                         push	ax
04011                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04012 0F28           E8         F613            call	_inb
04013 0F2B           44                         inc	sp
04014 0F2C           44                         inc	sp
04015                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04016 0F2D           24                     02  and	al,*2
04017 0F2F           84C0                       test	al,al
04018 0F31           74           0B            je  	.B0
04019                       00000F33            .B1:
04020                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04021 0F33           8B46         FE            mov	ax,-2[bp]
04022 0F36           48                         dec	ax
04023 0F37           8946         FE            mov	-2[bp],ax
04024                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04025 0F3A           85C0                       test	ax,ax
04026 0F3C           75           D8            jne	.AF
04027                       00000F3E            .B0:
04028                       00000F3E            .AD:
04029                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04030 0F3E           8B46         FE            mov	ax,-2[bp]
04031 0F41           85C0                       test	ax,ax
04032 0F43           75           09            jne 	.B2
04033                       00000F45            .B3:
04034                                           ! Debug: list int = const $A (used reg = )
04035 0F45           B8                   000A  mov	ax,*$A
04036 0F48           50                         push	ax
04037                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04038 0F49           E8         0364            call	_keyboard_panic
04039 0F4C           44                         inc	sp
04040 0F4D           44                         inc	sp
04041                                           !BCC_EOS
04042                                           ! 1206     max=0xffff;
04043                       00000F4E            .B2:
04044                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04045 0F4E           B8                   FFFF  mov	ax,#$FFFF
04046 0F51           8946         FE            mov	-2[bp],ax
04047                                           !BCC_EOS
04048                                           ! 1207     while ( ((inb
04049                                           ! 1207 (0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
04050 0F54           EB           0E            jmp .B5
04051                       00000F56            .B6:
04052                                           ! Debug: list int = const $11 (used reg = )
04053 0F56           B8                   0011  mov	ax,*$11
04054 0F59           50                         push	ax
04055                                           ! Debug: list int = const $80 (used reg = )
04056 0F5A           B8                   0080  mov	ax,#$80
04057 0F5D           50                         push	ax
04058                                           ! Debug: func () void = outb+0 (used reg = )
04059 0F5E           E8         F5F3            call	_outb
04060 0F61           83C4                   04  add	sp,*4
04061                                           !BCC_EOS
04062                                           ! 1208     if (max==0x0) keyboard_panic(11);
04063                       00000F64            .B5:
04064                                           ! Debug: list int = const $64 (used reg = )
04065 0F64           B8                   0064  mov	ax,*$64
04066 0F67           50                         push	ax
04067                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04068 0F68           E8         F5D3            call	_inb
04069 0F6B           44                         inc	sp
04070 0F6C           44                         inc	sp
04071                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04072 0F6D           24                     01  and	al,*1
04073                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04074 0F6F           84C0                       test	al,al
04075 0F71           75           0B            jne 	.B7
04076                       00000F73            .B8:
04077                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04078 0F73           8B46         FE            mov	ax,-2[bp]
04079 0F76           48                         dec	ax
04080 0F77           8946         FE            mov	-2[bp],ax
04081                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04082 0F7A           85C0                       test	ax,ax
04083 0F7C           75           D8            jne	.B6
04084                       00000F7E            .B7:
04085                       00000F7E            .B4:
04086                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04087 0F7E           8B46         FE            mov	ax,-2[bp]
04088 0F81           85C0                       test	ax,ax
04089 0F83           75           09            jne 	.B9
04090                       00000F85            .BA:
04091                                           ! Debug: list int = const $B (used reg = )
04092 0F85           B8                   000B  mov	ax,*$B
04093 0F88           50                         push	ax
04094                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04095 0F89           E8         0324            call	_keyboard_panic
04096 0F8C           44                         inc	sp
04097 0F8D           44                         inc	sp
04098                                           !BCC_EOS
04099                                           ! 1209     if ((inb(0x60) != 0x00)) {
04100                       00000F8E            .B9:
04101                                           ! Debug: list int = const $60 (used reg = )
04102 0F8E           B8                   0060  mov	ax,*$60
04103 0F91           50                         push	ax
04104                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04105 0F92           E8         F5A9            call	_inb
04106 0F95           44                         inc	sp
04107 0F96           44                         inc	sp
04108                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
04109 0F97           84C0                       test	al,al
04110 0F99           74           09            je  	.BB
04111                       00000F9B            .BC:
04112                                           ! 1210         keyboard_panic(992);
04113                                           ! Debug: list int = const $3E0 (used reg = )
04114 0F9B           B8                   03E0  mov	ax,#$3E0
04115 0F9E           50                         push	ax
04116                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04117 0F9F           E8         030E            call	_keyboard_panic
04118 0FA2           44                         inc	sp
04119 0FA3           44                         inc	sp
04120                                           !BCC_EOS
04121                                           ! 1211     }
04122                                           ! 1212     outb(0x64,0xae);
04123                       00000FA4            .BB:
04124                                           ! Debug: list int = const $AE (used reg = )
04125 0FA4           B8                   00AE  mov	ax,#$AE
04126 0FA7           50                         push	ax
04127                                           ! Debug: list int = const $64 (used reg = )
04128 0FA8           B8                   0064  mov	ax,*$64
04129 0FAB           50                         push	ax
04130                                           ! Debug: func () void = outb+0 (used reg = )
04131 0FAC           E8         F5A5            call	_outb
04132 0FAF           83C4                   04  add	sp,*4
04133                                           !BCC_EOS
04134                                           ! 1213     outb(0x64,0xa8);
04135                                           ! Debug: list int = const $A8 (used reg = )
04136 0FB2           B8                   00A8  mov	ax,#$A8
04137 0FB5           50                         push	ax
04138                                           ! Debug: list int = const $64 (used reg = )
04139 0FB6           B8                   0064  mov	ax,*$64
04140 0FB9           50                         push	ax
04141                                           ! Debug: func () void = outb+0 (used reg = )
04142 0FBA           E8         F597            call	_outb
04143 0FBD           83C4                   04  add	sp,*4
04144                                           !BCC_EOS
04145                                           ! 1214     outb(0x60, 0xff);
04146                                           ! Debug: list int = const $FF (used reg = )
04147 0FC0           B8                   00FF  mov	ax,#$FF
04148 0FC3           50                         push	ax
04149                                           ! Debug: list int = const $60 (used reg = )
04150 0FC4           B8                   0060  mov	ax,*$60
04151 0FC7           50                         push	ax
04152                                           ! Debug: func () void = outb+0 (used reg = )
04153 0FC8           E8         F589            call	_outb
04154 0FCB           83C4                   04  add	sp,*4
04155                                           !BCC_EOS
04156                                           ! 1215     max=0xffff;
04157                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04158 0FCE           B8                   FFFF  mov	ax,#$FFFF
04159 0FD1           8946         FE            mov	-2[bp],ax
04160                                           !BCC_EOS
04161                                           ! 1216     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20);
04162 0FD4           EB           0E            jmp .BE
04163                       00000FD6            .BF:
04164                                           ! Debug: list int = const $20 (used reg = )
04165 0FD6           B8                   0020  mov	ax,*$20
04166 0FD9           50                         push	ax
04167                                           ! Debug: list int = const $80 (used reg = )
04168 0FDA           B8                   0080  mov	ax,#$80
04169 0FDD           50                         push	ax
04170                                           ! Debug: func () void = outb+0 (used reg = )
04171 0FDE           E8         F573            call	_outb
04172 0FE1           83C4                   04  add	sp,*4
04173                                           !BCC_EOS
04174                                           ! 1217     if (max==0x0) keyboard_panic(20);
04175                       00000FE4            .BE:
04176                                           ! Debug: list int = const $64 (used reg = )
04177 0FE4           B8                   0064  mov	ax,*$64
04178 0FE7           50                         push	ax
04179                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04180 0FE8           E8         F553            call	_inb
04181 0FEB           44                         inc	sp
04182 0FEC           44                         inc	sp
04183                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04184 0FED           24                     02  and	al,*2
04185 0FEF           84C0                       test	al,al
04186 0FF1           74           0B            je  	.C0
04187                       00000FF3            .C1:
04188                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04189 0FF3           8B46         FE            mov	ax,-2[bp]
04190 0FF6           48                         dec	ax
04191 0FF7           8946         FE            mov	-2[bp],ax
04192                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04193 0FFA           85C0                       test	ax,ax
04194 0FFC           75           D8            jne	.BF
04195                       00000FFE            .C0:
04196                       00000FFE            .BD:
04197                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04198 0FFE           8B46         FE            mov	ax,-2[bp]
04199 1001           85C0                       test	ax,ax
04200 1003           75           09            jne 	.C2
04201                       00001005            .C3:
04202                                           ! Debug: list int = const $14 (used reg = )
04203 1005           B8                   0014  mov	ax,*$14
04204 1008           50                         push	ax
04205                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04206 1009           E8         02A4            call	_keyboard_panic
04207 100C           44                         inc	sp
04208 100D           44                         inc	sp
04209                                           !BCC_EOS
04210                                           ! 1218     max=0xffff;
04211                       0000100E            .C2:
04212                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04213 100E           B8                   FFFF  mov	ax,#$FFFF
04214 1011           8946         FE            mov	-2[bp],ax
04215                                           !BCC_EOS
04216                                           ! 1219     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
04217 1014           EB           0E            jmp .C5
04218                       00001016            .C6:
04219                                           ! Debug: list int = const $21 (used reg = )
04220 1016           B8                   0021  mov	ax,*$21
04221 1019           50                         push	ax
04222                                           ! Debug: list int = const $80 (used reg = )
04223 101A           B8                   0080  mov	ax,#$80
04224 101D           50                         push	ax
04225                                           ! Debug: func () void = outb+0 (used reg = )
04226 101E           E8         F533            call	_outb
04227 1021           83C4                   04  add	sp,*4
04228                                           !BCC_EOS
04229                                           ! 1220     if (max==0x0) keyboard_panic(21);
04230                       00001024            .C5:
04231                                           ! Debug: list int = const $64 (used reg = )
04232 1024           B8                   0064  mov	ax,*$64
04233 1027           50                         push	ax
04234                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04235 1028           E8         F513            call	_inb
04236 102B           44                         inc	sp
04237 102C           44                         inc	sp
04238                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04239 102D           24                     01  and	al,*1
04240                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04241 102F           84C0                       test	al,al
04242 1031           75           0B            jne 	.C7
04243                       00001033            .C8:
04244                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04245 1033           8B46         FE            mov	ax,-2[bp]
04246 1036           48                         dec	ax
04247 1037           8946         FE            mov	-2[bp],ax
04248                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04249 103A           85C0                       test	ax,ax
04250 103C           75           D8            jne	.C6
04251                       0000103E            .C7:
04252                       0000103E            .C4:
04253                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04254 103E           8B46         FE            mov	ax,-2[bp]
04255 1041           85C0                       test	ax,ax
04256 1043           75           09            jne 	.C9
04257                       00001045            .CA:
04258                                           ! Debug: list int = const $15 (used reg = )
04259 1045           B8                   0015  mov	ax,*$15
04260 1048           50                         push	ax
04261                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04262 1049           E8         0264            call	_keyboard_panic
04263 104C           44                         inc	sp
04264 104D           44                         inc	sp
04265                                           !BCC_EOS
04266                                           ! 1221     if ((inb(0x60) != 0xfa)) {
04267                       0000104E            .C9:
04268                                           ! Debug: list int = const $60 (used reg = )
04269 104E           B8                   0060  mov	ax,*$60
04270 1051           50                         push	ax
04271                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04272 1052           E8         F4E9            call	_inb
04273 1055           44                         inc	sp
04274 1056           44                         inc	sp
04275                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04276 1057           3C                     FA  cmp	al,#$FA
04277 1059           74           09            je  	.CB
04278                       0000105B            .CC:
04279                                           ! 1222         keyboard_panic(993);
04280                                           ! Debug: list int = const $3E1 (used reg = )
04281 105B           B8                   03E1  mov	ax,#$3E1
04282 105E           50                         push	ax
04283                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04284 105F           E8         024E            call	_keyboard_panic
04285 1062           44                         inc	sp
04286 1063           44                         inc	sp
04287                                           !BCC_EOS
04288                                           ! 1223     }
04289                                           ! 1224     max=0xffff;
04290                       00001064            .CB:
04291                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04292 1064           B8                   FFFF  mov	ax,#$FFFF
04293 1067           8946         FE            mov	-2[bp],ax
04294                                           !BCC_EOS
04295                                           ! 1225     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
04296 106A           EB           0E            jmp .CE
04297                       0000106C            .CF:
04298                                           ! Debug: list int = const $31 (used reg = )
04299 106C           B8                   0031  mov	ax,*$31
04300 106F           50                         push	ax
04301                                           ! Debug: list int = const $80 (used reg = )
04302 1070           B8                   0080  mov	ax,#$80
04303 1073           50                         push	ax
04304                                           ! Debug: func () void = outb+0 (used reg = )
04305 1074           E8         F4DD            call	_outb
04306 1077           83C4                   04  add	sp,*4
04307                                           !BCC_EOS
04308                                           ! 1226     if (max==0x0) keyboard_panic(31);
04309                       0000107A            .CE:
04310                                           ! Debug: list int = const $64 (used reg = )
04311 107A           B8                   0064  mov	ax,*$64
04312 107D           50                         push	ax
04313                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04314 107E           E8         F4BD            call	_inb
04315 1081           44                         inc	sp
04316 1082           44                         inc	sp
04317                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04318 1083           24                     01  and	al,*1
04319                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04320 1085           84C0                       test	al,al
04321 1087           75           0B            jne 	.D0
04322                       00001089            .D1:
04323                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04324 1089           8B46         FE            mov	ax,-2[bp]
04325 108C           48                         dec	ax
04326 108D           8946         FE            mov	-2[bp],ax
04327                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04328 1090           85C0                       test	ax,ax
04329 1092           75           D8            jne	.CF
04330                       00001094            .D0:
04331                       00001094            .CD:
04332                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04333 1094           8B46         FE            mov	ax,-2[bp]
04334 1097           85C0                       test	ax,ax
04335 1099           75           09            jne 	.D2
04336                       0000109B            .D3:
04337                                           ! Debug: list int = const $1F (used reg = )
04338 109B           B8                   001F  mov	ax,*$1F
04339 109E           50                         push	ax
04340                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04341 109F           E8         020E            call	_keyboard_panic
04342 10A2           44                         inc	sp
04343 10A3           44                         inc	sp
04344                                           !BCC_EOS
04345                                           ! 1227     if ((inb(0x60) != 0xaa)) {
04346                       000010A4            .D2:
04347                                           ! Debug: list int = const $60 (used reg = )
04348 10A4           B8                   0060  mov	ax,*$60
04349 10A7           50                         push	ax
04350                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04351 10A8           E8         F493            call	_inb
04352 10AB           44                         inc	sp
04353 10AC           44                         inc	sp
04354                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04355 10AD           3C                     AA  cmp	al,#$AA
04356 10AF           74           09            je  	.D4
04357                       000010B1            .D5:
04358                                           ! 1228         keyboard_panic(994);
04359                                           ! Debug: list int = const $3E2 (used reg = )
04360 10B1           B8                   03E2  mov	ax,#$3E2
04361 10B4           50                         push	ax
04362                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04363 10B5           E8         01F8            call	_keyboard_panic
04364 10B8           44                         inc	sp
04365 10B9           44                         inc	sp
04366                                           !BCC_EOS
04367                                           ! 1229     }
04368                                           ! 1230     outb(0x60, 0xf5);
04369                       000010BA            .D4:
04370                                           ! Debug: list int = const $F5 (used reg = )
04371 10BA           B8                   00F5  mov	ax,#$F5
04372 10BD           50                         push	ax
04373                                           ! Debug: list int = const $60 (used reg = )
04374 10BE           B8                   0060  mov	ax,*$60
04375 10C1           50                         push	ax
04376                                           ! Debug: func () void = outb+0 (used reg = )
04377 10C2           E8         F48F            call	_outb
04378 10C5           83C4                   04  add	sp,*4
04379                                           !BCC_EOS
04380                                           ! 1231     max=0xffff;
04381                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04382 10C8           B8                   FFFF  mov	ax,#$FFFF
04383 10CB           8946         FE            mov	-2[bp],ax
04384                                           !BCC_EOS
04385                                           ! 1232     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
04386 10CE           EB           0E            jmp .D7
04387                       000010D0            .D8:
04388                                           ! Debug: list int = const $40 (used reg = )
04389 10D0           B8                   0040  mov	ax,*$40
04390 10D3           50                         push	ax
04391                                           ! Debug: list int = const $80 (used reg = )
04392 10D4           B8                   0080  mov	ax,#$80
04393 10D7           50                         push	ax
04394                                           ! Debug: func () void = outb+0 (used reg = )
04395 10D8           E8         F479            call	_outb
04396 10DB           83C4                   04  add	sp,*4
04397                                           !BCC_EOS
04398                                           ! 1233     if (max==0x0) keyboard_panic(40);
04399                       000010DE            .D7:
04400                                           ! Debug: list int = const $64 (used reg = )
04401 10DE           B8                   0064  mov	ax,*$64
04402 10E1           50                         push	ax
04403                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04404 10E2           E8         F459            call	_inb
04405 10E5           44                         inc	sp
04406 10E6           44                         inc	sp
04407                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04408 10E7           24                     02  and	al,*2
04409 10E9           84C0                       test	al,al
04410 10EB           74           0B            je  	.D9
04411                       000010ED            .DA:
04412                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04413 10ED           8B46         FE            mov	ax,-2[bp]
04414 10F0           48                         dec	ax
04415 10F1           8946         FE            mov	-2[bp],ax
04416                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04417 10F4           85C0                       test	ax,ax
04418 10F6           75           D8            jne	.D8
04419                       000010F8            .D9:
04420                       000010F8            .D6:
04421                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04422 10F8           8B46         FE            mov	ax,-2[bp]
04423 10FB           85C0                       test	ax,ax
04424 10FD           75           09            jne 	.DB
04425                       000010FF            .DC:
04426                                           ! Debug: list int = const $28 (used reg = )
04427 10FF           B8                   0028  mov	ax,*$28
04428 1102           50                         push	ax
04429                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04430 1103           E8         01AA            call	_keyboard_panic
04431 1106           44                         inc	sp
04432 1107           44                         inc	sp
04433                                           !BCC_EOS
04434                                           ! 1234     max=0xffff;
04435                       00001108            .DB:
04436                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04437 1108           B8                   FFFF  mov	ax,#$FFFF
04438 110B           8946         FE            mov	-2[bp],ax
04439                                           !BCC_EOS
04440                                           ! 1235     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
04441 110E           EB           0E            jmp .DE
04442                       00001110            .DF:
04443                                           ! Debug: list int = const $41 (used reg = )
04444 1110           B8                   0041  mov	ax,*$41
04445 1113           50                         push	ax
04446                                           ! Debug: list int = const $80 (used reg = )
04447 1114           B8                   0080  mov	ax,#$80
04448 1117           50                         push	ax
04449                                           ! Debug: func () void = outb+0 (used reg = )
04450 1118           E8         F439            call	_outb
04451 111B           83C4                   04  add	sp,*4
04452                                           !BCC_EOS
04453                                           ! 1236     if (max==0x0) keyboard_panic(41);
04454                       0000111E            .DE:
04455                                           ! Debug: list int = const $64 (used reg = )
04456 111E           B8                   0064  mov	ax,*$64
04457 1121           50                         push	ax
04458                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04459 1122           E8         F419            call	_inb
04460 1125           44                         inc	sp
04461 1126           44                         inc	sp
04462                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04463 1127           24                     01  and	al,*1
04464                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04465 1129           84C0                       test	al,al
04466 112B           75           0B            jne 	.E0
04467                       0000112D            .E1:
04468                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04469 112D           8B46         FE            mov	ax,-2[bp]
04470 1130           48                         dec	ax
04471 1131           8946         FE            mov	-2[bp],ax
04472                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04473 1134           85C0                       test	ax,ax
04474 1136           75           D8            jne	.DF
04475                       00001138            .E0:
04476                       00001138            .DD:
04477                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04478 1138           8B46         FE            mov	ax,-2[bp]
04479 113B           85C0                       test	ax,ax
04480 113D           75           09            jne 	.E2
04481                       0000113F            .E3:
04482                                           ! Debug: list int = const $29 (used reg = )
04483 113F           B8                   0029  mov	ax,*$29
04484 1142           50                         push	ax
04485                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04486 1143           E8         016A            call	_keyboard_panic
04487 1146           44                         inc	sp
04488 1147           44                         inc	sp
04489                                           !BCC_EOS
04490                                           ! 1237     if ((inb(0x60) != 0xfa)) {
04491                       00001148            .E2:
04492                                           ! Debug: list int = const $60 (used reg = )
04493 1148           B8                   0060  mov	ax,*$60
04494 114B           50                         push	ax
04495                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04496 114C           E8         F3EF            call	_inb
04497 114F           44                         inc	sp
04498 1150           44                         inc	sp
04499                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04500 1151           3C                     FA  cmp	al,#$FA
04501 1153           74           09            je  	.E4
04502                       00001155            .E5:
04503                                           ! 1238         keyboard_panic(995);
04504                                           ! Debug: list int = const $3E3 (used reg = )
04505 1155           B8                   03E3  mov	ax,#$3E3
04506 1158           50                         push	ax
04507                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04508 1159           E8         0154            call	_keyboard_panic
04509 115C           44                         inc	sp
04510 115D           44                         inc	sp
04511                                           !BCC_EOS
04512                                           ! 1239     }
04513                                           ! 1240     outb(0x64, 0x60);
04514                       0000115E            .E4:
04515                                           ! Debug: list int = const $60 (used reg = )
04516 115E           B8                   0060  mov	ax,*$60
04517 1161           50                         push	ax
04518                                           ! Debug: list int = const $64 (used reg = )
04519 1162           B8                   0064  mov	ax,*$64
04520 1165           50                         push	ax
04521                                           ! Debug: func () void = outb+0 (used reg = )
04522 1166           E8         F3EB            call	_outb
04523 1169           83C4                   04  add	sp,*4
04524                                           !BCC_EOS
04525                                           ! 1241     max=0xffff;
04526                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04527 116C           B8                   FFFF  mov	ax,#$FFFF
04528 116F           8946         FE            mov	-2[bp],ax
04529                                           !BCC_EOS
04530                                           ! 1242     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
04531 1172           EB           0E            jmp .E7
04532                       00001174            .E8:
04533                                           ! Debug: list int = const $50 (used reg = )
04534 1174           B8                   0050  mov	ax,*$50
04535 1177           50                         push	ax
04536                                           ! Debug: list int = const $80 (used reg = )
04537 1178           B8                   0080  mov	ax,#$80
04538 117B           50                         push	ax
04539                                           ! Debug: func () void = outb+0 (used reg = )
04540 117C           E8         F3D5            call	_outb
04541 117F           83C4                   04  add	sp,*4
04542                                           !BCC_EOS
04543                                           ! 1243     if (max==0x0) keyboard_panic(50);
04544                       00001182            .E7:
04545                                           ! Debug: list int = const $64 (used reg = )
04546 1182           B8                   0064  mov	ax,*$64
04547 1185           50                         push	ax
04548                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04549 1186           E8         F3B5            call	_inb
04550 1189           44                         inc	sp
04551 118A           44                         inc	sp
04552                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04553 118B           24                     02  and	al,*2
04554 118D           84C0                       test	al,al
04555 118F           74           0B            je  	.E9
04556                       00001191            .EA:
04557                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04558 1191           8B46         FE            mov	ax,-2[bp]
04559 1194           48                         dec	ax
04560 1195           8946         FE            mov	-2[bp],ax
04561                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04562 1198           85C0                       test	ax,ax
04563 119A           75           D8            jne	.E8
04564                       0000119C            .E9:
04565                       0000119C            .E6:
04566                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04567 119C           8B46         FE            mov	ax,-2[bp]
04568 119F           85C0                       test	ax,ax
04569 11A1           75           09            jne 	.EB
04570                       000011A3            .EC:
04571                                           ! Debug: list int = const $32 (used reg = )
04572 11A3           B8                   0032  mov	ax,*$32
04573 11A6           50                         push	ax
04574                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04575 11A7           E8         0106            call	_keyboard_panic
04576 11AA           44                         inc	sp
04577 11AB           44                         inc	sp
04578                                           !BCC_EOS
04579                                           ! 1244     outb(0x60, 0x61);
04580                       000011AC            .EB:
04581                                           ! Debug: list int = const $61 (used reg = )
04582 11AC           B8                   0061  mov	ax,*$61
04583 11AF           50                         push	ax
04584                                           ! Debug: list int = const $60 (used reg = )
04585 11B0           B8                   0060  mov	ax,*$60
04586 11B3           50                         push	ax
04587                                           ! Debug: func () void = outb+0 (used reg = )
04588 11B4           E8         F39D            call	_outb
04589 11B7           83C4                   04  add	sp,*4
04590                                           !BCC_EOS
04591                                           ! 1245     max=0xffff;
04592                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04593 11BA           B8                   FFFF  mov	ax,#$FFFF
04594 11BD           8946         FE            mov	-2[bp],ax
04595                                           !BCC_EOS
04596                                           ! 1246     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
04597 11C0           EB           0E            jmp .EE
04598                       000011C2            .EF:
04599                                           ! Debug: list int = const $60 (used reg = )
04600 11C2           B8                   0060  mov	ax,*$60
04601 11C5           50                         push	ax
04602                                           ! Debug: list int = const $80 (used reg = )
04603 11C6           B8                   0080  mov	ax,#$80
04604 11C9           50                         push	ax
04605                                           ! Debug: func () void = outb+0 (used reg = )
04606 11CA           E8         F387            call	_outb
04607 11CD           83C4                   04  add	sp,*4
04608                                           !BCC_EOS
04609                                           ! 1247     if (max==0x0) keyboard_panic(60);
04610                       000011D0            .EE:
04611                                           ! Debug: list int = const $64 (used reg = )
04612 11D0           B8                   0064  mov	ax,*$64
04613 11D3           50                         push	ax
04614                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04615 11D4           E8         F367            call	_inb
04616 11D7           44                         inc	sp
04617 11D8           44                         inc	sp
04618                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04619 11D9           24                     02  and	al,*2
04620 11DB           84C0                       test	al,al
04621 11DD           74           0B            je  	.F0
04622                       000011DF            .F1:
04623                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04624 11DF           8B46         FE            mov	ax,-2[bp]
04625 11E2           48                         dec	ax
04626 11E3           8946         FE            mov	-2[bp],ax
04627                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04628 11E6           85C0                       test	ax,ax
04629 11E8           75           D8            jne	.EF
04630                       000011EA            .F0:
04631                       000011EA            .ED:
04632                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04633 11EA           8B46         FE            mov	ax,-2[bp]
04634 11ED           85C0                       test	ax,ax
04635 11EF           75           09            jne 	.F2
04636                       000011F1            .F3:
04637                                           ! Debug: list int = const $3C (used reg = )
04638 11F1           B8                   003C  mov	ax,*$3C
04639 11F4           50                         push	ax
04640                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04641 11F5           E8         00B8            call	_keyboard_panic
04642 11F8           44                         inc	sp
04643 11F9           44                         inc	sp
04644                                           !BCC_EOS
04645                                           ! 1248     outb(0x60, 0xf4);
04646                       000011FA            .F2:
04647                                           ! Debug: list int = const $F4 (used reg = )
04648 11FA           B8                   00F4  mov	ax,#$F4
04649 11FD           50                         push	ax
04650                                           ! Debug: list int = const $60 (used reg = )
04651 11FE           B8                   0060  mov	ax,*$60
04652 1201           50                         push	ax
04653                                           ! Debug: func () void = outb+0 (used reg = )
04654 1202           E8         F34F            call	_outb
04655 1205           83C4                   04  add	sp,*4
04656                                           !BCC_EOS
04657                                           ! 1249     max=0xffff;
04658                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04659 1208           B8                   FFFF  mov	ax,#$FFFF
04660 120B           8946         FE            mov	-2[bp],ax
04661                                           !BCC_EOS
04662                                           ! 1250     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
04663 120E           EB           0E            jmp .F5
04664                       00001210            .F6:
04665                                           ! Debug: list int = const $70 (used reg = )
04666 1210           B8                   0070  mov	ax,*$70
04667 1213           50                         push	ax
04668                                           ! Debug: list int = const $80 (used reg = )
04669 1214           B8                   0080  mov	ax,#$80
04670 1217           50                         push	ax
04671                                           ! Debug: func () void = outb+0 (used reg = )
04672 1218           E8         F339            call	_outb
04673 121B           83C4                   04  add	sp,*4
04674                                           !BCC_EOS
04675                                           ! 1251     if (max==0x0) keyboard_panic(70);
04676                       0000121E            .F5:
04677                                           ! Debug: list int = const $64 (used reg = )
04678 121E           B8                   0064  mov	ax,*$64
04679 1221           50                         push	ax
04680                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04681 1222           E8         F319            call	_inb
04682 1225           44                         inc	sp
04683 1226           44                         inc	sp
04684                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04685 1227           24                     02  and	al,*2
04686 1229           84C0                       test	al,al
04687 122B           74           0B            je  	.F7
04688                       0000122D            .F8:
04689                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04690 122D           8B46         FE            mov	ax,-2[bp]
04691 1230           48                         dec	ax
04692 1231           8946         FE            mov	-2[bp],ax
04693                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04694 1234           85C0                       test	ax,ax
04695 1236           75           D8            jne	.F6
04696                       00001238            .F7:
04697                       00001238            .F4:
04698                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04699 1238           8B46         FE            mov	ax,-2[bp]
04700 123B           85C0                       test	ax,ax
04701 123D           75           09            jne 	.F9
04702                       0000123F            .FA:
04703                                           ! Debug: list int = const $46 (used reg = )
04704 123F           B8                   0046  mov	ax,*$46
04705 1242           50                         push	ax
04706                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04707 1243           E8         006A            call	_keyboard_panic
04708 1246           44                         inc	sp
04709 1247           44                         inc	sp
04710                                           !BCC_EOS
04711                                           ! 1252     max=0xffff;
04712                       00001248            .F9:
04713                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04714 1248           B8                   FFFF  mov	ax,#$FFFF
04715 124B           8946         FE            mov	-2[bp],ax
04716                                           !BCC_EOS
04717                                           ! 1253     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
04718 124E           EB           0E            jmp .FC
04719                       00001250            .FD:
04720                                           ! Debug: list int = const $71 (used reg = )
04721 1250           B8                   0071  mov	ax,*$71
04722 1253           50                         push	ax
04723                                           ! Debug: list int = const $80 (used reg = )
04724 1254           B8                   0080  mov	ax,#$80
04725 1257           50                         push	ax
04726                                           ! Debug: func () void = outb+0 (used reg = )
04727 1258           E8         F2F9            call	_outb
04728 125B           83C4                   04  add	sp,*4
04729                                           !BCC_EOS
04730                                           ! 1254     if (max==0x0) keyboard_panic(70);
04731                       0000125E            .FC:
04732                                           ! Debug: list int = const $64 (used reg = )
04733 125E           B8                   0064  mov	ax,*$64
04734 1261           50                         push	ax
04735                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04736 1262           E8         F2D9            call	_inb
04737 1265           44                         inc	sp
04738 1266           44                         inc	sp
04739                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04740 1267           24                     01  and	al,*1
04741                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04742 1269           84C0                       test	al,al
04743 126B           75           0B            jne 	.FE
04744                       0000126D            .FF:
04745                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04746 126D           8B46         FE            mov	ax,-2[bp]
04747 1270           48                         dec	ax
04748 1271           8946         FE            mov	-2[bp],ax
04749                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04750 1274           85C0                       test	ax,ax
04751 1276           75           D8            jne	.FD
04752                       00001278            .FE:
04753                       00001278            .FB:
04754                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04755 1278           8B46         FE            mov	ax,-2[bp]
04756 127B           85C0                       test	ax,ax
04757 127D           75           09            jne 	.100
04758                       0000127F            .101:
04759                                           ! Debug: list int = const $46 (used reg = )
04760 127F           B8                   0046  mov	ax,*$46
04761 1282           50                         push	ax
04762                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04763 1283           E8         002A            call	_keyboard_panic
04764 1286           44                         inc	sp
04765 1287           44                         inc	sp
04766                                           !BCC_EOS
04767                                           ! 1255     if ((inb(0x60) != 0xfa)) {
04768                       00001288            .100:
04769                                           ! Debug: list int = const $60 (used reg = )
04770 1288           B8                   0060  mov	ax,*$60
04771 128B           50                         push	ax
04772                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04773 128C           E8         F2AF            call	_inb
04774 128F           44                         inc	sp
04775 1290           44                         inc	sp
04776                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04777 1291           3C                     FA  cmp	al,#$FA
04778 1293           74           09            je  	.102
04779                       00001295            .103:
04780                                           ! 1256         keyboard_panic(996);
04781                                           ! Debug: list int = const $3E4 (used reg = )
04782 1295           B8                   03E4  mov	ax,#$3E4
04783 1298           50                         push	ax
04784                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04785 1299           E8         0014            call	_keyboard_panic
04786 129C           44                         inc	sp
04787 129D           44                         inc	sp
04788                                           !BCC_EOS
04789                                           ! 1257     }
04790                                           ! 1258     outb(0x80, 0x77);
04791                       0000129E            .102:
04792                                           ! Debug: list int = const $77 (used reg = )
04793 129E           B8                   0077  mov	ax,*$77
04794 12A1           50                         push	ax
04795                                           ! Debug: list int = const $80 (used reg = )
04796 12A2           B8                   0080  mov	ax,#$80
04797 12A5           50                         push	ax
04798                                           ! Debug: func () void = outb+0 (used reg = )
04799 12A6           E8         F2AB            call	_outb
04800 12A9           83C4                   04  add	sp,*4
04801                                           !BCC_EOS
04802                                           ! 1259 }
04803 12AC           89EC                       mov	sp,bp
04804 12AE           5D                         pop	bp
04805 12AF           C3                         ret
04806                                           ! 1260   void
04807                                           ! 1261 keyboard_panic(status)
04808                                           ! 1262   Bit16u status;
04809                                           export	_keyboard_panic
04810                       000012B0            _keyboard_panic:
04811                                           !BCC_EOS
04812                                           ! 1263 {
04813                                           ! 1264   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04814 12B0           55                         push	bp
04815 12B1           89E5                       mov	bp,sp
04816                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04817 12B3           FF76         04            push	4[bp]
04818                                           ! Debug: list * char = .104+0 (used reg = )
04819 12B6           BB                   DDFE  mov	bx,#.104
04820 12B9           53                         push	bx
04821                                           ! Debug: list int = const 7 (used reg = )
04822 12BA           B8                   0007  mov	ax,*7
04823 12BD           50                         push	ax
04824                                           ! Debug: func () void = bios_printf+0 (used reg = )
04825 12BE           E8         F758            call	_bios_printf
04826 12C1           89EC                       mov	sp,bp
04827                                           !BCC_EOS
04828                                           ! 1265 }
04829 12C3           5D                         pop	bp
04830 12C4           C3                         ret
04831                                           ! 1266   void
04832                                           ! Register BX used in function keyboard_panic
04833                                           ! 1267 machine_reset()
04834                                           ! 1268 {
04835                                           export	_machine_reset
04836                       000012C5            _machine_reset:
04837                                           ! 1269 #asm
04838                                           !BCC_ASM
04839                                           ;we must check whether 0xFE is set or not
04840                                           ;if it is s3 resume, just jmp back to normal Post Entry
04841                                           ;below port io will prevent s3 resume
04842 12C5           B0                     0F    mov al, #0x0f
04843 12C7           E6                     70    out 0x70, al
04844 12C9           E4                     71    in al, 0x71
04845 12CB           3C                     FE    cmp al, #0xFE
04846 12CD   7503    E9         CD89              jz post
04847                                           ! 1278 endasm
04848                                           !BCC_ENDASM
04849                                           ! 1279   outb(0x64, 0x6
04850 12D2           55                         push	bp
04851 12D3           89E5                       mov	bp,sp
04852                                           ! 1279 0);
04853                                           ! Debug: list int = const $60 (used reg = )
04854 12D5           B8                   0060  mov	ax,*$60
04855 12D8           50                         push	ax
04856                                           ! Debug: list int = const $64 (used reg = )
04857 12D9           B8                   0064  mov	ax,*$64
04858 12DC           50                         push	ax
04859                                           ! Debug: func () void = outb+0 (used reg = )
04860 12DD           E8         F274            call	_outb
04861 12E0           89EC                       mov	sp,bp
04862                                           !BCC_EOS
04863                                           ! 1280   outb(0x60, 0x14);
04864                                           ! Debug: list int = const $14 (used reg = )
04865 12E2           B8                   0014  mov	ax,*$14
04866 12E5           50                         push	ax
04867                                           ! Debug: list int = const $60 (used reg = )
04868 12E6           B8                   0060  mov	ax,*$60
04869 12E9           50                         push	ax
04870                                           ! Debug: func () void = outb+0 (used reg = )
04871 12EA           E8         F267            call	_outb
04872 12ED           89EC                       mov	sp,bp
04873                                           !BCC_EOS
04874                                           ! 1281   outb(0x64, 0xfe);
04875                                           ! Debug: list int = const $FE (used reg = )
04876 12EF           B8                   00FE  mov	ax,#$FE
04877 12F2           50                         push	ax
04878                                           ! Debug: list int = const $64 (used reg = )
04879 12F3           B8                   0064  mov	ax,*$64
04880 12F6           50                         push	ax
04881                                           ! Debug: func () void = outb+0 (used reg = )
04882 12F7           E8         F25A            call	_outb
04883 12FA           89EC                       mov	sp,bp
04884                                           !BCC_EOS
04885                                           ! 1282   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
04886                                           ! Debug: list * char = .105+0 (used reg = )
04887 12FC           BB                   DDE2  mov	bx,#.105
04888 12FF           53                         push	bx
04889                                           ! Debug: list int = const 7 (used reg = )
04890 1300           B8                   0007  mov	ax,*7
04891 1303           50                         push	ax
04892                                           ! Debug: func () void = bios_printf+0 (used reg = )
04893 1304           E8         F712            call	_bios_printf
04894 1307           89EC                       mov	sp,bp
04895                                           !BCC_EOS
04896                                           ! 1283 }
04897 1309           5D                         pop	bp
04898 130A           C3                         ret
04899                                           ! 1284   void
04900                                           ! Register BX used in function machine_reset
04901                                           ! 1285 clobber_entry_point()
04902                                           ! 1286 {
04903                                           export	_clobber_entry_point
04904                       0000130B            _clobber_entry_point:
04905                                           ! 1287     write_word(0xffff, 0x0001, machine_reset);
04906 130B           55                         push	bp
04907 130C           89E5                       mov	bp,sp
04908                                           ! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
04909                                           ! Debug: list * () void = machine_reset+0 (used reg = )
04910 130E           BB                   12C5  mov	bx,#_machine_reset
04911 1311           53                         push	bx
04912                                           ! Debug: list int = const 1 (used reg = )
04913 1312           B8                   0001  mov	ax,*1
04914 1315           50                         push	ax
04915                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04916 1316           B8                   FFFF  mov	ax,#$FFFF
04917 1319           50                         push	ax
04918                                           ! Debug: func () void = write_word+0 (used reg = )
04919 131A           E8         F315            call	_write_word
04920 131D           89EC                       mov	sp,bp
04921                                           !BCC_EOS
04922                                           ! 1288 }
04923 131F           5D                         pop	bp
04924 1320           C3                         ret
04925                                           ! 1289   void
04926                                           ! Register BX used in function clobber_entry_point
04927                                           ! 1290 shutdown_status_panic(status)
04928                                           ! 1291   Bit16u status;
04929                                           export	_shutdown_status_panic
04930                       00001321            _shutdown_status_panic:
04931                                           !BCC_EOS
04932                                           ! 1292 {
04933                                           ! 1293   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04934 1321           55                         push	bp
04935 1322           89E5                       mov	bp,sp
04936                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04937 1324           8A46         04            mov	al,4[bp]
04938 1327           30E4                       xor	ah,ah
04939 1329           50                         push	ax
04940                                           ! Debug: list * char = .106+0 (used reg = )
04941 132A           BB                   DDBD  mov	bx,#.106
04942 132D           53                         push	bx
04943                                           ! Debug: list int = const 7 (used reg = )
04944 132E           B8                   0007  mov	ax,*7
04945 1331           50                         push	ax
04946                                           ! Debug: func () void = bios_printf+0 (used reg = )
04947 1332           E8         F6E4            call	_bios_printf
04948 1335           89EC                       mov	sp,bp
04949                                           !BCC_EOS
04950                                           ! 1294 }
04951 1337           5D                         pop	bp
04952 1338           C3                         ret
04953                                           ! 1295 void s3_resume_panic()
04954                                           ! Register BX used in function shutdown_status_panic
04955                                           ! 1296 {
04956                                           export	_s3_resume_panic
04957                       00001339            _s3_resume_panic:
04958                                           ! 1297   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04959 1339           55                         push	bp
04960 133A           89E5                       mov	bp,sp
04961                                           ! Debug: list * char = .107+0 (used reg = )
04962 133C           BB                   DDA3  mov	bx,#.107
04963 133F           53                         push	bx
04964                                           ! Debug: list int = const 7 (used reg = )
04965 1340           B8                   0007  mov	ax,*7
04966 1343           50                         push	ax
04967                                           ! Debug: func () void = bios_printf+0 (used reg = )
04968 1344           E8         F6D2            call	_bios_printf
04969 1347           89EC                       mov	sp,bp
04970                                           !BCC_EOS
04971                                           ! 1298 }
04972 1349           5D                         pop	bp
04973 134A           C3                         ret
04974                                           ! 1299 void
04975                                           ! Register BX used in function s3_resume_panic
04976                                           ! 1300 print_bios_banner()
04977                                           ! 1301 {
04978                                           export	_print_bios_banner
04979                       0000134B            _print_bios_banner:
04980                                           ! 1302   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "06/23/99", bios_cvs_version_string);
04981 134B           55                         push	bp
04982 134C           89E5                       mov	bp,sp
04983                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
04984 134E           BB                   0194  mov	bx,#_bios_cvs_version_string
04985 1351           53                         push	bx
04986                                           ! Debug: list * char = .109+0 (used reg = )
04987 1352           BB                   DD76  mov	bx,#.109
04988 1355           53                         push	bx
04989                                           ! Debug: list * char = .108+0 (used reg = )
04990 1356           BB                   DD7F  mov	bx,#.108
04991 1359           53                         push	bx
04992                                           ! Debug: list int = const 2 (used reg = )
04993 135A           B8                   0002  mov	ax,*2
04994 135D           50                         push	ax
04995                                           ! Debug: func () void = bios_printf+0 (used reg = )
04996 135E           E8         F6B8            call	_bios_printf
04997 1361           89EC                       mov	sp,bp
04998                                           !BCC_EOS
04999                                           ! 1303   bios_printf(2, "apmbios " "pcibios " "eltorito " "PMM " "\n\n");
05000                                           ! Debug: list * char = .10A+0 (used reg = )
05001 1363           BB                   DD56  mov	bx,#.10A
05002 1366           53                         push	bx
05003                                           ! Debug: list int = const 2 (used reg = )
05004 1367           B8                   0002  mov	ax,*2
05005 136A           50                         push	ax
05006                                           ! Debug: func () void = bios_printf+0 (used reg = )
05007 136B           E8         F6AB            call	_bios_printf
05008 136E           89EC                       mov	sp,bp
05009                                           !BCC_EOS
05010                                           ! 1304 }
05011 1370           5D                         pop	bp
05012 1371           C3                         ret
05013                                           ! 1305 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
05014                                           ! Register BX used in function print_bios_banner
05015                                           
05016                       00001372            _drivetypes:
05017                       00001372            .10B:
05018 1372                        00            .byte	0
05019 1373                  00000009            .blkb	9
05020                       0000137C            .10C:
05021 137C                        46            .ascii	"Floppy"
05022 1382                        00            .byte	0
05023 1383                  00000003            .blkb	3
05024                       00001386            .10D:
05025 1386                        48            .ascii	"Hard Disk"
05026 138F                        00            .byte	0
05027                       00001390            .10E:
05028 1390                        43            .ascii	"CD-Rom"
05029 1396                        00            .byte	0
05030 1397                  00000003            .blkb	3
05031                       0000139A            .10F:
05032 139A                        4E            .ascii	"Network"
05033 13A1                        00            .byte	0
05034 13A2                  00000002            .blkb	2
05035                                           !BCC_EOS
05036                                           ! 1306 static void
05037                                           ! 1307 init_boot_vectors()
05038                                           ! 1308 {
05039                                           
05040                       000013A4            _init_boot_vectors:
05041                                           ! 1309   ipl_entry_t e;
05042                                           !BCC_EOS
05043                                           ! 1310   Bit16u count = 0;
05044 13A4           55                         push	bp
05045 13A5           89E5                       mov	bp,sp
05046 13A7           83C4                   EE  add	sp,*-$12
05047                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
05048 13AA           31C0                       xor	ax,ax
05049 13AC           8946         EE            mov	-$12[bp],ax
05050                                           !BCC_EOS
05051                                           ! 1311   Bit16u ss = get_SS();
05052 13AF           4C                         dec	sp
05053 13B0           4C                         dec	sp
05054                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05055 13B1           E8         F299            call	_get_SS
05056                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
05057 13B4           8946         EC            mov	-$14[bp],ax
05058                                           !BCC_EOS
05059                                           ! 1312   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05060 13B7           4C                         dec	sp
05061 13B8           4C                         dec	sp
05062                                           ! Debug: list int = const $E (used reg = )
05063 13B9           B8                   000E  mov	ax,*$E
05064 13BC           50                         push	ax
05065                                           ! Debug: list int = const $40 (used reg = )
05066 13BD           B8                   0040  mov	ax,*$40
05067 13C0           50                         push	ax
05068                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05069 13C1           E8         F243            call	_read_word
05070 13C4           83C4                   04  add	sp,*4
05071                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$18-$18] (used reg = )
05072 13C7           8946         EA            mov	-$16[bp],ax
05073                                           !BCC_EOS
05074                                           ! 1313   memsetb(ebda_seg, 0x0300, 0, 0xff);
05075                                           ! Debug: list int = const $FF (used reg = )
05076 13CA           B8                   00FF  mov	ax,#$FF
05077 13CD           50                         push	ax
05078                                           ! Debug: list int = const 0 (used reg = )
05079 13CE           31C0                       xor	ax,ax
05080 13D0           50                         push	ax
05081                                           ! Debug: list int = const $300 (used reg = )
05082 13D1           B8                   0300  mov	ax,#$300
05083 13D4           50                         push	ax
05084                                           ! Debug: list unsigned short ebda_seg = [S+$1E-$18] (used reg = )
05085 13D5           FF76         EA            push	-$16[bp]
05086                                           ! Debug: func () void = memsetb+0 (used reg = )
05087 13D8           E8         EC25            call	_memsetb
05088 13DB           83C4                   08  add	sp,*8
05089                                           !BCC_EOS
05090                                           ! 1314   write_word(ebda_seg, 0x0384, 0xFFFF);
05091                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05092 13DE           B8                   FFFF  mov	ax,#$FFFF
05093 13E1           50                         push	ax
05094                                           ! Debug: list int = const $384 (used reg = )
05095 13E2           B8                   0384  mov	ax,#$384
05096 13E5           50                         push	ax
05097                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05098 13E6           FF76         EA            push	-$16[bp]
05099                                           ! Debug: func () void = write_word+0 (used reg = )
05100 13E9           E8         F246            call	_write_word
05101 13EC           83C4                   06  add	sp,*6
05102                                           !BCC_EOS
05103                                           ! 1315   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05104                                           ! Debug: eq int = const 1 to unsigned short e = [S+$18-$12] (used reg = )
05105 13EF           B8                   0001  mov	ax,*1
05106 13F2           8946         F0            mov	-$10[bp],ax
05107                                           !BCC_EOS
05108                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05109 13F5           31C0                       xor	ax,ax
05110 13F7           8946         F2            mov	-$E[bp],ax
05111                                           !BCC_EOS
05112                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05113 13FA           31C0                       xor	ax,ax
05114 13FC           31DB                       xor	bx,bx
05115 13FE           8946         F4            mov	-$C[bp],ax
05116 1401           895E         F6            mov	-$A[bp],bx
05117                                           !BCC_EOS
05118                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05119 1404           31C0                       xor	ax,ax
05120 1406           31DB                       xor	bx,bx
05121 1408           8946         F8            mov	-8[bp],ax
05122 140B           895E         FA            mov	-6[bp],bx
05123                                           !BCC_EOS
05124                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05125 140E           31C0                       xor	ax,ax
05126 1410           31DB                       xor	bx,bx
05127 1412           8946         FC            mov	-4[bp],ax
05128 1415           895E         FE            mov	-2[bp],bx
05129                                           !BCC_EOS
05130                                           ! 1316   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05131                                           ! Debug: list int = const $10 (used reg = )
05132 1418           B8                   0010  mov	ax,*$10
05133 141B           50                         push	ax
05134                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05135 141C           8D5E         F0            lea	bx,-$10[bp]
05136 141F           53                         push	bx
05137                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05138 1420           FF76         EC            push	-$14[bp]
05139                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05140 1423           8B46         EE            mov	ax,-$12[bp]
05141 1426           B1                     04  mov	cl,*4
05142 1428           D3E0                       shl	ax,cl
05143                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05144                                           ! Debug: expression subtree swapping
05145                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05146 142A           05                   0300  add	ax,#$300
05147 142D           50                         push	ax
05148                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05149 142E           FF76         EA            push	-$16[bp]
05150                                           ! Debug: func () void = memcpyb+0 (used reg = )
05151 1431           E8         EBF0            call	_memcpyb
05152 1434           83C4                   0A  add	sp,*$A
05153                                           !BCC_EOS
05154                                           ! 1317   count++;
05155                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05156 1437           8B46         EE            mov	ax,-$12[bp]
05157 143A           40                         inc	ax
05158 143B           8946         EE            mov	-$12[bp],ax
05159                                           !BCC_EOS
05160                                           ! 1318   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05161                                           ! Debug: eq int = const 2 to unsigned short e = [S+$18-$12] (used reg = )
05162 143E           B8                   0002  mov	ax,*2
05163 1441           8946         F0            mov	-$10[bp],ax
05164                                           !BCC_EOS
05165                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05166 1444           31C0                       xor	ax,ax
05167 1446           8946         F2            mov	-$E[bp],ax
05168                                           !BCC_EOS
05169                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05170 1449           31C0                       xor	ax,ax
05171 144B           31DB                       xor	bx,bx
05172 144D           8946         F4            mov	-$C[bp],ax
05173 1450           895E         F6            mov	-$A[bp],bx
05174                                           !BCC_EOS
05175                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05176 1453           31C0                       xor	ax,ax
05177 1455           31DB                       xor	bx,bx
05178 1457           8946         F8            mov	-8[bp],ax
05179 145A           895E         FA            mov	-6[bp],bx
05180                                           !BCC_EOS
05181                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05182 145D           31C0                       xor	ax,ax
05183 145F           31DB                       xor	bx,bx
05184 1461           8946         FC            mov	-4[bp],ax
05185 1464           895E         FE            mov	-2[bp],bx
05186                                           !BCC_EOS
05187                                           ! 1319   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05188                                           ! Debug: list int = const $10 (used reg = )
05189 1467           B8                   0010  mov	ax,*$10
05190 146A           50                         push	ax
05191                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05192 146B           8D5E         F0            lea	bx,-$10[bp]
05193 146E           53                         push	bx
05194                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05195 146F           FF76         EC            push	-$14[bp]
05196                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05197 1472           8B46         EE            mov	ax,-$12[bp]
05198 1475           B1                     04  mov	cl,*4
05199 1477           D3E0                       shl	ax,cl
05200                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05201                                           ! Debug: expression subtree swapping
05202                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05203 1479           05                   0300  add	ax,#$300
05204 147C           50                         push	ax
05205                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05206 147D           FF76         EA            push	-$16[bp]
05207                                           ! Debug: func () void = memcpyb+0 (used reg = )
05208 1480           E8         EBA1            call	_memcpyb
05209 1483           83C4                   0A  add	sp,*$A
05210                                           !BCC_EOS
05211                                           ! 1320   count++;
05212                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05213 1486           8B46         EE            mov	ax,-$12[bp]
05214 1489           40                         inc	ax
05215 148A           8946         EE            mov	-$12[bp],ax
05216                                           !BCC_EOS
05217                                           ! 1321   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05218                                           ! Debug: eq int = const 3 to unsigned short e = [S+$18-$12] (used reg = )
05219 148D           B8                   0003  mov	ax,*3
05220 1490           8946         F0            mov	-$10[bp],ax
05221                                           !BCC_EOS
05222                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05223 1493           31C0                       xor	ax,ax
05224 1495           8946         F2            mov	-$E[bp],ax
05225                                           !BCC_EOS
05226                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05227 1498           31C0                       xor	ax,ax
05228 149A           31DB                       xor	bx,bx
05229 149C           8946         F4            mov	-$C[bp],ax
05230 149F           895E         F6            mov	-$A[bp],bx
05231                                           !BCC_EOS
05232                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05233 14A2           31C0                       xor	ax,ax
05234 14A4           31DB                       xor	bx,bx
05235 14A6           8946         F8            mov	-8[bp],ax
05236 14A9           895E         FA            mov	-6[bp],bx
05237                                           !BCC_EOS
05238                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05239 14AC           31C0                       xor	ax,ax
05240 14AE           31DB                       xor	bx,bx
05241 14B0           8946         FC            mov	-4[bp],ax
05242 14B3           895E         FE            mov	-2[bp],bx
05243                                           !BCC_EOS
05244                                           ! 1322   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05245                                           ! Debug: list int = const $10 (used reg = )
05246 14B6           B8                   0010  mov	ax,*$10
05247 14B9           50                         push	ax
05248                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05249 14BA           8D5E         F0            lea	bx,-$10[bp]
05250 14BD           53                         push	bx
05251                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05252 14BE           FF76         EC            push	-$14[bp]
05253                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05254 14C1           8B46         EE            mov	ax,-$12[bp]
05255 14C4           B1                     04  mov	cl,*4
05256 14C6           D3E0                       shl	ax,cl
05257                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05258                                           ! Debug: expression subtree swapping
05259                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05260 14C8           05                   0300  add	ax,#$300
05261 14CB           50                         push	ax
05262                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05263 14CC           FF76         EA            push	-$16[bp]
05264                                           ! Debug: func () void = memcpyb+0 (used reg = )
05265 14CF           E8         EB52            call	_memcpyb
05266 14D2           83C4                   0A  add	sp,*$A
05267                                           !BCC_EOS
05268                                           ! 1323   count++;
05269                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05270 14D5           8B46         EE            mov	ax,-$12[bp]
05271 14D8           40                         inc	ax
05272 14D9           8946         EE            mov	-$12[bp],ax
05273                                           !BCC_EOS
05274                                           ! 1324   write_word(ebda_seg, 0x0380, count);
05275                                           ! Debug: list unsigned short count = [S+$18-$14] (used reg = )
05276 14DC           FF76         EE            push	-$12[bp]
05277                                           ! Debug: list int = const $380 (used reg = )
05278 14DF           B8                   0380  mov	ax,#$380
05279 14E2           50                         push	ax
05280                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05281 14E3           FF76         EA            push	-$16[bp]
05282                                           ! Debug: func () void = write_word+0 (used reg = )
05283 14E6           E8         F149            call	_write_word
05284 14E9           83C4                   06  add	sp,*6
05285                                           !BCC_EOS
05286                                           ! 1325   write_word(ebda_seg, 0x0382, 0xffff);
05287                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05288 14EC           B8                   FFFF  mov	ax,#$FFFF
05289 14EF           50                         push	ax
05290                                           ! Debug: list int = const $382 (used reg = )
05291 14F0           B8                   0382  mov	ax,#$382
05292 14F3           50                         push	ax
05293                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05294 14F4           FF76         EA            push	-$16[bp]
05295                                           ! Debug: func () void = write_word+0 (used reg = )
05296 14F7           E8         F138            call	_write_word
05297 14FA           83C4                   06  add	sp,*6
05298                                           !BCC_EOS
05299                                           ! 1326 }
05300 14FD           89EC                       mov	sp,bp
05301 14FF           5D                         pop	bp
05302 1500           C3                         ret
05303                                           ! 1327 static Bit8u
05304                                           ! Register BX used in function init_boot_vectors
05305                                           ! 1328 get_boot_vector(i, e)
05306                                           ! 1329 Bit16u i; ipl_entry_t *e;
05307                       00001501            _get_boot_vector:
05308                                           !BCC_EOS
05309                                           !BCC_EOS
05310                                           ! 1330 {
05311                                           ! 1331   Bit16u count;
05312                                           !BCC_EOS
05313                                           ! 1332   Bit16u ss = get_SS();
05314 1501           55                         push	bp
05315 1502           89E5                       mov	bp,sp
05316 1504           83C4                   FC  add	sp,*-4
05317                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05318 1507           E8         F143            call	_get_SS
05319                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05320 150A           8946         FC            mov	-4[bp],ax
05321                                           !BCC_EOS
05322                                           ! 1333   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05323 150D           4C                         dec	sp
05324 150E           4C                         dec	sp
05325                                           ! Debug: list int = const $E (used reg = )
05326 150F           B8                   000E  mov	ax,*$E
05327 1512           50                         push	ax
05328                                           ! Debug: list int = const $40 (used reg = )
05329 1513           B8                   0040  mov	ax,*$40
05330 1516           50                         push	ax
05331                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05332 1517           E8         F0ED            call	_read_word
05333 151A           83C4                   04  add	sp,*4
05334                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
05335 151D           8946         FA            mov	-6[bp],ax
05336                                           !BCC_EOS
05337                                           ! 1334   count = read_word(ebda_seg, 0x0380);
05338                                           ! Debug: list int = const $380 (used reg = )
05339 1520           B8                   0380  mov	ax,#$380
05340 1523           50                         push	ax
05341                                           ! Debug: list unsigned short ebda_seg = [S+$A-8] (used reg = )
05342 1524           FF76         FA            push	-6[bp]
05343                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05344 1527           E8         F0DD            call	_read_word
05345 152A           83C4                   04  add	sp,*4
05346                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+8-4] (used reg = )
05347 152D           8946         FE            mov	-2[bp],ax
05348                                           !BCC_EOS
05349                                           ! 1335   if (i >= count) return 0;
05350                                           ! Debug: ge unsigned short count = [S+8-4] to unsigned short i = [S+8+2] (used reg = )
05351 1530           8B46         04            mov	ax,4[bp]
05352 1533           3B46         FE            cmp	ax,-2[bp]
05353 1536           72           06            jb  	.110
05354                       00001538            .111:
05355 1538           30C0                       xor	al,al
05356 153A           89EC                       mov	sp,bp
05357 153C           5D                         pop	bp
05358 153D           C3                         ret
05359                                           !BCC_EOS
05360                                           ! 1336   memcpyb(ss, e, ebda_seg, 0x0300 + i * sizeof (*e), sizeof (*e));
05361                       0000153E            .110:
05362                                           ! Debug: list int = const $10 (used reg = )
05363 153E           B8                   0010  mov	ax,*$10
05364 1541           50                         push	ax
05365                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05366 1542           8B46         04            mov	ax,4[bp]
05367 1545           B1                     04  mov	cl,*4
05368 1547           D3E0                       shl	ax,cl
05369                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05370                                           ! Debug: expression subtree swapping
05371                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05372 1549           05                   0300  add	ax,#$300
05373 154C           50                         push	ax
05374                                           ! Debug: list unsigned short ebda_seg = [S+$C-8] (used reg = )
05375 154D           FF76         FA            push	-6[bp]
05376                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05377 1550           FF76         06            push	6[bp]
05378                                           ! Debug: list unsigned short ss = [S+$10-6] (used reg = )
05379 1553           FF76         FC            push	-4[bp]
05380                                           ! Debug: func () void = memcpyb+0 (used reg = )
05381 1556           E8         EACB            call	_memcpyb
05382 1559           83C4                   0A  add	sp,*$A
05383                                           !BCC_EOS
05384                                           ! 1337   return 1;
05385 155C           B0                     01  mov	al,*1
05386 155E           89EC                       mov	sp,bp
05387 1560           5D                         pop	bp
05388 1561           C3                         ret
05389                                           !BCC_EOS
05390                                           ! 1338 }
05391                                           ! 1339   void
05392                                           ! 1340 interactive_bootkey()
05393                                           ! 1341 {
05394                                           export	_interactive_bootkey
05395                       00001562            _interactive_bootkey:
05396                                           ! 1342   ipl_entry_t e;
05397                                           !BCC_EOS
05398                                           ! 1343   Bit16u count;
05399                                           !BCC_EOS
05400                                           ! 1344   char description[33];
05401                                           !BCC_EOS
05402                                           ! 1345   Bit8u scan_code;
05403                                           !BCC_EOS
05404                                           ! 1346   Bit8u i;
05405                                           !BCC_EOS
05406                                           ! 1347   Bit16u ss = get_SS();
05407 1562           55                         push	bp
05408 1563           89E5                       mov	bp,sp
05409 1565           83C4                   C8  add	sp,*-$38
05410                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05411 1568           E8         F0E2            call	_get_SS
05412                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05413 156B           8946         C8            mov	-$38[bp],ax
05414                                           !BCC_EOS
05415                                           ! 1348   Bit16u valid_choice = 0;
05416 156E           4C                         dec	sp
05417 156F           4C                         dec	sp
05418                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05419 1570           31C0                       xor	ax,ax
05420 1572           8946         C6            mov	-$3A[bp],ax
05421                                           !BCC_EOS
05422                                           ! 1349   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05423 1575           4C                         dec	sp
05424 1576           4C                         dec	sp
05425                                           ! Debug: list int = const $E (used reg = )
05426 1577           B8                   000E  mov	ax,*$E
05427 157A           50                         push	ax
05428                                           ! Debug: list int = const $40 (used reg = )
05429 157B           B8                   0040  mov	ax,*$40
05430 157E           50                         push	ax
05431                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05432 157F           E8         F085            call	_read_word
05433 1582           83C4                   04  add	sp,*4
05434                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$3E-$3E] (used reg = )
05435 1585           8946         C4            mov	-$3C[bp],ax
05436                                           !BCC_EOS
05437                                           ! 1350   bios_printf(2, "\n\nPress F12 for boot menu.\n\n");
05438                                           ! Debug: list * char = .112+0 (used reg = )
05439 1588           BB                   DD39  mov	bx,#.112
05440 158B           53                         push	bx
05441                                           ! Debug: list int = const 2 (used reg = )
05442 158C           B8                   0002  mov	ax,*2
05443 158F           50                         push	ax
05444                                           ! Debug: func () void = bios_printf+0 (used reg = )
05445 1590           E8         F486            call	_bios_printf
05446 1593           83C4                   04  add	sp,*4
05447                                           !BCC_EOS
05448                                           ! 1351   while (check_f
05449                                           ! 1351 or_keystroke())
05450                                           ! 1352   {
05451 1596           E9         01B4            br 	.114
05452                       00001599            .115:
05453                                           ! 1353     scan_code = get_keystroke();
05454                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05455 1599           E8         F444            call	_get_keystroke
05456                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05457 159C           8846         CC            mov	-$34[bp],al
05458                                           !BCC_EOS
05459                                           ! 1354     if (scan_code != 0x86)
05460                                           ! Debug: ne int = const $86 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05461 159F           8A46         CC            mov	al,-$34[bp]
05462 15A2           3C                     86  cmp	al,#$86
05463 15A4           74           03            je  	.116
05464                       000015A6            .117:
05465                                           ! 1355       continue;
05466 15A6           E9         01A4            br 	.114
05467                                           !BCC_EOS
05468                                           ! 1356     while (check_for_keystroke())
05469                       000015A9            .116:
05470                                           ! 1357       get_keystroke();
05471 15A9           EB           03            jmp .119
05472                       000015AB            .11A:
05473                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05474 15AB           E8         F432            call	_get_keystroke
05475                                           !BCC_EOS
05476                                           ! 1358     bios_printf(2, "Select boot device:\n\n");
05477                       000015AE            .119:
05478                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05479 15AE           E8         F421            call	_check_for_keystroke
05480 15B1           84C0                       test	al,al
05481 15B3           75           F6            jne	.11A
05482                       000015B5            .11B:
05483                       000015B5            .118:
05484                                           ! Debug: list * char = .11C+0 (used reg = )
05485 15B5           BB                   DD23  mov	bx,#.11C
05486 15B8           53                         push	bx
05487                                           ! Debug: list int = const 2 (used reg = )
05488 15B9           B8                   0002  mov	ax,*2
05489 15BC           50                         push	ax
05490                                           ! Debug: func () void = bios_printf+0 (used reg = )
05491 15BD           E8         F459            call	_bios_printf
05492 15C0           83C4                   04  add	sp,*4
05493                                           !BCC_EOS
05494                                           ! 1359     count = read_word(ebda_seg, 0x0380);
05495                                           ! Debug: list int = const $380 (used reg = )
05496 15C3           B8                   0380  mov	ax,#$380
05497 15C6           50                         push	ax
05498                                           ! Debug: list unsigned short ebda_seg = [S+$40-$3E] (used reg = )
05499 15C7           FF76         C4            push	-$3C[bp]
05500                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05501 15CA           E8         F03A            call	_read_word
05502 15CD           83C4                   04  add	sp,*4
05503                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3E-$14] (used reg = )
05504 15D0           8946         EE            mov	-$12[bp],ax
05505                                           !BCC_EOS
05506                                           ! 1360     for (i = 0; i < count; i++)
05507                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3E-$37] (used reg = )
05508 15D3           30C0                       xor	al,al
05509 15D5           8846         CB            mov	-$35[bp],al
05510                                           !BCC_EOS
05511                                           !BCC_EOS
05512                                           ! 1361     {
05513 15D8           E9         00FE            br 	.11F
05514                       000015DB            .120:
05515                                           ! 1362       memcpyb(ss, &e, ebda_seg, 0x0300 + i * sizeof (e), sizeof (e));
05516                                           ! Debug: list int = const $10 (used reg = )
05517 15DB           B8                   0010  mov	ax,*$10
05518 15DE           50                         push	ax
05519                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05520 15DF           8A46         CB            mov	al,-$35[bp]
05521 15E2           30E4                       xor	ah,ah
05522 15E4           B1                     04  mov	cl,*4
05523 15E6           D3E0                       shl	ax,cl
05524                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05525                                           ! Debug: expression subtree swapping
05526                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05527 15E8           05                   0300  add	ax,#$300
05528 15EB           50                         push	ax
05529                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05530 15EC           FF76         C4            push	-$3C[bp]
05531                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05532 15EF           8D5E         F0            lea	bx,-$10[bp]
05533 15F2           53                         push	bx
05534                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05535 15F3           FF76         C8            push	-$38[bp]
05536                                           ! Debug: func () void = memcpyb+0 (used reg = )
05537 15F6           E8         EA2B            call	_memcpyb
05538 15F9           83C4                   0A  add	sp,*$A
05539                                           !BCC_EOS
05540                                           ! 1363       bios_printf(2, "%d. ", i+1);
05541                                           ! Debug: add int = const 1 to unsigned char i = [S+$3E-$37] (used reg = )
05542 15FC           8A46         CB            mov	al,-$35[bp]
05543 15FF           30E4                       xor	ah,ah
05544                                           ! Debug: list unsigned int = ax+1 (used reg = )
05545 1601           40                         inc	ax
05546 1602           50                         push	ax
05547                                           ! Debug: list * char = .121+0 (used reg = )
05548 1603           BB                   DD1E  mov	bx,#.121
05549 1606           53                         push	bx
05550                                           ! Debug: list int = const 2 (used reg = )
05551 1607           B8                   0002  mov	ax,*2
05552 160A           50                         push	ax
05553                                           ! Debug: func () void = bios_printf+0 (used reg = )
05554 160B           E8         F40B            call	_bios_printf
05555 160E           83C4                   06  add	sp,*6
05556                                           !BCC_EOS
05557                                           ! 1364       switch(e.type)
05558 1611           8B46         F0            mov	ax,-$10[bp]
05559                                           ! 1365       {
05560 1614           E9         009F            br 	.124
05561                                           ! 1366         case 0x01:
05562                                           ! 1367         case 0x02:
05563                       00001617            .125:
05564                                           ! 1368         case 0x03:
05565                       00001617            .126:
05566                                           ! 1369           bios_printf(2, "%s\n", drivetypes[e.type]);
05567                       00001617            .127:
05568                                           ! Debug: ptradd unsigned short e = [S+$3E-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05569 1617           8B5E         F0            mov	bx,-$10[bp]
05570 161A           89DA                       mov	dx,bx
05571 161C           D1E3                       shl	bx,*1
05572 161E           D1E3                       shl	bx,*1
05573 1620           01D3                       add	bx,dx
05574 1622           D1E3                       shl	bx,*1
05575                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05576                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05577 1624           81C3                 1372  add	bx,#_drivetypes
05578 1628           53                         push	bx
05579                                           ! Debug: list * char = .128+0 (used reg = )
05580 1629           BB                   DD1A  mov	bx,#.128
05581 162C           53                         push	bx
05582                                           ! Debug: list int = const 2 (used reg = )
05583 162D           B8                   0002  mov	ax,*2
05584 1630           50                         push	ax
05585                                           ! Debug: func () void = bios_printf+0 (used reg = )
05586 1631           E8         F3E5            call	_bios_printf
05587 1634           83C4                   06  add	sp,*6
05588                                           !BCC_EOS
05589                                           ! 1370           break;
05590 1637           E9         0098            br 	.122
05591                                           !BCC_EOS
05592                                           ! 1371         case 0x80:
05593                                           ! 1372           bios_printf(2, "%s", drivetypes[4]);
05594                       0000163A            .129:
05595                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05596 163A           BB                   139A  mov	bx,#_drivetypes+$28
05597 163D           53                         push	bx
05598                                           ! Debug: list * char = .12A+0 (used reg = )
05599 163E           BB                   DD17  mov	bx,#.12A
05600 1641           53                         push	bx
05601                                           ! Debug: list int = const 2 (used reg = )
05602 1642           B8                   0002  mov	ax,*2
05603 1645           50                         push	ax
05604                                           ! Debug: func () void = bios_printf+0 (used reg = )
05605 1646           E8         F3D0            call	_bios_printf
05606 1649           83C4                   06  add	sp,*6
05607                                           !BCC_EOS
05608                                           ! 1373           if (e.description != 0)
05609                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3E-$A] (used reg = )
05610                                           ! Debug: expression subtree swapping
05611 164C           31C0                       xor	ax,ax
05612 164E           31DB                       xor	bx,bx
05613 1650           53                         push	bx
05614 1651           50                         push	ax
05615 1652           8B46         F8            mov	ax,-8[bp]
05616 1655           8B5E         FA            mov	bx,-6[bp]
05617 1658           8D7E         C0            lea	di,-2+..FFFF[bp]
05618 165B           E8         EA6D            call	lcmpul
05619 165E           8D66         C4            lea	sp,2+..FFFF[bp]
05620 1661           74           41            je  	.12B
05621                       00001663            .12C:
05622                                           ! 1374           {
05623                                           ! 1375             memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
05624                                           ! Debug: list int = const $20 (used reg = )
05625 1663           B8                   0020  mov	ax,*$20
05626 1666           50                         push	ax
05627                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$40-$A] (used reg = )
05628                                           ! Debug: expression subtree swapping
05629 1667           B8                   FFFF  mov	ax,#$FFFF
05630 166A           31DB                       xor	bx,bx
05631 166C           8D7E         F8            lea	di,-8[bp]
05632 166F           E8         EA49            call	landul
05633                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05634                                           ! Debug: list unsigned short = ax+0 (used reg = )
05635 1672           50                         push	ax
05636                                           ! Debug: sr int = const $10 to unsigned long e = [S+$42-$A] (used reg = )
05637 1673           8B46         F8            mov	ax,-8[bp]
05638 1676           8B5E         FA            mov	bx,-6[bp]
05639 1679           93                         xchg	bx,ax
05640 167A           31DB                       xor	bx,bx
05641                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05642                                           ! Debug: list unsigned short = ax+0 (used reg = )
05643 167C           50                         push	ax
05644                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05645 167D           8D5E         CD            lea	bx,-$33[bp]
05646 1680           53                         push	bx
05647                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05648 1681           FF76         C8            push	-$38[bp]
05649                                           ! Debug: func () void = memcpyb+0 (used reg = )
05650 1684           E8         E99D            call	_memcpyb
05651 1687           83C4                   0A  add	sp,*$A
05652                                           !BCC_EOS
05653                                           ! 1376             description[32] = 0;
05654                                           ! Debug: eq int = const 0 to char description = [S+$3E-$15] (used reg = )
05655 168A           30C0                       xor	al,al
05656 168C           8846         ED            mov	-$13[bp],al
05657                                           !BCC_EOS
05658                                           ! 1377             bios_printf(2, " [%S]", ss, description);
05659                                           ! Debug: list * char description = S+$3E-$35 (used reg = )
05660 168F           8D5E         CD            lea	bx,-$33[bp]
05661 1692           53                         push	bx
05662                                           ! Debug: list unsigned short ss = [S+$40-$3A] (used reg = )
05663 1693           FF76         C8            push	-$38[bp]
05664                                           ! Debug: list * char = .12D+0 (used reg = )
05665 1696           BB                   DD11  mov	bx,#.12D
05666 1699           53                         push	bx
05667                                           ! Debug: list int = const 2 (used reg = )
05668 169A           B8                   0002  mov	ax,*2
05669 169D           50                         push	ax
05670                                           ! Debug: func () void = bios_printf+0 (used reg = )
05671 169E           E8         F378            call	_bios_printf
05672 16A1           83C4                   08  add	sp,*8
05673                                           !BCC_EOS
05674                                           ! 1378          }
05675                                           ! 1379          bios_printf(2, "\n");
05676                       000016A4            .12B:
05677                                           ! Debug: list * char = .12E+0 (used reg = )
05678 16A4           BB                   DD0F  mov	bx,#.12E
05679 16A7           53                         push	bx
05680                                           ! Debug: list int = const 2 (used reg = )
05681 16A8           B8                   0002  mov	ax,*2
05682 16AB           50                         push	ax
05683                                           ! Debug: func () void = bios_printf+0 (used reg = )
05684 16AC           E8         F36A            call	_bios_printf
05685 16AF           83C4                   04  add	sp,*4
05686                                           !BCC_EOS
05687                                           ! 1380          break;
05688 16B2           EB           1E            jmp .122
05689                                           !BCC_EOS
05690                                           ! 1381       }
05691                                           ! 1382     }
05692 16B4           EB           1C            jmp .122
05693                       000016B6            .124:
05694 16B6           2D                   0001  sub	ax,*1
05695 16B9         0F84         FF5A            beq 	.125
05696 16BD           2D                   0001  sub	ax,*1
05697 16C0         0F84         FF53            beq 	.126
05698 16C4           2D                   0001  sub	ax,*1
05699 16C7         0F84         FF4C            beq 	.127
05700 16CB           2D                   007D  sub	ax,*$7D
05701 16CE         0F84         FF68            beq 	.129
05702                       000016D2            .122:
05703                       FFFFFFC2            ..FFFF	=	-$3E
05704                                           ! 1383     count++;
05705                       000016D2            .11E:
05706                                           ! Debug: postinc unsigned char i = [S+$3E-$37] (used reg = )
05707 16D2           8A46         CB            mov	al,-$35[bp]
05708 16D5           40                         inc	ax
05709 16D6           8846         CB            mov	-$35[bp],al
05710                       000016D9            .11F:
05711                                           ! Debug: lt unsigned short count = [S+$3E-$14] to unsigned char i = [S+$3E-$37] (used reg = )
05712 16D9           8A46         CB            mov	al,-$35[bp]
05713 16DC           30E4                       xor	ah,ah
05714 16DE           3B46         EE            cmp	ax,-$12[bp]
05715 16E1         0F82         FEF6            blo 	.120
05716                       000016E5            .12F:
05717                       000016E5            .11D:
05718                                           ! Debug: postinc unsigned short count = [S+$3E-$14] (used reg = )
05719 16E5           8B46         EE            mov	ax,-$12[bp]
05720 16E8           40                         inc	ax
05721 16E9           8946         EE            mov	-$12[bp],ax
05722                                           !BCC_EOS
05723                                           ! 1384     while (!valid_choice) {
05724 16EC           EB           48            jmp .131
05725                       000016EE            .132:
05726                                           ! 1385       scan_code = get_keystroke();
05727                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05728 16EE           E8         F2EF            call	_get_keystroke
05729                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05730 16F1           8846         CC            mov	-$34[bp],al
05731                                           !BCC_EOS
05732                                           ! 1386       if (scan_code == 0x01 || scan_code == 0x58)
05733                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05734 16F4           8A46         CC            mov	al,-$34[bp]
05735 16F7           3C                     01  cmp	al,*1
05736 16F9           74           07            je  	.134
05737                       000016FB            .135:
05738                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05739 16FB           8A46         CC            mov	al,-$34[bp]
05740 16FE           3C                     58  cmp	al,*$58
05741 1700           75           08            jne 	.133
05742                       00001702            .134:
05743                                           ! 1387       {
05744                                           ! 1388         valid_choice = 1;
05745                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05746 1702           B8                   0001  mov	ax,*1
05747 1705           8946         C6            mov	-$3A[bp],ax
05748                                           !BCC_EOS
05749                                           ! 1389       }
05750                                           ! 1390       else if (scan_code <= count)
05751 1708           EB           2C            jmp .136
05752                       0000170A            .133:
05753                                           ! Debug: le unsigned short count = [S+$3E-$14] to unsigned char scan_code = [S+$3E-$36] (used reg = )
05754 170A           8A46         CC            mov	al,-$34[bp]
05755 170D           30E4                       xor	ah,ah
05756 170F           3B46         EE            cmp	ax,-$12[bp]
05757 1712           77           22            ja  	.137
05758                       00001714            .138:
05759                                           ! 1391       {
05760                                           ! 1392         valid_choice = 1;
05761                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05762 1714           B8                   0001  mov	ax,*1
05763 1717           8946         C6            mov	-$3A[bp],ax
05764                                           !BCC_EOS
05765                                           ! 1393         scan_code -= 1;
05766                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05767 171A           8A46         CC            mov	al,-$34[bp]
05768 171D           30E4                       xor	ah,ah
05769 171F           48                         dec	ax
05770 1720           8846         CC            mov	-$34[bp],al
05771                                           !BCC_EOS
05772                                           ! 1394         write_word(ebda_seg, 0x0384, scan_code);
05773                                           ! Debug: list unsigned char scan_code = [S+$3E-$36] (used reg = )
05774 1723           8A46         CC            mov	al,-$34[bp]
05775 1726           30E4                       xor	ah,ah
05776 1728           50                         push	ax
05777                                           ! Debug: list int = const $384 (used reg = )
05778 1729           B8                   0384  mov	ax,#$384
05779 172C           50                         push	ax
05780                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05781 172D           FF76         C4            push	-$3C[bp]
05782                                           ! Debug: func () void = write_word+0 (used reg = )
05783 1730           E8         EEFF            call	_write_word
05784 1733           83C4                   06  add	sp,*6
05785                                           !BCC_EOS
05786                                           ! 1395       }
05787                                           ! 1396     }
05788                       00001736            .137:
05789                       00001736            .136:
05790                                           ! 1397     bios_printf(2, "\n");
05791                       00001736            .131:
05792 1736           8B46         C6            mov	ax,-$3A[bp]
05793 1739           85C0                       test	ax,ax
05794 173B           74           B1            je 	.132
05795                       0000173D            .139:
05796                       0000173D            .130:
05797                                           ! Debug: list * char = .13A+0 (used reg = )
05798 173D           BB                   DD0D  mov	bx,#.13A
05799 1740           53                         push	bx
05800                                           ! Debug: list int = const 2 (used reg = )
05801 1741           B8                   0002  mov	ax,*2
05802 1744           50                         push	ax
05803                                           ! Debug: func () void = bios_printf+0 (used reg = )
05804 1745           E8         F2D1            call	_bios_printf
05805 1748           83C4                   04  add	sp,*4
05806                                           !BCC_EOS
05807                                           ! 1398     break;
05808 174B           EB           09            jmp .113
05809                                           !BCC_EOS
05810                                           ! 1399   }
05811                                           ! 1400 }
05812                       0000174D            .114:
05813                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05814 174D           E8         F282            call	_check_for_keystroke
05815 1750           84C0                       test	al,al
05816 1752         0F85         FE43            bne 	.115
05817                       00001756            .13B:
05818                       00001756            .113:
05819 1756           89EC                       mov	sp,bp
05820 1758           5D                         pop	bp
05821 1759           C3                         ret
05822                                           ! 1401 void
05823                                           ! Register BX used in function interactive_bootkey
05824                                           ! 1402 print_boot_device(type, desc)
05825                                           ! 1403   Bit16u type; Bit32u desc;
05826                                           export	_print_boot_device
05827                       0000175A            _print_boot_device:
05828                                           !BCC_EOS
05829                                           !BCC_EOS
05830                                           ! 1404 {
05831                                           ! 1405   char description[33];
05832                                           !BCC_EOS
05833                                           ! 1406   Bit16u ss = get_SS();
05834 175A           55                         push	bp
05835 175B           89E5                       mov	bp,sp
05836 175D           83C4                   DC  add	sp,*-$24
05837                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05838 1760           E8         EEEA            call	_get_SS
05839                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$26-$26] (used reg = )
05840 1763           8946         DC            mov	-$24[bp],ax
05841                                           !BCC_EOS
05842                                           ! 1407   if (type == 0x80) type = 0x4;
05843                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$26+2] (used reg = )
05844 1766           8B46         04            mov	ax,4[bp]
05845 1769           3D                   0080  cmp	ax,#$80
05846 176C           75           06            jne 	.13C
05847                       0000176E            .13D:
05848                                           ! Debug: eq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05849 176E           B8                   0004  mov	ax,*4
05850 1771           8946         04            mov	4[bp],ax
05851                                           !BCC_EOS
05852                                           ! 1408   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05853                       00001774            .13C:
05854                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$26+2] (used reg = )
05855 1774           8B46         04            mov	ax,4[bp]
05856 1777           85C0                       test	ax,ax
05857 1779           74           08            je  	.13F
05858                       0000177B            .140:
05859                                           ! Debug: gt int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05860 177B           8B46         04            mov	ax,4[bp]
05861 177E           3D                   0004  cmp	ax,*4
05862 1781           76           0E            jbe 	.13E
05863                       00001783            .13F:
05864                                           ! Debug: list * char = .141+0 (used reg = )
05865 1783           BB                   DCFD  mov	bx,#.141
05866 1786           53                         push	bx
05867                                           ! Debug: list int = const 7 (used reg = )
05868 1787           B8                   0007  mov	ax,*7
05869 178A           50                         push	ax
05870                                           ! Debug: func () void = bios_printf+0 (used reg = )
05871 178B           E8         F28B            call	_bios_printf
05872 178E           83C4                   04  add	sp,*4
05873                                           !BCC_EOS
05874                                           ! 1409   bios_printf(2, "Booting from %s", drivetypes[type]);
05875                       00001791            .13E:
05876                                           ! Debug: ptradd unsigned short type = [S+$26+2] to [5] [$A] char = drivetypes+0 (used reg = )
05877 1791           8B5E         04            mov	bx,4[bp]
05878 1794           89DA                       mov	dx,bx
05879 1796           D1E3                       shl	bx,*1
05880 1798           D1E3                       shl	bx,*1
05881 179A           01D3                       add	bx,dx
05882 179C           D1E3                       shl	bx,*1
05883                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05884                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05885 179E           81C3                 1372  add	bx,#_drivetypes
05886 17A2           53                         push	bx
05887                                           ! Debug: list * char = .142+0 (used reg = )
05888 17A3           BB                   DCED  mov	bx,#.142
05889 17A6           53                         push	bx
05890                                           ! Debug: list int = const 2 (used reg = )
05891 17A7           B8                   0002  mov	ax,*2
05892 17AA           50                         push	ax
05893                                           ! Debug: func () void = bios_printf+0 (used reg = )
05894 17AB           E8         F26B            call	_bios_printf
05895 17AE           83C4                   06  add	sp,*6
05896                                           !BCC_EOS
05897                                           ! 1410   if (type == 4 && desc != 0) {
05898                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05899 17B1           8B46         04            mov	ax,4[bp]
05900 17B4           3D                   0004  cmp	ax,*4
05901 17B7           75           58            jne 	.143
05902                       000017B9            .145:
05903                                           ! Debug: ne unsigned long = const 0 to unsigned long desc = [S+$26+4] (used reg = )
05904                                           ! Debug: expression subtree swapping
05905 17B9           31C0                       xor	ax,ax
05906 17BB           31DB                       xor	bx,bx
05907 17BD           53                         push	bx
05908 17BE           50                         push	ax
05909 17BF           8B46         06            mov	ax,6[bp]
05910 17C2           8B5E         08            mov	bx,8[bp]
05911 17C5           8D7E         D8            lea	di,-$28[bp]
05912 17C8           E8         E900            call	lcmpul
05913 17CB           8D66         DC            lea	sp,-$24[bp]
05914 17CE           74           41            je  	.143
05915                       000017D0            .144:
05916                                           ! 1411     memcpyb(ss, &description, (Bit16u)(desc >> 16), (Bit16u)(desc & 0xffff), 32);
05917                                           ! Debug: list int = const $20 (used reg = )
05918 17D0           B8                   0020  mov	ax,*$20
05919 17D3           50                         push	ax
05920                                           ! Debug: and unsigned long = const $FFFF to unsigned long desc = [S+$28+4] (used reg = )
05921                                           ! Debug: expression subtree swapping
05922 17D4           B8                   FFFF  mov	ax,#$FFFF
05923 17D7           31DB                       xor	bx,bx
05924 17D9           8D7E         06            lea	di,6[bp]
05925 17DC           E8         E8DC            call	landul
05926                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05927                                           ! Debug: list unsigned short = ax+0 (used reg = )
05928 17DF           50                         push	ax
05929                                           ! Debug: sr int = const $10 to unsigned long desc = [S+$2A+4] (used reg = )
05930 17E0           8B46         06            mov	ax,6[bp]
05931 17E3           8B5E         08            mov	bx,8[bp]
05932 17E6           93                         xchg	bx,ax
05933 17E7           31DB                       xor	bx,bx
05934                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05935                                           ! Debug: list unsigned short = ax+0 (used reg = )
05936 17E9           50                         push	ax
05937                                           ! Debug: list * [$21] char description = S+$2C-$23 (used reg = )
05938 17EA           8D5E         DF            lea	bx,-$21[bp]
05939 17ED           53                         push	bx
05940                                           ! Debug: list unsigned short ss = [S+$2E-$26] (used reg = )
05941 17EE           FF76         DC            push	-$24[bp]
05942                                           ! Debug: func () void = memcpyb+0 (used reg = )
05943 17F1           E8         E830            call	_memcpyb
05944 17F4           83C4                   0A  add	sp,*$A
05945                                           !BCC_EOS
05946                                           ! 1412     description[32] = 0;
05947                                           ! Debug: eq int = const 0 to char description = [S+$26-3] (used reg = )
05948 17F7           30C0                       xor	al,al
05949 17F9           8846         FF            mov	-1[bp],al
05950                                           !BCC_EOS
05951                                           ! 1413     bios_printf(2, " [%S]", ss, description);
05952                                           ! Debug: list * char description = S+$26-$23 (used reg = )
05953 17FC           8D5E         DF            lea	bx,-$21[bp]
05954 17FF           53                         push	bx
05955                                           ! Debug: list unsigned short ss = [S+$28-$26] (used reg = )
05956 1800           FF76         DC            push	-$24[bp]
05957                                           ! Debug: list * char = .146+0 (used reg = )
05958 1803           BB                   DCE7  mov	bx,#.146
05959 1806           53                         push	bx
05960                                           ! Debug: list int = const 2 (used reg = )
05961 1807           B8                   0002  mov	ax,*2
05962 180A           50                         push	ax
05963                                           ! Debug: func () void = bios_printf+0 (used reg = )
05964 180B           E8         F20B            call	_bios_printf
05965 180E           83C4                   08  add	sp,*8
05966                                           !BCC_EOS
05967                                           ! 1414   }
05968                                           ! 1415   bios_printf(2, "...\n");
05969                       00001811            .143:
05970                                           ! Debug: list * char = .147+0 (used reg = )
05971 1811           BB                   DCE2  mov	bx,#.147
05972 1814           53                         push	bx
05973                                           ! Debug: list int = const 2 (used reg = )
05974 1815           B8                   0002  mov	ax,*2
05975 1818           50                         push	ax
05976                                           ! Debug: func () void = bios_printf+0 (used reg = )
05977 1819           E8         F1FD            call	_bios_printf
05978 181C           83C4                   04  add	sp,*4
05979                                           !BCC_EOS
05980                                           ! 1416 }
05981 181F           89EC                       mov	sp,bp
05982 1821           5D                         pop	bp
05983 1822           C3                         ret
05984                                           ! 1417   void
05985                                           ! Register BX used in function print_boot_device
05986                                           ! 1418 print_boot_failure(type, reason)
05987                                           ! 1419   Bit16u type; Bit8u reason;
05988                                           export	_print_boot_failure
05989                       00001823            _print_boot_failure:
05990                                           !BCC_EOS
05991                                           !BCC_EOS
05992                                           ! 1420 {
05993                                           ! 1421   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05994 1823           55                         push	bp
05995 1824           89E5                       mov	bp,sp
05996                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05997 1826           8B46         04            mov	ax,4[bp]
05998 1829           85C0                       test	ax,ax
05999 182B           74           08            je  	.149
06000                       0000182D            .14A:
06001                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
06002 182D           8B46         04            mov	ax,4[bp]
06003 1830           3D                   0003  cmp	ax,*3
06004 1833           76           0D            jbe 	.148
06005                       00001835            .149:
06006                                           ! Debug: list * char = .14B+0 (used reg = )
06007 1835           BB                   DCD2  mov	bx,#.14B
06008 1838           53                         push	bx
06009                                           ! Debug: list int = const 7 (used reg = )
06010 1839           B8                   0007  mov	ax,*7
06011 183C           50                         push	ax
06012                                           ! Debug: func () void = bios_printf+0 (used reg = )
06013 183D           E8         F1D9            call	_bios_printf
06014 1840           89EC                       mov	sp,bp
06015                                           !BCC_EOS
06016                                           ! 1422   bios_printf(2, "Boot from %s failed", drivetypes[type]);
06017                       00001842            .148:
06018                                           ! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
06019 1842           8B5E         04            mov	bx,4[bp]
06020 1845           89DA                       mov	dx,bx
06021 1847           D1E3                       shl	bx,*1
06022 1849           D1E3                       shl	bx,*1
06023 184B           01D3                       add	bx,dx
06024 184D           D1E3                       shl	bx,*1
06025                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
06026                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
06027 184F           81C3                 1372  add	bx,#_drivetypes
06028 1853           53                         push	bx
06029                                           ! Debug: list * char = .14C+0 (used reg = )
06030 1854           BB                   DCBE  mov	bx,#.14C
06031 1857           53                         push	bx
06032                                           ! Debug: list int = const 2 (used reg = )
06033 1858           B8                   0002  mov	ax,*2
06034 185B           50                         push	ax
06035                                           ! Debug: func () void = bios_printf+0 (used reg = )
06036 185C           E8         F1BA            call	_bios_printf
06037 185F           89EC                       mov	sp,bp
06038                                           !BCC_EOS
06039                                           ! 1423   if (type < 4) {
06040                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
06041 1861           8B46         04            mov	ax,4[bp]
06042 1864           3D                   0004  cmp	ax,*4
06043 1867           73           23            jae 	.14D
06044                       00001869            .14E:
06045                                           ! 1424     if (reason==0)
06046                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
06047 1869           8A46         06            mov	al,6[bp]
06048 186C           84C0                       test	al,al
06049 186E           75           0F            jne 	.14F
06050                       00001870            .150:
06051                                           ! 1425       bios_printf(2, "
06052                                           ! 1425 : not a bootable disk");
06053                                           ! Debug: list * char = .151+0 (used reg = )
06054 1870           BB                   DCA8  mov	bx,#.151
06055 1873           53                         push	bx
06056                                           ! Debug: list int = const 2 (used reg = )
06057 1874           B8                   0002  mov	ax,*2
06058 1877           50                         push	ax
06059                                           ! Debug: func () void = bios_printf+0 (used reg = )
06060 1878           E8         F19E            call	_bios_printf
06061 187B           89EC                       mov	sp,bp
06062                                           !BCC_EOS
06063                                           ! 1426     else
06064                                           ! 1427       bios_printf(2, ": could not read the boot disk");
06065 187D           EB           0D            jmp .152
06066                       0000187F            .14F:
06067                                           ! Debug: list * char = .153+0 (used reg = )
06068 187F           BB                   DC89  mov	bx,#.153
06069 1882           53                         push	bx
06070                                           ! Debug: list int = const 2 (used reg = )
06071 1883           B8                   0002  mov	ax,*2
06072 1886           50                         push	ax
06073                                           ! Debug: func () void = bios_printf+0 (used reg = )
06074 1887           E8         F18F            call	_bios_printf
06075 188A           89EC                       mov	sp,bp
06076                                           !BCC_EOS
06077                                           ! 1428   }
06078                       0000188C            .152:
06079                                           ! 1429   bios_printf(2, "\n\n");
06080                       0000188C            .14D:
06081                                           ! Debug: list * char = .154+0 (used reg = )
06082 188C           BB                   DC86  mov	bx,#.154
06083 188F           53                         push	bx
06084                                           ! Debug: list int = const 2 (used reg = )
06085 1890           B8                   0002  mov	ax,*2
06086 1893           50                         push	ax
06087                                           ! Debug: func () void = bios_printf+0 (used reg = )
06088 1894           E8         F182            call	_bios_printf
06089 1897           89EC                       mov	sp,bp
06090                                           !BCC_EOS
06091                                           ! 1430 }
06092 1899           5D                         pop	bp
06093 189A           C3                         ret
06094                                           ! 1431   void
06095                                           ! Register BX used in function print_boot_failure
06096                                           ! 1432 print_cdromboot_failure( code )
06097                                           ! 1433   Bit16u code;
06098                                           export	_print_cdromboot_failure
06099                       0000189B            _print_cdromboot_failure:
06100                                           !BCC_EOS
06101                                           ! 1434 {
06102                                           ! 1435   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
06103 189B           55                         push	bp
06104 189C           89E5                       mov	bp,sp
06105                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
06106 189E           FF76         04            push	4[bp]
06107                                           ! Debug: list * char = .155+0 (used reg = )
06108 18A1           BB                   DC66  mov	bx,#.155
06109 18A4           53                         push	bx
06110                                           ! Debug: list int = const 6 (used reg = )
06111 18A5           B8                   0006  mov	ax,*6
06112 18A8           50                         push	ax
06113                                           ! Debug: func () void = bios_printf+0 (used reg = )
06114 18A9           E8         F16D            call	_bios_printf
06115 18AC           89EC                       mov	sp,bp
06116                                           !BCC_EOS
06117                                           ! 1436   return;
06118 18AE           5D                         pop	bp
06119 18AF           C3                         ret
06120                                           !BCC_EOS
06121                                           ! 1437 }
06122                                           ! 1438 void
06123                                           ! Register BX used in function print_cdromboot_failure
06124                                           ! 1439 nmi_handler_msg()
06125                                           ! 1440 {
06126                                           export	_nmi_handler_msg
06127                       000018B0            _nmi_handler_msg:
06128                                           ! 1441   bios_printf((2 | 4 | 1), "NMI Handler called\n");
06129 18B0           55                         push	bp
06130 18B1           89E5                       mov	bp,sp
06131                                           ! Debug: list * char = .156+0 (used reg = )
06132 18B3           BB                   DC52  mov	bx,#.156
06133 18B6           53                         push	bx
06134                                           ! Debug: list int = const 7 (used reg = )
06135 18B7           B8                   0007  mov	ax,*7
06136 18BA           50                         push	ax
06137                                           ! Debug: func () void = bios_printf+0 (used reg = )
06138 18BB           E8         F15B            call	_bios_printf
06139 18BE           89EC                       mov	sp,bp
06140                                           !BCC_EOS
06141                                           ! 1442 }
06142 18C0           5D                         pop	bp
06143 18C1           C3                         ret
06144                                           ! 1443 void
06145                                           ! Register BX used in function nmi_handler_msg
06146                                           ! 1444 int18_panic_msg()
06147                                           ! 1445 {
06148                                           export	_int18_panic_msg
06149                       000018C2            _int18_panic_msg:
06150                                           ! 1446   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
06151 18C2           55                         push	bp
06152 18C3           89E5                       mov	bp,sp
06153                                           ! Debug: list * char = .157+0 (used reg = )
06154 18C5           BB                   DC3D  mov	bx,#.157
06155 18C8           53                         push	bx
06156                                           ! Debug: list int = const 7 (used reg = )
06157 18C9           B8                   0007  mov	ax,*7
06158 18CC           50                         push	ax
06159                                           ! Debug: func () void = bios_printf+0 (used reg = )
06160 18CD           E8         F149            call	_bios_printf
06161 18D0           89EC                       mov	sp,bp
06162                                           !BCC_EOS
06163                                           ! 1447 }
06164 18D2           5D                         pop	bp
06165 18D3           C3                         ret
06166                                           ! 1448 void
06167                                           ! Register BX used in function int18_panic_msg
06168                                           ! 1449 log_bios_start()
06169                                           ! 1450 {
06170                                           export	_log_bios_start
06171                       000018D4            _log_bios_start:
06172                                           ! 1451   bios_printf(4, "%s\n", bios_cvs_version_string);
06173 18D4           55                         push	bp
06174 18D5           89E5                       mov	bp,sp
06175                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
06176 18D7           BB                   0194  mov	bx,#_bios_cvs_version_string
06177 18DA           53                         push	bx
06178                                           ! Debug: list * char = .158+0 (used reg = )
06179 18DB           BB                   DC39  mov	bx,#.158
06180 18DE           53                         push	bx
06181                                           ! Debug: list int = const 4 (used reg = )
06182 18DF           B8                   0004  mov	ax,*4
06183 18E2           50                         push	ax
06184                                           ! Debug: func () void = bios_printf+0 (used reg = )
06185 18E3           E8         F133            call	_bios_printf
06186 18E6           89EC                       mov	sp,bp
06187                                           !BCC_EOS
06188                                           ! 1452 }
06189 18E8           5D                         pop	bp
06190 18E9           C3                         ret
06191                                           ! 1453   bx_bool
06192                                           ! Register BX used in function log_bios_start
06193                                           ! 1454 set_enable_a20(val)
06194                                           ! 1455   bx_bool val;
06195                                           export	_set_enable_a20
06196                       000018EA            _set_enable_a20:
06197                                           !BCC_EOS
06198                                           ! 1456 {
06199                                           ! 1457   Bit8u oldval;
06200                                           !BCC_EOS
06201                                           ! 1458   oldval = inb(0x92);
06202 18EA           55                         push	bp
06203 18EB           89E5                       mov	bp,sp
06204 18ED           4C                         dec	sp
06205 18EE           4C                         dec	sp
06206                                           ! Debug: list int = const $92 (used reg = )
06207 18EF           B8                   0092  mov	ax,#$92
06208 18F2           50                         push	ax
06209                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06210 18F3           E8         EC48            call	_inb
06211 18F6           44                         inc	sp
06212 18F7           44                         inc	sp
06213                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
06214 18F8           8846         FF            mov	-1[bp],al
06215                                           !BCC_EOS
06216                                           ! 1459   if (val)
06217 18FB           8B46         04            mov	ax,4[bp]
06218 18FE           85C0                       test	ax,ax
06219 1900           74           14            je  	.159
06220                       00001902            .15A:
06221                                           ! 1460     outb(0x92, oldval | 0x02);
06222                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06223 1902           8A46         FF            mov	al,-1[bp]
06224 1905           0C                     02  or	al,*2
06225                                           ! Debug: list unsigned char = al+0 (used reg = )
06226 1907           30E4                       xor	ah,ah
06227 1909           50                         push	ax
06228                                           ! Debug: list int = const $92 (used reg = )
06229 190A           B8                   0092  mov	ax,#$92
06230 190D           50                         push	ax
06231                                           ! Debug: func () void = outb+0 (used reg = )
06232 190E           E8         EC43            call	_outb
06233 1911           83C4                   04  add	sp,*4
06234                                           !BCC_EOS
06235                                           ! 1461   else
06236                                           ! 1462     outb(0x92, oldval & 0xfd);
06237 1914           EB           12            jmp .15B
06238                       00001916            .159:
06239                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06240 1916           8A46         FF            mov	al,-1[bp]
06241 1919           24                     FD  and	al,#$FD
06242                                           ! Debug: list unsigned char = al+0 (used reg = )
06243 191B           30E4                       xor	ah,ah
06244 191D           50                         push	ax
06245                                           ! Debug: list int = const $92 (used reg = )
06246 191E           B8                   0092  mov	ax,#$92
06247 1921           50                         push	ax
06248                                           ! Debug: func () void = outb+0 (used reg = )
06249 1922           E8         EC2F            call	_outb
06250 1925           83C4                   04  add	sp,*4
06251                                           !BCC_EOS
06252                                           ! 1463   return((oldval & 0x02) != 0);
06253                       00001928            .15B:
06254                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06255 1928           8A46         FF            mov	al,-1[bp]
06256 192B           24                     02  and	al,*2
06257                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06258 192D           84C0                       test	al,al
06259 192F           74           04            je 	.15C
06260 1931           B0                     01  mov	al,*1
06261 1933           EB           02            jmp	.15D
06262                       00001935            .15C:
06263 1935           30C0                       xor	al,al
06264                       00001937            .15D:
06265                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06266 1937           30E4                       xor	ah,ah
06267 1939           89EC                       mov	sp,bp
06268 193B           5D                         pop	bp
06269 193C           C3                         ret
06270                                           !BCC_EOS
06271                                           ! 1464 }
06272                                           ! 1465   void
06273                                           ! 1466 debugger_on()
06274                                           ! 1467 {
06275                                           export	_debugger_on
06276                       0000193D            _debugger_on:
06277                                           ! 1468   outb(0xfedc, 0x01);
06278 193D           55                         push	bp
06279 193E           89E5                       mov	bp,sp
06280                                           ! Debug: list int = const 1 (used reg = )
06281 1940           B8                   0001  mov	ax,*1
06282 1943           50                         push	ax
06283                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06284 1944           B8                   FEDC  mov	ax,#$FEDC
06285 1947           50                         push	ax
06286                                           ! Debug: func () void = outb+0 (used reg = )
06287 1948           E8         EC09            call	_outb
06288 194B           89EC                       mov	sp,bp
06289                                           !BCC_EOS
06290                                           ! 1469 }
06291 194D           5D                         pop	bp
06292 194E           C3                         ret
06293                                           ! 1470   void
06294                                           ! 1471 debugger_off()
06295                                           ! 1472 {
06296                                           export	_debugger_off
06297                       0000194F            _debugger_off:
06298                                           ! 1473   outb(0xfedc, 0x00);
06299 194F           55                         push	bp
06300 1950           89E5                       mov	bp,sp
06301                                           ! Debug: list int = const 0 (used reg = )
06302 1952           31C0                       xor	ax,ax
06303 1954           50                         push	ax
06304                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06305 1955           B8                   FEDC  mov	ax,#$FEDC
06306 1958           50                         push	ax
06307                                           ! Debug: func () void = outb+0 (used reg = )
06308 1959           E8         EBF8            call	_outb
06309 195C           89EC                       mov	sp,bp
06310                                           !BCC_EOS
06311                                           ! 1474 }
06312 195E           5D                         pop	bp
06313 195F           C3                         ret
06314                                           ! 1475 int
06315                                           ! 1476 s3_resume()
06316                                           ! 1477 {
06317                                           export	_s3_resume
06318                       00001960            _s3_resume:
06319                                           ! 1478     Bit32u s3_wakeup_vector;
06320                                           !BCC_EOS
06321                                           ! 1479     Bit8u s3_resume_flag;
06322                                           !BCC_EOS
06323                                           ! 1480     s3_resume_flag = read_byte(0x40, 0xb0);
06324 1960           55                         push	bp
06325 1961           89E5                       mov	bp,sp
06326 1963           83C4                   FA  add	sp,*-6
06327                                           ! Debug: list int = const $B0 (used reg = )
06328 1966           B8                   00B0  mov	ax,#$B0
06329 1969           50                         push	ax
06330                                           ! Debug: list int = const $40 (used reg = )
06331 196A           B8                   0040  mov	ax,*$40
06332 196D           50                         push	ax
06333                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
06334 196E           E8         EC83            call	_read_byte
06335 1971           83C4                   04  add	sp,*4
06336                                           ! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06337 1974           8846         FB            mov	-5[bp],al
06338                                           !BCC_EOS
06339                                           ! 1481     s3_wakeup_vector = get_s3_waking_vector();
06340                                           ! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
06341 1977           E8         9AF1            call	_get_s3_waking_vector
06342 197A           89D3                       mov	bx,dx
06343                                           ! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06344 197C           8946         FC            mov	-4[bp],ax
06345 197F           895E         FE            mov	-2[bp],bx
06346                                           !BCC_EOS
06347                                           ! 1482     bios_printf(4, "S3 resume called %x 0x%lx\n", s3_resume_flag, s3_wakeup_vector);
06348                                           ! Debug: list unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06349 1982           FF76         FE            push	-2[bp]
06350 1985           FF76         FC            push	-4[bp]
06351                                           ! Debug: list unsigned char s3_resume_flag = [S+$C-7] (used reg = )
06352 1988           8A46         FB            mov	al,-5[bp]
06353 198B           30E4                       xor	ah,ah
06354 198D           50                         push	ax
06355                                           ! Debug: list * char = .15E+0 (used reg = )
06356 198E           BB                   DC1E  mov	bx,#.15E
06357 1991           53                         push	bx
06358                                           ! Debug: list int = const 4 (used reg = )
06359 1992           B8                   0004  mov	ax,*4
06360 1995           50                         push	ax
06361                                           ! Debug: func () void = bios_printf+0 (used reg = )
06362 1996           E8         F080            call	_bios_printf
06363 1999           83C4                   0A  add	sp,*$A
06364                                           !BCC_EOS
06365                                           ! 1483     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06366                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06367 199C           8A46         FB            mov	al,-5[bp]
06368 199F           3C                     FE  cmp	al,#$FE
06369 19A1           75           0B            jne 	.160
06370                       000019A3            .161:
06371 19A3           8B46         FC            mov	ax,-4[bp]
06372 19A6           8B5E         FE            mov	bx,-2[bp]
06373 19A9           E8         E768            call	ltstl
06374 19AC           75           06            jne 	.15F
06375                       000019AE            .160:
06376                                           ! 1484      return 0;
06377 19AE           31C0                       xor	ax,ax
06378 19B0           89EC                       mov	sp,bp
06379 19B2           5D                         pop	bp
06380 19B3           C3                         ret
06381                                           !BCC_EOS
06382                                           ! 1485     write_byte(0x40, 0xb0, 0);
06383                       000019B4            .15F:
06384                                           ! Debug: list int = const 0 (used reg = )
06385 19B4           31C0                       xor	ax,ax
06386 19B6           50                         push	ax
06387                                           ! Debug: list int = const $B0 (used reg = )
06388 19B7           B8                   00B0  mov	ax,#$B0
06389 19BA           50                         push	ax
06390                                           ! Debug: list int = const $40 (used reg = )
06391 19BB           B8                   0040  mov	ax,*$40
06392 19BE           50                         push	ax
06393                                           ! Debug: func () void = write_byte+0 (used reg = )
06394 19BF           E8         EC58            call	_write_byte
06395 19C2           83C4                   06  add	sp,*6
06396                                           !BCC_EOS
06397                                           ! 1486     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
06398                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06399                                           ! Debug: expression subtree swapping
06400 19C5           B8                   000F  mov	ax,*$F
06401 19C8           31DB                       xor	bx,bx
06402 19CA           8D7E         FC            lea	di,-4[bp]
06403 19CD           E8         E6EB            call	landul
06404                                           ! Debug: list unsigned long = bx+0 (used reg = )
06405 19D0           53                         push	bx
06406 19D1           50                         push	ax
06407                                           ! Debug: list int = const $B6 (used reg = )
06408 19D2           B8                   00B6  mov	ax,#$B6
06409 19D5           50                         push	ax
06410                                           ! Debug: list int = const $40 (used reg = )
06411 19D6           B8                   0040  mov	ax,*$40
06412 19D9           50                         push	ax
06413                                           ! Debug: func () void = write_word+0 (used reg = )
06414 19DA           E8         EC55            call	_write_word
06415 19DD           83C4                   08  add	sp,*8
06416                                           !BCC_EOS
06417                                           ! 1487     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
06418                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06419 19E0           8B46         FC            mov	ax,-4[bp]
06420 19E3           8B5E         FE            mov	bx,-2[bp]
06421 19E6           BF                   0004  mov	di,*4
06422 19E9           E8         E73D            call	lsrul
06423                                           ! Debug: list unsigned long = bx+0 (used reg = )
06424 19EC           53                         push	bx
06425 19ED           50                         push	ax
06426                                           ! Debug: list int = const $B8 (used reg = )
06427 19EE           B8                   00B8  mov	ax,#$B8
06428 19F1           50                         push	ax
06429                                           ! Debug: list int = const $40 (used reg = )
06430 19F2           B8                   0040  mov	ax,*$40
06431 19F5           50                         push	ax
06432                                           ! Debug: func () void = write_word+0 (used reg = )
06433 19F6           E8         EC39            call	_write_word
06434 19F9           83C4                   08  add	sp,*8
06435                                           !BCC_EOS
06436                                           ! 1488     bios_printf(4, "S3 resume jump to %x:%x\n", (s3_wakeup_vector >> 4), (s3_wakeup_vector & 0xF));
06437                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06438                                           ! Debug: expression subtree swapping
06439 19FC           B8                   000F  mov	ax,*$F
06440 19FF           31DB                       xor	bx,bx
06441 1A01           8D7E         FC            lea	di,-4[bp]
06442 1A04           E8         E6B4            call	landul
06443                                           ! Debug: list unsigned long = bx+0 (used reg = )
06444 1A07           53                         push	bx
06445 1A08           50                         push	ax
06446                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
06447 1A09           8B46         FC            mov	ax,-4[bp]
06448 1A0C           8B5E         FE            mov	bx,-2[bp]
06449 1A0F           BF                   0004  mov	di,*4
06450 1A12           E8         E714            call	lsrul
06451                                           ! Debug: list unsigned long = bx+0 (used reg = )
06452 1A15           53                         push	bx
06453 1A16           50                         push	ax
06454                                           ! Debug: list * char = .162+0 (used reg = )
06455 1A17           BB                   DC05  mov	bx,#.162
06456 1A1A           53                         push	bx
06457                                           ! Debug: list int = const 4 (used reg = )
06458 1A1B           B8                   0004  mov	ax,*4
06459 1A1E           50                         push	ax
06460                                           ! Debug: func () void = bios_printf+0 (used reg = )
06461 1A1F           E8         EFF7            call	_bios_printf
06462 1A22           83C4                   0C  add	sp,*$C
06463                                           !BCC_EOS
06464                                           ! 1489 #asm
06465                                           !BCC_EOS
06466                                           !BCC_ASM
06467                       00000001            _s3_resume.s3_resume_flag	set	1
06468                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06469                       00000002            _s3_resume.s3_wakeup_vector	set	2
06470                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06471 1A25           FF2E       04B6                jmpf [0x04b6]
06472                                           ! 1491 endasm
06473                                           !BCC_ENDASM
06474                                           !BCC_EOS
06475                                           ! 1492     return 1;
06476 1A29           B8                   0001  mov	ax,*1
06477 1A2C           89EC                       mov	sp,bp
06478 1A2E           5D                         pop	bp
06479 1A2F           C3                         ret
06480                                           !BCC_EOS
06481                                           ! 1493 }
06482                                           ! 1494 void ata_init( )
06483                                           ! Register BX used in function s3_resume
06484                                           ! 1495 {
06485                                           export	_ata_init
06486                       00001A30            _ata_init:
06487                                           ! 1496   Bit16u ebda_seg=read_word(0x0040,0x000E);
06488 1A30           55                         push	bp
06489 1A31           89E5                       mov	bp,sp
06490 1A33           4C                         dec	sp
06491 1A34           4C                         dec	sp
06492                                           ! Debug: list int = const $E (used reg = )
06493 1A35           B8                   000E  mov	ax,*$E
06494 1A38           50                         push	ax
06495                                           ! Debug: list int = const $40 (used reg = )
06496 1A39           B8                   0040  mov	ax,*$40
06497 1A3C           50                         push	ax
06498                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06499 1A3D           E8         EBC7            call	_read_word
06500 1A40           83C4                   04  add	sp,*4
06501                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
06502 1A43           8946         FE            mov	-2[bp],ax
06503                                           !BCC_EOS
06504                                           ! 1497   Bit8u channel, device;
06505                                           !BCC_EOS
06506                                           ! 1498   for (channel=0; channel<4; channel++) {
06507 1A46           4C                         dec	sp
06508 1A47           4C                         dec	sp
06509                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
06510 1A48           30C0                       xor	al,al
06511 1A4A           8846         FD            mov	-3[bp],al
06512                                           !BCC_EOS
06513                                           !BCC_EOS
06514 1A4D           E9         0077            br 	.165
06515                       00001A50            .166:
06516                                           ! 1499     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
06517                                           ! Debug: list int = const 0 (used reg = )
06518 1A50           31C0                       xor	ax,ax
06519 1A52           50                         push	ax
06520                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06521 1A53           8A46         FD            mov	al,-3[bp]
06522 1A56           30E4                       xor	ah,ah
06523 1A58           B1                     03  mov	cl,*3
06524 1A5A           D3E0                       shl	ax,cl
06525 1A5C           89C3                       mov	bx,ax
06526                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06527                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
06528 1A5E           81C3                 0122  add	bx,#$122
06529 1A62           53                         push	bx
06530                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06531 1A63           FF76         FE            push	-2[bp]
06532                                           ! Debug: func () void = write_byte+0 (used reg = )
06533 1A66           E8         EBB1            call	_write_byte
06534 1A69           83C4                   06  add	sp,*6
06535                                           !BCC_EOS
06536                                           ! 1500     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
06537                                           ! Debug: list int = const 0 (used reg = )
06538 1A6C           31C0                       xor	ax,ax
06539 1A6E           50                         push	ax
06540                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06541 1A6F           8A46         FD            mov	al,-3[bp]
06542 1A72           30E4                       xor	ah,ah
06543 1A74           B1                     03  mov	cl,*3
06544 1A76           D3E0                       shl	ax,cl
06545 1A78           89C3                       mov	bx,ax
06546                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06547                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
06548 1A7A           81C3                 0124  add	bx,#$124
06549 1A7E           53                         push	bx
06550                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06551 1A7F           FF76         FE            push	-2[bp]
06552                                           ! Debug: func () void = write_word+0 (used reg = )
06553 1A82           E8         EBAD            call	_write_word
06554 1A85           83C4                   06  add	sp,*6
06555                                           !BCC_EOS
06556                                           ! 1501     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
06557                                           ! Debug: list int = const 0 (used reg = )
06558 1A88           31C0                       xor	ax,ax
06559 1A8A           50                         push	ax
06560                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06561 1A8B           8A46         FD            mov	al,-3[bp]
06562 1A8E           30E4                       xor	ah,ah
06563 1A90           B1                     03  mov	cl,*3
06564 1A92           D3E0                       shl	ax,cl
06565 1A94           89C3                       mov	bx,ax
06566                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06567                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
06568 1A96           81C3                 0126  add	bx,#$126
06569 1A9A           53                         push	bx
06570                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06571 1A9B           FF76         FE            push	-2[bp]
06572                                           ! Debug: func () void = write_word+0 (used reg = )
06573 1A9E           E8         EB91            call	_write_word
06574 1AA1           83C4                   06  add	sp,*6
06575                                           !BCC_EOS
06576                                           ! 1502     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
06577                                           ! Debug: list int = const 0 (used reg = )
06578 1AA4           31C0                       xor	ax,ax
06579 1AA6           50                         push	ax
06580                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06581 1AA7           8A46         FD            mov	al,-3[bp]
06582 1AAA           30E4                       xor	ah,ah
06583 1AAC           B1                     03  mov	cl,*3
06584 1AAE           D3E0                       shl	ax,cl
06585 1AB0           89C3                       mov	bx,ax
06586                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06587                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
06588 1AB2           81C3                 0128  add	bx,#$128
06589 1AB6           53                         push	bx
06590                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06591 1AB7           FF76         FE            push	-2[bp]
06592                                           ! Debug: func () void = write_byte+0 (used reg = )
06593 1ABA           E8         EB5D            call	_write_byte
06594 1ABD           83C4                   06  add	sp,*6
06595                                           !BCC_EOS
06596                                           ! 1503     }
06597                                           ! 1504   for (device=0; device<(4*2); device++) {
06598                       00001AC0            .164:
06599                                           ! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
06600 1AC0           8A46         FD            mov	al,-3[bp]
06601 1AC3           40                         inc	ax
06602 1AC4           8846         FD            mov	-3[bp],al
06603                       00001AC7            .165:
06604                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
06605 1AC7           8A46         FD            mov	al,-3[bp]
06606 1ACA           3C                     04  cmp	al,*4
06607 1ACC           72           82            jb 	.166
06608                       00001ACE            .167:
06609                       00001ACE            .163:
06610                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06611 1ACE           30C0                       xor	al,al
06612 1AD0           8846         FC            mov	-4[bp],al
06613                                           !BCC_EOS
06614                                           !BCC_EOS
06615 1AD3           E9         01C0            br 	.16A
06616                       00001AD6            .16B:
06617                                           ! 1505     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
06618                                           ! Debug: list int = const 0 (used reg = )
06619 1AD6           31C0                       xor	ax,ax
06620 1AD8           50                         push	ax
06621                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06622 1AD9           8A46         FC            mov	al,-4[bp]
06623 1ADC           30E4                       xor	ah,ah
06624 1ADE           B9                   001E  mov	cx,*$1E
06625 1AE1           F7E9                       imul	cx
06626 1AE3           89C3                       mov	bx,ax
06627                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06628                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06629 1AE5           81C3                 0142  add	bx,#$142
06630 1AE9           53                         push	bx
06631                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06632 1AEA           FF76         FE            push	-2[bp]
06633                                           ! Debug: func () void = write_byte+0 (used reg = )
06634 1AED           E8         EB2A            call	_write_byte
06635 1AF0           83C4                   06  add	sp,*6
06636                                           !BCC_EOS
06637                                           ! 1506     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
06638                                           ! Debug: list int = const 0 (used reg = )
06639 1AF3           31C0                       xor	ax,ax
06640 1AF5           50                         push	ax
06641                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06642 1AF6           8A46         FC            mov	al,-4[bp]
06643 1AF9           30E4                       xor	ah,ah
06644 1AFB           B9                   001E  mov	cx,*$1E
06645 1AFE           F7E9                       imul	cx
06646 1B00           89C3                       mov	bx,ax
06647                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06648                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
06649 1B02           81C3                 0143  add	bx,#$143
06650 1B06           53                         push	bx
06651                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06652 1B07           FF76         FE            push	-2[bp]
06653                                           ! Debug: func () void = write_byte+0 (used reg = )
06654 1B0A           E8         EB0D            call	_write_byte
06655 1B0D           83C4                   06  add	sp,*6
06656                                           !BCC_EOS
06657                                           ! 1507     w
06658                                           ! 1507 rite_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
06659                                           ! Debug: list int = const 0 (used reg = )
06660 1B10           31C0                       xor	ax,ax
06661 1B12           50                         push	ax
06662                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06663 1B13           8A46         FC            mov	al,-4[bp]
06664 1B16           30E4                       xor	ah,ah
06665 1B18           B9                   001E  mov	cx,*$1E
06666 1B1B           F7E9                       imul	cx
06667 1B1D           89C3                       mov	bx,ax
06668                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06669                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
06670 1B1F           81C3                 0144  add	bx,#$144
06671 1B23           53                         push	bx
06672                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06673 1B24           FF76         FE            push	-2[bp]
06674                                           ! Debug: func () void = write_byte+0 (used reg = )
06675 1B27           E8         EAF0            call	_write_byte
06676 1B2A           83C4                   06  add	sp,*6
06677                                           !BCC_EOS
06678                                           ! 1508     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
06679                                           ! Debug: list int = const 0 (used reg = )
06680 1B2D           31C0                       xor	ax,ax
06681 1B2F           50                         push	ax
06682                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06683 1B30           8A46         FC            mov	al,-4[bp]
06684 1B33           30E4                       xor	ah,ah
06685 1B35           B9                   001E  mov	cx,*$1E
06686 1B38           F7E9                       imul	cx
06687 1B3A           89C3                       mov	bx,ax
06688                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06689                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
06690 1B3C           81C3                 0145  add	bx,#$145
06691 1B40           53                         push	bx
06692                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06693 1B41           FF76         FE            push	-2[bp]
06694                                           ! Debug: func () void = write_byte+0 (used reg = )
06695 1B44           E8         EAD3            call	_write_byte
06696 1B47           83C4                   06  add	sp,*6
06697                                           !BCC_EOS
06698                                           ! 1509     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
06699                                           ! Debug: list int = const 0 (used reg = )
06700 1B4A           31C0                       xor	ax,ax
06701 1B4C           50                         push	ax
06702                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06703 1B4D           8A46         FC            mov	al,-4[bp]
06704 1B50           30E4                       xor	ah,ah
06705 1B52           B9                   001E  mov	cx,*$1E
06706 1B55           F7E9                       imul	cx
06707 1B57           89C3                       mov	bx,ax
06708                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06709                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
06710 1B59           81C3                 0146  add	bx,#$146
06711 1B5D           53                         push	bx
06712                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06713 1B5E           FF76         FE            push	-2[bp]
06714                                           ! Debug: func () void = write_byte+0 (used reg = )
06715 1B61           E8         EAB6            call	_write_byte
06716 1B64           83C4                   06  add	sp,*6
06717                                           !BCC_EOS
06718                                           ! 1510     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
06719                                           ! Debug: list int = const 0 (used reg = )
06720 1B67           31C0                       xor	ax,ax
06721 1B69           50                         push	ax
06722                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06723 1B6A           8A46         FC            mov	al,-4[bp]
06724 1B6D           30E4                       xor	ah,ah
06725 1B6F           B9                   001E  mov	cx,*$1E
06726 1B72           F7E9                       imul	cx
06727 1B74           89C3                       mov	bx,ax
06728                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06729                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
06730 1B76           81C3                 0148  add	bx,#$148
06731 1B7A           53                         push	bx
06732                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06733 1B7B           FF76         FE            push	-2[bp]
06734                                           ! Debug: func () void = write_word+0 (used reg = )
06735 1B7E           E8         EAB1            call	_write_word
06736 1B81           83C4                   06  add	sp,*6
06737                                           !BCC_EOS
06738                                           ! 1511     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
06739                                           ! Debug: list int = const 0 (used reg = )
06740 1B84           31C0                       xor	ax,ax
06741 1B86           50                         push	ax
06742                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06743 1B87           8A46         FC            mov	al,-4[bp]
06744 1B8A           30E4                       xor	ah,ah
06745 1B8C           B9                   001E  mov	cx,*$1E
06746 1B8F           F7E9                       imul	cx
06747 1B91           89C3                       mov	bx,ax
06748                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06749                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
06750 1B93           81C3                 014A  add	bx,#$14A
06751 1B97           53                         push	bx
06752                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06753 1B98           FF76         FE            push	-2[bp]
06754                                           ! Debug: func () void = write_byte+0 (used reg = )
06755 1B9B           E8         EA7C            call	_write_byte
06756 1B9E           83C4                   06  add	sp,*6
06757                                           !BCC_EOS
06758                                           ! 1512     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
06759                                           ! Debug: list int = const 0 (used reg = )
06760 1BA1           31C0                       xor	ax,ax
06761 1BA3           50                         push	ax
06762                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06763 1BA4           8A46         FC            mov	al,-4[bp]
06764 1BA7           30E4                       xor	ah,ah
06765 1BA9           B9                   001E  mov	cx,*$1E
06766 1BAC           F7E9                       imul	cx
06767 1BAE           89C3                       mov	bx,ax
06768                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06769                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
06770 1BB0           81C3                 014C  add	bx,#$14C
06771 1BB4           53                         push	bx
06772                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06773 1BB5           FF76         FE            push	-2[bp]
06774                                           ! Debug: func () void = write_word+0 (used reg = )
06775 1BB8           E8         EA77            call	_write_word
06776 1BBB           83C4                   06  add	sp,*6
06777                                           !BCC_EOS
06778                                           ! 1513     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
06779                                           ! Debug: list int = const 0 (used reg = )
06780 1BBE           31C0                       xor	ax,ax
06781 1BC0           50                         push	ax
06782                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06783 1BC1           8A46         FC            mov	al,-4[bp]
06784 1BC4           30E4                       xor	ah,ah
06785 1BC6           B9                   001E  mov	cx,*$1E
06786 1BC9           F7E9                       imul	cx
06787 1BCB           89C3                       mov	bx,ax
06788                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06789                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
06790 1BCD           81C3                 014E  add	bx,#$14E
06791 1BD1           53                         push	bx
06792                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06793 1BD2           FF76         FE            push	-2[bp]
06794                                           ! Debug: func () void = write_word+0 (used reg = )
06795 1BD5           E8         EA5A            call	_write_word
06796 1BD8           83C4                   06  add	sp,*6
06797                                           !BCC_EOS
06798                                           ! 1514     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
06799                                           ! Debug: list int = const 0 (used reg = )
06800 1BDB           31C0                       xor	ax,ax
06801 1BDD           50                         push	ax
06802                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06803 1BDE           8A46         FC            mov	al,-4[bp]
06804 1BE1           30E4                       xor	ah,ah
06805 1BE3           B9                   001E  mov	cx,*$1E
06806 1BE6           F7E9                       imul	cx
06807 1BE8           89C3                       mov	bx,ax
06808                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06809                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
06810 1BEA           81C3                 0150  add	bx,#$150
06811 1BEE           53                         push	bx
06812                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06813 1BEF           FF76         FE            push	-2[bp]
06814                                           ! Debug: func () void = write_word+0 (used reg = )
06815 1BF2           E8         EA3D            call	_write_word
06816 1BF5           83C4                   06  add	sp,*6
06817                                           !BCC_EOS
06818                                           ! 1515     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
06819                                           ! Debug: list int = const 0 (used reg = )
06820 1BF8           31C0                       xor	ax,ax
06821 1BFA           50                         push	ax
06822                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06823 1BFB           8A46         FC            mov	al,-4[bp]
06824 1BFE           30E4                       xor	ah,ah
06825 1C00           B9                   001E  mov	cx,*$1E
06826 1C03           F7E9                       imul	cx
06827 1C05           89C3                       mov	bx,ax
06828                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06829                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
06830 1C07           81C3                 0152  add	bx,#$152
06831 1C0B           53                         push	bx
06832                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06833 1C0C           FF76         FE            push	-2[bp]
06834                                           ! Debug: func () void = write_word+0 (used reg = )
06835 1C0F           E8         EA20            call	_write_word
06836 1C12           83C4                   06  add	sp,*6
06837                                           !BCC_EOS
06838                                           ! 1516     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
06839                                           ! Debug: list int = const 0 (used reg = )
06840 1C15           31C0                       xor	ax,ax
06841 1C17           50                         push	ax
06842                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06843 1C18           8A46         FC            mov	al,-4[bp]
06844 1C1B           30E4                       xor	ah,ah
06845 1C1D           B9                   001E  mov	cx,*$1E
06846 1C20           F7E9                       imul	cx
06847 1C22           89C3                       mov	bx,ax
06848                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06849                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
06850 1C24           81C3                 0154  add	bx,#$154
06851 1C28           53                         push	bx
06852                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06853 1C29           FF76         FE            push	-2[bp]
06854                                           ! Debug: func () void = write_word+0 (used reg = )
06855 1C2C           E8         EA03            call	_write_word
06856 1C2F           83C4                   06  add	sp,*6
06857                                           !BCC_EOS
06858                                           ! 1517     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
06859                                           ! Debug: list int = const 0 (used reg = )
06860 1C32           31C0                       xor	ax,ax
06861 1C34           50                         push	ax
06862                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06863 1C35           8A46         FC            mov	al,-4[bp]
06864 1C38           30E4                       xor	ah,ah
06865 1C3A           B9                   001E  mov	cx,*$1E
06866 1C3D           F7E9                       imul	cx
06867 1C3F           89C3                       mov	bx,ax
06868                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06869                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
06870 1C41           81C3                 0156  add	bx,#$156
06871 1C45           53                         push	bx
06872                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06873 1C46           FF76         FE            push	-2[bp]
06874                                           ! Debug: func () void = write_word+0 (used reg = )
06875 1C49           E8         E9E6            call	_write_word
06876 1C4C           83C4                   06  add	sp,*6
06877                                           !BCC_EOS
06878                                           ! 1518     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
06879                                           ! Debug: list long = const 0 (used reg = )
06880 1C4F           31C0                       xor	ax,ax
06881 1C51           31DB                       xor	bx,bx
06882 1C53           53                         push	bx
06883 1C54           50                         push	ax
06884                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06885 1C55           8A46         FC            mov	al,-4[bp]
06886 1C58           30E4                       xor	ah,ah
06887 1C5A           B9                   001E  mov	cx,*$1E
06888 1C5D           F7E9                       imul	cx
06889 1C5F           89C3                       mov	bx,ax
06890                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06891                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
06892 1C61           81C3                 0158  add	bx,#$158
06893 1C65           53                         push	bx
06894                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06895 1C66           FF76         FE            push	-2[bp]
06896                                           ! Debug: func () void = write_dword+0 (used reg = )
06897 1C69           E8         E42F            call	_write_dword
06898 1C6C           83C4                   08  add	sp,*8
06899                                           !BCC_EOS
06900                                           ! 1519     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
06901                                           ! Debug: list long = const 0 (used reg = )
06902 1C6F           31C0                       xor	ax,ax
06903 1C71           31DB                       xor	bx,bx
06904 1C73           53                         push	bx
06905 1C74           50                         push	ax
06906                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06907 1C75           8A46         FC            mov	al,-4[bp]
06908 1C78           30E4                       xor	ah,ah
06909 1C7A           B9                   001E  mov	cx,*$1E
06910 1C7D           F7E9                       imul	cx
06911 1C7F           89C3                       mov	bx,ax
06912                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06913                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
06914 1C81           81C3                 015C  add	bx,#$15C
06915 1C85           53                         push	bx
06916                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06917 1C86           FF76         FE            push	-2[bp]
06918                                           ! Debug: func () void = write_dword+0 (used reg = )
06919 1C89           E8         E40F            call	_write_dword
06920 1C8C           83C4                   08  add	sp,*8
06921                                           !BCC_EOS
06922                                           ! 1520     }
06923                                           ! 1521   for (device=0; device<(4*2); device++) {
06924                       00001C8F            .169:
06925                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06926 1C8F           8A46         FC            mov	al,-4[bp]
06927 1C92           40                         inc	ax
06928 1C93           8846         FC            mov	-4[bp],al
06929                       00001C96            .16A:
06930                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06931 1C96           8A46         FC            mov	al,-4[bp]
06932 1C99           3C                     08  cmp	al,*8
06933 1C9B         0F82         FE37            blo 	.16B
06934                       00001C9F            .16C:
06935                       00001C9F            .168:
06936                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06937 1C9F           30C0                       xor	al,al
06938 1CA1           8846         FC            mov	-4[bp],al
06939                                           !BCC_EOS
06940                                           !BCC_EOS
06941 1CA4           EB           39            jmp .16F
06942                       00001CA6            .170:
06943                                           ! 1522     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
06944                                           ! Debug: list int = const 8 (used reg = )
06945 1CA6           B8                   0008  mov	ax,*8
06946 1CA9           50                         push	ax
06947                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
06948 1CAA           8A46         FC            mov	al,-4[bp]
06949 1CAD           30E4                       xor	ah,ah
06950 1CAF           89C3                       mov	bx,ax
06951                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06952                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
06953 1CB1           81C3                 0233  add	bx,#$233
06954 1CB5           53                         push	bx
06955                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06956 1CB6           FF76         FE            push	-2[bp]
06957                                           ! Debug: func () void = write_byte+0 (used reg = )
06958 1CB9           E8         E95E            call	_write_byte
06959 1CBC           83C4                   06  add	sp,*6
06960                                           !BCC_EOS
06961                                           ! 1523     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
06962                                           ! Debug: list int = const 8 (used reg = )
06963 1CBF           B8                   0008  mov	ax,*8
06964 1CC2           50                         push	ax
06965                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
06966 1CC3           8A46         FC            mov	al,-4[bp]
06967 1CC6           30E4                       xor	ah,ah
06968 1CC8           89C3                       mov	bx,ax
06969                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06970                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
06971 1CCA           81C3                 023C  add	bx,#$23C
06972 1CCE           53                         push	bx
06973                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06974 1CCF           FF76         FE            push	-2[bp]
06975                                           ! Debug: func () void = write_byte+0 (used reg = )
06976 1CD2           E8         E945            call	_write_byte
06977 1CD5           83C4                   06  add	sp,*6
06978                                           !BCC_EOS
06979                                           ! 1524     }
06980                                           ! 1525   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
06981                       00001CD8            .16E:
06982                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06983 1CD8           8A46         FC            mov	al,-4[bp]
06984 1CDB           40                         inc	ax
06985 1CDC           8846         FC            mov	-4[bp],al
06986                       00001CDF            .16F:
06987                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06988 1CDF           8A46         FC            mov	al,-4[bp]
06989 1CE2           3C                     08  cmp	al,*8
06990 1CE4           72           C0            jb 	.170
06991                       00001CE6            .171:
06992                       00001CE6            .16D:
06993                                           ! Debug: list int = const 0 (used reg = )
06994 1CE6           31C0                       xor	ax,ax
06995 1CE8           50                         push	ax
06996                                           ! Debug: list * unsigned char = const $232 (used reg = )
06997 1CE9           B8                   0232  mov	ax,#$232
06998 1CEC           50                         push	ax
06999                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
07000 1CED           FF76         FE            push	-2[bp]
07001                                           ! Debug: func () void = write_byte+0 (used reg = )
07002 1CF0           E8         E927            call	_write_byte
07003 1CF3           83C4                   06  add	sp,*6
07004                                           !BCC_EOS
07005                                           ! 1526   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
07006                                           ! Debug: list int = const 0 (used reg = )
07007 1CF6           31C0                       xor	ax,ax
07008 1CF8           50                         push	ax
07009                                           ! Debug: list * unsigned char = const $23B (used reg = )
07010 1CF9           B8                   023B  mov	ax,#$23B
07011 1CFC           50                         push	ax
07012                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
07013 1CFD           FF76         FE            push	-2[bp]
07014                                           ! Debug: func () void = write_byte+0 (used reg = )
07015 1D00           E8         E917            call	_write_byte
07016 1D03           83C4                   06  add	sp,*6
07017                                           !BCC_EOS
07018                                           ! 1527 }
07019 1D06           89EC                       mov	sp,bp
07020 1D08           5D                         pop	bp
07021 1D09           C3                         ret
07022                                           ! 1528 int await_ide();
07023                                           ! Register BX used in function ata_init
07024                                           !BCC_EOS
07025                                           ! 1529 static int await_ide(when_done,base,timeout)
07026                                           ! 1530   Bit8u when_done;
07027                       00001D0A            _await_ide:
07028                                           !BCC_EOS
07029                                           ! 1531   Bit16u base;
07030                                           !BCC_EOS
07031                                           ! 1532   Bit16u timeout;
07032                                           !BCC_EOS
07033                                           ! 1533 {
07034                                           ! 1534   Bit32u time=0,last=0;
07035 1D0A           55                         push	bp
07036 1D0B           89E5                       mov	bp,sp
07037 1D0D           83C4                   FC  add	sp,*-4
07038                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
07039 1D10           31C0                       xor	ax,ax
07040 1D12           31DB                       xor	bx,bx
07041 1D14           8946         FC            mov	-4[bp],ax
07042 1D17           895E         FE            mov	-2[bp],bx
07043 1D1A           83C4                   FC  add	sp,*-4
07044                                           ! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
07045 1D1D           31C0                       xor	ax,ax
07046 1D1F           31DB                       xor	bx,bx
07047 1D21           8946         F8            mov	-8[bp],ax
07048 1D24           895E         FA            mov	-6[bp],bx
07049                                           !BCC_EOS
07050                                           ! 1535   Bit16u status;
07051                                           !BCC_EOS
07052                                           ! 1536   Bit8u result;
07053                                           !BCC_EOS
07054                                           ! 1537   status = inb(base + 7);
07055 1D27           83C4                   FC  add	sp,*-4
07056                                           ! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
07057 1D2A           8B46         06            mov	ax,6[bp]
07058                                           ! Debug: list unsigned int = ax+7 (used reg = )
07059 1D2D           05                   0007  add	ax,*7
07060 1D30           50                         push	ax
07061                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07062 1D31           E8         E80A            call	_inb
07063 1D34           44                         inc	sp
07064 1D35           44                         inc	sp
07065                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
07066 1D36           30E4                       xor	ah,ah
07067 1D38           8946         F6            mov	-$A[bp],ax
07068                                           !BCC_EOS
07069                                           ! 1538   for(;;) {
07070                                           !BCC_EOS
07071                                           !BCC_EOS
07072                       00001D3B            .174:
07073                                           ! 1539     status = inb(base+7);
07074                                           ! Debug: add int = const 7 to unsigned short base = [S+$E+4] (used reg = )
07075 1D3B           8B46         06            mov	ax,6[bp]
07076                                           ! Debug: list unsigned int = ax+7 (used reg = )
07077 1D3E           05                   0007  add	ax,*7
07078 1D41           50                         push	ax
07079                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07080 1D42           E8         E7F9            call	_inb
07081 1D45           44                         inc	sp
07082 1D46           44                         inc	sp
07083                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$E-$C] (used reg = )
07084 1D47           30E4                       xor	ah,ah
07085 1D49           8946         F6            mov	-$A[bp],ax
07086                                           !BCC_EOS
07087                                           ! 1540     time++;
07088                                           ! Debug: postinc unsigned long time = [S+$E-6] (used reg = )
07089 1D4C           8B46         FC            mov	ax,-4[bp]
07090 1D4F           8B76         FE            mov	si,-2[bp]
07091 1D52           8D5E         FC            lea	bx,-4[bp]
07092 1D55           E8         E3B7            call	lincl
07093                                           !BCC_EOS
07094                                           ! 1541     if (when_done == 1)
07095                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$E+2] (used reg = )
07096 1D58           8A46         04            mov	al,4[bp]
07097 1D5B           3C                     01  cmp	al,*1
07098 1D5D           75           0B            jne 	.175
07099                       00001D5F            .176:
07100                                           ! 1542       result = status & 0x80;
07101                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
07102 1D5F           8A46         F6            mov	al,-$A[bp]
07103 1D62           24                     80  and	al,#$80
07104                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
07105 1D64           8846         F5            mov	-$B[bp],al
07106                                           !BCC_EOS
07107                                           ! 1543     else if (when_done == 2)
07108 1D67           E9         0094            br 	.177
07109                       00001D6A            .175:
07110                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$E+2] (used reg = )
07111 1D6A           8A46         04            mov	al,4[bp]
07112 1D6D           3C                     02  cmp	al,*2
07113 1D6F           75           15            jne 	.178
07114                       00001D71            .179:
07115                                           ! 1544       result = !(status & 0x80);
07116                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
07117 1D71           8A46         F6            mov	al,-$A[bp]
07118 1D74           24                     80  and	al,#$80
07119 1D76           84C0                       test	al,al
07120 1D78           75           04            jne 	.17A
07121                       00001D7A            .17B:
07122 1D7A           B0                     01  mov	al,*1
07123 1D7C           EB           02            jmp	.17C
07124                       00001D7E            .17A:
07125 1D7E           30C0                       xor	al,al
07126                       00001D80            .17C:
07127                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
07128 1D80           8846         F5            mov	-$B[bp],al
07129                                           !BCC_EOS
07130                                           ! 1545     else if (when_done == 3)
07131 1D83           E9         0078            br 	.17D
07132                       00001D86            .178:
07133                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$E+2] (used reg = )
07134 1D86           8A46         04            mov	al,4[bp]
07135 1D89           3C                     03  cmp	al,*3
07136 1D8B           75           1D            jne 	.17E
07137                       00001D8D            .17F:
07138                                           ! 1546       result = !(status & 0x80) && (status & 0x08);
07139                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
07140 1D8D           8A46         F6            mov	al,-$A[bp]
07141 1D90           24                     80  and	al,#$80
07142 1D92           84C0                       test	al,al
07143 1D94           75           0D            jne 	.180
07144                       00001D96            .182:
07145                                           ! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
07146 1D96           8A46         F6            mov	al,-$A[bp]
07147 1D99           24                     08  and	al,*8
07148 1D9B           84C0                       test	al,al
07149 1D9D           74           04            je  	.180
07150                       00001D9F            .181:
07151 1D9F           B0                     01  mov	al,*1
07152 1DA1           EB           02            jmp	.183
07153                       00001DA3            .180:
07154 1DA3           30C0                       xor	al,al
07155                       00001DA5            .183:
07156                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
07157 1DA5           8846         F5            mov	-$B[bp],al
07158                                           !BCC_EOS
07159                                           ! 1547     else if (when_done == 4)
07160 1DA8           EB           54            jmp .184
07161                       00001DAA            .17E:
07162                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$E+2] (used reg = )
07163 1DAA           8A46         04            mov	al,4[bp]
07164 1DAD           3C                     04  cmp	al,*4
07165 1DAF           75           1D            jne 	.185
07166                       00001DB1            .186:
07167                                           ! 1548       result = !(status & 0x80) && !(status & 0x08);
07168                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
07169 1DB1           8A46         F6            mov	al,-$A[bp]
07170 1DB4           24                     80  and	al,#$80
07171 1DB6           84C0                       test	al,al
07172 1DB8           75           0D            jne 	.187
07173                       00001DBA            .189:
07174                                           ! Debug: and int = const 8 to unsigned short status = [S+$E-$C] (used reg = )
07175 1DBA           8A46         F6            mov	al,-$A[bp]
07176 1DBD           24                     08  and	al,*8
07177 1DBF           84C0                       test	al,al
07178 1DC1           75           04            jne 	.187
07179                       00001DC3            .188:
07180 1DC3           B0                     01  mov	al,*1
07181 1DC5           EB           02            jmp	.18A
07182                       00001DC7            .187:
07183 1DC7           30C0                       xor	al,al
07184                       00001DC9            .18A:
07185                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
07186 1DC9           8846         F5            mov	-$B[bp],al
07187                                           !BCC_EOS
07188                                           ! 1549     else if (when_done == 5)
07189 1DCC           EB           30            jmp .18B
07190                       00001DCE            .185:
07191                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$E+2] (used reg = )
07192 1DCE           8A46         04            mov	al,4[bp]
07193 1DD1           3C                     05  cmp	al,*5
07194 1DD3           75           1D            jne 	.18C
07195                       00001DD5            .18D:
07196                                           ! 1550       result = !(status & 0x80) && (status & 0x40);
07197                                           ! Debug: and int = const $80 to unsigned short status = [S+$E-$C] (used reg = )
07198 1DD5           8A46         F6            mov	al,-$A[bp]
07199 1DD8           24                     80  and	al,#$80
07200 1DDA           84C0                       test	al,al
07201 1DDC           75           0D            jne 	.18E
07202                       00001DDE            .190:
07203                                           ! Debug: and int = const $40 to unsigned short status = [S+$E-$C] (used reg = )
07204 1DDE           8A46         F6            mov	al,-$A[bp]
07205 1DE1           24                     40  and	al,*$40
07206 1DE3           84C0                       test	al,al
07207 1DE5           74           04            je  	.18E
07208                       00001DE7            .18F:
07209 1DE7           B0                     01  mov	al,*1
07210 1DE9           EB           02            jmp	.191
07211                       00001DEB            .18E:
07212 1DEB           30C0                       xor	al,al
07213                       00001DED            .191:
07214                                           ! Debug: eq char = al+0 to unsigned char result = [S+$E-$D] (used reg = )
07215 1DED           8846         F5            mov	-$B[bp],al
07216                                           !BCC_EOS
07217                                           ! 1551     else if (when_done == 0)
07218 1DF0           EB           0C            jmp .192
07219                       00001DF2            .18C:
07220                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$E+2] (used reg = )
07221 1DF2           8A46         04            mov	al,4[bp]
07222 1DF5           84C0                       test	al,al
07223 1DF7           75           05            jne 	.193
07224                       00001DF9            .194:
07225                                           ! 1552       result = 0;
07226                                           ! Debug: eq int = const 0 to unsigned char result = [S+$E-$D] (used reg = )
07227 1DF9           30C0                       xor	al,al
07228 1DFB           8846         F5            mov	-$B[bp],al
07229                                           !BCC_EOS
07230                                           ! 1553     if (result) retu
07231                       00001DFE            .193:
07232                       00001DFE            .192:
07233                       00001DFE            .18B:
07234                       00001DFE            .184:
07235                       00001DFE            .17D:
07236                       00001DFE            .177:
07237 1DFE           8A46         F5            mov	al,-$B[bp]
07238 1E01           84C0                       test	al,al
07239 1E03           74           06            je  	.195
07240                       00001E05            .196:
07241                                           ! 1553 rn 0;
07242 1E05           31C0                       xor	ax,ax
07243 1E07           89EC                       mov	sp,bp
07244 1E09           5D                         pop	bp
07245 1E0A           C3                         ret
07246                                           !BCC_EOS
07247                                           ! 1554     if (time>>16 != last)
07248                       00001E0B            .195:
07249                                           ! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
07250 1E0B           8B46         FC            mov	ax,-4[bp]
07251 1E0E           8B5E         FE            mov	bx,-2[bp]
07252 1E11           93                         xchg	bx,ax
07253 1E12           31DB                       xor	bx,bx
07254                                           ! Debug: ne unsigned long last = [S+$E-$A] to unsigned long = bx+0 (used reg = )
07255 1E14           8D7E         F8            lea	di,-8[bp]
07256 1E17           E8         E2B1            call	lcmpul
07257 1E1A           74           0F            je  	.197
07258                       00001E1C            .198:
07259                                           ! 1555     {
07260                                           ! 1556       last = time >>16;
07261                                           ! Debug: sr int = const $10 to unsigned long time = [S+$E-6] (used reg = )
07262 1E1C           8B46         FC            mov	ax,-4[bp]
07263 1E1F           8B5E         FE            mov	bx,-2[bp]
07264 1E22           93                         xchg	bx,ax
07265 1E23           31DB                       xor	bx,bx
07266                                           ! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$E-$A] (used reg = )
07267 1E25           8946         F8            mov	-8[bp],ax
07268 1E28           895E         FA            mov	-6[bp],bx
07269                                           !BCC_EOS
07270                                           ! 1557       ;
07271                                           !BCC_EOS
07272                                           ! 1558     }
07273                                           ! 1559     if (status & 0x01)
07274                       00001E2B            .197:
07275                                           ! Debug: and int = const 1 to unsigned short status = [S+$E-$C] (used reg = )
07276 1E2B           8A46         F6            mov	al,-$A[bp]
07277 1E2E           24                     01  and	al,*1
07278 1E30           84C0                       test	al,al
07279 1E32           74           07            je  	.199
07280                       00001E34            .19A:
07281                                           ! 1560     {
07282                                           ! 1561       ;
07283                                           !BCC_EOS
07284                                           ! 1562       return -1;
07285 1E34           B8                   FFFF  mov	ax,*-1
07286 1E37           89EC                       mov	sp,bp
07287 1E39           5D                         pop	bp
07288 1E3A           C3                         ret
07289                                           !BCC_EOS
07290                                           ! 1563     }
07291                                           ! 1564     if ((timeout == 0) || ((time>>11) > timeout)) break;
07292                       00001E3B            .199:
07293                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
07294 1E3B           8B46         08            mov	ax,8[bp]
07295 1E3E           85C0                       test	ax,ax
07296 1E40           74           26            je  	.19C
07297                       00001E42            .19D:
07298                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$E+6] (used reg = )
07299 1E42           8B46         08            mov	ax,8[bp]
07300 1E45           31DB                       xor	bx,bx
07301 1E47           53                         push	bx
07302 1E48           50                         push	ax
07303                                           ! Debug: sr int = const $B to unsigned long time = [S+$12-6] (used reg = )
07304 1E49           8B46         FC            mov	ax,-4[bp]
07305 1E4C           8B5E         FE            mov	bx,-2[bp]
07306 1E4F           88E0                       mov	al,ah
07307 1E51           88DC                       mov	ah,bl
07308 1E53           88FB                       mov	bl,bh
07309 1E55           28FF                       sub	bh,bh
07310 1E57           BF                   0003  mov	di,*3
07311 1E5A           E8         E2CC            call	lsrul
07312                                           ! Debug: gt unsigned long (temp) = [S+$12-$12] to unsigned long = bx+0 (used reg = )
07313 1E5D           8D7E         F0            lea	di,-$10[bp]
07314 1E60           E8         E268            call	lcmpul
07315 1E63           8D66         F4            lea	sp,-$C[bp]
07316 1E66           76           02            jbe 	.19B
07317                       00001E68            .19C:
07318 1E68           EB           03            jmp .172
07319                                           !BCC_EOS
07320                                           ! 1565   }
07321                       00001E6A            .19B:
07322                                           ! 1566   bios_printf(4, "IDE time out\n");
07323                       00001E6A            .173:
07324 1E6A           E9         FECE            br 	.174
07325                       00001E6D            .172:
07326                                           ! Debug: list * char = .19E+0 (used reg = )
07327 1E6D           BB                   DBF7  mov	bx,#.19E
07328 1E70           53                         push	bx
07329                                           ! Debug: list int = const 4 (used reg = )
07330 1E71           B8                   0004  mov	ax,*4
07331 1E74           50                         push	ax
07332                                           ! Debug: func () void = bios_printf+0 (used reg = )
07333 1E75           E8         EBA1            call	_bios_printf
07334 1E78           83C4                   04  add	sp,*4
07335                                           !BCC_EOS
07336                                           ! 1567   return -1;
07337 1E7B           B8                   FFFF  mov	ax,*-1
07338 1E7E           89EC                       mov	sp,bp
07339 1E80           5D                         pop	bp
07340 1E81           C3                         ret
07341                                           !BCC_EOS
07342                                           ! 1568 }
07343                                           ! 1569 void ata_detect( )
07344                                           ! Register BX used in function await_ide
07345                                           ! 1570 {
07346                                           export	_ata_detect
07347                       00001E82            _ata_detect:
07348                                           ! 1571   Bit16u ebda_seg=read_word(0x0040,0x000E);
07349 1E82           55                         push	bp
07350 1E83           89E5                       mov	bp,sp
07351 1E85           4C                         dec	sp
07352 1E86           4C                         dec	sp
07353                                           ! Debug: list int = const $E (used reg = )
07354 1E87           B8                   000E  mov	ax,*$E
07355 1E8A           50                         push	ax
07356                                           ! Debug: list int = const $40 (used reg = )
07357 1E8B           B8                   0040  mov	ax,*$40
07358 1E8E           50                         push	ax
07359                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07360 1E8F           E8         E775            call	_read_word
07361 1E92           83C4                   04  add	sp,*4
07362                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
07363 1E95           8946         FE            mov	-2[bp],ax
07364                                           !BCC_EOS
07365                                           ! 1572   Bit8u hdcount, cdcount, device, type;
07366                                           !BCC_EOS
07367                                           ! 1573   Bit8u buffer[0x0200];
07368                                           !BCC_EOS
07369                                           ! 1574   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
07370 1E98           81C4                 FDFC  add	sp,#-$204
07371                                           ! Debug: list int = const 0 (used reg = )
07372 1E9C           31C0                       xor	ax,ax
07373 1E9E           50                         push	ax
07374                                           ! Debug: list * unsigned char = const $122 (used reg = )
07375 1E9F           B8                   0122  mov	ax,#$122
07376 1EA2           50                         push	ax
07377                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07378 1EA3           FF76         FE            push	-2[bp]
07379                                           ! Debug: func () void = write_byte+0 (used reg = )
07380 1EA6           E8         E771            call	_write_byte
07381 1EA9           83C4                   06  add	sp,*6
07382                                           !BCC_EOS
07383                                           ! 1575   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
07384                                           ! Debug: list int = const $1F0 (used reg = )
07385 1EAC           B8                   01F0  mov	ax,#$1F0
07386 1EAF           50                         push	ax
07387                                           ! Debug: list * unsigned short = const $124 (used reg = )
07388 1EB0           B8                   0124  mov	ax,#$124
07389 1EB3           50                         push	ax
07390                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07391 1EB4           FF76         FE            push	-2[bp]
07392                                           ! Debug: func () void = write_word+0 (used reg = )
07393 1EB7           E8         E778            call	_write_word
07394 1EBA           83C4                   06  add	sp,*6
07395                                           !BCC_EOS
07396                                           ! 1576   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
07397                                           ! Debug: list int = const $3F0 (used reg = )
07398 1EBD           B8                   03F0  mov	ax,#$3F0
07399 1EC0           50                         push	ax
07400                                           ! Debug: list * unsigned short = const $126 (used reg = )
07401 1EC1           B8                   0126  mov	ax,#$126
07402 1EC4           50                         push	ax
07403                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07404 1EC5           FF76         FE            push	-2[bp]
07405                                           ! Debug: func () void = write_word+0 (used reg = )
07406 1EC8           E8         E767            call	_write_word
07407 1ECB           83C4                   06  add	sp,*6
07408                                           !BCC_EOS
07409                                           ! 1577   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
07410                                           ! Debug: list int = const $E (used reg = )
07411 1ECE           B8                   000E  mov	ax,*$E
07412 1ED1           50                         push	ax
07413                                           ! Debug: list * unsigned char = const $128 (used reg = )
07414 1ED2           B8                   0128  mov	ax,#$128
07415 1ED5           50                         push	ax
07416                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07417 1ED6           FF76         FE            push	-2[bp]
07418                                           ! Debug: func () void = write_byte+0 (used reg = )
07419 1ED9           E8         E73E            call	_write_byte
07420 1EDC           83C4                   06  add	sp,*6
07421                                           !BCC_EOS
07422                                           ! 1578   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
07423                                           ! Debug: list int = const 0 (used reg = )
07424 1EDF           31C0                       xor	ax,ax
07425 1EE1           50                         push	ax
07426                                           ! Debug: list * unsigned char = const $12A (used reg = )
07427 1EE2           B8                   012A  mov	ax,#$12A
07428 1EE5           50                         push	ax
07429                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07430 1EE6           FF76         FE            push	-2[bp]
07431                                           ! Debug: func () void = write_byte+0 (used reg = )
07432 1EE9           E8         E72E            call	_write_byte
07433 1EEC           83C4                   06  add	sp,*6
07434                                           !BCC_EOS
07435                                           ! 1579   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
07436                                           ! Debug: list int = const $170 (used reg = )
07437 1EEF           B8                   0170  mov	ax,#$170
07438 1EF2           50                         push	ax
07439                                           ! Debug: list * unsigned short = const $12C (used reg = )
07440 1EF3           B8                   012C  mov	ax,#$12C
07441 1EF6           50                         push	ax
07442                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07443 1EF7           FF76         FE            push	-2[bp]
07444                                           ! Debug: func () void = write_word+0 (used reg = )
07445 1EFA           E8         E735            call	_write_word
07446 1EFD           83C4                   06  add	sp,*6
07447                                           !BCC_EOS
07448                                           ! 1580   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
07449                                           ! Debug: list int = const $370 (used reg = )
07450 1F00           B8                   0370  mov	ax,#$370
07451 1F03           50                         push	ax
07452                                           ! Debug: list * unsigned short = const $12E (used reg = )
07453 1F04           B8                   012E  mov	ax,#$12E
07454 1F07           50                         push	ax
07455                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07456 1F08           FF76         FE            push	-2[bp]
07457                                           ! Debug: func () void = write_word+0 (used reg = )
07458 1F0B           E8         E724            call	_write_word
07459 1F0E           83C4                   06  add	sp,*6
07460                                           !BCC_EOS
07461                                           ! 1581   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
07462                                           ! Debug: list int = const $F (used reg = )
07463 1F11           B8                   000F  mov	ax,*$F
07464 1F14           50                         push	ax
07465                                           ! Debug: list * unsigned char = const $130 (used reg = )
07466 1F15           B8                   0130  mov	ax,#$130
07467 1F18           50                         push	ax
07468                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07469 1F19           FF76         FE            push	-2[bp]
07470                                           ! Debug: func () void = write_byte+0 (used reg = )
07471 1F1C           E8         E6FB            call	_write_byte
07472 1F1F           83C4                   06  add	sp,*6
07473                                           !BCC_EOS
07474                                           ! 1582   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
07475                                           ! Debug: list int = const 0 (used reg = )
07476 1F22           31C0                       xor	ax,ax
07477 1F24           50                         push	ax
07478                                           ! Debug: list * unsigned char = const $132 (used reg = )
07479 1F25           B8                   0132  mov	ax,#$132
07480 1F28           50                         push	ax
07481                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07482 1F29           FF76         FE            push	-2[bp]
07483                                           ! Debug: func () void = write_byte+0 (used reg = )
07484 1F2C           E8         E6EB            call	_write_byte
07485 1F2F           83C4                   06  add	sp,*6
07486                                           !BCC_EOS
07487                                           ! 1583   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
07488                                           ! Debug: list int = const $1E8 (used reg = )
07489 1F32           B8                   01E8  mov	ax,#$1E8
07490 1F35           50                         push	ax
07491                                           ! Debug: list * unsigned short = const $134 (used reg = )
07492 1F36           B8                   0134  mov	ax,#$134
07493 1F39           50                         push	ax
07494                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07495 1F3A           FF76         FE            push	-2[bp]
07496                                           ! Debug: func () void = write_word+0 (used reg = )
07497 1F3D           E8         E6F2            call	_write_word
07498 1F40           83C4                   06  add	sp,*6
07499                                           !BCC_EOS
07500                                           ! 1584   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
07501                                           ! Debug: list int = const $3E0 (used reg = )
07502 1F43           B8                   03E0  mov	ax,#$3E0
07503 1F46           50                         push	ax
07504                                           ! Debug: list * unsigned short = const $136 (used reg = )
07505 1F47           B8                   0136  mov	ax,#$136
07506 1F4A           50                         push	ax
07507                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07508 1F4B           FF76         FE            push	-2[bp]
07509                                           ! Debug: func () void = write_word+0 (used reg = )
07510 1F4E           E8         E6E1            call	_write_word
07511 1F51           83C4                   06  add	sp,*6
07512                                           !BCC_EOS
07513                                           ! 1585   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
07514                                           ! Debug: list int = const $C (used reg = )
07515 1F54           B8                   000C  mov	ax,*$C
07516 1F57           50                         push	ax
07517                                           ! Debug: list * unsigned char = const $138 (used reg = )
07518 1F58           B8                   0138  mov	ax,#$138
07519 1F5B           50                         push	ax
07520                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07521 1F5C           FF76         FE            push	-2[bp]
07522                                           ! Debug: func () void = write_byte+0 (used reg = )
07523 1F5F           E8         E6B8            call	_write_byte
07524 1F62           83C4                   06  add	sp,*6
07525                                           !BCC_EOS
07526                                           ! 1586   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
07527                                           ! Debug: list int = const 0 (used reg = )
07528 1F65           31C0                       xor	ax,ax
07529 1F67           50                         push	ax
07530                                           ! Debug: list * unsigned char = const $13A (used reg = )
07531 1F68           B8                   013A  mov	ax,#$13A
07532 1F6B           50                         push	ax
07533                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07534 1F6C           FF76         FE            push	-2[bp]
07535                                           ! Debug: func () void = write_byte+0 (used reg = )
07536 1F6F           E8         E6A8            call	_write_byte
07537 1F72           83C4                   06  add	sp,*6
07538                                           !BCC_EOS
07539                                           ! 1587   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
07540                                           ! Debug: list int = const $168 (used reg = )
07541 1F75           B8                   0168  mov	ax,#$168
07542 1F78           50                         push	ax
07543                                           ! Debug: list * unsigned short = const $13C (used reg = )
07544 1F79           B8                   013C  mov	ax,#$13C
07545 1F7C           50                         push	ax
07546                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07547 1F7D           FF76         FE            push	-2[bp]
07548                                           ! Debug: func () void = write_word+0 (used reg = )
07549 1F80           E8         E6AF            call	_write_word
07550 1F83           83C4                   06  add	sp,*6
07551                                           !BCC_EOS
07552                                           ! 1588   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
07553                                           ! Debug: list int = const $360 (used reg = )
07554 1F86           B8                   0360  mov	ax,#$360
07555 1F89           50                         push	ax
07556                                           ! Debug: list * unsigned short = const $13E (used reg = )
07557 1F8A           B8                   013E  mov	ax,#$13E
07558 1F8D           50                         push	ax
07559                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07560 1F8E           FF76         FE            push	-2[bp]
07561                                           ! Debug: func () void = write_word+0 (used reg = )
07562 1F91           E8         E69E            call	_write_word
07563 1F94           83C4                   06  add	sp,*6
07564                                           !BCC_EOS
07565                                           ! 1589   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
07566                                           ! Debug: list int = const $B (used reg = )
07567 1F97           B8                   000B  mov	ax,*$B
07568 1F9A           50                         push	ax
07569                                           ! Debug: list * unsigned char = const $140 (used reg = )
07570 1F9B           B8                   0140  mov	ax,#$140
07571 1F9E           50                         push	ax
07572                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07573 1F9F           FF76         FE            push	-2[bp]
07574                                           ! Debug: func () void = write_byte+0 (used reg = )
07575 1FA2           E8         E675            call	_write_byte
07576 1FA5           83C4                   06  add	sp,*6
07577                                           !BCC_EOS
07578                                           ! 1590   hdcount=cdcount=0;
07579                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
07580 1FA8           30C0                       xor	al,al
07581 1FAA           8846         FC            mov	-4[bp],al
07582                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
07583 1FAD           8846         FD            mov	-3[bp],al
07584                                           !BCC_EOS
07585                                           ! 1591   for(device=0; device<(4*2); device++) {
07586                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
07587 1FB0           30C0                       xor	al,al
07588 1FB2           8846         FB            mov	-5[bp],al
07589                                           !BCC_EOS
07590                                           !BCC_EOS
07591 1FB5           E9         0DB1            br 	.1A1
07592                       00001FB8            .1A2:
07593                                           ! 1592     Bit16u iobase1, iobase2;
07594                                           !BCC_EOS
07595                                           ! 1593     Bit8u channel, slave, shift;
07596                                           !BCC_EOS
07597                                           ! 1594     Bit8u sc, sn, cl, ch, st;
07598                                           !BCC_EOS
07599                                           ! 1595     channel = device / 2;
07600 1FB8           83C4                   F4  add	sp,*-$C
07601                                           ! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07602 1FBB           8A46         FB            mov	al,-5[bp]
07603 1FBE           30E4                       xor	ah,ah
07604 1FC0           D1E8                       shr	ax,*1
07605                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
07606 1FC2           8886       FDF5            mov	-$20B[bp],al
07607                                           !BCC_EOS
07608                                           ! 1596     slave = device % 2;
07609                                           ! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07610 1FC6           8A46         FB            mov	al,-5[bp]
07611 1FC9           30E4                       xor	ah,ah
07612 1FCB           24                     01  and	al,*1
07613                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
07614 1FCD           8886       FDF4            mov	-$20C[bp],al
07615                                           !BCC_EOS
07616                                           ! 1597     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
07617                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07618 1FD1           8A86       FDF5            mov	al,-$20B[bp]
07619 1FD5           30E4                       xor	ah,ah
07620 1FD7           B1                     03  mov	cl,*3
07621 1FD9           D3E0                       shl	ax,cl
07622 1FDB           89C3                       mov	bx,ax
07623                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07624                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
07625 1FDD           81C3                 0124  add	bx,#$124
07626 1FE1           53                         push	bx
07627                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07628 1FE2           FF76         FE            push	-2[bp]
07629                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07630 1FE5           E8         E61F            call	_read_word
07631 1FE8           83C4                   04  add	sp,*4
07632                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07633 1FEB           8986       FDF8            mov	-$208[bp],ax
07634                                           !BCC_EOS
07635                                           ! 1598     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
07636                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07637 1FEF           8A86       FDF5            mov	al,-$20B[bp]
07638 1FF3           30E4                       xor	ah,ah
07639 1FF5           B1                     03  mov	cl,*3
07640 1FF7           D3E0                       shl	ax,cl
07641 1FF9           89C3                       mov	bx,ax
07642                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07643                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
07644 1FFB           81C3                 0126  add	bx,#$126
07645 1FFF           53                         push	bx
07646                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07647 2000           FF76         FE            push	-2[bp]
07648                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07649 2003           E8         E601            call	_read_word
07650 2006           83C4                   04  add	sp,*4
07651                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
07652 2009           8986       FDF6            mov	-$20A[bp],ax
07653                                           !BCC_EOS
07654                                           ! 1599     outb(iobase2+6, 0x08 | 0x02);
07655                                           ! Debug: list int = const $A (used reg = )
07656 200D           B8                   000A  mov	ax,*$A
07657 2010           50                         push	ax
07658                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07659 2011           8B86       FDF6            mov	ax,-$20A[bp]
07660                                           ! Debug: list unsigned int = ax+6 (used reg = )
07661 2015           05                   0006  add	ax,*6
07662 2018           50                         push	ax
07663                                           ! Debug: func () void = outb+0 (used reg = )
07664 2019           E8         E538            call	_outb
07665 201C           83C4                   04  add	sp,*4
07666                                           !BCC_EOS
07667                                           ! 1600     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07668 201F           8A86       FDF4            mov	al,-$20C[bp]
07669 2023           84C0                       test	al,al
07670 2025           74           04            je  	.1A3
07671                       00002027            .1A4:
07672 2027           B0                     B0  mov	al,#$B0
07673 2029           EB           02            jmp .1A5
07674                       0000202B            .1A3:
07675 202B           B0                     A0  mov	al,#$A0
07676                       0000202D            .1A5:
07677                                           ! Debug: list char = al+0 (used reg = )
07678 202D           30E4                       xor	ah,ah
07679 202F           50                         push	ax
07680                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07681 2030           8B86       FDF8            mov	ax,-$208[bp]
07682                                           ! Debug: list unsigned int = ax+6 (used reg = )
07683 2034           05                   0006  add	ax,*6
07684 2037           50                         push	ax
07685                                           ! Debug: func () void = outb+0 (used reg = )
07686 2038           E8         E519            call	_outb
07687 203B           83C4                   04  add	sp,*4
07688                                           !BCC_EOS
07689                                           ! 1601     outb(iobase1+2, 0x55);
07690                                           ! Debug: list int = const $55 (used reg = )
07691 203E           B8                   0055  mov	ax,*$55
07692 2041           50                         push	ax
07693                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07694 2042           8B86       FDF8            mov	ax,-$208[bp]
07695                                           ! Debug: list unsigned int = ax+2 (used reg = )
07696 2046           40                         inc	ax
07697 2047           40                         inc	ax
07698 2048           50                         push	ax
07699                                           ! Debug: func () void = outb+0 (used reg = )
07700 2049           E8         E508            call	_outb
07701 204C           83C4                   04  add	sp,*4
07702                                           !BCC_EOS
07703                                           ! 1602     outb(iobase
07704                                           ! 1602 1+3, 0xaa);
07705                                           ! Debug: list int = const $AA (used reg = )
07706 204F           B8                   00AA  mov	ax,#$AA
07707 2052           50                         push	ax
07708                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07709 2053           8B86       FDF8            mov	ax,-$208[bp]
07710                                           ! Debug: list unsigned int = ax+3 (used reg = )
07711 2057           05                   0003  add	ax,*3
07712 205A           50                         push	ax
07713                                           ! Debug: func () void = outb+0 (used reg = )
07714 205B           E8         E4F6            call	_outb
07715 205E           83C4                   04  add	sp,*4
07716                                           !BCC_EOS
07717                                           ! 1603     outb(iobase1+2, 0xaa);
07718                                           ! Debug: list int = const $AA (used reg = )
07719 2061           B8                   00AA  mov	ax,#$AA
07720 2064           50                         push	ax
07721                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07722 2065           8B86       FDF8            mov	ax,-$208[bp]
07723                                           ! Debug: list unsigned int = ax+2 (used reg = )
07724 2069           40                         inc	ax
07725 206A           40                         inc	ax
07726 206B           50                         push	ax
07727                                           ! Debug: func () void = outb+0 (used reg = )
07728 206C           E8         E4E5            call	_outb
07729 206F           83C4                   04  add	sp,*4
07730                                           !BCC_EOS
07731                                           ! 1604     outb(iobase1+3, 0x55);
07732                                           ! Debug: list int = const $55 (used reg = )
07733 2072           B8                   0055  mov	ax,*$55
07734 2075           50                         push	ax
07735                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07736 2076           8B86       FDF8            mov	ax,-$208[bp]
07737                                           ! Debug: list unsigned int = ax+3 (used reg = )
07738 207A           05                   0003  add	ax,*3
07739 207D           50                         push	ax
07740                                           ! Debug: func () void = outb+0 (used reg = )
07741 207E           E8         E4D3            call	_outb
07742 2081           83C4                   04  add	sp,*4
07743                                           !BCC_EOS
07744                                           ! 1605     outb(iobase1+2, 0x55);
07745                                           ! Debug: list int = const $55 (used reg = )
07746 2084           B8                   0055  mov	ax,*$55
07747 2087           50                         push	ax
07748                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07749 2088           8B86       FDF8            mov	ax,-$208[bp]
07750                                           ! Debug: list unsigned int = ax+2 (used reg = )
07751 208C           40                         inc	ax
07752 208D           40                         inc	ax
07753 208E           50                         push	ax
07754                                           ! Debug: func () void = outb+0 (used reg = )
07755 208F           E8         E4C2            call	_outb
07756 2092           83C4                   04  add	sp,*4
07757                                           !BCC_EOS
07758                                           ! 1606     outb(iobase1+3, 0xaa);
07759                                           ! Debug: list int = const $AA (used reg = )
07760 2095           B8                   00AA  mov	ax,#$AA
07761 2098           50                         push	ax
07762                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07763 2099           8B86       FDF8            mov	ax,-$208[bp]
07764                                           ! Debug: list unsigned int = ax+3 (used reg = )
07765 209D           05                   0003  add	ax,*3
07766 20A0           50                         push	ax
07767                                           ! Debug: func () void = outb+0 (used reg = )
07768 20A1           E8         E4B0            call	_outb
07769 20A4           83C4                   04  add	sp,*4
07770                                           !BCC_EOS
07771                                           ! 1607     sc = inb(iobase1+2);
07772                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07773 20A7           8B86       FDF8            mov	ax,-$208[bp]
07774                                           ! Debug: list unsigned int = ax+2 (used reg = )
07775 20AB           40                         inc	ax
07776 20AC           40                         inc	ax
07777 20AD           50                         push	ax
07778                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07779 20AE           E8         E48D            call	_inb
07780 20B1           44                         inc	sp
07781 20B2           44                         inc	sp
07782                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07783 20B3           8886       FDF2            mov	-$20E[bp],al
07784                                           !BCC_EOS
07785                                           ! 1608     sn = inb(iobase1+3);
07786                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07787 20B7           8B86       FDF8            mov	ax,-$208[bp]
07788                                           ! Debug: list unsigned int = ax+3 (used reg = )
07789 20BB           05                   0003  add	ax,*3
07790 20BE           50                         push	ax
07791                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07792 20BF           E8         E47C            call	_inb
07793 20C2           44                         inc	sp
07794 20C3           44                         inc	sp
07795                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07796 20C4           8886       FDF1            mov	-$20F[bp],al
07797                                           !BCC_EOS
07798                                           ! 1609     if ( (sc == 0x55) && (sn == 0xaa) ) {
07799                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
07800 20C8           8A86       FDF2            mov	al,-$20E[bp]
07801 20CC           3C                     55  cmp	al,*$55
07802 20CE         0F85         014F            bne 	.1A6
07803                       000020D2            .1A8:
07804                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
07805 20D2           8A86       FDF1            mov	al,-$20F[bp]
07806 20D6           3C                     AA  cmp	al,#$AA
07807 20D8         0F85         0145            bne 	.1A6
07808                       000020DC            .1A7:
07809                                           ! 1610       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
07810                                           ! Debug: list int = const 1 (used reg = )
07811 20DC           B8                   0001  mov	ax,*1
07812 20DF           50                         push	ax
07813                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07814 20E0           8A46         FB            mov	al,-5[bp]
07815 20E3           30E4                       xor	ah,ah
07816 20E5           B9                   001E  mov	cx,*$1E
07817 20E8           F7E9                       imul	cx
07818 20EA           89C3                       mov	bx,ax
07819                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07820                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07821 20EC           81C3                 0142  add	bx,#$142
07822 20F0           53                         push	bx
07823                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07824 20F1           FF76         FE            push	-2[bp]
07825                                           ! Debug: func () void = write_byte+0 (used reg = )
07826 20F4           E8         E523            call	_write_byte
07827 20F7           83C4                   06  add	sp,*6
07828                                           !BCC_EOS
07829                                           ! 1611       ata_reset(device);
07830                                           ! Debug: list unsigned char device = [S+$214-7] (used reg = )
07831 20FA           8A46         FB            mov	al,-5[bp]
07832 20FD           30E4                       xor	ah,ah
07833 20FF           50                         push	ax
07834                                           ! Debug: func () void = ata_reset+0 (used reg = )
07835 2100           E8         0CBB            call	_ata_reset
07836 2103           44                         inc	sp
07837 2104           44                         inc	sp
07838                                           !BCC_EOS
07839                                           ! 1612       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07840 2105           8A86       FDF4            mov	al,-$20C[bp]
07841 2109           84C0                       test	al,al
07842 210B           74           04            je  	.1A9
07843                       0000210D            .1AA:
07844 210D           B0                     B0  mov	al,#$B0
07845 210F           EB           02            jmp .1AB
07846                       00002111            .1A9:
07847 2111           B0                     A0  mov	al,#$A0
07848                       00002113            .1AB:
07849                                           ! Debug: list char = al+0 (used reg = )
07850 2113           30E4                       xor	ah,ah
07851 2115           50                         push	ax
07852                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07853 2116           8B86       FDF8            mov	ax,-$208[bp]
07854                                           ! Debug: list unsigned int = ax+6 (used reg = )
07855 211A           05                   0006  add	ax,*6
07856 211D           50                         push	ax
07857                                           ! Debug: func () void = outb+0 (used reg = )
07858 211E           E8         E433            call	_outb
07859 2121           83C4                   04  add	sp,*4
07860                                           !BCC_EOS
07861                                           ! 1613       sc = inb(iobase1+2);
07862                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07863 2124           8B86       FDF8            mov	ax,-$208[bp]
07864                                           ! Debug: list unsigned int = ax+2 (used reg = )
07865 2128           40                         inc	ax
07866 2129           40                         inc	ax
07867 212A           50                         push	ax
07868                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07869 212B           E8         E410            call	_inb
07870 212E           44                         inc	sp
07871 212F           44                         inc	sp
07872                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07873 2130           8886       FDF2            mov	-$20E[bp],al
07874                                           !BCC_EOS
07875                                           ! 1614       sn = inb(iobase1+3);
07876                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07877 2134           8B86       FDF8            mov	ax,-$208[bp]
07878                                           ! Debug: list unsigned int = ax+3 (used reg = )
07879 2138           05                   0003  add	ax,*3
07880 213B           50                         push	ax
07881                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07882 213C           E8         E3FF            call	_inb
07883 213F           44                         inc	sp
07884 2140           44                         inc	sp
07885                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07886 2141           8886       FDF1            mov	-$20F[bp],al
07887                                           !BCC_EOS
07888                                           ! 1615       if ((sc==0x01) && (sn==0x01)) {
07889                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
07890 2145           8A86       FDF2            mov	al,-$20E[bp]
07891 2149           3C                     01  cmp	al,*1
07892 214B         0F85         00D2            bne 	.1AC
07893                       0000214F            .1AE:
07894                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
07895 214F           8A86       FDF1            mov	al,-$20F[bp]
07896 2153           3C                     01  cmp	al,*1
07897 2155         0F85         00C8            bne 	.1AC
07898                       00002159            .1AD:
07899                                           ! 1616         cl = inb(iobase1+4);
07900                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07901 2159           8B86       FDF8            mov	ax,-$208[bp]
07902                                           ! Debug: list unsigned int = ax+4 (used reg = )
07903 215D           05                   0004  add	ax,*4
07904 2160           50                         push	ax
07905                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07906 2161           E8         E3DA            call	_inb
07907 2164           44                         inc	sp
07908 2165           44                         inc	sp
07909                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
07910 2166           8886       FDF0            mov	-$210[bp],al
07911                                           !BCC_EOS
07912                                           ! 1617         ch = inb(iobase1+5);
07913                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07914 216A           8B86       FDF8            mov	ax,-$208[bp]
07915                                           ! Debug: list unsigned int = ax+5 (used reg = )
07916 216E           05                   0005  add	ax,*5
07917 2171           50                         push	ax
07918                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07919 2172           E8         E3C9            call	_inb
07920 2175           44                         inc	sp
07921 2176           44                         inc	sp
07922                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
07923 2177           8886       FDEF            mov	-$211[bp],al
07924                                           !BCC_EOS
07925                                           ! 1618         st = inb(iobase1+7);
07926                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07927 217B           8B86       FDF8            mov	ax,-$208[bp]
07928                                           ! Debug: list unsigned int = ax+7 (used reg = )
07929 217F           05                   0007  add	ax,*7
07930 2182           50                         push	ax
07931                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07932 2183           E8         E3B8            call	_inb
07933 2186           44                         inc	sp
07934 2187           44                         inc	sp
07935                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
07936 2188           8886       FDEE            mov	-$212[bp],al
07937                                           !BCC_EOS
07938                                           ! 1619         if ((cl==0x14) && (ch==0xeb)) {
07939                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
07940 218C           8A86       FDF0            mov	al,-$210[bp]
07941 2190           3C                     14  cmp	al,*$14
07942 2192           75           28            jne 	.1AF
07943                       00002194            .1B1:
07944                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
07945 2194           8A86       FDEF            mov	al,-$211[bp]
07946 2198           3C                     EB  cmp	al,#$EB
07947 219A           75           20            jne 	.1AF
07948                       0000219C            .1B0:
07949                                           ! 1620           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
07950                                           ! Debug: list int = const 3 (used reg = )
07951 219C           B8                   0003  mov	ax,*3
07952 219F           50                         push	ax
07953                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07954 21A0           8A46         FB            mov	al,-5[bp]
07955 21A3           30E4                       xor	ah,ah
07956 21A5           B9                   001E  mov	cx,*$1E
07957 21A8           F7E9                       imul	cx
07958 21AA           89C3                       mov	bx,ax
07959                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07960                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07961 21AC           81C3                 0142  add	bx,#$142
07962 21B0           53                         push	bx
07963                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07964 21B1           FF76         FE            push	-2[bp]
07965                                           ! Debug: func () void = write_byte+0 (used reg = )
07966 21B4           E8         E463            call	_write_byte
07967 21B7           83C4                   06  add	sp,*6
07968                                           !BCC_EOS
07969                                           ! 1621         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07970 21BA           EB           65            jmp .1B2
07971                       000021BC            .1AF:
07972                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
07973 21BC           8A86       FDF0            mov	al,-$210[bp]
07974 21C0           84C0                       test	al,al
07975 21C2           75           30            jne 	.1B3
07976                       000021C4            .1B6:
07977                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
07978 21C4           8A86       FDEF            mov	al,-$211[bp]
07979 21C8           84C0                       test	al,al
07980 21CA           75           28            jne 	.1B3
07981                       000021CC            .1B5:
07982                                           ! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
07983 21CC           8A86       FDEE            mov	al,-$212[bp]
07984 21D0           84C0                       test	al,al
07985 21D2           74           20            je  	.1B3
07986                       000021D4            .1B4:
07987                                           ! 1622           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
07988                                           ! Debug: list int = const 2 (used reg = )
07989 21D4           B8                   0002  mov	ax,*2
07990 21D7           50                         push	ax
07991                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07992 21D8           8A46         FB            mov	al,-5[bp]
07993 21DB           30E4                       xor	ah,ah
07994 21DD           B9                   001E  mov	cx,*$1E
07995 21E0           F7E9                       imul	cx
07996 21E2           89C3                       mov	bx,ax
07997                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07998                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07999 21E4           81C3                 0142  add	bx,#$142
08000 21E8           53                         push	bx
08001                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
08002 21E9           FF76         FE            push	-2[bp]
08003                                           ! Debug: func () void = write_byte+0 (used reg = )
08004 21EC           E8         E42B            call	_write_byte
08005 21EF           83C4                   06  add	sp,*6
08006                                           !BCC_EOS
08007                                           ! 1623         } else if ((cl==0xff) && (ch==0xff)) {
08008 21F2           EB           2D            jmp .1B7
08009                       000021F4            .1B3:
08010                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
08011 21F4           8A86       FDF0            mov	al,-$210[bp]
08012 21F8           3C                     FF  cmp	al,#$FF
08013 21FA           75           25            jne 	.1B8
08014                       000021FC            .1BA:
08015                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
08016 21FC           8A86       FDEF            mov	al,-$211[bp]
08017 2200           3C                     FF  cmp	al,#$FF
08018 2202           75           1D            jne 	.1B8
08019                       00002204            .1B9:
08020                                           ! 1624           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
08021                                           ! Debug: list int = const 0 (used reg = )
08022 2204           31C0                       xor	ax,ax
08023 2206           50                         push	ax
08024                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
08025 2207           8A46         FB            mov	al,-5[bp]
08026 220A           30E4                       xor	ah,ah
08027 220C           B9                   001E  mov	cx,*$1E
08028 220F           F7E9                       imul	cx
08029 2211           89C3                       mov	bx,ax
08030                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
08031                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
08032 2213           81C3                 0142  add	bx,#$142
08033 2217           53                         push	bx
08034                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
08035 2218           FF76         FE            push	-2[bp]
08036                                           ! Debug: func () void = write_byte+0 (used reg = )
08037 221B           E8         E3FC            call	_write_byte
08038 221E           83C4                   06  add	sp,*6
08039                                           !BCC_EOS
08040                                           ! 1625         }
08041                                           ! 1626       }
08042                       00002221            .1B8:
08043                       00002221            .1B7:
08044                       00002221            .1B2:
08045                                           ! 1627     }
08046                       00002221            .1AC:
08047                                           ! 1628     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
08048                       00002221            .1A6:
08049                                           ! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
08050 2221           8A46         FB            mov	al,-5[bp]
08051 2224           30E4                       xor	ah,ah
08052 2226           B9                   001E  mov	cx,*$1E
08053 2229           F7E9                       imul	cx
08054 222B           89C3                       mov	bx,ax
08055                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
08056                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
08057 222D           81C3                 0142  add	bx,#$142
08058 2231           53                         push	bx
08059                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
08060 2232           FF76         FE            push	-2[bp]
08061                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08062 2235           E8         E3BC            call	_read_byte
08063 2238           83C4                   04  add	sp,*4
08064                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
08065 223B           8846         FA            mov	-6[bp],al
08066                                           !BCC_EOS
08067                                           ! 1629     if(type == 0x02) {
08068                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
08069 223E           8A46         FA            mov	al,-6[bp]
08070 2241           3C                     02  cmp	al,*2
08071 2243         0F85         05AE            bne 	.1BB
08072                       00002247            .1BC:
08073                                           ! 1630       Bit32u sectors_low, sectors_high;
08074                                           !BCC_EOS
08075                                           ! 1631       Bit16u cylinders, heads, spt, blksize;
08076                                           !BCC_EOS
08077                                           ! 1632       Bit8u translation, removable, mode;
08078                                           !BCC_EOS
08079                                           ! 1633       mode = 0x00;
08080 2247           83C4                   EC  add	sp,*-$14
08081                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$228-$227] (used reg = )
08082 224A           30C0                       xor	al,al
08083 224C           8886       FDDB            mov	-$225[bp],al
08084                                           !BCC_EOS
08085                                           ! 1634       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
08086                                           ! Debug: list int = const $FF (used reg = )
08087 2250           B8                   00FF  mov	ax,#$FF
08088 2253           50                         push	ax
08089                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08090 2254           8A46         FB            mov	al,-5[bp]
08091 2257           30E4                       xor	ah,ah
08092 2259           B9                   001E  mov	cx,*$1E
08093 225C           F7E9                       imul	cx
08094 225E           89C3                       mov	bx,ax
08095                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08096                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08097 2260           81C3                 0143  add	bx,#$143
08098 2264           53                         push	bx
08099                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08100 2265           FF76         FE            push	-2[bp]
08101                                           ! Debug: func () void = write_byte+0 (used reg = )
08102 2268           E8         E3AF            call	_write_byte
08103 226B           83C4                   06  add	sp,*6
08104                                           !BCC_EOS
08105                                           ! 1635       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08106                                           ! Debug: list int = const 0 (used reg = )
08107 226E           31C0                       xor	ax,ax
08108 2270           50                         push	ax
08109                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08110 2271           8A46         FB            mov	al,-5[bp]
08111 2274           30E4                       xor	ah,ah
08112 2276           B9                   001E  mov	cx,*$1E
08113 2279           F7E9                       imul	cx
08114 227B           89C3                       mov	bx,ax
08115                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08116                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08117 227D           81C3                 0146  add	bx,#$146
08118 2281           53                         push	bx
08119                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08120 2282           FF76         FE            push	-2[bp]
08121                                           ! Debug: func () void = write_byte+0 (used reg = )
08122 2285           E8         E392            call	_write_byte
08123 2288           83C4                   06  add	sp,*6
08124                                           !BCC_EOS
08125                                           ! 1636       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
08126                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08127 228B           8D9E       FDFA            lea	bx,-$206[bp]
08128 228F           53                         push	bx
08129                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08130 2290           E8         E3BA            call	_get_SS
08131                                           ! Debug: list unsigned short = ax+0 (used reg = )
08132 2293           50                         push	ax
08133                                           ! Debug: list long = const 0 (used reg = )
08134 2294           31C0                       xor	ax,ax
08135 2296           31DB                       xor	bx,bx
08136 2298           53                         push	bx
08137 2299           50                         push	ax
08138                                           ! Debug: list long = const 0 (used reg = )
08139 229A           31C0                       xor	ax,ax
08140 229C           31DB                       xor	bx,bx
08141 229E           53                         push	bx
08142 229F           50                         push	ax
08143                                           ! Debug: list int = const 0 (used reg = )
08144 22A0           31C0                       xor	ax,ax
08145 22A2           50                         push	ax
08146                                           ! Debug: list int = const 0 (used reg = )
08147 22A3           31C0                       xor	ax,ax
08148 22A5           50                         push	ax
08149                                           ! Debug: list int = const 0 (used reg = )
08150 22A6           31C0                       xor	ax,ax
08151 22A8           50                         push	ax
08152                                           ! Debug: list int = const 1 (used reg = )
08153 22A9           B8                   0001  mov	ax,*1
08154 22AC           50                         push	ax
08155                                           ! Debug: list int = const $EC (used reg = )
08156 22AD           B8                   00EC  mov	ax,#$EC
08157 22B0           50                         push	ax
08158                                           ! Debug: list unsigned char device = [S+$23E-7] (used reg = )
08159 22B1           8A46         FB            mov	al,-5[bp]
08160 22B4           30E4                       xor	ah,ah
08161 22B6           50                         push	ax
08162                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08163 22B7           E8         0C5C            call	_ata_cmd_data_in
08164 22BA           83C4                   18  add	sp,*$18
08165                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08166 22BD           85C0                       test	ax,ax
08167 22BF           74           0E            je  	.1BD
08168                       000022C1            .1BE:
08169                                           ! 1637         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
08170                                           ! Debug: list * char = .1BF+0 (used reg = )
08171 22C1           BB                   DBCE  mov	bx,#.1BF
08172 22C4           53                         push	bx
08173                                           ! Debug: list int = const 7 (used reg = )
08174 22C5           B8                   0007  mov	ax,*7
08175 22C8           50                         push	ax
08176                                           ! Debug: func () void = bios_printf+0 (used reg = )
08177 22C9           E8         E74D            call	_bios_printf
08178 22CC           83C4                   04  add	sp,*4
08179                                           !BCC_EOS
08180                                           ! 1638       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
08181                       000022CF            .1BD:
08182                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08183 22CF           8D9E       FDFA            lea	bx,-$206[bp]
08184 22D3           53                         push	bx
08185                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08186 22D4           E8         E376            call	_get_SS
08187                                           ! Debug: list unsigned short = ax+0 (used reg = )
08188 22D7           50                         push	ax
08189                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08190 22D8           E8         E319            call	_read_byte
08191 22DB           83C4                   04  add	sp,*4
08192                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08193 22DE           24                     80  and	al,#$80
08194 22E0           84C0                       test	al,al
08195 22E2           74           04            je  	.1C0
08196                       000022E4            .1C1:
08197 22E4           B0                     01  mov	al,*1
08198 22E6           EB           02            jmp .1C2
08199                       000022E8            .1C0:
08200 22E8           30C0                       xor	al,al
08201                       000022EA            .1C2:
08202                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
08203 22EA           8886       FDDC            mov	-$224[bp],al
08204                                           !BCC_EOS
08205                                           ! 1639       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
08206                                           ! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
08207 22EE           8D9E       FE5A            lea	bx,-$1A6[bp]
08208 22F2           53                         push	bx
08209                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08210 22F3           E8         E357            call	_get_SS
08211                                           ! Debug: list unsigned short = ax+0 (used reg = )
08212 22F6           50                         push	ax
08213                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08214 22F7           E8         E2FA            call	_read_byte
08215 22FA           83C4                   04  add	sp,*4
08216 22FD           84C0                       test	al,al
08217 22FF           74           04            je  	.1C3
08218                       00002301            .1C4:
08219 2301           B0                     01  mov	al,*1
08220 2303           EB           02            jmp .1C5
08221                       00002305            .1C3:
08222 2305           30C0                       xor	al,al
08223                       00002307            .1C5:
08224                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
08225 2307           8886       FDDB            mov	-$225[bp],al
08226                                           !BCC_EOS
08227                                           ! 1640       blksize = read_word(get_SS(),buffer+10);
08228                                           ! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
08229 230B           8D9E       FE04            lea	bx,-$1FC[bp]
08230 230F           53                         push	bx
08231                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08232 2310           E8         E33A            call	_get_SS
08233                                           ! Debug: list unsigned short = ax+0 (used reg = )
08234 2313           50                         push	ax
08235                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08236 2314           E8         E2F0            call	_read_word
08237 2317           83C4                   04  add	sp,*4
08238                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
08239 231A           8986       FDDE            mov	-$222[bp],ax
08240                                           !BCC_EOS
08241                                           ! 1641       cylinders = read_word(get_SS(),buffer+(1*2));
08242                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
08243 231E           8D9E       FDFC            lea	bx,-$204[bp]
08244 2322           53                         push	bx
08245                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08246 2323           E8         E327            call	_get_SS
08247                                           ! Debug: list unsigned short = ax+0 (used reg = )
08248 2326           50                         push	ax
08249                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08250 2327           E8         E2DD            call	_read_word
08251 232A           83C4                   04  add	sp,*4
08252                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08253 232D           8986       FDE4            mov	-$21C[bp],ax
08254                                           !BCC_EOS
08255                                           ! 1642       heads = read_word(get_SS(),buffer+(3*2));
08256                                           ! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
08257 2331           8D9E       FE00            lea	bx,-$200[bp]
08258 2335           53                         push	bx
08259                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08260 2336           E8         E314            call	_get_SS
08261                                           ! Debug: list unsigned short = ax+0 (used reg = )
08262 2339           50                         push	ax
08263                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08264 233A           E8         E2CA            call	_read_word
08265 233D           83C4                   04  add	sp,*4
08266                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
08267 2340           8986       FDE2            mov	-$21E[bp],ax
08268                                           !BCC_EOS
08269                                           ! 1643       spt = read_word(get_SS(),buffer+(6*2));
08270                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
08271 2344           8D9E       FE06            lea	bx,-$1FA[bp]
08272 2348           53                         push	bx
08273                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08274 2349           E8         E301            call	_get_SS
08275                                           ! Debug: list unsigned short = ax+0 (used reg = )
08276 234C           50                         push	ax
08277                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08278 234D           E8         E2B7            call	_read_word
08279 2350           83C4                   04  add	sp,*4
08280                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
08281 2353           8986       FDE0            mov	-$220[bp],ax
08282                                           !BCC_EOS
08283                                           ! 1644       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
08284                                           ! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
08285 2357           8D9E       FEA0            lea	bx,-$160[bp]
08286 235B           53                         push	bx
08287                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08288 235C           E8         E2EE            call	_get_SS
08289                                           ! Debug: list unsigned short = ax+0 (used reg = )
08290 235F           50                         push	ax
08291                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08292 2360           E8         E2A4            call	_read_word
08293 2363           83C4                   04  add	sp,*4
08294                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
08295 2366           25                   0400  and	ax,#$400
08296 2369           85C0                       test	ax,ax
08297 236B           74           34            je  	.1C6
08298                       0000236D            .1C7:
08299                                           ! 1645         sectors_low = read_dword(get_SS(),buffer+(100*2));
08300                                           ! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
08301 236D           8D9E       FEC2            lea	bx,-$13E[bp]
08302 2371           53                         push	bx
08303                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08304 2372           E8         E2D8            call	_get_SS
08305                                           ! Debug: list unsigned short = ax+0 (used reg = )
08306 2375           50                         push	ax
08307                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08308 2376           E8         DD0A            call	_read_dword
08309 2379           89D3                       mov	bx,dx
08310 237B           83C4                   04  add	sp,*4
08311                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08312 237E           8986       FDEA            mov	-$216[bp],ax
08313 2382           899E       FDEC            mov	-$214[bp],bx
08314                                           !BCC_EOS
08315                                           ! 1646         sectors_high = read_dword(get_SS(),buffer+(102*2));
08316                                           ! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
08317 2386           8D9E       FEC6            lea	bx,-$13A[bp]
08318 238A           53                         push	bx
08319                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08320 238B           E8         E2BF            call	_get_SS
08321                                           ! Debug: list unsigned short = ax+0 (used reg = )
08322 238E           50                         push	ax
08323                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08324 238F           E8         DCF1            call	_read_dword
08325 2392           89D3                       mov	bx,dx
08326 2394           83C4                   04  add	sp,*4
08327                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08328 2397           8986       FDE6            mov	-$21A[bp],ax
08329 239B           899E       FDE8            mov	-$218[bp],bx
08330                                           !BCC_EOS
08331                                           ! 1647       } else {
08332 239F           EB           25            jmp .1C8
08333                       000023A1            .1C6:
08334                                           ! 1648      
08335                                           ! 1648    sectors_low = read_dword(get_SS(),buffer+(60*2));
08336                                           ! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
08337 23A1           8D9E       FE72            lea	bx,-$18E[bp]
08338 23A5           53                         push	bx
08339                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08340 23A6           E8         E2A4            call	_get_SS
08341                                           ! Debug: list unsigned short = ax+0 (used reg = )
08342 23A9           50                         push	ax
08343                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08344 23AA           E8         DCD6            call	_read_dword
08345 23AD           89D3                       mov	bx,dx
08346 23AF           83C4                   04  add	sp,*4
08347                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08348 23B2           8986       FDEA            mov	-$216[bp],ax
08349 23B6           899E       FDEC            mov	-$214[bp],bx
08350                                           !BCC_EOS
08351                                           ! 1649         sectors_high = 0;
08352                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08353 23BA           31C0                       xor	ax,ax
08354 23BC           31DB                       xor	bx,bx
08355 23BE           8986       FDE6            mov	-$21A[bp],ax
08356 23C2           899E       FDE8            mov	-$218[bp],bx
08357                                           !BCC_EOS
08358                                           ! 1650       }
08359                                           ! 1651       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
08360                       000023C6            .1C8:
08361                                           ! Debug: list int = const $FF (used reg = )
08362 23C6           B8                   00FF  mov	ax,#$FF
08363 23C9           50                         push	ax
08364                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08365 23CA           8A46         FB            mov	al,-5[bp]
08366 23CD           30E4                       xor	ah,ah
08367 23CF           B9                   001E  mov	cx,*$1E
08368 23D2           F7E9                       imul	cx
08369 23D4           89C3                       mov	bx,ax
08370                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08371                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08372 23D6           81C3                 0143  add	bx,#$143
08373 23DA           53                         push	bx
08374                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08375 23DB           FF76         FE            push	-2[bp]
08376                                           ! Debug: func () void = write_byte+0 (used reg = )
08377 23DE           E8         E239            call	_write_byte
08378 23E1           83C4                   06  add	sp,*6
08379                                           !BCC_EOS
08380                                           ! 1652       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
08381                                           ! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
08382 23E4           8A86       FDDC            mov	al,-$224[bp]
08383 23E8           30E4                       xor	ah,ah
08384 23EA           50                         push	ax
08385                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08386 23EB           8A46         FB            mov	al,-5[bp]
08387 23EE           30E4                       xor	ah,ah
08388 23F0           B9                   001E  mov	cx,*$1E
08389 23F3           F7E9                       imul	cx
08390 23F5           89C3                       mov	bx,ax
08391                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08392                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
08393 23F7           81C3                 0144  add	bx,#$144
08394 23FB           53                         push	bx
08395                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08396 23FC           FF76         FE            push	-2[bp]
08397                                           ! Debug: func () void = write_byte+0 (used reg = )
08398 23FF           E8         E218            call	_write_byte
08399 2402           83C4                   06  add	sp,*6
08400                                           !BCC_EOS
08401                                           ! 1653       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
08402                                           ! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
08403 2405           8A86       FDDB            mov	al,-$225[bp]
08404 2409           30E4                       xor	ah,ah
08405 240B           50                         push	ax
08406                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08407 240C           8A46         FB            mov	al,-5[bp]
08408 240F           30E4                       xor	ah,ah
08409 2411           B9                   001E  mov	cx,*$1E
08410 2414           F7E9                       imul	cx
08411 2416           89C3                       mov	bx,ax
08412                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08413                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08414 2418           81C3                 0146  add	bx,#$146
08415 241C           53                         push	bx
08416                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08417 241D           FF76         FE            push	-2[bp]
08418                                           ! Debug: func () void = write_byte+0 (used reg = )
08419 2420           E8         E1F7            call	_write_byte
08420 2423           83C4                   06  add	sp,*6
08421                                           !BCC_EOS
08422                                           ! 1654       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
08423                                           ! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
08424 2426           FFB6       FDDE            push	-$222[bp]
08425                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08426 242A           8A46         FB            mov	al,-5[bp]
08427 242D           30E4                       xor	ah,ah
08428 242F           B9                   001E  mov	cx,*$1E
08429 2432           F7E9                       imul	cx
08430 2434           89C3                       mov	bx,ax
08431                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08432                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
08433 2436           81C3                 0148  add	bx,#$148
08434 243A           53                         push	bx
08435                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08436 243B           FF76         FE            push	-2[bp]
08437                                           ! Debug: func () void = write_word+0 (used reg = )
08438 243E           E8         E1F1            call	_write_word
08439 2441           83C4                   06  add	sp,*6
08440                                           !BCC_EOS
08441                                           ! 1655       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
08442                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08443 2444           FFB6       FDE2            push	-$21E[bp]
08444                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08445 2448           8A46         FB            mov	al,-5[bp]
08446 244B           30E4                       xor	ah,ah
08447 244D           B9                   001E  mov	cx,*$1E
08448 2450           F7E9                       imul	cx
08449 2452           89C3                       mov	bx,ax
08450                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
08451                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
08452 2454           81C3                 0152  add	bx,#$152
08453 2458           53                         push	bx
08454                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08455 2459           FF76         FE            push	-2[bp]
08456                                           ! Debug: func () void = write_word+0 (used reg = )
08457 245C           E8         E1D3            call	_write_word
08458 245F           83C4                   06  add	sp,*6
08459                                           !BCC_EOS
08460                                           ! 1656       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
08461                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08462 2462           FFB6       FDE4            push	-$21C[bp]
08463                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08464 2466           8A46         FB            mov	al,-5[bp]
08465 2469           30E4                       xor	ah,ah
08466 246B           B9                   001E  mov	cx,*$1E
08467 246E           F7E9                       imul	cx
08468 2470           89C3                       mov	bx,ax
08469                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
08470                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
08471 2472           81C3                 0154  add	bx,#$154
08472 2476           53                         push	bx
08473                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08474 2477           FF76         FE            push	-2[bp]
08475                                           ! Debug: func () void = write_word+0 (used reg = )
08476 247A           E8         E1B5            call	_write_word
08477 247D           83C4                   06  add	sp,*6
08478                                           !BCC_EOS
08479                                           ! 1657       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
08480                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08481 2480           FFB6       FDE0            push	-$220[bp]
08482                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08483 2484           8A46         FB            mov	al,-5[bp]
08484 2487           30E4                       xor	ah,ah
08485 2489           B9                   001E  mov	cx,*$1E
08486 248C           F7E9                       imul	cx
08487 248E           89C3                       mov	bx,ax
08488                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
08489                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
08490 2490           81C3                 0156  add	bx,#$156
08491 2494           53                         push	bx
08492                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08493 2495           FF76         FE            push	-2[bp]
08494                                           ! Debug: func () void = write_word+0 (used reg = )
08495 2498           E8         E197            call	_write_word
08496 249B           83C4                   06  add	sp,*6
08497                                           !BCC_EOS
08498                                           ! 1658       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
08499                                           ! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
08500 249E           FFB6       FDEC            push	-$214[bp]
08501 24A2           FFB6       FDEA            push	-$216[bp]
08502                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08503 24A6           8A46         FB            mov	al,-5[bp]
08504 24A9           30E4                       xor	ah,ah
08505 24AB           B9                   001E  mov	cx,*$1E
08506 24AE           F7E9                       imul	cx
08507 24B0           89C3                       mov	bx,ax
08508                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08509                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
08510 24B2           81C3                 0158  add	bx,#$158
08511 24B6           53                         push	bx
08512                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08513 24B7           FF76         FE            push	-2[bp]
08514                                           ! Debug: func () void = write_dword+0 (used reg = )
08515 24BA           E8         DBDE            call	_write_dword
08516 24BD           83C4                   08  add	sp,*8
08517                                           !BCC_EOS
08518                                           ! 1659       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
08519                                           ! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
08520 24C0           FFB6       FDE8            push	-$218[bp]
08521 24C4           FFB6       FDE6            push	-$21A[bp]
08522                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08523 24C8           8A46         FB            mov	al,-5[bp]
08524 24CB           30E4                       xor	ah,ah
08525 24CD           B9                   001E  mov	cx,*$1E
08526 24D0           F7E9                       imul	cx
08527 24D2           89C3                       mov	bx,ax
08528                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08529                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
08530 24D4           81C3                 015C  add	bx,#$15C
08531 24D8           53                         push	bx
08532                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08533 24D9           FF76         FE            push	-2[bp]
08534                                           ! Debug: func () void = write_dword+0 (used reg = )
08535 24DC           E8         DBBC            call	_write_dword
08536 24DF           83C4                   08  add	sp,*8
08537                                           !BCC_EOS
08538                                           ! 1660       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
08539                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08540 24E2           FFB6       FDE0            push	-$220[bp]
08541                                           ! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
08542 24E6           FFB6       FDE2            push	-$21E[bp]
08543                                           ! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
08544 24EA           FFB6       FDE4            push	-$21C[bp]
08545                                           ! Debug: list unsigned char slave = [S+$22E-$20E] (used reg = )
08546 24EE           8A86       FDF4            mov	al,-$20C[bp]
08547 24F2           30E4                       xor	ah,ah
08548 24F4           50                         push	ax
08549                                           ! Debug: list unsigned char channel = [S+$230-$20D] (used reg = )
08550 24F5           8A86       FDF5            mov	al,-$20B[bp]
08551 24F9           30E4                       xor	ah,ah
08552 24FB           50                         push	ax
08553                                           ! Debug: list * char = .1C9+0 (used reg = )
08554 24FC           BB                   DBA9  mov	bx,#.1C9
08555 24FF           53                         push	bx
08556                                           ! Debug: list int = const 4 (used reg = )
08557 2500           B8                   0004  mov	ax,*4
08558 2503           50                         push	ax
08559                                           ! Debug: func () void = bios_printf+0 (used reg = )
08560 2504           E8         E512            call	_bios_printf
08561 2507           83C4                   0E  add	sp,*$E
08562                                           !BCC_EOS
08563                                           ! 1661       translation = inb_cmos(0x39 + channel/2);
08564                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
08565 250A           8A86       FDF5            mov	al,-$20B[bp]
08566 250E           30E4                       xor	ah,ah
08567 2510           D1E8                       shr	ax,*1
08568                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
08569                                           ! Debug: expression subtree swapping
08570                                           ! Debug: list unsigned int = ax+$39 (used reg = )
08571 2512           05                   0039  add	ax,*$39
08572 2515           50                         push	ax
08573                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
08574 2516           E8         E06A            call	_inb_cmos
08575 2519           44                         inc	sp
08576 251A           44                         inc	sp
08577                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
08578 251B           8886       FDDD            mov	-$223[bp],al
08579                                           !BCC_EOS
08580                                           ! 1662       for (shift=device%4; shift>0; shift--) translation >>= 2;
08581                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
08582 251F           8A46         FB            mov	al,-5[bp]
08583 2522           30E4                       xor	ah,ah
08584 2524           24                     03  and	al,*3
08585                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
08586 2526           8886       FDF3            mov	-$20D[bp],al
08587                                           !BCC_EOS
08588                                           !BCC_EOS
08589 252A           EB           17            jmp .1CC
08590                       0000252C            .1CD:
08591                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
08592 252C           8A86       FDDD            mov	al,-$223[bp]
08593 2530           30E4                       xor	ah,ah
08594 2532           D1E8                       shr	ax,*1
08595 2534           D1E8                       shr	ax,*1
08596 2536           8886       FDDD            mov	-$223[bp],al
08597                                           !BCC_EOS
08598                                           ! 1663       translation &= 0x03;
08599                       0000253A            .1CB:
08600                                           ! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
08601 253A           8A86       FDF3            mov	al,-$20D[bp]
08602 253E           48                         dec	ax
08603 253F           8886       FDF3            mov	-$20D[bp],al
08604                       00002543            .1CC:
08605                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
08606 2543           8A86       FDF3            mov	al,-$20D[bp]
08607 2547           84C0                       test	al,al
08608 2549           75           E1            jne	.1CD
08609                       0000254B            .1CE:
08610                       0000254B            .1CA:
08611                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
08612 254B           8A86       FDDD            mov	al,-$223[bp]
08613 254F           24                     03  and	al,*3
08614 2551           8886       FDDD            mov	-$223[bp],al
08615                                           !BCC_EOS
08616                                           ! 1664       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
08617                                           ! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
08618 2555           8A86       FDDD            mov	al,-$223[bp]
08619 2559           30E4                       xor	ah,ah
08620 255B           50                         push	ax
08621                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08622 255C           8A46         FB            mov	al,-5[bp]
08623 255F           30E4                       xor	ah,ah
08624 2561           B9                   001E  mov	cx,*$1E
08625 2564           F7E9                       imul	cx
08626 2566           89C3                       mov	bx,ax
08627                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
08628                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
08629 2568           81C3                 014A  add	bx,#$14A
08630 256C           53                         push	bx
08631                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08632 256D           FF76         FE            push	-2[bp]
08633                                           ! Debug: func () void = write_byte+0 (used reg = )
08634 2570           E8         E0A7            call	_write_byte
08635 2573           83C4                   06  add	sp,*6
08636                                           !BCC_EOS
08637                                           ! 1665       switch (translation) {
08638 2576           8A86       FDDD            mov	al,-$223[bp]
08639 257A           EB           42            jmp .1D1
08640                                           ! 1666         case 0:
08641                                           ! 1667           bios_printf(4, "none");
08642                       0000257C            .1D2:
08643                                           ! Debug: list * char = .1D3+0 (used reg = )
08644 257C           BB                   DBA4  mov	bx,#.1D3
08645 257F           53                         push	bx
08646                                           ! Debug: list int = const 4 (used reg = )
08647 2580           B8                   0004  mov	ax,*4
08648 2583           50                         push	ax
08649                                           ! Debug: func () void = bios_printf+0 (used reg = )
08650 2584           E8         E492            call	_bios_printf
08651 2587           83C4                   04  add	sp,*4
08652                                           !BCC_EOS
08653                                           ! 1668           break;
08654 258A           EB           42            jmp .1CF
08655                                           !BCC_EOS
08656                                           ! 1669         case 1:
08657                                           ! 1670           bios_printf(4, "lba");
08658                       0000258C            .1D4:
08659                                           ! Debug: list * char = .1D5+0 (used reg = )
08660 258C           BB                   DBA0  mov	bx,#.1D5
08661 258F           53                         push	bx
08662                                           ! Debug: list int = const 4 (used reg = )
08663 2590           B8                   0004  mov	ax,*4
08664 2593           50                         push	ax
08665                                           ! Debug: func () void = bios_printf+0 (used reg = )
08666 2594           E8         E482            call	_bios_printf
08667 2597           83C4                   04  add	sp,*4
08668                                           !BCC_EOS
08669                                           ! 1671           break;
08670 259A           EB           32            jmp .1CF
08671                                           !BCC_EOS
08672                                           ! 1672         case 2:
08673                                           ! 1673           bios_printf(4, "large");
08674                       0000259C            .1D6:
08675                                           ! Debug: list * char = .1D7+0 (used reg = )
08676 259C           BB                   DB9A  mov	bx,#.1D7
08677 259F           53                         push	bx
08678                                           ! Debug: list int = const 4 (used reg = )
08679 25A0           B8                   0004  mov	ax,*4
08680 25A3           50                         push	ax
08681                                           ! Debug: func () void = bios_printf+0 (used reg = )
08682 25A4           E8         E472            call	_bios_printf
08683 25A7           83C4                   04  add	sp,*4
08684                                           !BCC_EOS
08685                                           ! 1674           break;
08686 25AA           EB           22            jmp .1CF
08687                                           !BCC_EOS
08688                                           ! 1675         case 3:
08689                                           ! 1676           bios_printf(4, "r-echs");
08690                       000025AC            .1D8:
08691                                           ! Debug: list * char = .1D9+0 (used reg = )
08692 25AC           BB                   DB93  mov	bx,#.1D9
08693 25AF           53                         push	bx
08694                                           ! Debug: list int = const 4 (used reg = )
08695 25B0           B8                   0004  mov	ax,*4
08696 25B3           50                         push	ax
08697                                           ! Debug: func () void = bios_printf+0 (used reg = )
08698 25B4           E8         E462            call	_bios_printf
08699 25B7           83C4                   04  add	sp,*4
08700                                           !BCC_EOS
08701                                           ! 1677           break;
08702 25BA           EB           12            jmp .1CF
08703                                           !BCC_EOS
08704                                           ! 1678         }
08705                                           ! 1679       switch (translation) {
08706 25BC           EB           10            jmp .1CF
08707                       000025BE            .1D1:
08708 25BE           2C                     00  sub	al,*0
08709 25C0           74           BA            je 	.1D2
08710 25C2           2C                     01  sub	al,*1
08711 25C4           74           C6            je 	.1D4
08712 25C6           2C                     01  sub	al,*1
08713 25C8           74           D2            je 	.1D6
08714 25CA           2C                     01  sub	al,*1
08715 25CC           74           DE            je 	.1D8
08716                       000025CE            .1CF:
08717                       FFFFFDD8            ..FFFE	=	-$228
08718 25CE           8A86       FDDD            mov	al,-$223[bp]
08719 25D2           E9         0161            br 	.1DC
08720                                           ! 1680         case 0:
08721                                           ! 1681           break;
08722                       000025D5            .1DD:
08723 25D5           E9         0174            br 	.1DA
08724                                           !BCC_EOS
08725                                           ! 1682         case 1:
08726                                           ! 1683           spt = 63;
08727                       000025D8            .1DE:
08728                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
08729 25D8           B8                   003F  mov	ax,*$3F
08730 25DB           8986       FDE0            mov	-$220[bp],ax
08731                                           !BCC_EOS
08732                                           ! 1684           sectors_low /= 63;
08733                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
08734 25DF           B8                   003F  mov	ax,*$3F
08735 25E2           31DB                       xor	bx,bx
08736 25E4           53                         push	bx
08737 25E5           50                         push	ax
08738 25E6           8B86       FDEA            mov	ax,-$216[bp]
08739 25EA           8B9E       FDEC            mov	bx,-$214[bp]
08740 25EE           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08741 25F2           E8         DB79            call	ldivul
08742 25F5           8986       FDEA            mov	-$216[bp],ax
08743 25F9           899E       FDEC            mov	-$214[bp],bx
08744 25FD           83C4                   04  add	sp,*4
08745                                           !BCC_EOS
08746                                           ! 1685           heads = sectors_low / 1024;
08747                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08748 2600           B8                   0400  mov	ax,#$400
08749 2603           31DB                       xor	bx,bx
08750 2605           53                         push	bx
08751 2606           50                         push	ax
08752 2607           8B86       FDEA            mov	ax,-$216[bp]
08753 260B           8B9E       FDEC            mov	bx,-$214[bp]
08754 260F           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08755 2613           E8         DB58            call	ldivul
08756 2616           83C4                   04  add	sp,*4
08757                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
08758 2619           8986       FDE2            mov	-$21E[bp],ax
08759                                           !BCC_EOS
08760                                           ! 1686           if (heads>128) heads = 255;
08761                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08762 261D           8B86       FDE2            mov	ax,-$21E[bp]
08763 2621           3D                   0080  cmp	ax,#$80
08764 2624           76           09            jbe 	.1DF
08765                       00002626            .1E0:
08766                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
08767 2626           B8                   00FF  mov	ax,#$FF
08768 2629           8986       FDE2            mov	-$21E[bp],ax
08769                                           !BCC_EOS
08770                                           ! 1687           else if (heads>64) heads = 128;
08771 262D           EB           3D            jmp .1E1
08772                       0000262F            .1DF:
08773                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08774 262F           8B86       FDE2            mov	ax,-$21E[bp]
08775 2633           3D                   0040  cmp	ax,*$40
08776 2636           76           09            jbe 	.1E2
08777                       00002638            .1E3:
08778                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08779 2638           B8                   0080  mov	ax,#$80
08780 263B           8986       FDE2            mov	-$21E[bp],ax
08781                                           !BCC_EOS
08782                                           ! 1688           else if (heads>32) heads = 64;
08783 263F           EB           2B            jmp .1E4
08784                       00002641            .1E2:
08785                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08786 2641           8B86       FDE2            mov	ax,-$21E[bp]
08787 2645           3D                   0020  cmp	ax,*$20
08788 2648           76           09            jbe 	.1E5
08789                       0000264A            .1E6:
08790                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08791 264A           B8                   0040  mov	ax,*$40
08792 264D           8986       FDE2            mov	-$21E[bp],ax
08793                                           !BCC_EOS
08794                                           ! 1689           else if (heads>16) heads = 32;
08795 2651           EB           19            jmp .1E7
08796                       00002653            .1E5:
08797                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08798 2653           8B86       FDE2            mov	ax,-$21E[bp]
08799 2657           3D                   0010  cmp	ax,*$10
08800 265A           76           09            jbe 	.1E8
08801                       0000265C            .1E9:
08802                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08803 265C           B8                   0020  mov	ax,*$20
08804 265F           8986       FDE2            mov	-$21E[bp],ax
08805                                           !BCC_EOS
08806                                           ! 1690           else heads=16;
08807 2663           EB           07            jmp .1EA
08808                       00002665            .1E8:
08809                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08810 2665           B8                   0010  mov	ax,*$10
08811 2668           8986       FDE2            mov	-$21E[bp],ax
08812                                           !BCC_EOS
08813                                           ! 1691           cylinders = sectors_low / heads;
08814                       0000266C            .1EA:
08815                       0000266C            .1E7:
08816                       0000266C            .1E4:
08817                       0000266C            .1E1:
08818                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
08819 266C           8B86       FDE2            mov	ax,-$21E[bp]
08820 2670           31DB                       xor	bx,bx
08821                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08822 2672           53                         push	bx
08823 2673           50                         push	ax
08824 2674           8B86       FDEA            mov	ax,-$216[bp]
08825 2678           8B9E       FDEC            mov	bx,-$214[bp]
08826 267C           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08827 2680           E8         DAEB            call	ldivul
08828 2683           83C4                   04  add	sp,*4
08829                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08830 2686           8986       FDE4            mov	-$21C[bp],ax
08831                                           !BCC_EOS
08832                                           ! 1692           break;
08833 268A           E9         00BF            br 	.1DA
08834                                           !BCC_EOS
08835                                           ! 1693         case 3:
08836                                           ! 1694           if (heads==16) {
08837                       0000268D            .1EB:
08838                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08839 268D           8B86       FDE2            mov	ax,-$21E[bp]
08840 2691           3D                   0010  cmp	ax,*$10
08841 2694           75           72            jne 	.1EC
08842                       00002696            .1ED:
08843                                           ! 1695             if(cylinders>61439) cylinders=61439;
08844                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08845 2696           8B86       FDE4            mov	ax,-$21C[bp]
08846 269A           31DB                       xor	bx,bx
08847                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08848 269C           53                         push	bx
08849 269D           50                         push	ax
08850 269E           B8                   EFFF  mov	ax,#$EFFF
08851 26A1           31DB                       xor	bx,bx
08852 26A3           53                         push	bx
08853 26A4           50                         push	ax
08854 26A5           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08855 26A9           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08856 26AD           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08857 26B1           E8         DA17            call	lcmpul
08858 26B4           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08859 26B8           76           07            jbe 	.1EE
08860                       000026BA            .1EF:
08861                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
08862 26BA           B8                   EFFF  mov	ax,#$EFFF
08863 26BD           8986       FDE4            mov	-$21C[bp],ax
08864                                           !BCC_EOS
08865                                           ! 1696            
08866                                           ! 1696  heads=15;
08867                       000026C1            .1EE:
08868                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
08869 26C1           B8                   000F  mov	ax,*$F
08870 26C4           8986       FDE2            mov	-$21E[bp],ax
08871                                           !BCC_EOS
08872                                           ! 1697             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08873                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08874 26C8           8B86       FDE4            mov	ax,-$21C[bp]
08875 26CC           31DB                       xor	bx,bx
08876                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08877 26CE           53                         push	bx
08878 26CF           50                         push	ax
08879 26D0           B8                   0010  mov	ax,*$10
08880 26D3           31DB                       xor	bx,bx
08881 26D5           53                         push	bx
08882 26D6           50                         push	ax
08883 26D7           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08884 26DB           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08885 26DF           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08886 26E3           E8         DA03            call	lmulul
08887 26E6           83C4                   08  add	sp,*8
08888                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08889 26E9           53                         push	bx
08890 26EA           50                         push	ax
08891 26EB           B8                   000F  mov	ax,*$F
08892 26EE           31DB                       xor	bx,bx
08893 26F0           53                         push	bx
08894 26F1           50                         push	ax
08895 26F2           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08896 26F6           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08897 26FA           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08898 26FE           E8         DA6D            call	ldivul
08899 2701           83C4                   08  add	sp,*8
08900                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08901                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08902 2704           8986       FDE4            mov	-$21C[bp],ax
08903                                           !BCC_EOS
08904                                           ! 1698             }
08905                                           ! 1699         case 2:
08906                       00002708            .1EC:
08907                                           ! 1700           while(cylinders > 1024) {
08908                       00002708            .1F0:
08909 2708           EB           1F            jmp .1F2
08910                       0000270A            .1F3:
08911                                           ! 1701             cylinders >>= 1;
08912                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08913 270A           8B86       FDE4            mov	ax,-$21C[bp]
08914 270E           D1E8                       shr	ax,*1
08915 2710           8986       FDE4            mov	-$21C[bp],ax
08916                                           !BCC_EOS
08917                                           ! 1702             heads <<= 1;
08918                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
08919 2714           8B86       FDE2            mov	ax,-$21E[bp]
08920 2718           D1E0                       shl	ax,*1
08921 271A           8986       FDE2            mov	-$21E[bp],ax
08922                                           !BCC_EOS
08923                                           ! 1703             if (heads > 127) break;
08924                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
08925 271E           8B86       FDE2            mov	ax,-$21E[bp]
08926 2722           3D                   007F  cmp	ax,*$7F
08927 2725           76           02            jbe 	.1F4
08928                       00002727            .1F5:
08929 2727           EB           09            jmp .1F1
08930                                           !BCC_EOS
08931                                           ! 1704           }
08932                       00002729            .1F4:
08933                                           ! 1705           break;
08934                       00002729            .1F2:
08935                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08936 2729           8B86       FDE4            mov	ax,-$21C[bp]
08937 272D           3D                   0400  cmp	ax,#$400
08938 2730           77           D8            ja 	.1F3
08939                       00002732            .1F6:
08940                       00002732            .1F1:
08941 2732           EB           18            jmp .1DA
08942                                           !BCC_EOS
08943                                           ! 1706         }
08944                                           ! 1707       if (cylinders > 1024) cylinders=1024;
08945 2734           EB           16            jmp .1DA
08946                       00002736            .1DC:
08947 2736           2C                     00  sub	al,*0
08948 2738         0F84         FE99            beq 	.1DD
08949 273C           2C                     01  sub	al,*1
08950 273E         0F84         FE96            beq 	.1DE
08951 2742           2C                     01  sub	al,*1
08952 2744           74           C2            je 	.1F0
08953 2746           2C                     01  sub	al,*1
08954 2748         0F84         FF41            beq 	.1EB
08955                       0000274C            .1DA:
08956                       FFFFFDD8            ..FFFD	=	-$228
08957                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08958 274C           8B86       FDE4            mov	ax,-$21C[bp]
08959 2750           3D                   0400  cmp	ax,#$400
08960 2753           76           07            jbe 	.1F7
08961                       00002755            .1F8:
08962                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08963 2755           B8                   0400  mov	ax,#$400
08964 2758           8986       FDE4            mov	-$21C[bp],ax
08965                                           !BCC_EOS
08966                                           ! 1708       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
08967                       0000275C            .1F7:
08968                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08969 275C           FFB6       FDE0            push	-$220[bp]
08970                                           ! Debug: list unsigned short heads = [S+$22A-$220] (used reg = )
08971 2760           FFB6       FDE2            push	-$21E[bp]
08972                                           ! Debug: list unsigned short cylinders = [S+$22C-$21E] (used reg = )
08973 2764           FFB6       FDE4            push	-$21C[bp]
08974                                           ! Debug: list * char = .1F9+0 (used reg = )
08975 2768           BB                   DB83  mov	bx,#.1F9
08976 276B           53                         push	bx
08977                                           ! Debug: list int = const 4 (used reg = )
08978 276C           B8                   0004  mov	ax,*4
08979 276F           50                         push	ax
08980                                           ! Debug: func () void = bios_printf+0 (used reg = )
08981 2770           E8         E2A6            call	_bios_printf
08982 2773           83C4                   0A  add	sp,*$A
08983                                           !BCC_EOS
08984                                           ! 1709       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
08985                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08986 2776           FFB6       FDE2            push	-$21E[bp]
08987                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08988 277A           8A46         FB            mov	al,-5[bp]
08989 277D           30E4                       xor	ah,ah
08990 277F           B9                   001E  mov	cx,*$1E
08991 2782           F7E9                       imul	cx
08992 2784           89C3                       mov	bx,ax
08993                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08994                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
08995 2786           81C3                 014C  add	bx,#$14C
08996 278A           53                         push	bx
08997                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08998 278B           FF76         FE            push	-2[bp]
08999                                           ! Debug: func () void = write_word+0 (used reg = )
09000 278E           E8         DEA1            call	_write_word
09001 2791           83C4                   06  add	sp,*6
09002                                           !BCC_EOS
09003                                           ! 1710       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
09004                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
09005 2794           FFB6       FDE4            push	-$21C[bp]
09006                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
09007 2798           8A46         FB            mov	al,-5[bp]
09008 279B           30E4                       xor	ah,ah
09009 279D           B9                   001E  mov	cx,*$1E
09010 27A0           F7E9                       imul	cx
09011 27A2           89C3                       mov	bx,ax
09012                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
09013                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
09014 27A4           81C3                 014E  add	bx,#$14E
09015 27A8           53                         push	bx
09016                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
09017 27A9           FF76         FE            push	-2[bp]
09018                                           ! Debug: func () void = write_word+0 (used reg = )
09019 27AC           E8         DE83            call	_write_word
09020 27AF           83C4                   06  add	sp,*6
09021                                           !BCC_EOS
09022                                           ! 1711       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
09023                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
09024 27B2           FFB6       FDE0            push	-$220[bp]
09025                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
09026 27B6           8A46         FB            mov	al,-5[bp]
09027 27B9           30E4                       xor	ah,ah
09028 27BB           B9                   001E  mov	cx,*$1E
09029 27BE           F7E9                       imul	cx
09030 27C0           89C3                       mov	bx,ax
09031                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
09032                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
09033 27C2           81C3                 0150  add	bx,#$150
09034 27C6           53                         push	bx
09035                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
09036 27C7           FF76         FE            push	-2[bp]
09037                                           ! Debug: func () void = write_word+0 (used reg = )
09038 27CA           E8         DE65            call	_write_word
09039 27CD           83C4                   06  add	sp,*6
09040                                           !BCC_EOS
09041                                           ! 1712       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
09042                                           ! Debug: list unsigned char device = [S+$228-7] (used reg = )
09043 27D0           8A46         FB            mov	al,-5[bp]
09044 27D3           30E4                       xor	ah,ah
09045 27D5           50                         push	ax
09046                                           ! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
09047 27D6           8A46         FD            mov	al,-3[bp]
09048 27D9           30E4                       xor	ah,ah
09049 27DB           89C3                       mov	bx,ax
09050                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
09051                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
09052 27DD           81C3                 0233  add	bx,#$233
09053 27E1           53                         push	bx
09054                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
09055 27E2           FF76         FE            push	-2[bp]
09056                                           ! Debug: func () void = write_byte+0 (used reg = )
09057 27E5           E8         DE32            call	_write_byte
09058 27E8           83C4                   06  add	sp,*6
09059                                           !BCC_EOS
09060                                           ! 1713       hdcount++;
09061                                           ! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
09062 27EB           8A46         FD            mov	al,-3[bp]
09063 27EE           40                         inc	ax
09064 27EF           8846         FD            mov	-3[bp],al
09065                                           !BCC_EOS
09066                                           ! 1714       }
09067 27F2           83C4                   14  add	sp,*$14
09068                                           ! 1715     if(type == 0x03) {
09069                       000027F5            .1BB:
09070                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
09071 27F5           8A46         FA            mov	al,-6[bp]
09072 27F8           3C                     03  cmp	al,*3
09073 27FA         0F85         0186            bne 	.1FA
09074                       000027FE            .1FB:
09075                                           ! 1716       Bit8u type, removable, mode;
09076                                           !BCC_EOS
09077                                           ! 1717       Bit16u blksize;
09078                                           !BCC_EOS
09079                                           ! 1718       mode = 0x00;
09080 27FE           83C4                   FA  add	sp,*-6
09081                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
09082 2801           30C0                       xor	al,al
09083 2803           8886       FDEB            mov	-$215[bp],al
09084                                           !BCC_EOS
09085                                           ! 1719       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
09086                                           ! Debug: list int = const 5 (used reg = )
09087 2807           B8                   0005  mov	ax,*5
09088 280A           50                         push	ax
09089                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09090 280B           8A46         FB            mov	al,-5[bp]
09091 280E           30E4                       xor	ah,ah
09092 2810           B9                   001E  mov	cx,*$1E
09093 2813           F7E9                       imul	cx
09094 2815           89C3                       mov	bx,ax
09095                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09096                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09097 2817           81C3                 0143  add	bx,#$143
09098 281B           53                         push	bx
09099                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09100 281C           FF76         FE            push	-2[bp]
09101                                           ! Debug: func () void = write_byte+0 (used reg = )
09102 281F           E8         DDF8            call	_write_byte
09103 2822           83C4                   06  add	sp,*6
09104                                           !BCC_EOS
09105                                           ! 1720       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
09106                                           ! Debug: list int = const 0 (used reg = )
09107 2825           31C0                       xor	ax,ax
09108 2827           50                         push	ax
09109                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09110 2828           8A46         FB            mov	al,-5[bp]
09111 282B           30E4                       xor	ah,ah
09112 282D           B9                   001E  mov	cx,*$1E
09113 2830           F7E9                       imul	cx
09114 2832           89C3                       mov	bx,ax
09115                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09116                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09117 2834           81C3                 0146  add	bx,#$146
09118 2838           53                         push	bx
09119                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09120 2839           FF76         FE            push	-2[bp]
09121                                           ! Debug: func () void = write_byte+0 (used reg = )
09122 283C           E8         DDDB            call	_write_byte
09123 283F           83C4                   06  add	sp,*6
09124                                           !BCC_EOS
09125                                           ! 1721       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
09126                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
09127 2842           8D9E       FDFA            lea	bx,-$206[bp]
09128 2846           53                         push	bx
09129                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09130 2847           E8         DE03            call	_get_SS
09131                                           ! Debug: list unsigned short = ax+0 (used reg = )
09132 284A           50                         push	ax
09133                                           ! Debug: list long = const 0 (used reg = )
09134 284B           31C0                       xor	ax,ax
09135 284D           31DB                       xor	bx,bx
09136 284F           53                         push	bx
09137 2850           50                         push	ax
09138                                           ! Debug: list long = const 0 (used reg = )
09139 2851           31C0                       xor	ax,ax
09140 2853           31DB                       xor	bx,bx
09141 2855           53                         push	bx
09142 2856           50                         push	ax
09143                                           ! Debug: list int = const 0 (used reg = )
09144 2857           31C0                       xor	ax,ax
09145 2859           50                         push	ax
09146                                           ! Debug: list int = const 0 (used reg = )
09147 285A           31C0                       xor	ax,ax
09148 285C           50                         push	ax
09149                                           ! Debug: list int = const 0 (used reg = )
09150 285D           31C0                       xor	ax,ax
09151 285F           50                         push	ax
09152                                           ! Debug: list int = const 1 (used reg = )
09153 2860           B8                   0001  mov	ax,*1
09154 2863           50                         push	ax
09155                                           ! Debug: list int = const $A1 (used reg = )
09156 2864           B8                   00A1  mov	ax,#$A1
09157 2867           50                         push	ax
09158                                           ! Debug: list unsigned char device = [S+$230-7] (used reg = )
09159 2868           8A46         FB            mov	al,-5[bp]
09160 286B           30E4                       xor	ah,ah
09161 286D           50                         push	ax
09162                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
09163 286E           E8         06A5            call	_ata_cmd_data_in
09164 2871           83C4                   18  add	sp,*$18
09165                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
09166 2874           85C0                       test	ax,ax
09167 2876           74           0E            je  	.1FC
09168                       00002878            .1FD:
09169                                           ! 1722         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
09170                                           ! Debug: list * char = .1FE+0 (used reg = )
09171 2878           BB                   DB58  mov	bx,#.1FE
09172 287B           53                         push	bx
09173                                           ! Debug: list int = const 7 (used reg = )
09174 287C           B8                   0007  mov	ax,*7
09175 287F           50                         push	ax
09176                                           ! Debug: func () void = bios_printf+0 (used reg = )
09177 2880           E8         E196            call	_bios_printf
09178 2883           83C4                   04  add	sp,*4
09179                                           !BCC_EOS
09180                                           ! 1723       type = read_byte(get_SS(),buffer+1) & 0x1f;
09181                       00002886            .1FC:
09182                                           ! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
09183 2886           8D9E       FDFB            lea	bx,-$205[bp]
09184 288A           53                         push	bx
09185                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09186 288B           E8         DDBF            call	_get_SS
09187                                           ! Debug: list unsigned short = ax+0 (used reg = )
09188 288E           50                         push	ax
09189                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09190 288F           E8         DD62            call	_read_byte
09191 2892           83C4                   04  add	sp,*4
09192                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
09193 2895           24                     1F  and	al,*$1F
09194                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
09195 2897           8886       FDED            mov	-$213[bp],al
09196                                           !BCC_EOS
09197                                           ! 1724       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
09198                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
09199 289B           8D9E       FDFA            lea	bx,-$206[bp]
09200 289F           53                         push	bx
09201                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09202 28A0           E8         DDAA            call	_get_SS
09203                                           ! Debug: list unsigned short = ax+0 (used reg = )
09204 28A3           50                         push	ax
09205                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09206 28A4           E8         DD4D            call	_read_byte
09207 28A7           83C4                   04  add	sp,*4
09208                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
09209 28AA           24                     80  and	al,#$80
09210 28AC           84C0                       test	al,al
09211 28AE           74           04            je  	.1FF
09212                       000028B0            .200:
09213 28B0           B0                     01  mov	al,*1
09214 28B2           EB           02            jmp .201
09215                       000028B4            .1FF:
09216 28B4           30C0                       xor	al,al
09217                       000028B6            .201:
09218                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
09219 28B6           8886       FDEC            mov	-$214[bp],al
09220                                           !BCC_EOS
09221                                           ! 1725       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
09222                                           ! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
09223 28BA           8D9E       FE5A            lea	bx,-$1A6[bp]
09224 28BE           53                         push	bx
09225                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09226 28BF           E8         DD8B            call	_get_SS
09227                                           ! Debug: list unsigned short = ax+0 (used reg = )
09228 28C2           50                         push	ax
09229                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09230 28C3           E8         DD2E            call	_read_byte
09231 28C6           83C4                   04  add	sp,*4
09232 28C9           84C0                       test	al,al
09233 28CB           74           04            je  	.202
09234                       000028CD            .203:
09235 28CD           B0                     01  mov	al,*1
09236 28CF           EB           02            jmp .204
09237                       000028D1            .202:
09238 28D1           30C0                       xor	al,al
09239                       000028D3            .204:
09240                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
09241 28D3           8886       FDEB            mov	-$215[bp],al
09242                                           !BCC_EOS
09243                                           ! 1726       blksize = 2048;
09244                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
09245 28D7           B8                   0800  mov	ax,#$800
09246 28DA           8986       FDE8            mov	-$218[bp],ax
09247                                           !BCC_EOS
09248                                           ! 1727       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
09249                                           ! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
09250 28DE           8A86       FDED            mov	al,-$213[bp]
09251 28E2           30E4                       xor	ah,ah
09252 28E4           50                         push	ax
09253                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09254 28E5           8A46         FB            mov	al,-5[bp]
09255 28E8           30E4                       xor	ah,ah
09256 28EA           B9                   001E  mov	cx,*$1E
09257 28ED           F7E9                       imul	cx
09258 28EF           89C3                       mov	bx,ax
09259                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09260                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09261 28F1           81C3                 0143  add	bx,#$143
09262 28F5           53                         push	bx
09263                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09264 28F6           FF76         FE            push	-2[bp]
09265                                           ! Debug: func () void = write_byte+0 (used reg = )
09266 28F9           E8         DD1E            call	_write_byte
09267 28FC           83C4                   06  add	sp,*6
09268                                           !BCC_EOS
09269                                           ! 1728       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
09270                                           ! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
09271 28FF           8A86       FDEC            mov	al,-$214[bp]
09272 2903           30E4                       xor	ah,ah
09273 2905           50                         push	ax
09274                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09275 2906           8A46         FB            mov	al,-5[bp]
09276 2909           30E4                       xor	ah,ah
09277 290B           B9                   001E  mov	cx,*$1E
09278 290E           F7E9                       imul	cx
09279 2910           89C3                       mov	bx,ax
09280                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
09281                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
09282 2912           81C3                 0144  add	bx,#$144
09283 2916           53                         push	bx
09284                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09285 2917           FF76         FE            push	-2[bp]
09286                                           ! Debug: func () void = write_byte+0 (used reg = )
09287 291A           E8         DCFD            call	_write_byte
09288 291D           83C4                   06  add	sp,*6
09289                                           !BCC_EOS
09290                                           ! 1729       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
09291                                           ! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
09292 2920           8A86       FDEB            mov	al,-$215[bp]
09293 2924           30E4                       xor	ah,ah
09294 2926           50                         push	ax
09295                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09296 2927           8A46         FB            mov	al,-5[bp]
09297 292A           30E4                       xor	ah,ah
09298 292C           B9                   001E  mov	cx,*$1E
09299 292F           F7E9                       imul	cx
09300 2931           89C3                       mov	bx,ax
09301                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09302                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09303 2933           81C3                 0146  add	bx,#$146
09304 2937           53                         push	bx
09305                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09306 2938           FF76         FE            push	-2[bp]
09307                                           ! Debug: func () void = write_byte+0 (used reg = )
09308 293B           E8         DCDC            call	_write_byte
09309 293E           83C4                   06  add	sp,*6
09310                                           !BCC_EOS
09311                                           ! 1730       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
09312                                           ! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
09313 2941           FFB6       FDE8            push	-$218[bp]
09314                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09315 2945           8A46         FB            mov	al,-5[bp]
09316 2948           30E4                       xor	ah,ah
09317 294A           B9                   001E  mov	cx,*$1E
09318 294D           F7E9                       imul	cx
09319 294F           89C3                       mov	bx,ax
09320                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09321                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
09322 2951           81C3                 0148  add	bx,#$148
09323 2955           53                         push	bx
09324                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09325 2956           FF76         FE            push	-2[bp]
09326                                           ! Debug: func () void = write_word+0 (used reg = )
09327 2959           E8         DCD6            call	_write_word
09328 295C           83C4                   06  add	sp,*6
09329                                           !BCC_EOS
09330                                           ! 1731       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
09331                                           ! Debug: list unsigned char device = [S+$21A-7] (used reg = )
09332 295F           8A46         FB            mov	al,-5[bp]
09333 2962           30E4                       xor	ah,ah
09334 2964           50                         push	ax
09335                                           ! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
09336 2965           8A46         FC            mov	al,-4[bp]
09337 2968           30E4                       xor	ah,ah
09338 296A           89C3                       mov	bx,ax
09339                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
09340                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
09341 296C           81C3                 023C  add	bx,#$23C
09342 2970           53                         push	bx
09343                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09344 2971           FF76         FE            push	-2[bp]
09345                                           ! Debug: func () void = write_byte+0 (used reg = )
09346 2974           E8         DCA3            call	_write_byte
09347 2977           83C4                   06  add	sp,*6
09348                                           !BCC_EOS
09349                                           ! 1732       cdcount++;
09350                                           ! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
09351 297A           8A46         FC            mov	al,-4[bp]
09352 297D           40                         inc	ax
09353 297E           8846         FC            mov	-4[bp],al
09354                                           !BCC_EOS
09355                                           ! 1733       }
09356 2981           83C4                   06  add	sp,*6
09357                                           ! 1734       {
09358                       00002984            .1FA:
09359                                           ! 1735       Bit32u sizeinmb;
09360                                           !BCC_EOS
09361                                           ! 1736       Bit16u ataversion;
09362                                           !BCC_EOS
09363                                           ! 1737       Bit8u c, i, version, model[41];
09364                                           !BCC_EOS
09365                                           ! 1738       switch (type) {
09366 2984           83C4                   CE  add	sp,*-$32
09367 2987           8A46         FA            mov	al,-6[bp]
09368 298A           E9         020B            br 	.207
09369                                           ! 1739         case 0x02:
09370                                           ! 1740           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) <
09371                       0000298D            .208:
09372                                           ! 1740 < 21)
09373                                           ! 1741             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
09374                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09375 298D           8A46         FB            mov	al,-5[bp]
09376 2990           30E4                       xor	ah,ah
09377 2992           B9                   001E  mov	cx,*$1E
09378 2995           F7E9                       imul	cx
09379 2997           89C3                       mov	bx,ax
09380                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
09381                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
09382 2999           81C3                 0158  add	bx,#$158
09383 299D           53                         push	bx
09384                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09385 299E           FF76         FE            push	-2[bp]
09386                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09387 29A1           E8         D6DF            call	_read_dword
09388 29A4           89D3                       mov	bx,dx
09389 29A6           83C4                   04  add	sp,*4
09390                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
09391 29A9           88E0                       mov	al,ah
09392 29AB           88DC                       mov	ah,bl
09393 29AD           88FB                       mov	bl,bh
09394 29AF           28FF                       sub	bh,bh
09395 29B1           BF                   0003  mov	di,*3
09396 29B4           E8         D772            call	lsrul
09397 29B7           53                         push	bx
09398 29B8           50                         push	ax
09399                                           ! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
09400 29B9           8A46         FB            mov	al,-5[bp]
09401 29BC           30E4                       xor	ah,ah
09402 29BE           B9                   001E  mov	cx,*$1E
09403 29C1           F7E9                       imul	cx
09404 29C3           89C3                       mov	bx,ax
09405                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
09406                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
09407 29C5           81C3                 015C  add	bx,#$15C
09408 29C9           53                         push	bx
09409                                           ! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
09410 29CA           FF76         FE            push	-2[bp]
09411                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09412 29CD           E8         D6B3            call	_read_dword
09413 29D0           89D3                       mov	bx,dx
09414 29D2           83C4                   04  add	sp,*4
09415                                           ! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
09416 29D5           B1                     05  mov	cl,*5
09417 29D7           D3E0                       shl	ax,cl
09418 29D9           93                         xchg	bx,ax
09419 29DA           31C0                       xor	ax,ax
09420                                           ! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
09421 29DC           8DBE       FDB8            lea	di,-2+..FFFC[bp]
09422 29E0           E8         D724            call	lorul
09423 29E3           83C4                   04  add	sp,*4
09424                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09425 29E6           8986       FDEA            mov	-$216[bp],ax
09426 29EA           899E       FDEC            mov	-$214[bp],bx
09427                                           !BCC_EOS
09428                                           ! 1742         case 0x03:
09429                                           ! 1743           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
09430                       000029EE            .209:
09431                                           ! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
09432 29EE           8D9E       FE9A            lea	bx,-$166[bp]
09433 29F2           53                         push	bx
09434                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09435 29F3           E8         DC57            call	_get_SS
09436                                           ! Debug: list unsigned short = ax+0 (used reg = )
09437 29F6           50                         push	ax
09438                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09439 29F7           E8         DBFA            call	_read_byte
09440 29FA           83C4                   04  add	sp,*4
09441 29FD           50                         push	ax
09442                                           ! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
09443 29FE           8D9E       FE9B            lea	bx,-$165[bp]
09444 2A02           53                         push	bx
09445                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09446 2A03           E8         DC47            call	_get_SS
09447                                           ! Debug: list unsigned short = ax+0 (used reg = )
09448 2A06           50                         push	ax
09449                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09450 2A07           E8         DBEA            call	_read_byte
09451 2A0A           83C4                   04  add	sp,*4
09452                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
09453 2A0D           30E4                       xor	ah,ah
09454                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
09455 2A0F           88C4                       mov	ah,al
09456 2A11           30C0                       xor	al,al
09457                                           ! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
09458 2A13           0A86       FDBA            or	al,0+..FFFC[bp]
09459 2A17           44                         inc	sp
09460 2A18           44                         inc	sp
09461                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09462 2A19           8986       FDE8            mov	-$218[bp],ax
09463                                           !BCC_EOS
09464                                           ! 1744           for(version=15;version>0;version--) {
09465                                           ! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
09466 2A1D           B0                     0F  mov	al,*$F
09467 2A1F           8886       FDE5            mov	-$21B[bp],al
09468                                           !BCC_EOS
09469                                           !BCC_EOS
09470 2A23           EB           22            jmp .20C
09471                       00002A25            .20D:
09472                                           ! 1745             if((ataversion&(1<<version))!=0)
09473                                           ! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
09474 2A25           8A86       FDE5            mov	al,-$21B[bp]
09475 2A29           30E4                       xor	ah,ah
09476 2A2B           89C3                       mov	bx,ax
09477 2A2D           B8                   0001  mov	ax,*1
09478 2A30           89D9                       mov	cx,bx
09479 2A32           D3E0                       shl	ax,cl
09480                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09481                                           ! Debug: expression subtree swapping
09482 2A34           2386       FDE8            and	ax,-$218[bp]
09483                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
09484 2A38           85C0                       test	ax,ax
09485 2A3A           74           02            je  	.20E
09486                       00002A3C            .20F:
09487                                           ! 1746             break;
09488 2A3C           EB           11            jmp .20A
09489                                           !BCC_EOS
09490                                           ! 1747             }
09491                       00002A3E            .20E:
09492                                           ! 1748           for(i=0;i<20;i++){
09493                       00002A3E            .20B:
09494                                           ! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
09495 2A3E           8A86       FDE5            mov	al,-$21B[bp]
09496 2A42           48                         dec	ax
09497 2A43           8886       FDE5            mov	-$21B[bp],al
09498                       00002A47            .20C:
09499                                           ! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
09500 2A47           8A86       FDE5            mov	al,-$21B[bp]
09501 2A4B           84C0                       test	al,al
09502 2A4D           75           D6            jne	.20D
09503                       00002A4F            .210:
09504                       00002A4F            .20A:
09505                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09506 2A4F           30C0                       xor	al,al
09507 2A51           8886       FDE6            mov	-$21A[bp],al
09508                                           !BCC_EOS
09509                                           !BCC_EOS
09510 2A55           EB           7B            jmp .213
09511                       00002A57            .214:
09512                                           ! 1749             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
09513                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09514 2A57           8A86       FDE6            mov	al,-$21A[bp]
09515 2A5B           30E4                       xor	ah,ah
09516 2A5D           D1E0                       shl	ax,*1
09517                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09518 2A5F           89EB                       mov	bx,bp
09519 2A61           01C3                       add	bx,ax
09520                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09521                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
09522                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
09523                                           ! Debug: list * unsigned char = bx-$1CF (used reg = )
09524 2A63           81C3                 FE31  add	bx,#-$1CF
09525 2A67           53                         push	bx
09526                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09527 2A68           E8         DBE2            call	_get_SS
09528                                           ! Debug: list unsigned short = ax+0 (used reg = )
09529 2A6B           50                         push	ax
09530                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09531 2A6C           E8         DB85            call	_read_byte
09532 2A6F           83C4                   04  add	sp,*4
09533                                           ! Debug: list unsigned char = al+0 (used reg = )
09534 2A72           30E4                       xor	ah,ah
09535 2A74           50                         push	ax
09536                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09537 2A75           8A86       FDE6            mov	al,-$21A[bp]
09538 2A79           30E4                       xor	ah,ah
09539 2A7B           D1E0                       shl	ax,*1
09540                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09541 2A7D           89EB                       mov	bx,bp
09542 2A7F           01C3                       add	bx,ax
09543                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09544                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09545 2A81           81C3                 FDBC  add	bx,#-$244
09546 2A85           53                         push	bx
09547                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09548 2A86           E8         DBC4            call	_get_SS
09549                                           ! Debug: list unsigned short = ax+0 (used reg = )
09550 2A89           50                         push	ax
09551                                           ! Debug: func () void = write_byte+0 (used reg = )
09552 2A8A           E8         DB8D            call	_write_byte
09553 2A8D           83C4                   06  add	sp,*6
09554                                           !BCC_EOS
09555                                           ! 1750             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
09556                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09557 2A90           8A86       FDE6            mov	al,-$21A[bp]
09558 2A94           30E4                       xor	ah,ah
09559 2A96           D1E0                       shl	ax,*1
09560                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09561 2A98           89EB                       mov	bx,bp
09562 2A9A           01C3                       add	bx,ax
09563                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09564                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
09565                                           ! Debug: list * unsigned char = bx-$1D0 (used reg = )
09566 2A9C           81C3                 FE30  add	bx,#-$1D0
09567 2AA0           53                         push	bx
09568                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09569 2AA1           E8         DBA9            call	_get_SS
09570                                           ! Debug: list unsigned short = ax+0 (used reg = )
09571 2AA4           50                         push	ax
09572                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09573 2AA5           E8         DB4C            call	_read_byte
09574 2AA8           83C4                   04  add	sp,*4
09575                                           ! Debug: list unsigned char = al+0 (used reg = )
09576 2AAB           30E4                       xor	ah,ah
09577 2AAD           50                         push	ax
09578                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09579 2AAE           8A86       FDE6            mov	al,-$21A[bp]
09580 2AB2           30E4                       xor	ah,ah
09581 2AB4           D1E0                       shl	ax,*1
09582                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09583 2AB6           89EB                       mov	bx,bp
09584 2AB8           01C3                       add	bx,ax
09585                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
09586                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
09587                                           ! Debug: list * unsigned char = bx-$243 (used reg = )
09588 2ABA           81C3                 FDBD  add	bx,#-$243
09589 2ABE           53                         push	bx
09590                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09591 2ABF           E8         DB8B            call	_get_SS
09592                                           ! Debug: list unsigned short = ax+0 (used reg = )
09593 2AC2           50                         push	ax
09594                                           ! Debug: func () void = write_byte+0 (used reg = )
09595 2AC3           E8         DB54            call	_write_byte
09596 2AC6           83C4                   06  add	sp,*6
09597                                           !BCC_EOS
09598                                           ! 1751           }
09599                                           ! 1752           write_byte(get_SS(),model+40,0x00);
09600                       00002AC9            .212:
09601                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09602 2AC9           8A86       FDE6            mov	al,-$21A[bp]
09603 2ACD           40                         inc	ax
09604 2ACE           8886       FDE6            mov	-$21A[bp],al
09605                       00002AD2            .213:
09606                                           ! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
09607 2AD2           8A86       FDE6            mov	al,-$21A[bp]
09608 2AD6           3C                     14  cmp	al,*$14
09609 2AD8         0F82         FF7B            blo 	.214
09610                       00002ADC            .215:
09611                       00002ADC            .211:
09612                                           ! Debug: list int = const 0 (used reg = )
09613 2ADC           31C0                       xor	ax,ax
09614 2ADE           50                         push	ax
09615                                           ! Debug: list * unsigned char model = S+$248-$21E (used reg = )
09616 2ADF           8D9E       FDE4            lea	bx,-$21C[bp]
09617 2AE3           53                         push	bx
09618                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09619 2AE4           E8         DB66            call	_get_SS
09620                                           ! Debug: list unsigned short = ax+0 (used reg = )
09621 2AE7           50                         push	ax
09622                                           ! Debug: func () void = write_byte+0 (used reg = )
09623 2AE8           E8         DB2F            call	_write_byte
09624 2AEB           83C4                   06  add	sp,*6
09625                                           !BCC_EOS
09626                                           ! 1753           for(i=39;i>0;i--){
09627                                           ! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
09628 2AEE           B0                     27  mov	al,*$27
09629 2AF0           8886       FDE6            mov	-$21A[bp],al
09630                                           !BCC_EOS
09631                                           !BCC_EOS
09632 2AF4           EB           46            jmp .218
09633                       00002AF6            .219:
09634                                           ! 1754             if(read_byte(get_SS(),model+i)==0x20)
09635                                           ! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
09636 2AF6           8A86       FDE6            mov	al,-$21A[bp]
09637 2AFA           30E4                       xor	ah,ah
09638 2AFC           89EB                       mov	bx,bp
09639 2AFE           01C3                       add	bx,ax
09640                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09641                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09642 2B00           81C3                 FDBC  add	bx,#-$244
09643 2B04           53                         push	bx
09644                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09645 2B05           E8         DB45            call	_get_SS
09646                                           ! Debug: list unsigned short = ax+0 (used reg = )
09647 2B08           50                         push	ax
09648                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09649 2B09           E8         DAE8            call	_read_byte
09650 2B0C           83C4                   04  add	sp,*4
09651                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
09652 2B0F           3C                     20  cmp	al,*$20
09653 2B11           75           1E            jne 	.21A
09654                       00002B13            .21B:
09655                                           ! 1755               write_byte(get_SS(),model+i,0x00);
09656                                           ! Debug: list int = const 0 (used reg = )
09657 2B13           31C0                       xor	ax,ax
09658 2B15           50                         push	ax
09659                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09660 2B16           8A86       FDE6            mov	al,-$21A[bp]
09661 2B1A           30E4                       xor	ah,ah
09662 2B1C           89EB                       mov	bx,bp
09663 2B1E           01C3                       add	bx,ax
09664                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09665                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09666 2B20           81C3                 FDBC  add	bx,#-$244
09667 2B24           53                         push	bx
09668                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09669 2B25           E8         DB25            call	_get_SS
09670                                           ! Debug: list unsigned short = ax+0 (used reg = )
09671 2B28           50                         push	ax
09672                                           ! Debug: func () void = write_byte+0 (used reg = )
09673 2B29           E8         DAEE            call	_write_byte
09674 2B2C           83C4                   06  add	sp,*6
09675                                           !BCC_EOS
09676                                           ! 1756             else break;
09677 2B2F           EB           02            jmp .21C
09678                       00002B31            .21A:
09679 2B31           EB           11            jmp .216
09680                                           !BCC_EOS
09681                                           ! 1757           }
09682                       00002B33            .21C:
09683                                           ! 1758           if (i>36) {
09684                       00002B33            .217:
09685                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09686 2B33           8A86       FDE6            mov	al,-$21A[bp]
09687 2B37           48                         dec	ax
09688 2B38           8886       FDE6            mov	-$21A[bp],al
09689                       00002B3C            .218:
09690                                           ! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09691 2B3C           8A86       FDE6            mov	al,-$21A[bp]
09692 2B40           84C0                       test	al,al
09693 2B42           75           B2            jne	.219
09694                       00002B44            .21D:
09695                       00002B44            .216:
09696                                           ! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
09697 2B44           8A86       FDE6            mov	al,-$21A[bp]
09698 2B48           3C                     24  cmp	al,*$24
09699 2B4A           76           48            jbe 	.21E
09700                       00002B4C            .21F:
09701                                           ! 1759             write_byte(get_SS(),model+36,0x00);
09702                                           ! Debug: list int = const 0 (used reg = )
09703 2B4C           31C0                       xor	ax,ax
09704 2B4E           50                         push	ax
09705                                           ! Debug: list * unsigned char model = S+$248-$222 (used reg = )
09706 2B4F           8D9E       FDE0            lea	bx,-$220[bp]
09707 2B53           53                         push	bx
09708                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09709 2B54           E8         DAF6            call	_get_SS
09710                                           ! Debug: list unsigned short = ax+0 (used reg = )
09711 2B57           50                         push	ax
09712                                           ! Debug: func () void = write_byte+0 (used reg = )
09713 2B58           E8         DABF            call	_write_byte
09714 2B5B           83C4                   06  add	sp,*6
09715                                           !BCC_EOS
09716                                           ! 1760             for(i=35;i>32;i--){
09717                                           ! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
09718 2B5E           B0                     23  mov	al,*$23
09719 2B60           8886       FDE6            mov	-$21A[bp],al
09720                                           !BCC_EOS
09721                                           !BCC_EOS
09722 2B64           EB           26            jmp .222
09723                       00002B66            .223:
09724                                           ! 1761               write_byte(get_SS(),model+i,0x2E);
09725                                           ! Debug: list int = const $2E (used reg = )
09726 2B66           B8                   002E  mov	ax,*$2E
09727 2B69           50                         push	ax
09728                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09729 2B6A           8A86       FDE6            mov	al,-$21A[bp]
09730 2B6E           30E4                       xor	ah,ah
09731 2B70           89EB                       mov	bx,bp
09732 2B72           01C3                       add	bx,ax
09733                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09734                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09735 2B74           81C3                 FDBC  add	bx,#-$244
09736 2B78           53                         push	bx
09737                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09738 2B79           E8         DAD1            call	_get_SS
09739                                           ! Debug: list unsigned short = ax+0 (used reg = )
09740 2B7C           50                         push	ax
09741                                           ! Debug: func () void = write_byte+0 (used reg = )
09742 2B7D           E8         DA9A            call	_write_byte
09743 2B80           83C4                   06  add	sp,*6
09744                                           !BCC_EOS
09745                                           ! 1762             }
09746                                           ! 1763           }
09747                       00002B83            .221:
09748                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09749 2B83           8A86       FDE6            mov	al,-$21A[bp]
09750 2B87           48                         dec	ax
09751 2B88           8886       FDE6            mov	-$21A[bp],al
09752                       00002B8C            .222:
09753                                           ! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
09754 2B8C           8A86       FDE6            mov	al,-$21A[bp]
09755 2B90           3C                     20  cmp	al,*$20
09756 2B92           77           D2            ja 	.223
09757                       00002B94            .224:
09758                       00002B94            .220:
09759                                           ! 1764           break;
09760                       00002B94            .21E:
09761 2B94           EB           0E            jmp .205
09762                                           !BCC_EOS
09763                                           ! 1765         }
09764                                           ! 1766       switch (type) {
09765 2B96           EB           0C            jmp .205
09766                       00002B98            .207:
09767 2B98           2C                     02  sub	al,*2
09768 2B9A         0F84         FDEF            beq 	.208
09769 2B9E           2C                     01  sub	al,*1
09770 2BA0         0F84         FE4A            beq 	.209
09771                       00002BA4            .205:
09772                       FFFFFDBA            ..FFFC	=	-$246
09773 2BA4           8A46         FA            mov	al,-6[bp]
09774 2BA7           E9         01A2            br 	.227
09775                                           ! 1767         case 0x02:
09776                                           ! 1768           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09777                       00002BAA            .228:
09778 2BAA           8A86       FDF4            mov	al,-$20C[bp]
09779 2BAE           84C0                       test	al,al
09780 2BB0           74           05            je  	.22C
09781                       00002BB2            .22D:
09782 2BB2           BB                   DB46  mov	bx,#.22A
09783 2BB5           EB           03            jmp .22E
09784                       00002BB7            .22C:
09785 2BB7           BB                   DB3F  mov	bx,#.22B
09786                       00002BBA            .22E:
09787                                           ! Debug: list * char = bx+0 (used reg = )
09788 2BBA           53                         push	bx
09789                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09790 2BBB           8A86       FDF5            mov	al,-$20B[bp]
09791 2BBF           30E4                       xor	ah,ah
09792 2BC1           50                         push	ax
09793                                           ! Debug: list * char = .229+0 (used reg = )
09794 2BC2           BB                   DB4D  mov	bx,#.229
09795 2BC5           53                         push	bx
09796                                           ! Debug: list int = const 2 (used reg = )
09797 2BC6           B8                   0002  mov	ax,*2
09798 2BC9           50                         push	ax
09799                                           ! Debug: func () void = bios_printf+0 (used reg = )
09800 2BCA           E8         DE4C            call	_bios_printf
09801 2BCD           83C4                   08  add	sp,*8
09802                                           !BCC_EOS
09803                                           ! 1769           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09804                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09805 2BD0           30C0                       xor	al,al
09806 2BD2           8886       FDE6            mov	-$21A[bp],al
09807                                           !BCC_EOS
09808 2BD6           EB           15            jmp .230
09809                       00002BD8            .231:
09810                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09811 2BD8           8A86       FDE7            mov	al,-$219[bp]
09812 2BDC           30E4                       xor	ah,ah
09813 2BDE           50                         push	ax
09814                                           ! Debug: list * char = .232+0 (used reg = )
09815 2BDF           BB                   DB3C  mov	bx,#.232
09816 2BE2           53                         push	bx
09817                                           ! Debug: list int = const 2 (used reg = )
09818 2BE3           B8                   0002  mov	ax,*2
09819 2BE6           50                         push	ax
09820                                           ! Debug: func () void = bios_printf+0 (used reg = )
09821 2BE7           E8         DE2F            call	_bios_printf
09822 2BEA           83C4                   06  add	sp,*6
09823                                           !BCC_EOS
09824                                           ! 1770    if (sizeinmb < (1UL<<16))
09825                       00002BED            .230:
09826                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09827 2BED           8A86       FDE6            mov	al,-$21A[bp]
09828 2BF1           40                         inc	ax
09829 2BF2           8886       FDE6            mov	-$21A[bp],al
09830                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09831 2BF6           48                         dec	ax
09832 2BF7           30E4                       xor	ah,ah
09833 2BF9           89EB                       mov	bx,bp
09834 2BFB           01C3                       add	bx,ax
09835                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09836                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09837 2BFD           81C3                 FDBC  add	bx,#-$244
09838 2C01           53                         push	bx
09839                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09840 2C02           E8         DA48            call	_get_SS
09841                                           ! Debug: list unsigned short = ax+0 (used reg = )
09842 2C05           50                         push	ax
09843                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09844 2C06           E8         D9EB            call	_read_byte
09845 2C09           83C4                   04  add	sp,*4
09846                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09847 2C0C           8886       FDE7            mov	-$219[bp],al
09848 2C10           84C0                       test	al,al
09849 2C12           75           C4            jne	.231
09850                       00002C14            .233:
09851                       00002C14            .22F:
09852                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09853 2C14           31C0                       xor	ax,ax
09854 2C16           BB                   0001  mov	bx,*1
09855 2C19           8DBE       FDEA            lea	di,-$216[bp]
09856 2C1D           E8         D4AB            call	lcmpul
09857 2C20           76           1B            jbe 	.234
09858                       00002C22            .235:
09859                                           ! 1771             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09860                                           ! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
09861 2C22           FFB6       FDEA            push	-$216[bp]
09862                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09863 2C26           8A86       FDE5            mov	al,-$21B[bp]
09864 2C2A           30E4                       xor	ah,ah
09865 2C2C           50                         push	ax
09866                                           ! Debug: list * char = .236+0 (used reg = )
09867 2C2D           BB                   DB1C  mov	bx,#.236
09868 2C30           53                         push	bx
09869                                           ! Debug: list int = const 2 (used reg = )
09870 2C31           B8                   0002  mov	ax,*2
09871 2C34           50                         push	ax
09872                                           ! Debug: func () void = bios_printf+0 (used reg = )
09873 2C35           E8         DDE1            call	_bios_printf
09874 2C38           83C4                   08  add	sp,*8
09875                                           !BCC_EOS
09876                                           ! 1772    else
09877                                           ! 1773             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09878 2C3B           EB           2C            jmp .237
09879                       00002C3D            .234:
09880                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09881 2C3D           8B86       FDEA            mov	ax,-$216[bp]
09882 2C41           8B9E       FDEC            mov	bx,-$214[bp]
09883 2C45           88E0                       mov	al,ah
09884 2C47           88DC                       mov	ah,bl
09885 2C49           88FB                       mov	bl,bh
09886 2C4B           28FF                       sub	bh,bh
09887 2C4D           BF                   0002  mov	di,*2
09888 2C50           E8         D4D6            call	lsrul
09889                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09890                                           ! Debug: list unsigned short = ax+0 (used reg = )
09891 2C53           50                         push	ax
09892                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09893 2C54           8A86       FDE5            mov	al,-$21B[bp]
09894 2C58           30E4                       xor	ah,ah
09895 2C5A           50                         push	ax
09896                                           ! Debug: list * char = .238+0 (used reg = )
09897 2C5B           BB                   DAFC  mov	bx,#.238
09898 2C5E           53                         push	bx
09899                                           ! Debug: list int = const 2 (used reg = )
09900 2C5F           B8                   0002  mov	ax,*2
09901 2C62           50                         push	ax
09902                                           ! Debug: func () void = bios_printf+0 (used reg = )
09903 2C63           E8         DDB3            call	_bios_printf
09904 2C66           83C4                   08  add	sp,*8
09905                                           !BCC_EOS
09906                                           ! 1774           break;
09907                       00002C69            .237:
09908 2C69           E9         00F0            br 	.225
09909                                           !BCC_EOS
09910                                           ! 1775         case 0x03:
09911                                           ! 1776           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09912                       00002C6C            .239:
09913 2C6C           8A86       FDF4            mov	al,-$20C[bp]
09914 2C70           84C0                       test	al,al
09915 2C72           74           05            je  	.23D
09916                       00002C74            .23E:
09917 2C74           BB                   DAEA  mov	bx,#.23B
09918 2C77           EB           03            jmp .23F
09919                       00002C79            .23D:
09920 2C79           BB                   DAE3  mov	bx,#.23C
09921                       00002C7C            .23F:
09922                                           ! Debug: list * char = bx+0 (used reg = )
09923 2C7C           53                         push	bx
09924                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09925 2C7D           8A86       FDF5            mov	al,-$20B[bp]
09926 2C81           30E4                       xor	ah,ah
09927 2C83           50                         push	ax
09928                                           ! Debug: list * char = .23A+0 (used reg = )
09929 2C84           BB                   DAF1  mov	bx,#.23A
09930 2C87           53                         push	bx
09931                                           ! Debug: list int = const 2 (used reg = )
09932 2C88           B8                   0002  mov	ax,*2
09933 2C8B           50                         push	ax
09934                                           ! Debug: func () void = bios_printf+0 (used reg = )
09935 2C8C           E8         DD8A            call	_bios_printf
09936 2C8F           83C4                   08  add	sp,*8
09937                                           !BCC_EOS
09938                                           ! 1777           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09939                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09940 2C92           30C0                       xor	al,al
09941 2C94           8886       FDE6            mov	-$21A[bp],al
09942                                           !BCC_EOS
09943 2C98           EB           15            jmp .241
09944                       00002C9A            .242:
09945                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09946 2C9A           8A86       FDE7            mov	al,-$219[bp]
09947 2C9E           30E4                       xor	ah,ah
09948 2CA0           50                         push	ax
09949                                           ! Debug: list * char = .243+0 (used reg = )
09950 2CA1           BB                   DAE0  mov	bx,#.243
09951 2CA4           53                         push	bx
09952                                           ! Debug: list int = const 2 (used reg = )
09953 2CA5           B8                   0002  mov	ax,*2
09954 2CA8           50                         push	ax
09955                                           ! Debug: func () void = bios_printf+0 (used reg = )
09956 2CA9           E8         DD6D            call	_bios_printf
09957 2CAC           83C4                   06  add	sp,*6
09958                                           !BCC_EOS
09959                                           ! 1778           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
09960                       00002CAF            .241:
09961                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09962 2CAF           8A86       FDE6            mov	al,-$21A[bp]
09963 2CB3           40                         inc	ax
09964 2CB4           8886       FDE6            mov	-$21A[bp],al
09965                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09966 2CB8           48                         dec	ax
09967 2CB9           30E4                       xor	ah,ah
09968 2CBB           89EB                       mov	bx,bp
09969 2CBD           01C3                       add	bx,ax
09970                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09971                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09972 2CBF           81C3                 FDBC  add	bx,#-$244
09973 2CC3           53                         push	bx
09974                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09975 2CC4           E8         D986            call	_get_SS
09976                                           ! Debug: list unsigned short = ax+0 (used reg = )
09977 2CC7           50                         push	ax
09978                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09979 2CC8           E8         D929            call	_read_byte
09980 2CCB           83C4                   04  add	sp,*4
09981                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09982 2CCE           8886       FDE7            mov	-$219[bp],al
09983 2CD2           84C0                       test	al,al
09984 2CD4           75           C4            jne	.242
09985                       00002CD6            .244:
09986                       00002CD6            .240:
09987                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09988 2CD6           8A46         FB            mov	al,-5[bp]
09989 2CD9           30E4                       xor	ah,ah
09990 2CDB           B9                   001E  mov	cx,*$1E
09991 2CDE           F7E9                       imul	cx
09992 2CE0           89C3                       mov	bx,ax
09993                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09994                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09995 2CE2           81C3                 0143  add	bx,#$143
09996 2CE6           53                         push	bx
09997                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09998 2CE7           FF76         FE            push	-2[bp]
09999                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10000 2CEA           E8         D907            call	_read_byte
10001 2CED           83C4                   04  add	sp,*4
10002                                           ! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
10003 2CF0           3C                     05  cmp	al,*5
10004 2CF2           75           17            jne 	.245
10005                       00002CF4            .246:
10006                                           ! 1779             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
10007                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
10008 2CF4           8A86       FDE5            mov	al,-$21B[bp]
10009 2CF8           30E4                       xor	ah,ah
10010 2CFA           50                         push	ax
10011                                           ! Debug: list * char = .247+0 (used reg = )
10012 2CFB           BB                   DAC6  mov	bx,#.247
10013 2CFE           53                         push	bx
10014                                           ! Debug: list int = const 2 (used reg = )
10015 2CFF           B8                   0002  mov	ax,*2
10016 2D02           50                         push	ax
10017                                           ! Debug: func () void = bios_printf+0 (used reg = )
10018 2D03           E8         DD13            call	_bios_printf
10019 2D06           83C4                   06  add	sp,*6
10020                                           !BCC_EOS
10021                                           ! 1780           else
10022                                           ! 1781             bios_printf(2, " ATAPI-%d Device\n",version);
10023 2D09           EB           15            jmp .248
10024                       00002D0B            .245:
10025                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
10026 2D0B           8A86       FDE5            mov	al,-$21B[bp]
10027 2D0F           30E4                       xor	ah,ah
10028 2D11           50                         push	ax
10029                                           ! Debug: list * char = .249+0 (used reg = )
10030 2D12           BB                   DAB4  mov	bx,#.249
10031 2D15           53                         push	bx
10032                                           ! Debug: list int = const 2 (used reg = )
10033 2D16           B8                   0002  mov	ax,*2
10034 2D19           50                         push	ax
10035                                           ! Debug: func () void = bios_printf+0 (used reg = )
10036 2D1A           E8         DCFC            call	_bios_printf
10037 2D1D           83C4                   06  add	sp,*6
10038                                           !BCC_EOS
10039                                           ! 1782           break;
10040                       00002D20            .248:
10041 2D20           EB           3A            jmp .225
10042                                           !BCC_EOS
10043                                           ! 1783         case 0x01:
10044                                           ! 1784           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
10045                       00002D22            .24A:
10046 2D22           8A86       FDF4            mov	al,-$20C[bp]
10047 2D26           84C0                       test	al,al
10048 2D28           74           05            je  	.24E
10049                       00002D2A            .24F:
10050 2D2A           BB                   DA93  mov	bx,#.24C
10051 2D2D           EB           03            jmp .250
10052                       00002D2F            .24E:
10053 2D2F           BB                   DA8C  mov	bx,#.24D
10054                       00002D32            .250:
10055                                           ! Debug: list * char = bx+0 (used reg = )
10056 2D32           53                         push	bx
10057                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
10058 2D33           8A86       FDF5            mov	al,-$20B[bp]
10059 2D37           30E4                       xor	ah,ah
10060 2D39           50                         push	ax
10061                                           ! Debug: list * char = .24B+0 (used reg = )
10062 2D3A           BB                   DA9A  mov	bx,#.24B
10063 2D3D           53                         push	bx
10064                                           ! Debug: list int = const 2 (used reg = )
10065 2D3E           B8                   0002  mov	ax,*2
10066 2D41           50                         push	ax
10067                                           ! Debug: func () void = bios_printf+0 (used reg = )
10068 2D42           E8         DCD4            call	_bios_printf
10069 2D45           83C4                   08  add	sp,*8
10070                                           !BCC_EOS
10071                                           ! 1785           break;
10072 2D48           EB           12            jmp .225
10073                                           !BCC_EOS
10074                                           ! 1786         }
10075                                           ! 1787       }
10076 2D4A           EB           10            jmp .225
10077                       00002D4C            .227:
10078 2D4C           2C                     01  sub	al,*1
10079 2D4E           74           D2            je 	.24A
10080 2D50           2C                     01  sub	al,*1
10081 2D52         0F84         FE54            beq 	.228
10082 2D56           2C                     01  sub	al,*1
10083 2D58         0F84         FF10            beq 	.239
10084                       00002D5C            .225:
10085                       FFFFFDBA            ..FFFB	=	-$246
10086 2D5C           83C4                   32  add	sp,*$32
10087                                           ! 1788     }
10088 2D5F           83C4                   0C  add	sp,*$C
10089                                           ! 1789   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
10090                       00002D62            .1A0:
10091                                           ! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
10092 2D62           8A46         FB            mov	al,-5[bp]
10093 2D65           40                         inc	ax
10094 2D66           8846         FB            mov	-5[bp],al
10095                       00002D69            .1A1:
10096                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
10097 2D69           8A46         FB            mov	al,-5[bp]
10098 2D6C           3C                     08  cmp	al,*8
10099 2D6E         0F82         F246            blo 	.1A2
10100                       00002D72            .251:
10101                       00002D72            .19F:
10102                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
10103 2D72           8A46         FD            mov	al,-3[bp]
10104 2D75           30E4                       xor	ah,ah
10105 2D77           50                         push	ax
10106                                           ! Debug: list * unsigned char = const $232 (used reg = )
10107 2D78           B8                   0232  mov	ax,#$232
10108 2D7B           50                         push	ax
10109                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
10110 2D7C           FF76         FE            push	-2[bp]
10111                                           ! Debug: func () void = write_byte+0 (used reg = )
10112 2D7F           E8         D898            call	_write_byte
10113 2D82           83C4                   06  add	sp,*6
10114                                           !BCC_EOS
10115                                           ! 1790   write_byte(eb
10116                                           ! 1790 da_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
10117                                           ! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
10118 2D85           8A46         FC            mov	al,-4[bp]
10119 2D88           30E4                       xor	ah,ah
10120 2D8A           50                         push	ax
10121                                           ! Debug: list * unsigned char = const $23B (used reg = )
10122 2D8B           B8                   023B  mov	ax,#$23B
10123 2D8E           50                         push	ax
10124                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
10125 2D8F           FF76         FE            push	-2[bp]
10126                                           ! Debug: func () void = write_byte+0 (used reg = )
10127 2D92           E8         D885            call	_write_byte
10128 2D95           83C4                   06  add	sp,*6
10129                                           !BCC_EOS
10130                                           ! 1791   write_byte(0x40,0x75, hdcount);
10131                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
10132 2D98           8A46         FD            mov	al,-3[bp]
10133 2D9B           30E4                       xor	ah,ah
10134 2D9D           50                         push	ax
10135                                           ! Debug: list int = const $75 (used reg = )
10136 2D9E           B8                   0075  mov	ax,*$75
10137 2DA1           50                         push	ax
10138                                           ! Debug: list int = const $40 (used reg = )
10139 2DA2           B8                   0040  mov	ax,*$40
10140 2DA5           50                         push	ax
10141                                           ! Debug: func () void = write_byte+0 (used reg = )
10142 2DA6           E8         D871            call	_write_byte
10143 2DA9           83C4                   06  add	sp,*6
10144                                           !BCC_EOS
10145                                           ! 1792   bios_printf(2, "\n");
10146                                           ! Debug: list * char = .252+0 (used reg = )
10147 2DAC           BB                   DA8A  mov	bx,#.252
10148 2DAF           53                         push	bx
10149                                           ! Debug: list int = const 2 (used reg = )
10150 2DB0           B8                   0002  mov	ax,*2
10151 2DB3           50                         push	ax
10152                                           ! Debug: func () void = bios_printf+0 (used reg = )
10153 2DB4           E8         DC62            call	_bios_printf
10154 2DB7           83C4                   04  add	sp,*4
10155                                           !BCC_EOS
10156                                           ! 1793 }
10157 2DBA           89EC                       mov	sp,bp
10158 2DBC           5D                         pop	bp
10159 2DBD           C3                         ret
10160                                           ! 1794 void ata_reset(device)
10161                                           ! Register BX used in function ata_detect
10162                                           ! 1795 Bit16u device;
10163                                           export	_ata_reset
10164                       00002DBE            _ata_reset:
10165                                           !BCC_EOS
10166                                           ! 1796 {
10167                                           ! 1797   Bit16u ebda_seg=read_word(0x0040,0x000E);
10168 2DBE           55                         push	bp
10169 2DBF           89E5                       mov	bp,sp
10170 2DC1           4C                         dec	sp
10171 2DC2           4C                         dec	sp
10172                                           ! Debug: list int = const $E (used reg = )
10173 2DC3           B8                   000E  mov	ax,*$E
10174 2DC6           50                         push	ax
10175                                           ! Debug: list int = const $40 (used reg = )
10176 2DC7           B8                   0040  mov	ax,*$40
10177 2DCA           50                         push	ax
10178                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10179 2DCB           E8         D839            call	_read_word
10180 2DCE           83C4                   04  add	sp,*4
10181                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10182 2DD1           8946         FE            mov	-2[bp],ax
10183                                           !BCC_EOS
10184                                           ! 1798   Bit16u iobase1, iobase2;
10185                                           !BCC_EOS
10186                                           ! 1799   Bit8u channel, slave, sn, sc;
10187                                           !BCC_EOS
10188                                           ! 1800   Bit8u type;
10189                                           !BCC_EOS
10190                                           ! 1801   Bit16u max;
10191                                           !BCC_EOS
10192                                           ! 1802   channel = device / 2;
10193 2DD4           83C4                   F4  add	sp,*-$C
10194                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10195 2DD7           8B46         04            mov	ax,4[bp]
10196 2DDA           D1E8                       shr	ax,*1
10197                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
10198 2DDC           8846         F9            mov	-7[bp],al
10199                                           !BCC_EOS
10200                                           ! 1803   slave = device % 2;
10201                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10202 2DDF           8B46         04            mov	ax,4[bp]
10203 2DE2           24                     01  and	al,*1
10204                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
10205 2DE4           8846         F8            mov	-8[bp],al
10206                                           !BCC_EOS
10207                                           ! 1804   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10208                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
10209 2DE7           8A46         F9            mov	al,-7[bp]
10210 2DEA           30E4                       xor	ah,ah
10211 2DEC           B1                     03  mov	cl,*3
10212 2DEE           D3E0                       shl	ax,cl
10213 2DF0           89C3                       mov	bx,ax
10214                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10215                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10216 2DF2           81C3                 0124  add	bx,#$124
10217 2DF6           53                         push	bx
10218                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10219 2DF7           FF76         FE            push	-2[bp]
10220                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10221 2DFA           E8         D80A            call	_read_word
10222 2DFD           83C4                   04  add	sp,*4
10223                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10224 2E00           8946         FC            mov	-4[bp],ax
10225                                           !BCC_EOS
10226                                           ! 1805   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10227                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
10228 2E03           8A46         F9            mov	al,-7[bp]
10229 2E06           30E4                       xor	ah,ah
10230 2E08           B1                     03  mov	cl,*3
10231 2E0A           D3E0                       shl	ax,cl
10232 2E0C           89C3                       mov	bx,ax
10233                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10234                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10235 2E0E           81C3                 0126  add	bx,#$126
10236 2E12           53                         push	bx
10237                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10238 2E13           FF76         FE            push	-2[bp]
10239                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10240 2E16           E8         D7EE            call	_read_word
10241 2E19           83C4                   04  add	sp,*4
10242                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10243 2E1C           8946         FA            mov	-6[bp],ax
10244                                           !BCC_EOS
10245                                           ! 1806   outb(iobase2+6, 0x08 | 0x02 | 0x04);
10246                                           ! Debug: list int = const $E (used reg = )
10247 2E1F           B8                   000E  mov	ax,*$E
10248 2E22           50                         push	ax
10249                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10250 2E23           8B46         FA            mov	ax,-6[bp]
10251                                           ! Debug: list unsigned int = ax+6 (used reg = )
10252 2E26           05                   0006  add	ax,*6
10253 2E29           50                         push	ax
10254                                           ! Debug: func () void = outb+0 (used reg = )
10255 2E2A           E8         D727            call	_outb
10256 2E2D           83C4                   04  add	sp,*4
10257                                           !BCC_EOS
10258                                           ! 1807   await_ide(1, iobase1, 20);
10259                                           ! Debug: list int = const $14 (used reg = )
10260 2E30           B8                   0014  mov	ax,*$14
10261 2E33           50                         push	ax
10262                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10263 2E34           FF76         FC            push	-4[bp]
10264                                           ! Debug: list int = const 1 (used reg = )
10265 2E37           B8                   0001  mov	ax,*1
10266 2E3A           50                         push	ax
10267                                           ! Debug: func () int = await_ide+0 (used reg = )
10268 2E3B           E8         EECC            call	_await_ide
10269 2E3E           83C4                   06  add	sp,*6
10270                                           !BCC_EOS
10271                                           ! 1808   outb(iobase2+6, 0x08 | 0x02);
10272                                           ! Debug: list int = const $A (used reg = )
10273 2E41           B8                   000A  mov	ax,*$A
10274 2E44           50                         push	ax
10275                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10276 2E45           8B46         FA            mov	ax,-6[bp]
10277                                           ! Debug: list unsigned int = ax+6 (used reg = )
10278 2E48           05                   0006  add	ax,*6
10279 2E4B           50                         push	ax
10280                                           ! Debug: func () void = outb+0 (used reg = )
10281 2E4C           E8         D705            call	_outb
10282 2E4F           83C4                   04  add	sp,*4
10283                                           !BCC_EOS
10284                                           ! 1809   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
10285                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10286 2E52           8B46         04            mov	ax,4[bp]
10287 2E55           B9                   001E  mov	cx,*$1E
10288 2E58           F7E9                       imul	cx
10289 2E5A           89C3                       mov	bx,ax
10290                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
10291                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
10292 2E5C           81C3                 0142  add	bx,#$142
10293 2E60           53                         push	bx
10294                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10295 2E61           FF76         FE            push	-2[bp]
10296                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10297 2E64           E8         D78D            call	_read_byte
10298 2E67           83C4                   04  add	sp,*4
10299                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
10300 2E6A           8846         F5            mov	-$B[bp],al
10301                                           !BCC_EOS
10302                                           ! 1810   if (type != 0x00) {
10303                                           ! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
10304 2E6D           8A46         F5            mov	al,-$B[bp]
10305 2E70           84C0                       test	al,al
10306 2E72         0F84         0084            beq 	.253
10307                       00002E76            .254:
10308                                           ! 1811     outb(iobase1+6, slave?0xb0:0xa0);
10309 2E76           8A46         F8            mov	al,-8[bp]
10310 2E79           84C0                       test	al,al
10311 2E7B           74           04            je  	.255
10312                       00002E7D            .256:
10313 2E7D           B0                     B0  mov	al,#$B0
10314 2E7F           EB           02            jmp .257
10315                       00002E81            .255:
10316 2E81           B0                     A0  mov	al,#$A0
10317                       00002E83            .257:
10318                                           ! Debug: list char = al+0 (used reg = )
10319 2E83           30E4                       xor	ah,ah
10320 2E85           50                         push	ax
10321                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10322 2E86           8B46         FC            mov	ax,-4[bp]
10323                                           ! Debug: list unsigned int = ax+6 (used reg = )
10324 2E89           05                   0006  add	ax,*6
10325 2E8C           50                         push	ax
10326                                           ! Debug: func () void = outb+0 (used reg = )
10327 2E8D           E8         D6C4            call	_outb
10328 2E90           83C4                   04  add	sp,*4
10329                                           !BCC_EOS
10330                                           ! 1812     sc = inb(iobase1+2);
10331                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
10332 2E93           8B46         FC            mov	ax,-4[bp]
10333                                           ! Debug: list unsigned int = ax+2 (used reg = )
10334 2E96           40                         inc	ax
10335 2E97           40                         inc	ax
10336 2E98           50                         push	ax
10337                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10338 2E99           E8         D6A2            call	_inb
10339 2E9C           44                         inc	sp
10340 2E9D           44                         inc	sp
10341                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
10342 2E9E           8846         F6            mov	-$A[bp],al
10343                                           !BCC_EOS
10344                                           ! 1813     sn = inb(iobase1+3);
10345                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
10346 2EA1           8B46         FC            mov	ax,-4[bp]
10347                                           ! Debug: list unsigned int = ax+3 (used reg = )
10348 2EA4           05                   0003  add	ax,*3
10349 2EA7           50                         push	ax
10350                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10351 2EA8           E8         D693            call	_inb
10352 2EAB           44                         inc	sp
10353 2EAC           44                         inc	sp
10354                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
10355 2EAD           8846         F7            mov	-9[bp],al
10356                                           !BCC_EOS
10357                                           ! 1814     if ( (sc==0x01) && (sn==0x01) ) {
10358                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
10359 2EB0           8A46         F6            mov	al,-$A[bp]
10360 2EB3           3C                     01  cmp	al,*1
10361 2EB5           75           32            jne 	.258
10362                       00002EB7            .25A:
10363                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
10364 2EB7           8A46         F7            mov	al,-9[bp]
10365 2EBA           3C                     01  cmp	al,*1
10366 2EBC           75           2B            jne 	.258
10367                       00002EBE            .259:
10368                                           ! 1815       if (type == 0x02)
10369                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
10370 2EBE           8A46         F5            mov	al,-$B[bp]
10371 2EC1           3C                     02  cmp	al,*2
10372 2EC3           75           13            jne 	.25B
10373                       00002EC5            .25C:
10374                                           ! 1816         await_ide(5, iobase1, 32000u);
10375                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10376 2EC5           B8                   7D00  mov	ax,#$7D00
10377 2EC8           50                         push	ax
10378                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10379 2EC9           FF76         FC            push	-4[bp]
10380                                           ! Debug: list int = const 5 (used reg = )
10381 2ECC           B8                   0005  mov	ax,*5
10382 2ECF           50                         push	ax
10383                                           ! Debug: func () int = await_ide+0 (used reg = )
10384 2ED0           E8         EE37            call	_await_ide
10385 2ED3           83C4                   06  add	sp,*6
10386                                           !BCC_EOS
10387                                           ! 1817       else
10388                                           ! 1818         await_ide(2, iobase1, 32000u);
10389 2ED6           EB           11            jmp .25D
10390                       00002ED8            .25B:
10391                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10392 2ED8           B8                   7D00  mov	ax,#$7D00
10393 2EDB           50                         push	ax
10394                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10395 2EDC           FF76         FC            push	-4[bp]
10396                                           ! Debug: list int = const 2 (used reg = )
10397 2EDF           B8                   0002  mov	ax,*2
10398 2EE2           50                         push	ax
10399                                           ! Debug: func () int = await_ide+0 (used reg = )
10400 2EE3           E8         EE24            call	_await_ide
10401 2EE6           83C4                   06  add	sp,*6
10402                                           !BCC_EOS
10403                                           ! 1819     }
10404                       00002EE9            .25D:
10405                                           ! 1820     await_ide(2, iobase1, 32000u);
10406                       00002EE9            .258:
10407                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10408 2EE9           B8                   7D00  mov	ax,#$7D00
10409 2EEC           50                         push	ax
10410                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10411 2EED           FF76         FC            push	-4[bp]
10412                                           ! Debug: list int = const 2 (used reg = )
10413 2EF0           B8                   0002  mov	ax,*2
10414 2EF3           50                         push	ax
10415                                           ! Debug: func () int = await_ide+0 (used reg = )
10416 2EF4           E8         EE13            call	_await_ide
10417 2EF7           83C4                   06  add	sp,*6
10418                                           !BCC_EOS
10419                                           ! 1821   }
10420                                           ! 1822   outb(iobase2+6, 0x08);
10421                       00002EFA            .253:
10422                                           ! Debug: list int = const 8 (used reg = )
10423 2EFA           B8                   0008  mov	ax,*8
10424 2EFD           50                         push	ax
10425                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10426 2EFE           8B46         FA            mov	ax,-6[bp]
10427                                           ! Debug: list unsigned int = ax+6 (used reg = )
10428 2F01           05                   0006  add	ax,*6
10429 2F04           50                         push	ax
10430                                           ! Debug: func () void = outb+0 (used reg = )
10431 2F05           E8         D64C            call	_outb
10432 2F08           83C4                   04  add	sp,*4
10433                                           !BCC_EOS
10434                                           ! 1823 }
10435 2F0B           89EC                       mov	sp,bp
10436 2F0D           5D                         pop	bp
10437 2F0E           C3                         ret
10438                                           ! 1824 Bit16u ata_cmd_non_data()
10439                                           ! Register BX used in function ata_reset
10440                                           ! 1825 {return 0;}
10441                                           export	_ata_cmd_non_data
10442                       00002F0F            _ata_cmd_non_data:
10443 2F0F           55                         push	bp
10444 2F10           89E5                       mov	bp,sp
10445 2F12           31C0                       xor	ax,ax
10446 2F14           5D                         pop	bp
10447 2F15           C3                         ret
10448                                           !BCC_EOS
10449                                           ! 1826 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
10450                                           ! 1827 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10451                                           export	_ata_cmd_data_in
10452                       00002F16            _ata_cmd_data_in:
10453                                           !BCC_EOS
10454                                           ! 1828 Bit32u lba_low, lba_high;
10455                                           !BCC_EOS
10456                                           ! 1829 {
10457                                           ! 1830   Bit16u ebda_seg=read_word(0x0040,0x000E);
10458 2F16           55                         push	bp
10459 2F17           89E5                       mov	bp,sp
10460 2F19           4C                         dec	sp
10461 2F1A           4C                         dec	sp
10462                                           ! Debug: list int = const $E (used reg = )
10463 2F1B           B8                   000E  mov	ax,*$E
10464 2F1E           50                         push	ax
10465                                           ! Debug: list int = const $40 (used reg = )
10466 2F1F           B8                   0040  mov	ax,*$40
10467 2F22           50                         push	ax
10468                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10469 2F23           E8         D6E1            call	_read_word
10470 2F26           83C4                   04  add	sp,*4
10471                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10472 2F29           8946         FE            mov	-2[bp],ax
10473                                           !BCC_EOS
10474                                           ! 1831   Bit16u iobase1, iobase2, blksize;
10475                                           !BCC_EOS
10476                                           ! 1832   Bit8u channel, slave;
10477                                           !BCC_EOS
10478                                           ! 1833   Bit8u status, current, mode;
10479                                           !BCC_EOS
10480                                           ! 1834   channel = device / 2;
10481 2F2C           83C4                   F4  add	sp,*-$C
10482                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10483 2F2F           8B46         04            mov	ax,4[bp]
10484 2F32           D1E8                       shr	ax,*1
10485                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10486 2F34           8846         F7            mov	-9[bp],al
10487                                           !BCC_EOS
10488                                           ! 1835   slave = device % 2;
10489                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10490 2F37           8B46         04            mov	ax,4[bp]
10491 2F3A           24                     01  and	al,*1
10492                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
10493 2F3C           8846         F6            mov	-$A[bp],al
10494                                           !BCC_EOS
10495                                           ! 1836   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10496                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10497 2F3F           8A46         F7            mov	al,-9[bp]
10498 2F42           30E4                       xor	ah,ah
10499 2F44           B1                     03  mov	cl,*3
10500 2F46           D3E0                       shl	ax,cl
10501 2F48           89C3                       mov	bx,ax
10502                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10503                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10504 2F4A           81C3                 0124  add	bx,#$124
10505 2F4E           53                         push	bx
10506                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10507 2F4F           FF76         FE            push	-2[bp]
10508                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10509 2F52           E8         D6B2            call	_read_word
10510 2F55           83C4                   04  add	sp,*4
10511                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10512 2F58           8946         FC            mov	-4[bp],ax
10513                                           !BCC_EOS
10514                                           ! 1837   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10515                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10516 2F5B           8A46         F7            mov	al,-9[bp]
10517 2F5E           30E4                       xor	ah,ah
10518 2F60           B1                     03  mov	cl,*3
10519 2F62           D3E0                       shl	ax,cl
10520 2F64           89C3                       mov	bx,ax
10521                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10522                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10523 2F66           81C3                 0126  add	bx,#$126
10524 2F6A           53                         push	bx
10525                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10526 2F6B           FF76         FE            push	-2[bp]
10527                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10528 2F6E           E8         D696            call	_read_word
10529 2F71           83C4                   04  add	sp,*4
10530                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10531 2F74           8946         FA            mov	-6[bp],ax
10532                                           !BCC_EOS
10533                                           ! 1838   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
10534                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10535 2F77           8B46         04            mov	ax,4[bp]
10536 2F7A           B9                   001E  mov	cx,*$1E
10537 2F7D           F7E9                       imul	cx
10538 2F7F           89C3                       mov	bx,ax
10539                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10540                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
10541 2F81           81C3                 0146  add	bx,#$146
10542 2F85           53                         push	bx
10543                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10544 2F86           FF76         FE            push	-2[bp]
10545                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10546 2F89           E8         D668            call	_read_byte
10547 2F8C           83C4                   04  add	sp,*4
10548                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
10549 2F8F           8846         F3            mov	-$D[bp],al
10550                                           !BCC_EOS
10551                                           ! 1839   blksize = 0x200;
10552                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
10553 2F92           B8                   0200  mov	ax,#$200
10554 2F95           8946         F8            mov	-8[bp],ax
10555                                           !BCC_EOS
10556                                           ! 1840   if (mode == 0x01) blksize>>=2;
10557                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
10558 2F98           8A46         F3            mov	al,-$D[bp]
10559 2F9B           3C                     01  cmp	al,*1
10560 2F9D           75           0C            jne 	.25E
10561                       00002F9F            .25F:
10562                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
10563 2F9F           8B46         F8            mov	ax,-8[bp]
10564 2FA2           D1E8                       shr	ax,*1
10565 2FA4           D1E8                       shr	ax,*1
10566 2FA6           8946         F8            mov	-8[bp],ax
10567                                           !BCC_EOS
10568                                           ! 1841   else blksize>>=1;
10569 2FA9           EB           08            jmp .260
10570                       00002FAB            .25E:
10571                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
10572 2FAB           8B46         F8            mov	ax,-8[bp]
10573 2FAE           D1E8                       shr	ax,*1
10574 2FB0           8946         F8            mov	-8[bp],ax
10575                                           !BCC_EOS
10576                                           ! 1842   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
10577                       00002FB3            .260:
10578                                           ! Debug: list int = const 0 (used reg = )
10579 2FB3           31C0                       xor	ax,ax
10580 2FB5           50                         push	ax
10581                                           ! Debug: list * unsigned short = const $254 (used reg = )
10582 2FB6           B8                   0254  mov	ax,#$254
10583 2FB9           50                         push	ax
10584                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10585 2FBA           FF76         FE            push	-2[bp]
10586                                           ! Debug: func () void = write_word+0 (used reg = )
10587 2FBD           E8         D672            call	_write_word
10588 2FC0           83C4                   06  add	sp,*6
10589                                           !BCC_EOS
10590                                           ! 1843   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
10591                                           ! Debug: list long = const 0 (used reg = )
10592 2FC3           31C0                       xor	ax,ax
10593 2FC5           31DB                       xor	bx,bx
10594 2FC7           53                         push	bx
10595 2FC8           50                         push	ax
10596                                           ! Debug: list * unsigned long = const $256 (used reg = )
10597 2FC9           B8                   0256  mov	ax,#$256
10598 2FCC           50                         push	ax
10599                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
10600 2FCD           FF76         FE            push	-2[bp]
10601                                           ! Debug: func () void = write_dword+0 (used reg = )
10602 2FD0           E8         D0C8            call	_write_dword
10603 2FD3           83C4                   08  add	sp,*8
10604                                           !BCC_EOS
10605                                           ! 1844   current = 0;
10606                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
10607 2FD6           30C0                       xor	al,al
10608 2FD8           8846         F4            mov	-$C[bp],al
10609                                           !BCC_EOS
10610                                           ! 1845   status = inb(iobase1 + 7);
10611                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10612 2FDB           8B46         FC            mov	ax,-4[bp]
10613                                           ! Debug: list unsigned int = ax+7 (used reg = )
10614 2FDE           05                   0007  add	ax,*7
10615 2FE1           50                         push	ax
10616                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10617 2FE2           E8         D559            call	_inb
10618 2FE5           44                         inc	sp
10619 2FE6           44                         inc	sp
10620                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10621 2FE7           8846         F5            mov	-$B[bp],al
10622                                           !BCC_EOS
10623                                           ! 1846   if (status & 0x80) return 1;
10624                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10625 2FEA           8A46         F5            mov	al,-$B[bp]
10626 2FED           24                     80  and	al,#$80
10627 2FEF           84C0                       test	al,al
10628 2FF1           74           07            je  	.261
10629                       00002FF3            .262:
10630 2FF3           B8                   0001  mov	ax,*1
10631 2FF6           89EC                       mov	sp,bp
10632 2FF8           5D                         pop	bp
10633 2FF9           C3                         ret
10634                                           !BCC_EOS
10635                                           ! 1847   outb(iobase2 + 6, 0x08 | 0x02);
10636                       00002FFA            .261:
10637                                           ! Debug: list int = const $A (used reg = )
10638 2FFA           B8                   000A  mov	ax,*$A
10639 2FFD           50                         push	ax
10640                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10641 2FFE           8B46         FA            mov	ax,-6[bp]
10642                                           ! Debug: list unsigned int = ax+6 (used reg = )
10643 3001           05                   0006  add	ax,*6
10644 3004           50                         push	ax
10645                                           ! Debug: func () void = outb+0 (used reg = )
10646 3005           E8         D54C            call	_outb
10647 3008           83C4                   04  add	sp,*4
10648                                           !BCC_EOS
10649                                           ! 1848   if (sector == 0) {
10650                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
10651 300B           8B46         0E            mov	ax,$E[bp]
10652 300E           85C0                       test	ax,ax
10653 3010         0F85         0167            bne 	.263
10654                       00003014            .264:
10655                                           ! 1849     if ((count >= 1 << 8) || lb
10656                                           ! 1849 a_high || (lba_low + count >= 1UL << 28)) {
10657                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
10658 3014           8B46         08            mov	ax,8[bp]
10659 3017           3D                   0100  cmp	ax,#$100
10660 301A           72           04            jb 	.269
10661 301C           B0                     01  mov	al,*1
10662 301E           EB           02            jmp	.26A
10663                       00003020            .269:
10664 3020           30C0                       xor	al,al
10665                       00003022            .26A:
10666                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
10667 3022           30E4                       xor	ah,ah
10668 3024           99                         cwd
10669 3025           89D3                       mov	bx,dx
10670 3027           E8         D0EA            call	ltstl
10671 302A           75           32            jne 	.266
10672                       0000302C            .268:
10673 302C           8B46         14            mov	ax,$14[bp]
10674 302F           8B5E         16            mov	bx,$16[bp]
10675 3032           E8         D0DF            call	ltstl
10676 3035           75           27            jne 	.266
10677                       00003037            .267:
10678                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
10679 3037           8B46         08            mov	ax,8[bp]
10680 303A           31DB                       xor	bx,bx
10681                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
10682                                           ! Debug: expression subtree swapping
10683 303C           8D7E         10            lea	di,$10[bp]
10684 303F           E8         D081            call	laddul
10685                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
10686 3042           53                         push	bx
10687 3043           50                         push	ax
10688 3044           31C0                       xor	ax,ax
10689 3046           BB                   1000  mov	bx,#$1000
10690 3049           53                         push	bx
10691 304A           50                         push	ax
10692 304B           8B46         EE            mov	ax,-$12[bp]
10693 304E           8B5E         F0            mov	bx,-$10[bp]
10694 3051           8D7E         EA            lea	di,-$16[bp]
10695 3054           E8         D074            call	lcmpul
10696 3057           8D66         F2            lea	sp,-$E[bp]
10697 305A         0F82         00BC            blo 	.265
10698                       0000305E            .266:
10699                                           ! 1850       outb(iobase1 + 1, 0x00);
10700                                           ! Debug: list int = const 0 (used reg = )
10701 305E           31C0                       xor	ax,ax
10702 3060           50                         push	ax
10703                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10704 3061           8B46         FC            mov	ax,-4[bp]
10705                                           ! Debug: list unsigned int = ax+1 (used reg = )
10706 3064           40                         inc	ax
10707 3065           50                         push	ax
10708                                           ! Debug: func () void = outb+0 (used reg = )
10709 3066           E8         D4EB            call	_outb
10710 3069           83C4                   04  add	sp,*4
10711                                           !BCC_EOS
10712                                           ! 1851       outb(iobase1 + 2, (count >> 8) & 0xff);
10713                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
10714 306C           8B46         08            mov	ax,8[bp]
10715 306F           88E0                       mov	al,ah
10716 3071           30E4                       xor	ah,ah
10717                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
10718                                           ! Debug: list unsigned char = al+0 (used reg = )
10719 3073           30E4                       xor	ah,ah
10720 3075           50                         push	ax
10721                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10722 3076           8B46         FC            mov	ax,-4[bp]
10723                                           ! Debug: list unsigned int = ax+2 (used reg = )
10724 3079           40                         inc	ax
10725 307A           40                         inc	ax
10726 307B           50                         push	ax
10727                                           ! Debug: func () void = outb+0 (used reg = )
10728 307C           E8         D4D5            call	_outb
10729 307F           83C4                   04  add	sp,*4
10730                                           !BCC_EOS
10731                                           ! 1852       outb(iobase1 + 3, lba_low >> 24);
10732                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10733 3082           8B46         10            mov	ax,$10[bp]
10734 3085           8B5E         12            mov	bx,$12[bp]
10735 3088           93                         xchg	bx,ax
10736 3089           88E0                       mov	al,ah
10737 308B           30E4                       xor	ah,ah
10738 308D           31DB                       xor	bx,bx
10739                                           ! Debug: list unsigned long = bx+0 (used reg = )
10740 308F           53                         push	bx
10741 3090           50                         push	ax
10742                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
10743 3091           8B46         FC            mov	ax,-4[bp]
10744                                           ! Debug: list unsigned int = ax+3 (used reg = )
10745 3094           05                   0003  add	ax,*3
10746 3097           50                         push	ax
10747                                           ! Debug: func () void = outb+0 (used reg = )
10748 3098           E8         D4B9            call	_outb
10749 309B           83C4                   06  add	sp,*6
10750                                           !BCC_EOS
10751                                           ! 1853       outb(iobase1 + 4, lba_high & 0xff);
10752                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
10753                                           ! Debug: expression subtree swapping
10754 309E           B8                   00FF  mov	ax,#$FF
10755 30A1           31DB                       xor	bx,bx
10756 30A3           8D7E         14            lea	di,$14[bp]
10757 30A6           E8         D012            call	landul
10758                                           ! Debug: list unsigned long = bx+0 (used reg = )
10759 30A9           53                         push	bx
10760 30AA           50                         push	ax
10761                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
10762 30AB           8B46         FC            mov	ax,-4[bp]
10763                                           ! Debug: list unsigned int = ax+4 (used reg = )
10764 30AE           05                   0004  add	ax,*4
10765 30B1           50                         push	ax
10766                                           ! Debug: func () void = outb+0 (used reg = )
10767 30B2           E8         D49F            call	_outb
10768 30B5           83C4                   06  add	sp,*6
10769                                           !BCC_EOS
10770                                           ! 1854       outb(iobase1 + 5, lba_high >> 8);
10771                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
10772 30B8           8B46         14            mov	ax,$14[bp]
10773 30BB           8B5E         16            mov	bx,$16[bp]
10774 30BE           88E0                       mov	al,ah
10775 30C0           88DC                       mov	ah,bl
10776 30C2           88FB                       mov	bl,bh
10777 30C4           28FF                       sub	bh,bh
10778                                           ! Debug: list unsigned long = bx+0 (used reg = )
10779 30C6           53                         push	bx
10780 30C7           50                         push	ax
10781                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
10782 30C8           8B46         FC            mov	ax,-4[bp]
10783                                           ! Debug: list unsigned int = ax+5 (used reg = )
10784 30CB           05                   0005  add	ax,*5
10785 30CE           50                         push	ax
10786                                           ! Debug: func () void = outb+0 (used reg = )
10787 30CF           E8         D482            call	_outb
10788 30D2           83C4                   06  add	sp,*6
10789                                           !BCC_EOS
10790                                           ! 1855       command |= 0x04;
10791                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
10792 30D5           8B46         06            mov	ax,6[bp]
10793 30D8           0C                     04  or	al,*4
10794 30DA           8946         06            mov	6[bp],ax
10795                                           !BCC_EOS
10796                                           ! 1856       count &= (1UL << 8) - 1;
10797                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
10798 30DD           8B46         08            mov	ax,8[bp]
10799 30E0           31DB                       xor	bx,bx
10800 30E2           53                         push	bx
10801 30E3           50                         push	ax
10802 30E4           B8                   00FF  mov	ax,#$FF
10803 30E7           31DB                       xor	bx,bx
10804 30E9           53                         push	bx
10805 30EA           50                         push	ax
10806 30EB           8B46         EE            mov	ax,-$12[bp]
10807 30EE           8B5E         F0            mov	bx,-$10[bp]
10808 30F1           8D7E         EA            lea	di,-$16[bp]
10809 30F4           E8         CFC4            call	landul
10810 30F7           8946         08            mov	8[bp],ax
10811 30FA           83C4                   08  add	sp,*8
10812                                           !BCC_EOS
10813                                           ! 1857       lba_low &= (1UL << 24) - 1;
10814                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
10815 30FD           B8                   FFFF  mov	ax,#$FFFF
10816 3100           BB                   00FF  mov	bx,#$FF
10817 3103           53                         push	bx
10818 3104           50                         push	ax
10819 3105           8B46         10            mov	ax,$10[bp]
10820 3108           8B5E         12            mov	bx,$12[bp]
10821 310B           8D7E         EE            lea	di,-$12[bp]
10822 310E           E8         CFAA            call	landul
10823 3111           8946         10            mov	$10[bp],ax
10824 3114           895E         12            mov	$12[bp],bx
10825 3117           83C4                   04  add	sp,*4
10826                                           !BCC_EOS
10827                                           ! 1858       }
10828                                           ! 1859     sector = (Bit16u) (lba_low & 0x000000ffL);
10829                       0000311A            .265:
10830                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
10831                                           ! Debug: expression subtree swapping
10832 311A           B8                   00FF  mov	ax,#$FF
10833 311D           31DB                       xor	bx,bx
10834 311F           8D7E         10            lea	di,$10[bp]
10835 3122           E8         CF96            call	landul
10836                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10837                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
10838 3125           8946         0E            mov	$E[bp],ax
10839                                           !BCC_EOS
10840                                           ! 1860     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
10841                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
10842 3128           8B46         10            mov	ax,$10[bp]
10843 312B           8B5E         12            mov	bx,$12[bp]
10844 312E           88E0                       mov	al,ah
10845 3130           88DC                       mov	ah,bl
10846 3132           88FB                       mov	bl,bh
10847 3134           28FF                       sub	bh,bh
10848                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
10849 3136           53                         push	bx
10850 3137           50                         push	ax
10851 3138           B8                   FFFF  mov	ax,#$FFFF
10852 313B           31DB                       xor	bx,bx
10853 313D           53                         push	bx
10854 313E           50                         push	ax
10855 313F           8B46         EE            mov	ax,-$12[bp]
10856 3142           8B5E         F0            mov	bx,-$10[bp]
10857 3145           8D7E         EA            lea	di,-$16[bp]
10858 3148           E8         CF70            call	landul
10859 314B           83C4                   08  add	sp,*8
10860                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10861                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
10862 314E           8946         0A            mov	$A[bp],ax
10863                                           !BCC_EOS
10864                                           ! 1861     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
10865                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10866 3151           8B46         10            mov	ax,$10[bp]
10867 3154           8B5E         12            mov	bx,$12[bp]
10868 3157           93                         xchg	bx,ax
10869 3158           88E0                       mov	al,ah
10870 315A           30E4                       xor	ah,ah
10871 315C           31DB                       xor	bx,bx
10872                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
10873 315E           53                         push	bx
10874 315F           50                         push	ax
10875 3160           B8                   000F  mov	ax,*$F
10876 3163           31DB                       xor	bx,bx
10877 3165           53                         push	bx
10878 3166           50                         push	ax
10879 3167           8B46         EE            mov	ax,-$12[bp]
10880 316A           8B5E         F0            mov	bx,-$10[bp]
10881 316D           8D7E         EA            lea	di,-$16[bp]
10882 3170           E8         CF48            call	landul
10883 3173           83C4                   08  add	sp,*8
10884                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10885                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
10886 3176           0C                     40  or	al,*$40
10887                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
10888 3178           8946         0C            mov	$C[bp],ax
10889                                           !BCC_EOS
10890                                           ! 1862   }
10891                                           ! 1863   outb(iobase1 + 1, 0x00);
10892                       0000317B            .263:
10893                                           ! Debug: list int = const 0 (used reg = )
10894 317B           31C0                       xor	ax,ax
10895 317D           50                         push	ax
10896                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10897 317E           8B46         FC            mov	ax,-4[bp]
10898                                           ! Debug: list unsigned int = ax+1 (used reg = )
10899 3181           40                         inc	ax
10900 3182           50                         push	ax
10901                                           ! Debug: func () void = outb+0 (used reg = )
10902 3183           E8         D3CE            call	_outb
10903 3186           83C4                   04  add	sp,*4
10904                                           !BCC_EOS
10905                                           ! 1864   outb(iobase1 + 2, count);
10906                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
10907 3189           FF76         08            push	8[bp]
10908                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10909 318C           8B46         FC            mov	ax,-4[bp]
10910                                           ! Debug: list unsigned int = ax+2 (used reg = )
10911 318F           40                         inc	ax
10912 3190           40                         inc	ax
10913 3191           50                         push	ax
10914                                           ! Debug: func () void = outb+0 (used reg = )
10915 3192           E8         D3BF            call	_outb
10916 3195           83C4                   04  add	sp,*4
10917                                           !BCC_EOS
10918                                           ! 1865   outb(iobase1 + 3, sector);
10919                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
10920 3198           FF76         0E            push	$E[bp]
10921                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
10922 319B           8B46         FC            mov	ax,-4[bp]
10923                                           ! Debug: list unsigned int = ax+3 (used reg = )
10924 319E           05                   0003  add	ax,*3
10925 31A1           50                         push	ax
10926                                           ! Debug: func () void = outb+0 (used reg = )
10927 31A2           E8         D3AF            call	_outb
10928 31A5           83C4                   04  add	sp,*4
10929                                           !BCC_EOS
10930                                           ! 1866   outb(iobase1 + 4, cylinder & 0x00ff);
10931                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
10932 31A8           8A46         0A            mov	al,$A[bp]
10933                                           ! Debug: list unsigned char = al+0 (used reg = )
10934 31AB           30E4                       xor	ah,ah
10935 31AD           50                         push	ax
10936                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10937 31AE           8B46         FC            mov	ax,-4[bp]
10938                                           ! Debug: list unsigned int = ax+4 (used reg = )
10939 31B1           05                   0004  add	ax,*4
10940 31B4           50                         push	ax
10941                                           ! Debug: func () void = outb+0 (used reg = )
10942 31B5           E8         D39C            call	_outb
10943 31B8           83C4                   04  add	sp,*4
10944                                           !BCC_EOS
10945                                           ! 1867   outb(iobase1 + 5, cylinder >> 8);
10946                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
10947 31BB           8B46         0A            mov	ax,$A[bp]
10948 31BE           88E0                       mov	al,ah
10949 31C0           30E4                       xor	ah,ah
10950                                           ! Debug: list unsigned int = ax+0 (used reg = )
10951 31C2           50                         push	ax
10952                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10953 31C3           8B46         FC            mov	ax,-4[bp]
10954                                           ! Debug: list unsigned int = ax+5 (used reg = )
10955 31C6           05                   0005  add	ax,*5
10956 31C9           50                         push	ax
10957                                           ! Debug: func () void = outb+0 (used reg = )
10958 31CA           E8         D387            call	_outb
10959 31CD           83C4                   04  add	sp,*4
10960                                           !BCC_EOS
10961                                           ! 1868   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10962 31D0           8A46         F6            mov	al,-$A[bp]
10963 31D3           84C0                       test	al,al
10964 31D5           74           04            je  	.26C
10965                       000031D7            .26D:
10966 31D7           B0                     B0  mov	al,#$B0
10967 31D9           EB           02            jmp .26E
10968                       000031DB            .26C:
10969 31DB           B0                     A0  mov	al,#$A0
10970                       000031DD            .26E:
10971                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
10972 31DD           0A46         0C            or	al,$C[bp]
10973                                           ! Debug: list unsigned char = al+0 (used reg = )
10974 31E0           30E4                       xor	ah,ah
10975 31E2           50                         push	ax
10976                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10977 31E3           8B46         FC            mov	ax,-4[bp]
10978                                           ! Debug: list unsigned int = ax+6 (used reg = )
10979 31E6           05                   0006  add	ax,*6
10980 31E9           50                         push	ax
10981                                           ! Debug: func () void = outb+0 (used reg = )
10982 31EA           E8         D367            call	_outb
10983 31ED           83C4                   04  add	sp,*4
10984                                           !BCC_EOS
10985                                           ! 1869   outb(iobase1 + 7, command);
10986                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
10987 31F0           FF76         06            push	6[bp]
10988                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
10989 31F3           8B46         FC            mov	ax,-4[bp]
10990                                           ! Debug: list unsigned int = ax+7 (used reg = )
10991 31F6           05                   0007  add	ax,*7
10992 31F9           50                         push	ax
10993                                           ! Debug: func () void = outb+0 (used reg = )
10994 31FA           E8         D357            call	_outb
10995 31FD           83C4                   04  add	sp,*4
10996                                           !BCC_EOS
10997                                           ! 1870   await_ide(3, iobase1, 32000u);
10998                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10999 3200           B8                   7D00  mov	ax,#$7D00
11000 3203           50                         push	ax
11001                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11002 3204           FF76         FC            push	-4[bp]
11003                                           ! Debug: list int = const 3 (used reg = )
11004 3207           B8                   0003  mov	ax,*3
11005 320A           50                         push	ax
11006                                           ! Debug: func () int = await_ide+0 (used reg = )
11007 320B           E8         EAFC            call	_await_ide
11008 320E           83C4                   06  add	sp,*6
11009                                           !BCC_EOS
11010                                           ! 1871   status = inb(iobase1 + 7);
11011                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11012 3211           8B46         FC            mov	ax,-4[bp]
11013                                           ! Debug: list unsigned int = ax+7 (used reg = )
11014 3214           05                   0007  add	ax,*7
11015 3217           50                         push	ax
11016                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11017 3218           E8         D323            call	_inb
11018 321B           44                         inc	sp
11019 321C           44                         inc	sp
11020                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11021 321D           8846         F5            mov	-$B[bp],al
11022                                           !BCC_EOS
11023                                           ! 1872   if (status & 0x01) {
11024                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
11025 3220           8A46         F5            mov	al,-$B[bp]
11026 3223           24                     01  and	al,*1
11027 3225           84C0                       test	al,al
11028 3227           74           09            je  	.26F
11029                       00003229            .270:
11030                                           ! 1873     ;
11031                                           !BCC_EOS
11032                                           ! 1874     return 2;
11033 3229           B8                   0002  mov	ax,*2
11034 322C           89EC                       mov	sp,bp
11035 322E           5D                         pop	bp
11036 322F           C3                         ret
11037                                           !BCC_EOS
11038                                           ! 1875     } else if ( !(status & 0x08) ) {
11039 3230           EB           10            jmp .271
11040                       00003232            .26F:
11041                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
11042 3232           8A46         F5            mov	al,-$B[bp]
11043 3235           24                     08  and	al,*8
11044 3237           84C0                       test	al,al
11045 3239           75           07            jne 	.272
11046                       0000323B            .273:
11047                                           ! 1876     ;
11048                                           !BCC_EOS
11049                                           ! 1877     return 3;
11050 323B           B8                   0003  mov	ax,*3
11051 323E           89EC                       mov	sp,bp
11052 3240           5D                         pop	bp
11053 3241           C3                         ret
11054                                           !BCC_EOS
11055                                           ! 1878   }
11056                                           ! 1879 #asm
11057                       00003242            .272:
11058                       00003242            .271:
11059                                           !BCC_EOS
11060                                           !BCC_ASM
11061                       00000016            _ata_cmd_data_in.count	set	$16
11062                       00000008            .ata_cmd_data_in.count	set	8
11063                       00000026            _ata_cmd_data_in.segment	set	$26
11064                       00000018            .ata_cmd_data_in.segment	set	$18
11065                       0000000A            _ata_cmd_data_in.iobase1	set	$A
11066                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
11067                       00000005            _ata_cmd_data_in.channel	set	5
11068                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
11069                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
11070                       00000010            .ata_cmd_data_in.lba_low	set	$10
11071                       00000022            _ata_cmd_data_in.lba_high	set	$22
11072                       00000014            .ata_cmd_data_in.lba_high	set	$14
11073                       0000001C            _ata_cmd_data_in.sector	set	$1C
11074                       0000000E            .ata_cmd_data_in.sector	set	$E
11075                       00000006            _ata_cmd_data_in.blksize	set	6
11076                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
11077                       0000001A            _ata_cmd_data_in.head	set	$1A
11078                       0000000C            .ata_cmd_data_in.head	set	$C
11079                       00000018            _ata_cmd_data_in.cylinder	set	$18
11080                       0000000A            .ata_cmd_data_in.cylinder	set	$A
11081                       00000012            _ata_cmd_data_in.device	set	$12
11082                       00000004            .ata_cmd_data_in.device	set	4
11083                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
11084                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
11085                       00000003            _ata_cmd_data_in.status	set	3
11086                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
11087                       00000002            _ata_cmd_data_in.current	set	2
11088                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
11089                       00000014            _ata_cmd_data_in.command	set	$14
11090                       00000006            .ata_cmd_data_in.command	set	6
11091                       00000001            _ata_cmd_data_in.mode	set	1
11092                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
11093                       00000008            _ata_cmd_data_in.iobase2	set	8
11094                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
11095                       00000028            _ata_cmd_data_in.offset	set	$28
11096                       0000001A            .ata_cmd_data_in.offset	set	$1A
11097                       00000004            _ata_cmd_data_in.slave	set	4
11098                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
11099 3242           FB                                 sti ;; enable higher priority interrupts
11100                                           ! 1881 endasm
11101                                           !BCC_ENDASM
11102                                           !BCC_EOS
11103                                           ! 1882   while (1) {
11104                       00003243            .276:
11105                                           ! 1883 #asm
11106                                           !BCC_EOS
11107                                           !BCC_ASM
11108                       00000016            _ata_cmd_data_in.count	set	$16
11109                       00000008            .ata_cmd_data_in.count	set	8
11110                       00000026            _ata_cmd_data_in.segment	set	$26
11111                       00000018            .ata_cmd_data_in.segment	set	$18
11112                       0000000A            _ata_cmd_data_in.iobase1	set	$A
11113                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
11114                       00000005            _ata_cmd_data_in.channel	set	5
11115                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
11116                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
11117                       00000010            .ata_cmd_data_in.lba_low	set	$10
11118                       00000022            _ata_cmd_data_in.lba_high	set	$22
11119                       00000014            .ata_cmd_data_in.lba_high	set	$14
11120                       0000001C            _ata_cmd_data_in.sector	set	$1C
11121                       0000000E            .ata_cmd_data_in.sector	set	$E
11122                       00000006            _ata_cmd_data_in.blksize	set	6
11123                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
11124                       0000001A            _ata_cmd_data_in.head	set	$1A
11125                       0000000C            .ata_cmd_data_in.head	set	$C
11126                       00000018            _ata_cmd_data_in.cylinder	set	$18
11127                       0000000A            .ata_cmd_data_in.cylinder	set	$A
11128                       00000012            _ata_cmd_data_in.device	set	$12
11129                       00000004            .ata_cmd_data_in.device	set	4
11130                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
11131                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
11132                       00000003            _ata_cmd_data_in.status	set	3
11133                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
11134                       00000002            _ata_cmd_data_in.current	set	2
11135                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
11136                       00000014            _ata_cmd_data_in.command	set	$14
11137                       00000006            .ata_cmd_data_in.command	set	6
11138                       00000001            _ata_cmd_data_in.mode	set	1
11139                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
11140                       00000008            _ata_cmd_data_in.iobase2	set	8
11141                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
11142                       00000028            _ata_cmd_data_in.offset	set	$28
11143                       0000001A            .ata_cmd_data_in.offset	set	$1A
11144                       00000004            _ata_cmd_data_in.slave	set	4
11145                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
11146 3243           55                                 push bp
11147 3244           89E5                               mov bp, sp
11148 3246           8B7E         2A                    mov di, _ata_cmd_data_in.offset + 2[bp]
11149 3249           8B46         28                    mov ax, _ata_cmd_data_in.segment + 2[bp]
11150 324C           8B4E         08                    mov cx, _ata_cmd_data_in.blksize + 2[bp]
11151                                                   ;; adjust if there will be an overrun. 2K max sector size
11152 324F           81FF                 F800          cmp di, #0xf800 ;;
11153 3253           76           07                    jbe ata_in_no_adjust
11154                       00003255            ata_in_adjust:
11155 3255           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
11156 3259           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
11157                       0000325C            ata_in_no_adjust:
11158 325C           8EC0                               mov es, ax ;; segment in es
11159 325E           8B56         0C                    mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
11160 3261           8A66         03                    mov ah, _ata_cmd_data_in.mode + 2[bp]
11161 3264           80FC                   01          cmp ah, #0x01
11162 3267           74           04                    je ata_in_32
11163                       00003269            ata_in_16:
11164 3269           F3                                 rep
11165 326A           6D                                   insw ;; CX words transfered from port(DX) to ES:[DI]
11166 326B           EB           03                    jmp ata_in_done
11167                       0000326D            ata_in_32:
11168 326D           F3                                 rep
11169 326E     66    6D                                   insd ;; CX dwords transfered from port(DX) to ES:[DI]
11170                       00003270            ata_in_done:
11171 3270           897E         2A                    mov _ata_cmd_data_in.offset + 2[bp], di
11172 3273           8C46         28                    mov _ata_cmd_data_in.segment + 2[bp], es
11173 3276           5D                                 pop bp
11174                                           ! 1912 endasm
11175                                           !BCC_ENDASM
11176                                           !BCC_EOS
11177                                           ! 1913     current++;
11178                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11179 3277           8A46         F4            mov	al,-$C[bp]
11180 327A           40                         inc	ax
11181 327B           8846         F4            mov	-$C[bp],al
11182                                           !BCC_EOS
11183                                           ! 1914     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,curr
11184                                           ! 1914 ent);
11185                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11186 327E           8A46         F4            mov	al,-$C[bp]
11187 3281           30E4                       xor	ah,ah
11188 3283           50                         push	ax
11189                                           ! Debug: list * unsigned short = const $254 (used reg = )
11190 3284           B8                   0254  mov	ax,#$254
11191 3287           50                         push	ax
11192                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11193 3288           FF76         FE            push	-2[bp]
11194                                           ! Debug: func () void = write_word+0 (used reg = )
11195 328B           E8         D3A4            call	_write_word
11196 328E           83C4                   06  add	sp,*6
11197                                           !BCC_EOS
11198                                           ! 1915     count--;
11199                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11200 3291           8B46         08            mov	ax,8[bp]
11201 3294           48                         dec	ax
11202 3295           8946         08            mov	8[bp],ax
11203                                           !BCC_EOS
11204                                           ! 1916     await_ide(2, iobase1, 32000u);
11205                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11206 3298           B8                   7D00  mov	ax,#$7D00
11207 329B           50                         push	ax
11208                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11209 329C           FF76         FC            push	-4[bp]
11210                                           ! Debug: list int = const 2 (used reg = )
11211 329F           B8                   0002  mov	ax,*2
11212 32A2           50                         push	ax
11213                                           ! Debug: func () int = await_ide+0 (used reg = )
11214 32A3           E8         EA64            call	_await_ide
11215 32A6           83C4                   06  add	sp,*6
11216                                           !BCC_EOS
11217                                           ! 1917     status = inb(iobase1 + 7);
11218                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11219 32A9           8B46         FC            mov	ax,-4[bp]
11220                                           ! Debug: list unsigned int = ax+7 (used reg = )
11221 32AC           05                   0007  add	ax,*7
11222 32AF           50                         push	ax
11223                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11224 32B0           E8         D28B            call	_inb
11225 32B3           44                         inc	sp
11226 32B4           44                         inc	sp
11227                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11228 32B5           8846         F5            mov	-$B[bp],al
11229                                           !BCC_EOS
11230                                           ! 1918     if (count == 0) {
11231                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11232 32B8           8B46         08            mov	ax,8[bp]
11233 32BB           85C0                       test	ax,ax
11234 32BD           75           14            jne 	.277
11235                       000032BF            .278:
11236                                           ! 1919       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11237                                           ! 1920           != 0x40 ) {
11238                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11239 32BF           8A46         F5            mov	al,-$B[bp]
11240 32C2           24                     C9  and	al,#$C9
11241                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11242 32C4           3C                     40  cmp	al,*$40
11243 32C6           74           07            je  	.279
11244                       000032C8            .27A:
11245                                           ! 1921         ;
11246                                           !BCC_EOS
11247                                           ! 1922         return 4;
11248 32C8           B8                   0004  mov	ax,*4
11249 32CB           89EC                       mov	sp,bp
11250 32CD           5D                         pop	bp
11251 32CE           C3                         ret
11252                                           !BCC_EOS
11253                                           ! 1923         }
11254                                           ! 1924       break;
11255                       000032CF            .279:
11256 32CF           EB           17            jmp .274
11257                                           !BCC_EOS
11258                                           ! 1925       }
11259                                           ! 1926     else {
11260 32D1           EB           12            jmp .27B
11261                       000032D3            .277:
11262                                           ! 1927       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11263                                           ! 1928           != (0x40 | 0x08) ) {
11264                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11265 32D3           8A46         F5            mov	al,-$B[bp]
11266 32D6           24                     C9  and	al,#$C9
11267                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11268 32D8           3C                     48  cmp	al,*$48
11269 32DA           74           07            je  	.27C
11270                       000032DC            .27D:
11271                                           ! 1929         ;
11272                                           !BCC_EOS
11273                                           ! 1930         return 5;
11274 32DC           B8                   0005  mov	ax,*5
11275 32DF           89EC                       mov	sp,bp
11276 32E1           5D                         pop	bp
11277 32E2           C3                         ret
11278                                           !BCC_EOS
11279                                           ! 1931       }
11280                                           ! 1932       continue;
11281                       000032E3            .27C:
11282 32E3           EB           00            jmp .275
11283                                           !BCC_EOS
11284                                           ! 1933     }
11285                                           ! 1934   }
11286                       000032E5            .27B:
11287                                           ! 1935   outb(iobase2+6, 0x08);
11288                       000032E5            .275:
11289 32E5           E9         FF5B            jmp	.276
11290                       000032E8            .27E:
11291                       000032E8            .274:
11292                                           ! Debug: list int = const 8 (used reg = )
11293 32E8           B8                   0008  mov	ax,*8
11294 32EB           50                         push	ax
11295                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11296 32EC           8B46         FA            mov	ax,-6[bp]
11297                                           ! Debug: list unsigned int = ax+6 (used reg = )
11298 32EF           05                   0006  add	ax,*6
11299 32F2           50                         push	ax
11300                                           ! Debug: func () void = outb+0 (used reg = )
11301 32F3           E8         D25E            call	_outb
11302 32F6           83C4                   04  add	sp,*4
11303                                           !BCC_EOS
11304                                           ! 1936   return 0;
11305 32F9           31C0                       xor	ax,ax
11306 32FB           89EC                       mov	sp,bp
11307 32FD           5D                         pop	bp
11308 32FE           C3                         ret
11309                                           !BCC_EOS
11310                                           ! 1937 }
11311                                           ! 1938 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
11312                                           ! Register BX used in function ata_cmd_data_in
11313                                           ! 1939 Bit16u device, command, count, cylinder, head, sector, segment, offset;
11314                                           export	_ata_cmd_data_out
11315                       000032FF            _ata_cmd_data_out:
11316                                           !BCC_EOS
11317                                           ! 1940 Bit32u lba_low, lba_high;
11318                                           !BCC_EOS
11319                                           ! 1941 {
11320                                           ! 1942   Bit16u ebda_seg=read_word(0x0040,0x000E);
11321 32FF           55                         push	bp
11322 3300           89E5                       mov	bp,sp
11323 3302           4C                         dec	sp
11324 3303           4C                         dec	sp
11325                                           ! Debug: list int = const $E (used reg = )
11326 3304           B8                   000E  mov	ax,*$E
11327 3307           50                         push	ax
11328                                           ! Debug: list int = const $40 (used reg = )
11329 3308           B8                   0040  mov	ax,*$40
11330 330B           50                         push	ax
11331                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11332 330C           E8         D2F8            call	_read_word
11333 330F           83C4                   04  add	sp,*4
11334                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11335 3312           8946         FE            mov	-2[bp],ax
11336                                           !BCC_EOS
11337                                           ! 1943   Bit16u iobase1, iobase2, blksize;
11338                                           !BCC_EOS
11339                                           ! 1944   Bit8u channel, slave;
11340                                           !BCC_EOS
11341                                           ! 1945   Bit8u status, current, mode;
11342                                           !BCC_EOS
11343                                           ! 1946   channel = device / 2;
11344 3315           83C4                   F4  add	sp,*-$C
11345                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11346 3318           8B46         04            mov	ax,4[bp]
11347 331B           D1E8                       shr	ax,*1
11348                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
11349 331D           8846         F7            mov	-9[bp],al
11350                                           !BCC_EOS
11351                                           ! 1947   slave = device % 2;
11352                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11353 3320           8B46         04            mov	ax,4[bp]
11354 3323           24                     01  and	al,*1
11355                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
11356 3325           8846         F6            mov	-$A[bp],al
11357                                           !BCC_EOS
11358                                           ! 1948   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11359                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11360 3328           8A46         F7            mov	al,-9[bp]
11361 332B           30E4                       xor	ah,ah
11362 332D           B1                     03  mov	cl,*3
11363 332F           D3E0                       shl	ax,cl
11364 3331           89C3                       mov	bx,ax
11365                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11366                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11367 3333           81C3                 0124  add	bx,#$124
11368 3337           53                         push	bx
11369                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11370 3338           FF76         FE            push	-2[bp]
11371                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11372 333B           E8         D2C9            call	_read_word
11373 333E           83C4                   04  add	sp,*4
11374                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
11375 3341           8946         FC            mov	-4[bp],ax
11376                                           !BCC_EOS
11377                                           ! 1949   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11378                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11379 3344           8A46         F7            mov	al,-9[bp]
11380 3347           30E4                       xor	ah,ah
11381 3349           B1                     03  mov	cl,*3
11382 334B           D3E0                       shl	ax,cl
11383 334D           89C3                       mov	bx,ax
11384                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11385                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11386 334F           81C3                 0126  add	bx,#$126
11387 3353           53                         push	bx
11388                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11389 3354           FF76         FE            push	-2[bp]
11390                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11391 3357           E8         D2AD            call	_read_word
11392 335A           83C4                   04  add	sp,*4
11393                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
11394 335D           8946         FA            mov	-6[bp],ax
11395                                           !BCC_EOS
11396                                           ! 1950   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11397                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
11398 3360           8B46         04            mov	ax,4[bp]
11399 3363           B9                   001E  mov	cx,*$1E
11400 3366           F7E9                       imul	cx
11401 3368           89C3                       mov	bx,ax
11402                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11403                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11404 336A           81C3                 0146  add	bx,#$146
11405 336E           53                         push	bx
11406                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11407 336F           FF76         FE            push	-2[bp]
11408                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11409 3372           E8         D27F            call	_read_byte
11410 3375           83C4                   04  add	sp,*4
11411                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
11412 3378           8846         F3            mov	-$D[bp],al
11413                                           !BCC_EOS
11414                                           ! 1951   blksize = 0x200;
11415                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
11416 337B           B8                   0200  mov	ax,#$200
11417 337E           8946         F8            mov	-8[bp],ax
11418                                           !BCC_EOS
11419                                           ! 1952   if (mode == 0x01) blksize>>=2;
11420                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
11421 3381           8A46         F3            mov	al,-$D[bp]
11422 3384           3C                     01  cmp	al,*1
11423 3386           75           0C            jne 	.27F
11424                       00003388            .280:
11425                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
11426 3388           8B46         F8            mov	ax,-8[bp]
11427 338B           D1E8                       shr	ax,*1
11428 338D           D1E8                       shr	ax,*1
11429 338F           8946         F8            mov	-8[bp],ax
11430                                           !BCC_EOS
11431                                           ! 1953   else blksize>>=1;
11432 3392           EB           08            jmp .281
11433                       00003394            .27F:
11434                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
11435 3394           8B46         F8            mov	ax,-8[bp]
11436 3397           D1E8                       shr	ax,*1
11437 3399           8946         F8            mov	-8[bp],ax
11438                                           !BCC_EOS
11439                                           ! 1954   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11440                       0000339C            .281:
11441                                           ! Debug: list int = const 0 (used reg = )
11442 339C           31C0                       xor	ax,ax
11443 339E           50                         push	ax
11444                                           ! Debug: list * unsigned short = const $254 (used reg = )
11445 339F           B8                   0254  mov	ax,#$254
11446 33A2           50                         push	ax
11447                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11448 33A3           FF76         FE            push	-2[bp]
11449                                           ! Debug: func () void = write_word+0 (used reg = )
11450 33A6           E8         D289            call	_write_word
11451 33A9           83C4                   06  add	sp,*6
11452                                           !BCC_EOS
11453                                           ! 1955   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11454                                           ! Debug: list long = const 0 (used reg = )
11455 33AC           31C0                       xor	ax,ax
11456 33AE           31DB                       xor	bx,bx
11457 33B0           53                         push	bx
11458 33B1           50                         push	ax
11459                                           ! Debug: list * unsigned long = const $256 (used reg = )
11460 33B2           B8                   0256  mov	ax,#$256
11461 33B5           50                         push	ax
11462                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
11463 33B6           FF76         FE            push	-2[bp]
11464                                           ! Debug: func () void = write_dword+0 (used reg = )
11465 33B9           E8         CCDF            call	_write_dword
11466 33BC           83C4                   08  add	sp,*8
11467                                           !BCC_EOS
11468                                           ! 1956   current = 0;
11469                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
11470 33BF           30C0                       xor	al,al
11471 33C1           8846         F4            mov	-$C[bp],al
11472                                           !BCC_EOS
11473                                           ! 1957   status = inb(iobase1 + 7);
11474                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11475 33C4           8B46         FC            mov	ax,-4[bp]
11476                                           ! Debug: list unsigned int = ax+7 (used reg = )
11477 33C7           05                   0007  add	ax,*7
11478 33CA           50                         push	ax
11479                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11480 33CB           E8         D170            call	_inb
11481 33CE           44                         inc	sp
11482 33CF           44                         inc	sp
11483                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11484 33D0           8846         F5            mov	-$B[bp],al
11485                                           !BCC_EOS
11486                                           ! 1958   if (status & 0x80) return 1;
11487                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
11488 33D3           8A46         F5            mov	al,-$B[bp]
11489 33D6           24                     80  and	al,#$80
11490 33D8           84C0                       test	al,al
11491 33DA           74           07            je  	.282
11492                       000033DC            .283:
11493 33DC           B8                   0001  mov	ax,*1
11494 33DF           89EC                       mov	sp,bp
11495 33E1           5D                         pop	bp
11496 33E2           C3                         ret
11497                                           !BCC_EOS
11498                                           ! 1959   outb(iobase2 + 6, 0x08 | 0x02);
11499                       000033E3            .282:
11500                                           ! Debug: list int = const $A (used reg = )
11501 33E3           B8                   000A  mov	ax,*$A
11502 33E6           50                         push	ax
11503                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11504 33E7           8B46         FA            mov	ax,-6[bp]
11505                                           ! Debug: list unsigned int = ax+6 (used reg = )
11506 33EA           05                   0006  add	ax,*6
11507 33ED           50                         push	ax
11508                                           ! Debug: func () void = outb+0 (used reg = )
11509 33EE           E8         D163            call	_outb
11510 33F1           83C4                   04  add	sp,*4
11511                                           !BCC_EOS
11512                                           ! 1960   if (sector == 0) {
11513                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
11514 33F4           8B46         0E            mov	ax,$E[bp]
11515 33F7           85C0                       test	ax,ax
11516 33F9         0F85         0167            bne 	.284
11517                       000033FD            .285:
11518                                           ! 1961     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
11519                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
11520 33FD           8B46         08            mov	ax,8[bp]
11521 3400           3D                   0100  cmp	ax,#$100
11522 3403           72           04            jb 	.28A
11523 3405           B0                     01  mov	al,*1
11524 3407           EB           02            jmp	.28B
11525                       00003409            .28A:
11526 3409           30C0                       xor	al,al
11527                       0000340B            .28B:
11528                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
11529 340B           30E4                       xor	ah,ah
11530 340D           99                         cwd
11531 340E           89D3                       mov	bx,dx
11532 3410           E8         CD01            call	ltstl
11533 3413           75           32            jne 	.287
11534                       00003415            .289:
11535 3415           8B46         14            mov	ax,$14[bp]
11536 3418           8B5E         16            mov	bx,$16[bp]
11537 341B           E8         CCF6            call	ltstl
11538 341E           75           27            jne 	.287
11539                       00003420            .288:
11540                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
11541 3420           8B46         08            mov	ax,8[bp]
11542 3423           31DB                       xor	bx,bx
11543                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
11544                                           ! Debug: expression subtree swapping
11545 3425           8D7E         10            lea	di,$10[bp]
11546 3428           E8         CC98            call	laddul
11547                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
11548 342B           53                         push	bx
11549 342C           50                         push	ax
11550 342D           31C0                       xor	ax,ax
11551 342F           BB                   1000  mov	bx,#$1000
11552 3432           53                         push	bx
11553 3433           50                         push	ax
11554 3434           8B46         EE            mov	ax,-$12[bp]
11555 3437           8B5E         F0            mov	bx,-$10[bp]
11556 343A           8D7E         EA            lea	di,-$16[bp]
11557 343D           E8         CC8B            call	lcmpul
11558 3440           8D66         F2            lea	sp,-$E[bp]
11559 3443         0F82         00BC            blo 	.286
11560                       00003447            .287:
11561                                           ! 1962       outb(iobase1 + 1, 0x00);
11562                                           ! Debug: list int = const 0 (used reg = )
11563 3447           31C0                       xor	ax,ax
11564 3449           50                         push	ax
11565                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11566 344A           8B46         FC            mov	ax,-4[bp]
11567                                           ! Debug: list unsigned int = ax+1 (used reg = )
11568 344D           40                         inc	ax
11569 344E           50                         push	ax
11570                                           ! Debug: func () void = outb+0 (used reg = )
11571 344F           E8         D102            call	_outb
11572 3452           83C4                   04  add	sp,*4
11573                                           !BCC_EOS
11574                                           ! 1963       outb(iobase1 + 2, (count >> 8) & 0xff);
11575                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
11576 3455           8B46         08            mov	ax,8[bp]
11577 3458           88E0                       mov	al,ah
11578 345A           30E4                       xor	ah,ah
11579                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
11580                                           ! Debug: list unsigned char = al+0 (used reg = )
11581 345C           30E4                       xor	ah,ah
11582 345E           50                         push	ax
11583                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11584 345F           8B46         FC            mov	ax,-4[bp]
11585                                           ! Debug: list unsigned int = ax+2 (used reg = )
11586 3462           40                         inc	ax
11587 3463           40                         inc	ax
11588 3464           50                         push	ax
11589                                           ! Debug: func () void = outb+0 (used reg = )
11590 3465           E8         D0EC            call	_outb
11591 3468           83C4                   04  add	sp,*4
11592                                           !BCC_EOS
11593                                           ! 1964       outb(iobase1 + 3, lba_low >> 24);
11594                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11595 346B           8B46         10            mov	ax,$10[bp]
11596 346E           8B5E         12            mov	bx,$12[bp]
11597 3471           93                         xchg	bx,ax
11598 3472           88E0                       mov	al,ah
11599 3474           30E4                       xor	ah,ah
11600 3476           31DB                       xor	bx,bx
11601                                           ! Debug: list unsigned long = bx+0 (used reg = )
11602 3478           53                         push	bx
11603 3479           50                         push	ax
11604                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
11605 347A           8B46         FC            mov	ax,-4[bp]
11606                                           ! Debug: list unsigned int = ax+3 (used reg = )
11607 347D           05                   0003  add	ax,*3
11608 3480           50                         push	ax
11609                                           ! Debug: func () void = outb+0 (used reg = )
11610 3481           E8         D0D0            call	_outb
11611 3484           83C4                   06  add	sp,*6
11612                                           !BCC_EOS
11613                                           ! 1965       outb(iobase1 + 4, lba_high & 0xff);
11614                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
11615                                           ! Debug: expression subtree swapping
11616 3487           B8                   00FF  mov	ax,#$FF
11617 348A           31DB                       xor	bx,bx
11618 348C           8D7E         14            lea	di,$14[bp]
11619 348F           E8         CC29            call	landul
11620                                           ! Debug: list unsigned long = bx+0 (used reg = )
11621 3492           53                         push	bx
11622 3493           50                         push	ax
11623                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
11624 3494           8B46         FC            mov	ax,-4[bp]
11625                                           ! Debug: list unsigned int = ax+4 (used reg = )
11626 3497           05                   0004  add	ax,*4
11627 349A           50                         push	ax
11628                                           ! Debug: func () void = outb+0 (used reg = )
11629 349B           E8         D0B6            call	_outb
11630 349E           83C4                   06  add	sp,*6
11631                                           !BCC_EOS
11632                                           ! 1966       outb(iobase1 + 5, lba_high >> 8);
11633                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
11634 34A1           8B46         14            mov	ax,$14[bp]
11635 34A4           8B5E         16            mov	bx,$16[bp]
11636 34A7           88E0                       mov	al,ah
11637 34A9           88DC                       mov	ah,bl
11638 34AB           88FB                       mov	bl,bh
11639 34AD           28FF                       sub	bh,bh
11640                                           ! Debug: list unsigned long = bx+0 (used reg = )
11641 34AF           53                         push	bx
11642 34B0           50                         push	ax
11643                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
11644 34B1           8B46         FC            mov	ax,-4[bp]
11645                                           ! Debug: list unsigned int = ax+5 (used reg = )
11646 34B4           05                   0005  add	ax,*5
11647 34B7           50                         push	ax
11648                                           ! Debug: func () void = outb+0 (used reg = )
11649 34B8           E8         D099            call	_outb
11650 34BB           83C4                   06  add	sp,*6
11651                                           !BCC_EOS
11652                                           ! 1967       command |= 0x04;
11653                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
11654 34BE           8B46         06            mov	ax,6[bp]
11655 34C1           0C                     04  or	al,*4
11656 34C3           8946         06            mov	6[bp],ax
11657                                           !BCC_EOS
11658                                           ! 1968       count &= (1UL << 8) - 1;
11659                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
11660 34C6           8B46         08            mov	ax,8[bp]
11661 34C9           31DB                       xor	bx,bx
11662 34CB           53                         push	bx
11663 34CC           50                         push	ax
11664 34CD           B8                   00FF  mov	ax,#$FF
11665 34D0           31DB                       xor	bx,bx
11666 34D2           53                         push	bx
11667 34D3           50                         push	ax
11668 34D4           8B46         EE            mov	ax,-$12[bp]
11669 34D7           8B5E         F0            mov	bx,-$10[bp]
11670 34DA           8D7E         EA            lea	di,-$16[bp]
11671 34DD           E8         CBDB            call	landul
11672 34E0           8946         08            mov	8[bp],ax
11673 34E3           83C4                   08  add	sp,*8
11674                                           !BCC_EOS
11675                                           ! 1969       lba_low &= (1UL << 24) - 1;
11676                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
11677 34E6           B8                   FFFF  mov	ax,#$FFFF
11678 34E9           BB                   00FF  mov	bx,#$FF
11679 34EC           53                         push	bx
11680 34ED           50                         push	ax
11681 34EE           8B46         10            mov	ax,$10[bp]
11682 34F1           8B5E         12            mov	bx,$12[bp]
11683 34F4           8D7E         EE            lea	di,-$12[bp]
11684 34F7           E8         CBC1            call	landul
11685 34FA           8946         10            mov	$10[bp],ax
11686 34FD           895E         12            mov	$12[bp],bx
11687 3500           83C4                   04  add	sp,*4
11688                                           !BCC_EOS
11689                                           ! 1970       }
11690                                           ! 1971     sector = (Bit16u) (lba_low & 0x000000ffL);
11691                       00003503            .286:
11692                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
11693                                           ! Debug: expression subtree swapping
11694 3503           B8                   00FF  mov	ax,#$FF
11695 3506           31DB                       xor	bx,bx
11696 3508           8D7E         10            lea	di,$10[bp]
11697 350B           E8         CBAD            call	landul
11698                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11699                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
11700 350E           8946         0E            mov	$E[bp],ax
11701                                           !BCC_EOS
11702                                           ! 1972     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
11703                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
11704 3511           8B46         10            mov	ax,$10[bp]
11705 3514           8B5E         12            mov	bx,$12[bp]
11706 3517           88E0                       mov	al,ah
11707 3519           88DC                       mov	ah,bl
11708 351B           88FB                       mov	bl,bh
11709 351D           28FF                       sub	bh,bh
11710                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
11711 351F           53                         push	bx
11712 3520           50                         push	ax
11713 3521           B8                   FFFF  mov	ax,#$FFFF
11714 3524           31DB                       xor	bx,bx
11715 3526           53                         push	bx
11716 3527           50                         push	ax
11717 3528           8B46         EE            mov	ax,-$12[bp]
11718 352B           8B5E         F0            mov	bx,-$10[bp]
11719 352E           8D7E         EA            lea	di,-$16[bp]
11720 3531           E8         CB87            call	landul
11721 3534           83C4                   08  add	sp,*8
11722                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11723                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
11724 3537           8946         0A            mov	$A[bp],ax
11725                                           !BCC_EOS
11726                                           ! 1973     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
11727                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11728 353A           8B46         10            mov	ax,$10[bp]
11729 353D           8B5E         12            mov	bx,$12[bp]
11730 3540           93                         xchg	bx,ax
11731 3541           88E0                       mov	al,ah
11732 3543           30E4                       xor	ah,ah
11733 3545           31DB                       xor	bx,bx
11734                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
11735 3547           53                         push	bx
11736 3548           50                         push	ax
11737 3549           B8                   000F  mov	ax,*$F
11738 354C           31DB                       xor	bx,bx
11739 354E           53                         push	bx
11740 354F           50                         push	ax
11741 3550           8B46         EE            mov	ax,-$12[bp]
11742 3553           8B5E         F0            mov	bx,-$10[bp]
11743 3556           8D7E         EA            lea	di,-$16[bp]
11744 3559           E8         CB5F            call	landul
11745 355C           83C4                   08  add	sp,*8
11746                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11747                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
11748 355F           0C                     40  or	al,*$40
11749                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
11750 3561           8946         0C            mov	$C[bp],ax
11751                                           !BCC_EOS
11752                                           ! 1974   }
11753                                           ! 1975   outb(iobase1 + 1, 0x00);
11754                       00003564            .284:
11755                                           ! Debug: list int = const 0 (used reg = )
11756 3564           31C0                       xor	ax,ax
11757 3566           50                         push	ax
11758                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11759 3567           8B46         FC            mov	ax,-4[bp]
11760                                           ! Debug: list unsigned int = ax+1 (used reg = )
11761 356A           40                         inc	ax
11762 356B           50                         push	ax
11763                                           ! Debug: func () void = outb+0 (used reg = )
11764 356C           E8         CFE5            call	_outb
11765 356F           83C4                   04  add	sp,*4
11766                                           !BCC_EOS
11767                                           ! 1976   outb(iobase1 + 2, count);
11768                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
11769 3572           FF76         08            push	8[bp]
11770                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11771 3575           8B46         FC            mov	ax,-4[bp]
11772                                           ! Debug: list unsigned int = ax+2 (used reg = )
11773 3578           40                         inc	ax
11774 3579           40                         inc	ax
11775 357A           50                         push	ax
11776                                           ! Debug: func () void = outb+0 (used reg = )
11777 357B           E8         CFD6            call	_outb
11778 357E           83C4                   04  add	sp,*4
11779                                           !BCC_EOS
11780                                           ! 1977   outb(iobase1 + 3, sector);
11781                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
11782 3581           FF76         0E            push	$E[bp]
11783                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
11784 3584           8B46         FC            mov	ax,-4[bp]
11785                                           ! Debug: list unsigned int = ax+3 (used reg = )
11786 3587           05                   0003  add	ax,*3
11787 358A           50                         push	ax
11788                                           ! Debug: func () void = outb+0 (used reg = )
11789 358B           E8         CFC6            call	_outb
11790 358E           83C4                   04  add	sp,*4
11791                                           !BCC_EOS
11792                                           ! 1978   outb(iobase1 + 4, cylin
11793                                           ! 1978 der & 0x00ff);
11794                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
11795 3591           8A46         0A            mov	al,$A[bp]
11796                                           ! Debug: list unsigned char = al+0 (used reg = )
11797 3594           30E4                       xor	ah,ah
11798 3596           50                         push	ax
11799                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
11800 3597           8B46         FC            mov	ax,-4[bp]
11801                                           ! Debug: list unsigned int = ax+4 (used reg = )
11802 359A           05                   0004  add	ax,*4
11803 359D           50                         push	ax
11804                                           ! Debug: func () void = outb+0 (used reg = )
11805 359E           E8         CFB3            call	_outb
11806 35A1           83C4                   04  add	sp,*4
11807                                           !BCC_EOS
11808                                           ! 1979   outb(iobase1 + 5, cylinder >> 8);
11809                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
11810 35A4           8B46         0A            mov	ax,$A[bp]
11811 35A7           88E0                       mov	al,ah
11812 35A9           30E4                       xor	ah,ah
11813                                           ! Debug: list unsigned int = ax+0 (used reg = )
11814 35AB           50                         push	ax
11815                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
11816 35AC           8B46         FC            mov	ax,-4[bp]
11817                                           ! Debug: list unsigned int = ax+5 (used reg = )
11818 35AF           05                   0005  add	ax,*5
11819 35B2           50                         push	ax
11820                                           ! Debug: func () void = outb+0 (used reg = )
11821 35B3           E8         CF9E            call	_outb
11822 35B6           83C4                   04  add	sp,*4
11823                                           !BCC_EOS
11824                                           ! 1980   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
11825 35B9           8A46         F6            mov	al,-$A[bp]
11826 35BC           84C0                       test	al,al
11827 35BE           74           04            je  	.28D
11828                       000035C0            .28E:
11829 35C0           B0                     B0  mov	al,#$B0
11830 35C2           EB           02            jmp .28F
11831                       000035C4            .28D:
11832 35C4           B0                     A0  mov	al,#$A0
11833                       000035C6            .28F:
11834                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
11835 35C6           0A46         0C            or	al,$C[bp]
11836                                           ! Debug: list unsigned char = al+0 (used reg = )
11837 35C9           30E4                       xor	ah,ah
11838 35CB           50                         push	ax
11839                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
11840 35CC           8B46         FC            mov	ax,-4[bp]
11841                                           ! Debug: list unsigned int = ax+6 (used reg = )
11842 35CF           05                   0006  add	ax,*6
11843 35D2           50                         push	ax
11844                                           ! Debug: func () void = outb+0 (used reg = )
11845 35D3           E8         CF7E            call	_outb
11846 35D6           83C4                   04  add	sp,*4
11847                                           !BCC_EOS
11848                                           ! 1981   outb(iobase1 + 7, command);
11849                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
11850 35D9           FF76         06            push	6[bp]
11851                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
11852 35DC           8B46         FC            mov	ax,-4[bp]
11853                                           ! Debug: list unsigned int = ax+7 (used reg = )
11854 35DF           05                   0007  add	ax,*7
11855 35E2           50                         push	ax
11856                                           ! Debug: func () void = outb+0 (used reg = )
11857 35E3           E8         CF6E            call	_outb
11858 35E6           83C4                   04  add	sp,*4
11859                                           !BCC_EOS
11860                                           ! 1982   await_ide(3, iobase1, 32000u);
11861                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11862 35E9           B8                   7D00  mov	ax,#$7D00
11863 35EC           50                         push	ax
11864                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11865 35ED           FF76         FC            push	-4[bp]
11866                                           ! Debug: list int = const 3 (used reg = )
11867 35F0           B8                   0003  mov	ax,*3
11868 35F3           50                         push	ax
11869                                           ! Debug: func () int = await_ide+0 (used reg = )
11870 35F4           E8         E713            call	_await_ide
11871 35F7           83C4                   06  add	sp,*6
11872                                           !BCC_EOS
11873                                           ! 1983   status = inb(iobase1 + 7);
11874                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11875 35FA           8B46         FC            mov	ax,-4[bp]
11876                                           ! Debug: list unsigned int = ax+7 (used reg = )
11877 35FD           05                   0007  add	ax,*7
11878 3600           50                         push	ax
11879                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11880 3601           E8         CF3A            call	_inb
11881 3604           44                         inc	sp
11882 3605           44                         inc	sp
11883                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11884 3606           8846         F5            mov	-$B[bp],al
11885                                           !BCC_EOS
11886                                           ! 1984   if (status & 0x01) {
11887                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
11888 3609           8A46         F5            mov	al,-$B[bp]
11889 360C           24                     01  and	al,*1
11890 360E           84C0                       test	al,al
11891 3610           74           09            je  	.290
11892                       00003612            .291:
11893                                           ! 1985     ;
11894                                           !BCC_EOS
11895                                           ! 1986     return 2;
11896 3612           B8                   0002  mov	ax,*2
11897 3615           89EC                       mov	sp,bp
11898 3617           5D                         pop	bp
11899 3618           C3                         ret
11900                                           !BCC_EOS
11901                                           ! 1987     } else if ( !(status & 0x08) ) {
11902 3619           EB           10            jmp .292
11903                       0000361B            .290:
11904                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
11905 361B           8A46         F5            mov	al,-$B[bp]
11906 361E           24                     08  and	al,*8
11907 3620           84C0                       test	al,al
11908 3622           75           07            jne 	.293
11909                       00003624            .294:
11910                                           ! 1988     ;
11911                                           !BCC_EOS
11912                                           ! 1989     return 3;
11913 3624           B8                   0003  mov	ax,*3
11914 3627           89EC                       mov	sp,bp
11915 3629           5D                         pop	bp
11916 362A           C3                         ret
11917                                           !BCC_EOS
11918                                           ! 1990     }
11919                                           ! 1991 #asm
11920                       0000362B            .293:
11921                       0000362B            .292:
11922                                           !BCC_EOS
11923                                           !BCC_ASM
11924                       00000016            _ata_cmd_data_out.count	set	$16
11925                       00000008            .ata_cmd_data_out.count	set	8
11926                       00000026            _ata_cmd_data_out.segment	set	$26
11927                       00000018            .ata_cmd_data_out.segment	set	$18
11928                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11929                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11930                       00000005            _ata_cmd_data_out.channel	set	5
11931                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11932                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11933                       00000010            .ata_cmd_data_out.lba_low	set	$10
11934                       00000022            _ata_cmd_data_out.lba_high	set	$22
11935                       00000014            .ata_cmd_data_out.lba_high	set	$14
11936                       0000001C            _ata_cmd_data_out.sector	set	$1C
11937                       0000000E            .ata_cmd_data_out.sector	set	$E
11938                       00000006            _ata_cmd_data_out.blksize	set	6
11939                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11940                       0000001A            _ata_cmd_data_out.head	set	$1A
11941                       0000000C            .ata_cmd_data_out.head	set	$C
11942                       00000018            _ata_cmd_data_out.cylinder	set	$18
11943                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11944                       00000012            _ata_cmd_data_out.device	set	$12
11945                       00000004            .ata_cmd_data_out.device	set	4
11946                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11947                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11948                       00000003            _ata_cmd_data_out.status	set	3
11949                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11950                       00000002            _ata_cmd_data_out.current	set	2
11951                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11952                       00000014            _ata_cmd_data_out.command	set	$14
11953                       00000006            .ata_cmd_data_out.command	set	6
11954                       00000001            _ata_cmd_data_out.mode	set	1
11955                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11956                       00000008            _ata_cmd_data_out.iobase2	set	8
11957                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11958                       00000028            _ata_cmd_data_out.offset	set	$28
11959                       0000001A            .ata_cmd_data_out.offset	set	$1A
11960                       00000004            _ata_cmd_data_out.slave	set	4
11961                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11962 362B           FB                                 sti ;; enable higher priority interrupts
11963                                           ! 1993 endasm
11964                                           !BCC_ENDASM
11965                                           !BCC_EOS
11966                                           ! 1994   while (1) {
11967                       0000362C            .297:
11968                                           ! 1995 #asm
11969                                           !BCC_EOS
11970                                           !BCC_ASM
11971                       00000016            _ata_cmd_data_out.count	set	$16
11972                       00000008            .ata_cmd_data_out.count	set	8
11973                       00000026            _ata_cmd_data_out.segment	set	$26
11974                       00000018            .ata_cmd_data_out.segment	set	$18
11975                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11976                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11977                       00000005            _ata_cmd_data_out.channel	set	5
11978                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11979                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11980                       00000010            .ata_cmd_data_out.lba_low	set	$10
11981                       00000022            _ata_cmd_data_out.lba_high	set	$22
11982                       00000014            .ata_cmd_data_out.lba_high	set	$14
11983                       0000001C            _ata_cmd_data_out.sector	set	$1C
11984                       0000000E            .ata_cmd_data_out.sector	set	$E
11985                       00000006            _ata_cmd_data_out.blksize	set	6
11986                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11987                       0000001A            _ata_cmd_data_out.head	set	$1A
11988                       0000000C            .ata_cmd_data_out.head	set	$C
11989                       00000018            _ata_cmd_data_out.cylinder	set	$18
11990                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11991                       00000012            _ata_cmd_data_out.device	set	$12
11992                       00000004            .ata_cmd_data_out.device	set	4
11993                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11994                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11995                       00000003            _ata_cmd_data_out.status	set	3
11996                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11997                       00000002            _ata_cmd_data_out.current	set	2
11998                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11999                       00000014            _ata_cmd_data_out.command	set	$14
12000                       00000006            .ata_cmd_data_out.command	set	6
12001                       00000001            _ata_cmd_data_out.mode	set	1
12002                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
12003                       00000008            _ata_cmd_data_out.iobase2	set	8
12004                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
12005                       00000028            _ata_cmd_data_out.offset	set	$28
12006                       0000001A            .ata_cmd_data_out.offset	set	$1A
12007                       00000004            _ata_cmd_data_out.slave	set	4
12008                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
12009 362C           55                                 push bp
12010 362D           89E5                               mov bp, sp
12011 362F           8B76         2A                    mov si, _ata_cmd_data_out.offset + 2[bp]
12012 3632           8B46         28                    mov ax, _ata_cmd_data_out.segment + 2[bp]
12013 3635           8B4E         08                    mov cx, _ata_cmd_data_out.blksize + 2[bp]
12014                                                   ;; adjust if there will be an overrun. 2K max sector size
12015 3638           81FE                 F800          cmp si, #0xf800 ;;
12016 363C           76           07                    jbe ata_out_no_adjust
12017                       0000363E            ata_out_adjust:
12018 363E           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
12019 3642           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
12020                       00003645            ata_out_no_adjust:
12021 3645           8EC0                               mov es, ax ;; segment in es
12022 3647           8B56         0C                    mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
12023 364A           8A66         03                    mov ah, _ata_cmd_data_out.mode + 2[bp]
12024 364D           80FC                   01          cmp ah, #0x01
12025 3650           74           05                    je ata_out_32
12026                       00003652            ata_out_16:
12027 3652           26                                 seg ES
12028 3653           F3                                 rep
12029 3654           6F                                   outsw ;; CX words transfered from port(DX) to ES:[SI]
12030 3655           EB           04                    jmp ata_out_done
12031                       00003657            ata_out_32:
12032 3657           26                                 seg ES
12033 3658           F3                                 rep
12034 3659     66    6F                                   outsd ;; CX dwords transfered from port(DX) to ES:[SI]
12035                       0000365B            ata_out_done:
12036 365B           8976         2A                    mov _ata_cmd_data_out.offset + 2[bp], si
12037 365E           8C46         28                    mov _ata_cmd_data_out.segment + 2[bp], es
12038 3661           5D                                 pop bp
12039                                           ! 2026 endasm
12040                                           !BCC_ENDASM
12041                                           !BCC_EOS
12042                                           ! 2027     current++;
12043                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
12044 3662           8A46         F4            mov	al,-$C[bp]
12045 3665           40                         inc	ax
12046 3666           8846         F4            mov	-$C[bp],al
12047                                           !BCC_EOS
12048                                           ! 2028     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
12049                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
12050 3669           8A46         F4            mov	al,-$C[bp]
12051 366C           30E4                       xor	ah,ah
12052 366E           50                         push	ax
12053                                           ! Debug: list * unsigned short = const $254 (used reg = )
12054 366F           B8                   0254  mov	ax,#$254
12055 3672           50                         push	ax
12056                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
12057 3673           FF76         FE            push	-2[bp]
12058                                           ! Debug: func () void = write_word+0 (used reg = )
12059 3676           E8         CFB9            call	_write_word
12060 3679           83C4                   06  add	sp,*6
12061                                           !BCC_EOS
12062                                           ! 2029     count--;
12063                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
12064 367C           8B46         08            mov	ax,8[bp]
12065 367F           48                         dec	ax
12066 3680           8946         08            mov	8[bp],ax
12067                                           !BCC_EOS
12068                                           ! 2030     status = inb(iobase1 + 7);
12069                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
12070 3683           8B46         FC            mov	ax,-4[bp]
12071                                           ! Debug: list unsigned int = ax+7 (used reg = )
12072 3686           05                   0007  add	ax,*7
12073 3689           50                         push	ax
12074                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12075 368A           E8         CEB1            call	_inb
12076 368D           44                         inc	sp
12077 368E           44                         inc	sp
12078                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
12079 368F           8846         F5            mov	-$B[bp],al
12080                                           !BCC_EOS
12081                                           ! 2031     if (count == 0) {
12082                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
12083 3692           8B46         08            mov	ax,8[bp]
12084 3695           85C0                       test	ax,ax
12085 3697           75           14            jne 	.298
12086                       00003699            .299:
12087                                           ! 2032       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
12088                                           ! 2033           != 0x40 ) {
12089                                           ! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
12090 3699           8A46         F5            mov	al,-$B[bp]
12091 369C           24                     E9  and	al,#$E9
12092                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
12093 369E           3C                     40  cmp	al,*$40
12094 36A0           74           07            je  	.29A
12095                       000036A2            .29B:
12096                                           ! 2034         ;
12097                                           !BCC_EOS
12098                                           ! 2035         return 6;
12099 36A2           B8                   0006  mov	ax,*6
12100 36A5           89EC                       mov	sp,bp
12101 36A7           5D                         pop	bp
12102 36A8           C3                         ret
12103                                           !BCC_EOS
12104                                           ! 2036         }
12105                                           ! 2037       break;
12106                       000036A9            .29A:
12107 36A9           EB           17            jmp .295
12108                                           !BCC_EOS
12109                                           ! 2038       }
12110                                           ! 2039     else {
12111 36AB           EB           12            jmp .29C
12112                       000036AD            .298:
12113                                           ! 2040       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
12114                                           ! 2041           != (0x40 | 0x08) ) {
12115                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
12116 36AD           8A46         F5            mov	al,-$B[bp]
12117 36B0           24                     C9  and	al,#$C9
12118                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
12119 36B2           3C                     48  cmp	al,*$48
12120 36B4           74           07            je  	.29D
12121                       000036B6            .29E:
12122                                           ! 2042         ;
12123                                           !BCC_EOS
12124                                           ! 2043         return 7;
12125 36B6           B8                   0007  mov	ax,*7
12126 36B9           89EC                       mov	sp,bp
12127 36BB           5D                         pop	bp
12128 36BC           C3                         ret
12129                                           !BCC_EOS
12130                                           ! 2044       }
12131                                           ! 2045       continue;
12132                       000036BD            .29D:
12133 36BD           EB           00            jmp .296
12134                                           !BCC_EOS
12135                                           ! 2046     }
12136                                           ! 2047   }
12137                       000036BF            .29C:
12138                                           ! 2048   outb(iobase2+6, 0x08);
12139                       000036BF            .296:
12140 36BF           E9         FF6A            jmp	.297
12141                       000036C2            .29F:
12142                       000036C2            .295:
12143                                           ! Debug: list int = const 8 (used reg = )
12144 36C2           B8                   0008  mov	ax,*8
12145 36C5           50                         push	ax
12146                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
12147 36C6           8B46         FA            mov	ax,-6[bp]
12148                                           ! Debug: list unsigned int = ax+6 (used reg = )
12149 36C9           05                   0006  add	ax,*6
12150 36CC           50                         push	ax
12151                                           ! Debug: func () void = outb+0 (used reg = )
12152 36CD           E8         CE84            call	_outb
12153 36D0           83C4                   04  add	sp,*4
12154                                           !BCC_EOS
12155                                           ! 2049   return 0;
12156 36D3           31C0                       xor	ax,ax
12157 36D5           89EC                       mov	sp,bp
12158 36D7           5D                         pop	bp
12159 36D8           C3                         ret
12160                                           !BCC_EOS
12161                                           ! 2050 }
12162                                           ! 2051 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
12163                                           ! Register BX used in function ata_cmd_data_out
12164                                           ! 2052 Bit8u cmdlen,inout;
12165                                           export	_ata_cmd_packet
12166                       000036D9            _ata_cmd_packet:
12167                                           !BCC_EOS
12168                                           ! 2053 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
12169                                           ! 2053 
12170                                           !BCC_EOS
12171                                           ! 2054 Bit16u header;
12172                                           !BCC_EOS
12173                                           ! 2055 Bit32u length;
12174                                           !BCC_EOS
12175                                           ! 2056 {
12176                                           ! 2057   Bit16u ebda_seg=read_word(0x0040,0x000E);
12177 36D9           55                         push	bp
12178 36DA           89E5                       mov	bp,sp
12179 36DC           4C                         dec	sp
12180 36DD           4C                         dec	sp
12181                                           ! Debug: list int = const $E (used reg = )
12182 36DE           B8                   000E  mov	ax,*$E
12183 36E1           50                         push	ax
12184                                           ! Debug: list int = const $40 (used reg = )
12185 36E2           B8                   0040  mov	ax,*$40
12186 36E5           50                         push	ax
12187                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12188 36E6           E8         CF1E            call	_read_word
12189 36E9           83C4                   04  add	sp,*4
12190                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12191 36EC           8946         FE            mov	-2[bp],ax
12192                                           !BCC_EOS
12193                                           ! 2058   Bit16u iobase1, iobase2;
12194                                           !BCC_EOS
12195                                           ! 2059   Bit16u lcount, lbefore, lafter, count;
12196                                           !BCC_EOS
12197                                           ! 2060   Bit8u channel, slave;
12198                                           !BCC_EOS
12199                                           ! 2061   Bit8u status, mode, lmode;
12200                                           !BCC_EOS
12201                                           ! 2062   Bit32u total, transfer;
12202                                           !BCC_EOS
12203                                           ! 2063   channel = device / 2;
12204 36EF           83C4                   E6  add	sp,*-$1A
12205                                           ! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
12206 36F2           8B46         04            mov	ax,4[bp]
12207 36F5           D1E8                       shr	ax,*1
12208                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
12209 36F7           8846         F1            mov	-$F[bp],al
12210                                           !BCC_EOS
12211                                           ! 2064   slave = device % 2;
12212                                           ! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
12213 36FA           8B46         04            mov	ax,4[bp]
12214 36FD           24                     01  and	al,*1
12215                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
12216 36FF           8846         F0            mov	-$10[bp],al
12217                                           !BCC_EOS
12218                                           ! 2065   if (inout == 0x02) {
12219                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
12220 3702           8A46         12            mov	al,$12[bp]
12221 3705           3C                     02  cmp	al,*2
12222 3707           75           15            jne 	.2A0
12223                       00003709            .2A1:
12224                                           ! 2066     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
12225                                           ! Debug: list * char = .2A2+0 (used reg = )
12226 3709           BB                   DA5E  mov	bx,#.2A2
12227 370C           53                         push	bx
12228                                           ! Debug: list int = const 4 (used reg = )
12229 370D           B8                   0004  mov	ax,*4
12230 3710           50                         push	ax
12231                                           ! Debug: func () void = bios_printf+0 (used reg = )
12232 3711           E8         D305            call	_bios_printf
12233 3714           83C4                   04  add	sp,*4
12234                                           !BCC_EOS
12235                                           ! 2067     return 1;
12236 3717           B8                   0001  mov	ax,*1
12237 371A           89EC                       mov	sp,bp
12238 371C           5D                         pop	bp
12239 371D           C3                         ret
12240                                           !BCC_EOS
12241                                           ! 2068     }
12242                                           ! 2069   if (header & 1) {
12243                       0000371E            .2A0:
12244                                           ! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
12245 371E           8A46         0C            mov	al,$C[bp]
12246 3721           24                     01  and	al,*1
12247 3723           84C0                       test	al,al
12248 3725           74           07            je  	.2A3
12249                       00003727            .2A4:
12250                                           ! 2070     ;
12251                                           !BCC_EOS
12252                                           ! 2071     return 1;
12253 3727           B8                   0001  mov	ax,*1
12254 372A           89EC                       mov	sp,bp
12255 372C           5D                         pop	bp
12256 372D           C3                         ret
12257                                           !BCC_EOS
12258                                           ! 2072     }
12259                                           ! 2073   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
12260                       0000372E            .2A3:
12261                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12262 372E           8A46         F1            mov	al,-$F[bp]
12263 3731           30E4                       xor	ah,ah
12264 3733           B1                     03  mov	cl,*3
12265 3735           D3E0                       shl	ax,cl
12266 3737           89C3                       mov	bx,ax
12267                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
12268                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
12269 3739           81C3                 0124  add	bx,#$124
12270 373D           53                         push	bx
12271                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12272 373E           FF76         FE            push	-2[bp]
12273                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12274 3741           E8         CEC3            call	_read_word
12275 3744           83C4                   04  add	sp,*4
12276                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12277 3747           8946         FC            mov	-4[bp],ax
12278                                           !BCC_EOS
12279                                           ! 2074   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
12280                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12281 374A           8A46         F1            mov	al,-$F[bp]
12282 374D           30E4                       xor	ah,ah
12283 374F           B1                     03  mov	cl,*3
12284 3751           D3E0                       shl	ax,cl
12285 3753           89C3                       mov	bx,ax
12286                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
12287                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
12288 3755           81C3                 0126  add	bx,#$126
12289 3759           53                         push	bx
12290                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12291 375A           FF76         FE            push	-2[bp]
12292                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12293 375D           E8         CEA7            call	_read_word
12294 3760           83C4                   04  add	sp,*4
12295                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
12296 3763           8946         FA            mov	-6[bp],ax
12297                                           !BCC_EOS
12298                                           ! 2075   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
12299                                           ! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
12300 3766           8B46         04            mov	ax,4[bp]
12301 3769           B9                   001E  mov	cx,*$1E
12302 376C           F7E9                       imul	cx
12303 376E           89C3                       mov	bx,ax
12304                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
12305                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
12306 3770           81C3                 0146  add	bx,#$146
12307 3774           53                         push	bx
12308                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12309 3775           FF76         FE            push	-2[bp]
12310                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12311 3778           E8         CE79            call	_read_byte
12312 377B           83C4                   04  add	sp,*4
12313                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
12314 377E           8846         EE            mov	-$12[bp],al
12315                                           !BCC_EOS
12316                                           ! 2076   transfer= 0L;
12317                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
12318 3781           31C0                       xor	ax,ax
12319 3783           31DB                       xor	bx,bx
12320 3785           8946         E4            mov	-$1C[bp],ax
12321 3788           895E         E6            mov	-$1A[bp],bx
12322                                           !BCC_EOS
12323                                           ! 2077   if (cmdlen < 12) cmdlen=12;
12324                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12325 378B           8A46         06            mov	al,6[bp]
12326 378E           3C                     0C  cmp	al,*$C
12327 3790           73           05            jae 	.2A5
12328                       00003792            .2A6:
12329                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12330 3792           B0                     0C  mov	al,*$C
12331 3794           8846         06            mov	6[bp],al
12332                                           !BCC_EOS
12333                                           ! 2078   if (cmdlen > 12) cmdlen=16;
12334                       00003797            .2A5:
12335                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12336 3797           8A46         06            mov	al,6[bp]
12337 379A           3C                     0C  cmp	al,*$C
12338 379C           76           05            jbe 	.2A7
12339                       0000379E            .2A8:
12340                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12341 379E           B0                     10  mov	al,*$10
12342 37A0           8846         06            mov	6[bp],al
12343                                           !BCC_EOS
12344                                           ! 2079   cmdlen>>=1;
12345                       000037A3            .2A7:
12346                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12347 37A3           8A46         06            mov	al,6[bp]
12348 37A6           30E4                       xor	ah,ah
12349 37A8           D1E8                       shr	ax,*1
12350 37AA           8846         06            mov	6[bp],al
12351                                           !BCC_EOS
12352                                           ! 2080   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
12353                                           ! Debug: list int = const 0 (used reg = )
12354 37AD           31C0                       xor	ax,ax
12355 37AF           50                         push	ax
12356                                           ! Debug: list * unsigned short = const $254 (used reg = )
12357 37B0           B8                   0254  mov	ax,#$254
12358 37B3           50                         push	ax
12359                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
12360 37B4           FF76         FE            push	-2[bp]
12361                                           ! Debug: func () void = write_word+0 (used reg = )
12362 37B7           E8         CE78            call	_write_word
12363 37BA           83C4                   06  add	sp,*6
12364                                           !BCC_EOS
12365                                           ! 2081   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
12366                                           ! Debug: list long = const 0 (used reg = )
12367 37BD           31C0                       xor	ax,ax
12368 37BF           31DB                       xor	bx,bx
12369 37C1           53                         push	bx
12370 37C2           50                         push	ax
12371                                           ! Debug: list * unsigned long = const $256 (used reg = )
12372 37C3           B8                   0256  mov	ax,#$256
12373 37C6           50                         push	ax
12374                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
12375 37C7           FF76         FE            push	-2[bp]
12376                                           ! Debug: func () void = write_dword+0 (used reg = )
12377 37CA           E8         C8CE            call	_write_dword
12378 37CD           83C4                   08  add	sp,*8
12379                                           !BCC_EOS
12380                                           ! 2082   status = inb(iobase1 + 7);
12381                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12382 37D0           8B46         FC            mov	ax,-4[bp]
12383                                           ! Debug: list unsigned int = ax+7 (used reg = )
12384 37D3           05                   0007  add	ax,*7
12385 37D6           50                         push	ax
12386                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12387 37D7           E8         CD64            call	_inb
12388 37DA           44                         inc	sp
12389 37DB           44                         inc	sp
12390                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12391 37DC           8846         EF            mov	-$11[bp],al
12392                                           !BCC_EOS
12393                                           ! 2083   if (status & 0x80) return 2;
12394                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
12395 37DF           8A46         EF            mov	al,-$11[bp]
12396 37E2           24                     80  and	al,#$80
12397 37E4           84C0                       test	al,al
12398 37E6           74           07            je  	.2A9
12399                       000037E8            .2AA:
12400 37E8           B8                   0002  mov	ax,*2
12401 37EB           89EC                       mov	sp,bp
12402 37ED           5D                         pop	bp
12403 37EE           C3                         ret
12404                                           !BCC_EOS
12405                                           ! 2084   outb(iobase2 + 6, 0x08 | 0x02);
12406                       000037EF            .2A9:
12407                                           ! Debug: list int = const $A (used reg = )
12408 37EF           B8                   000A  mov	ax,*$A
12409 37F2           50                         push	ax
12410                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
12411 37F3           8B46         FA            mov	ax,-6[bp]
12412                                           ! Debug: list unsigned int = ax+6 (used reg = )
12413 37F6           05                   0006  add	ax,*6
12414 37F9           50                         push	ax
12415                                           ! Debug: func () void = outb+0 (used reg = )
12416 37FA           E8         CD57            call	_outb
12417 37FD           83C4                   04  add	sp,*4
12418                                           !BCC_EOS
12419                                           ! 2085   outb(iobase1 + 1, 0x00);
12420                                           ! Debug: list int = const 0 (used reg = )
12421 3800           31C0                       xor	ax,ax
12422 3802           50                         push	ax
12423                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
12424 3803           8B46         FC            mov	ax,-4[bp]
12425                                           ! Debug: list unsigned int = ax+1 (used reg = )
12426 3806           40                         inc	ax
12427 3807           50                         push	ax
12428                                           ! Debug: func () void = outb+0 (used reg = )
12429 3808           E8         CD49            call	_outb
12430 380B           83C4                   04  add	sp,*4
12431                                           !BCC_EOS
12432                                           ! 2086   outb(iobase1 + 2, 0x00);
12433                                           ! Debug: list int = const 0 (used reg = )
12434 380E           31C0                       xor	ax,ax
12435 3810           50                         push	ax
12436                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
12437 3811           8B46         FC            mov	ax,-4[bp]
12438                                           ! Debug: list unsigned int = ax+2 (used reg = )
12439 3814           40                         inc	ax
12440 3815           40                         inc	ax
12441 3816           50                         push	ax
12442                                           ! Debug: func () void = outb+0 (used reg = )
12443 3817           E8         CD3A            call	_outb
12444 381A           83C4                   04  add	sp,*4
12445                                           !BCC_EOS
12446                                           ! 2087   outb(iobase1 + 3, 0x00);
12447                                           ! Debug: list int = const 0 (used reg = )
12448 381D           31C0                       xor	ax,ax
12449 381F           50                         push	ax
12450                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
12451 3820           8B46         FC            mov	ax,-4[bp]
12452                                           ! Debug: list unsigned int = ax+3 (used reg = )
12453 3823           05                   0003  add	ax,*3
12454 3826           50                         push	ax
12455                                           ! Debug: func () void = outb+0 (used reg = )
12456 3827           E8         CD2A            call	_outb
12457 382A           83C4                   04  add	sp,*4
12458                                           !BCC_EOS
12459                                           ! 2088   outb(iobase1 + 4, 0xfff0 & 0x00ff);
12460                                           ! Debug: list unsigned int = const $F0 (used reg = )
12461 382D           B8                   00F0  mov	ax,#$F0
12462 3830           50                         push	ax
12463                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
12464 3831           8B46         FC            mov	ax,-4[bp]
12465                                           ! Debug: list unsigned int = ax+4 (used reg = )
12466 3834           05                   0004  add	ax,*4
12467 3837           50                         push	ax
12468                                           ! Debug: func () void = outb+0 (used reg = )
12469 3838           E8         CD19            call	_outb
12470 383B           83C4                   04  add	sp,*4
12471                                           !BCC_EOS
12472                                           ! 2089   outb(iobase1 + 5, 0xfff0 >> 8);
12473                                           ! Debug: list unsigned int = const $FF (used reg = )
12474 383E           B8                   00FF  mov	ax,#$FF
12475 3841           50                         push	ax
12476                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
12477 3842           8B46         FC            mov	ax,-4[bp]
12478                                           ! Debug: list unsigned int = ax+5 (used reg = )
12479 3845           05                   0005  add	ax,*5
12480 3848           50                         push	ax
12481                                           ! Debug: func () void = outb+0 (used reg = )
12482 3849           E8         CD08            call	_outb
12483 384C           83C4                   04  add	sp,*4
12484                                           !BCC_EOS
12485                                           ! 2090   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
12486 384F           8A46         F0            mov	al,-$10[bp]
12487 3852           84C0                       test	al,al
12488 3854           74           04            je  	.2AB
12489                       00003856            .2AC:
12490 3856           B0                     B0  mov	al,#$B0
12491 3858           EB           02            jmp .2AD
12492                       0000385A            .2AB:
12493 385A           B0                     A0  mov	al,#$A0
12494                       0000385C            .2AD:
12495                                           ! Debug: list char = al+0 (used reg = )
12496 385C           30E4                       xor	ah,ah
12497 385E           50                         push	ax
12498                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
12499 385F           8B46         FC            mov	ax,-4[bp]
12500                                           ! Debug: list unsigned int = ax+6 (used reg = )
12501 3862           05                   0006  add	ax,*6
12502 3865           50                         push	ax
12503                                           ! Debug: func () void = outb+0 (used reg = )
12504 3866           E8         CCEB            call	_outb
12505 3869           83C4                   04  add	sp,*4
12506                                           !BCC_EOS
12507                                           ! 2091   outb(iobase1 + 7, 0xA0);
12508                                           ! Debug: list int = const $A0 (used reg = )
12509 386C           B8                   00A0  mov	ax,#$A0
12510 386F           50                         push	ax
12511                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
12512 3870           8B46         FC            mov	ax,-4[bp]
12513                                           ! Debug: list unsigned int = ax+7 (used reg = )
12514 3873           05                   0007  add	ax,*7
12515 3876           50                         push	ax
12516                                           ! Debug: func () void = outb+0 (used reg = )
12517 3877           E8         CCDA            call	_outb
12518 387A           83C4                   04  add	sp,*4
12519                                           !BCC_EOS
12520                                           ! 2092   await_ide(3, iobase1, 32000u);
12521                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12522 387D           B8                   7D00  mov	ax,#$7D00
12523 3880           50                         push	ax
12524                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12525 3881           FF76         FC            push	-4[bp]
12526                                           ! Debug: list int = const 3 (used reg = )
12527 3884           B8                   0003  mov	ax,*3
12528 3887           50                         push	ax
12529                                           ! Debug: func () int = await_ide+0 (used reg = )
12530 3888           E8         E47F            call	_await_ide
12531 388B           83C4                   06  add	sp,*6
12532                                           !BCC_EOS
12533                                           ! 2093   status = inb(iobase1 + 7);
12534                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12535 388E           8B46         FC            mov	ax,-4[bp]
12536                                           ! Debug: list unsigned int = ax+7 (used reg = )
12537 3891           05                   0007  add	ax,*7
12538 3894           50                         push	ax
12539                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12540 3895           E8         CCA6            call	_inb
12541 3898           44                         inc	sp
12542 3899           44                         inc	sp
12543                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12544 389A           8846         EF            mov	-$11[bp],al
12545                                           !BCC_EOS
12546                                           ! 2094   if (status & 0x01) {
12547                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
12548 389D           8A46         EF            mov	al,-$11[bp]
12549 38A0           24                     01  and	al,*1
12550 38A2           84C0                       test	al,al
12551 38A4           74           09            je  	.2AE
12552                       000038A6            .2AF:
12553                                           ! 2095     ;
12554                                           !BCC_EOS
12555                                           ! 2096     return 3;
12556 38A6           B8                   0003  mov	ax,*3
12557 38A9           89EC                       mov	sp,bp
12558 38AB           5D                         pop	bp
12559 38AC           C3                         ret
12560                                           !BCC_EOS
12561                                           ! 2097     } else if ( !(status & 0x08) ) {
12562 38AD           EB           10            jmp .2B0
12563                       000038AF            .2AE:
12564                                           ! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
12565 38AF           8A46         EF            mov	al,-$11[bp]
12566 38B2           24                     08  and	al,*8
12567 38B4           84C0                       test	al,al
12568 38B6           75           07            jne 	.2B1
12569                       000038B8            .2B2:
12570                                           ! 2098     ;
12571                                           !BCC_EOS
12572                                           ! 2099     return 4;
12573 38B8           B8                   0004  mov	ax,*4
12574 38BB           89EC                       mov	sp,bp
12575 38BD           5D                         pop	bp
12576 38BE           C3                         ret
12577                                           !BCC_EOS
12578                                           ! 2100     }
12579                                           ! 2101   cmdseg += (cmdoff / 16);
12580                       000038BF            .2B1:
12581                       000038BF            .2B0:
12582                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12583 38BF           8B46         0A            mov	ax,$A[bp]
12584 38C2           B1                     04  mov	cl,*4
12585 38C4           D3E8                       shr	ax,cl
12586                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
12587 38C6           0346         08            add	ax,8[bp]
12588 38C9           8946         08            mov	8[bp],ax
12589                                           !BCC_EOS
12590                                           ! 2102   cmdoff %= 16;
12591                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12592 38CC           8B46         0A            mov	ax,$A[bp]
12593 38CF           24                     0F  and	al,*$F
12594 38D1           30E4                       xor	ah,ah
12595 38D3           8946         0A            mov	$A[bp],ax
12596                                           !BCC_EOS
12597                                           ! 2103 #asm
12598                                           !BCC_EOS
12599                                           !BCC_ASM
12600                       00000026            _ata_cmd_packet.cmdoff	set	$26
12601                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12602                       00000028            _ata_cmd_packet.header	set	$28
12603                       0000000C            .ata_cmd_packet.header	set	$C
12604                       0000000E            _ata_cmd_packet.count	set	$E
12605                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12606                       00000010            _ata_cmd_packet.lafter	set	$10
12607                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12608                       00000018            _ata_cmd_packet.iobase1	set	$18
12609                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12610                       0000000D            _ata_cmd_packet.channel	set	$D
12611                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12612                       00000024            _ata_cmd_packet.cmdseg	set	$24
12613                       00000008            .ata_cmd_packet.cmdseg	set	8
12614                       00000022            _ata_cmd_packet.cmdlen	set	$22
12615                       00000006            .ata_cmd_packet.cmdlen	set	6
12616                       00000009            _ata_cmd_packet.lmode	set	9
12617                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12618                       00000020            _ata_cmd_packet.device	set	$20
12619                       00000004            .ata_cmd_packet.device	set	4
12620                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
12621                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12622                       00000014            _ata_cmd_packet.lcount	set	$14
12623                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12624                       00000004            _ata_cmd_packet.total	set	4
12625                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12626                       0000000B            _ata_cmd_packet.status	set	$B
12627                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12628                       0000000A            _ata_cmd_packet.mode	set	$A
12629                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12630                       00000032            _ata_cmd_packet.bufoff	set	$32
12631                       00000016            .ata_cmd_packet.bufoff	set	$16
12632                       00000000            _ata_cmd_packet.transfer	set	0
12633                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12634                       00000016            _ata_cmd_packet.iobase2	set	$16
12635                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12636                       00000012            _ata_cmd_packet.lbefore	set	$12
12637                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12638                       00000030            _ata_cmd_packet.bufseg	set	$30
12639                       00000014            .ata_cmd_packet.bufseg	set	$14
12640                       0000000C            _ata_cmd_packet.slave	set	$C
12641                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12642                       0000002E            _ata_cmd_packet.inout	set	$2E
12643                       00000012            .ata_cmd_packet.inout	set	$12
12644                       0000002A            _ata_cmd_packet.length	set	$2A
12645                       0000000E            .ata_cmd_packet.length	set	$E
12646 38D6           FB                               sti ;; enable higher priority interrupts
12647 38D7           55                               push bp
12648 38D8           89E5                             mov bp, sp
12649 38DA           8B76         28                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
12650 38DD           8B46         26                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
12651 38E0           8B4E         24                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
12652 38E3           8EC0                             mov es, ax ;; segment in es
12653 38E5           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
12654 38E8           26                               seg ES
12655 38E9           F3                               rep
12656 38EA           6F                                 outsw ;; CX words transfered from port(DX) to ES:[SI]
12657 38EB           5D                               pop bp
12658                                           ! 2116 endasm
12659                                           !BCC_ENDASM
12660                                           !BCC_EOS
12661                                           ! 2117   if (inout == 0x00) {
12662                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
12663 38EC           8A46         12            mov	al,$12[bp]
12664 38EF           84C0                       test	al,al
12665 38F1           75           23            jne 	.2B3
12666                       000038F3            .2B4:
12667                                           ! 2118     await_ide(2, iobase1, 32000u);
12668                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12669 38F3           B8                   7D00  mov	ax,#$7D00
12670 38F6           50                         push	ax
12671                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12672 38F7           FF76         FC            push	-4[bp]
12673                                           ! Debug: list int = const 2 (used reg = )
12674 38FA           B8                   0002  mov	ax,*2
12675 38FD           50                         push	ax
12676                                           ! Debug: func () int = await_ide+0 (used reg = )
12677 38FE           E8         E409            call	_await_ide
12678 3901           83C4                   06  add	sp,*6
12679                                           !BCC_EOS
12680                                           ! 2119     status = inb(iobase1 + 7);
12681                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12682 3904           8B46         FC            mov	ax,-4[bp]
12683                                           ! Debug: list unsigned int = ax+7 (used reg = )
12684 3907           05                   0007  add	ax,*7
12685 390A           50                         push	ax
12686                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12687 390B           E8         CC30            call	_inb
12688 390E           44                         inc	sp
12689 390F           44                         inc	sp
12690                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12691 3910           8846         EF            mov	-$11[bp],al
12692                                           !BCC_EOS
12693                                           ! 2120     }
12694                                           ! 2121   else {
12695 3913           E9         027B            br 	.2B5
12696                       00003916            .2B3:
12697                                           ! 2122         Bit16u loops = 0;
12698 3916           4C                         dec	sp
12699 3917           4C                         dec	sp
12700                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
12701 3918           31C0                       xor	ax,ax
12702 391A           8946         E2            mov	-$1E[bp],ax
12703                                           !BCC_EOS
12704                                           ! 2123         Bit8u sc;
12705                                           !BCC_EOS
12706                                           ! 2124   while (1) {
12707 391D           4C                         dec	sp
12708 391E           4C                         dec	sp
12709                       0000391F            .2B8:
12710                                           ! 2125       if (loops == 0) {
12711                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
12712 391F           8B46         E2            mov	ax,-$1E[bp]
12713 3922           85C0                       test	ax,ax
12714 3924           75           22            jne 	.2B9
12715                       00003926            .2BA:
12716                                           ! 2126         sta
12717                                           ! 2126 tus = inb(iobase2 + 6);
12718                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
12719 3926           8B46         FA            mov	ax,-6[bp]
12720                                           ! Debug: list unsigned int = ax+6 (used reg = )
12721 3929           05                   0006  add	ax,*6
12722 392C           50                         push	ax
12723                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12724 392D           E8         CC0E            call	_inb
12725 3930           44                         inc	sp
12726 3931           44                         inc	sp
12727                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12728 3932           8846         EF            mov	-$11[bp],al
12729                                           !BCC_EOS
12730                                           ! 2127         await_ide(3, iobase1, 32000u);
12731                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12732 3935           B8                   7D00  mov	ax,#$7D00
12733 3938           50                         push	ax
12734                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12735 3939           FF76         FC            push	-4[bp]
12736                                           ! Debug: list int = const 3 (used reg = )
12737 393C           B8                   0003  mov	ax,*3
12738 393F           50                         push	ax
12739                                           ! Debug: func () int = await_ide+0 (used reg = )
12740 3940           E8         E3C7            call	_await_ide
12741 3943           83C4                   06  add	sp,*6
12742                                           !BCC_EOS
12743                                           ! 2128       }
12744                                           ! 2129       else
12745                                           ! 2130         await_ide(2, iobase1, 32000u);
12746 3946           EB           11            jmp .2BB
12747                       00003948            .2B9:
12748                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12749 3948           B8                   7D00  mov	ax,#$7D00
12750 394B           50                         push	ax
12751                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12752 394C           FF76         FC            push	-4[bp]
12753                                           ! Debug: list int = const 2 (used reg = )
12754 394F           B8                   0002  mov	ax,*2
12755 3952           50                         push	ax
12756                                           ! Debug: func () int = await_ide+0 (used reg = )
12757 3953           E8         E3B4            call	_await_ide
12758 3956           83C4                   06  add	sp,*6
12759                                           !BCC_EOS
12760                                           ! 2131       loops++;
12761                       00003959            .2BB:
12762                                           ! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
12763 3959           8B46         E2            mov	ax,-$1E[bp]
12764 395C           40                         inc	ax
12765 395D           8946         E2            mov	-$1E[bp],ax
12766                                           !BCC_EOS
12767                                           ! 2132       status = inb(iobase1 + 7);
12768                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$22-6] (used reg = )
12769 3960           8B46         FC            mov	ax,-4[bp]
12770                                           ! Debug: list unsigned int = ax+7 (used reg = )
12771 3963           05                   0007  add	ax,*7
12772 3966           50                         push	ax
12773                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12774 3967           E8         CBD4            call	_inb
12775 396A           44                         inc	sp
12776 396B           44                         inc	sp
12777                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12778 396C           8846         EF            mov	-$11[bp],al
12779                                           !BCC_EOS
12780                                           ! 2133       sc = inb(iobase1 + 2);
12781                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12782 396F           8B46         FC            mov	ax,-4[bp]
12783                                           ! Debug: list unsigned int = ax+2 (used reg = )
12784 3972           40                         inc	ax
12785 3973           40                         inc	ax
12786 3974           50                         push	ax
12787                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12788 3975           E8         CBC6            call	_inb
12789 3978           44                         inc	sp
12790 3979           44                         inc	sp
12791                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
12792 397A           8846         E1            mov	-$1F[bp],al
12793                                           !BCC_EOS
12794                                           ! 2134       if(((inb(iobase1 + 2)&0x7)==0x3) &&
12795                                           ! 2135          ((status & (0x40 | 0x01)) == 0x40)) break;
12796                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12797 397D           8B46         FC            mov	ax,-4[bp]
12798                                           ! Debug: list unsigned int = ax+2 (used reg = )
12799 3980           40                         inc	ax
12800 3981           40                         inc	ax
12801 3982           50                         push	ax
12802                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12803 3983           E8         CBB8            call	_inb
12804 3986           44                         inc	sp
12805 3987           44                         inc	sp
12806                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
12807 3988           24                     07  and	al,*7
12808                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
12809 398A           3C                     03  cmp	al,*3
12810 398C           75           0C            jne 	.2BC
12811                       0000398E            .2BE:
12812                                           ! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
12813 398E           8A46         EF            mov	al,-$11[bp]
12814 3991           24                     41  and	al,*$41
12815                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
12816 3993           3C                     40  cmp	al,*$40
12817 3995           75           03            jne 	.2BC
12818                       00003997            .2BD:
12819 3997           E9         01F4            br 	.2B6
12820                                           !BCC_EOS
12821                                           ! 2136       if (status & 0x01) {
12822                       0000399A            .2BC:
12823                                           ! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
12824 399A           8A46         EF            mov	al,-$11[bp]
12825 399D           24                     01  and	al,*1
12826 399F           84C0                       test	al,al
12827 39A1           74           07            je  	.2BF
12828                       000039A3            .2C0:
12829                                           ! 2137         ;
12830                                           !BCC_EOS
12831                                           ! 2138         return 3;
12832 39A3           B8                   0003  mov	ax,*3
12833 39A6           89EC                       mov	sp,bp
12834 39A8           5D                         pop	bp
12835 39A9           C3                         ret
12836                                           !BCC_EOS
12837                                           ! 2139       }
12838                                           ! 2140       bufseg += (bufoff / 16);
12839                       000039AA            .2BF:
12840                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12841 39AA           8B46         16            mov	ax,$16[bp]
12842 39AD           B1                     04  mov	cl,*4
12843 39AF           D3E8                       shr	ax,cl
12844                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
12845 39B1           0346         14            add	ax,$14[bp]
12846 39B4           8946         14            mov	$14[bp],ax
12847                                           !BCC_EOS
12848                                           ! 2141       bufoff %= 16;
12849                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12850 39B7           8B46         16            mov	ax,$16[bp]
12851 39BA           24                     0F  and	al,*$F
12852 39BC           30E4                       xor	ah,ah
12853 39BE           8946         16            mov	$16[bp],ax
12854                                           !BCC_EOS
12855                                           ! 2142       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
12856                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
12857 39C1           8B46         FC            mov	ax,-4[bp]
12858                                           ! Debug: list unsigned int = ax+4 (used reg = )
12859 39C4           05                   0004  add	ax,*4
12860 39C7           50                         push	ax
12861                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12862 39C8           E8         CB73            call	_inb
12863 39CB           44                         inc	sp
12864 39CC           44                         inc	sp
12865 39CD           50                         push	ax
12866                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
12867 39CE           8B46         FC            mov	ax,-4[bp]
12868                                           ! Debug: list unsigned int = ax+5 (used reg = )
12869 39D1           05                   0005  add	ax,*5
12870 39D4           50                         push	ax
12871                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12872 39D5           E8         CB66            call	_inb
12873 39D8           44                         inc	sp
12874 39D9           44                         inc	sp
12875                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
12876 39DA           30E4                       xor	ah,ah
12877                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
12878 39DC           88C4                       mov	ah,al
12879 39DE           30C0                       xor	al,al
12880                                           ! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
12881 39E0           0246         DE            add	al,-$22[bp]
12882 39E3           80D4                   00  adc	ah,*0
12883 39E6           44                         inc	sp
12884 39E7           44                         inc	sp
12885                                           ! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
12886 39E8           8946         F8            mov	-8[bp],ax
12887                                           !BCC_EOS
12888                                           ! 2143       if(header>lcount) {
12889                                           ! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12890 39EB           8B46         0C            mov	ax,$C[bp]
12891 39EE           3B46         F8            cmp	ax,-8[bp]
12892 39F1           76           16            jbe 	.2C1
12893                       000039F3            .2C2:
12894                                           ! 2144          lbefore=lcount;
12895                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12896 39F3           8B46         F8            mov	ax,-8[bp]
12897 39F6           8946         F6            mov	-$A[bp],ax
12898                                           !BCC_EOS
12899                                           ! 2145          header-=lcount;
12900                                           ! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12901 39F9           8B46         0C            mov	ax,$C[bp]
12902 39FC           2B46         F8            sub	ax,-8[bp]
12903 39FF           8946         0C            mov	$C[bp],ax
12904                                           !BCC_EOS
12905                                           ! 2146          lcount=0;
12906                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12907 3A02           31C0                       xor	ax,ax
12908 3A04           8946         F8            mov	-8[bp],ax
12909                                           !BCC_EOS
12910                                           ! 2147          }
12911                                           ! 2148       else {
12912 3A07           EB           14            jmp .2C3
12913                       00003A09            .2C1:
12914                                           ! 2149         lbefore=header;
12915                                           ! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12916 3A09           8B46         0C            mov	ax,$C[bp]
12917 3A0C           8946         F6            mov	-$A[bp],ax
12918                                           !BCC_EOS
12919                                           ! 2150         header=0;
12920                                           ! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
12921 3A0F           31C0                       xor	ax,ax
12922 3A11           8946         0C            mov	$C[bp],ax
12923                                           !BCC_EOS
12924                                           ! 2151         lcount-=lbefore;
12925                                           ! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12926 3A14           8B46         F8            mov	ax,-8[bp]
12927 3A17           2B46         F6            sub	ax,-$A[bp]
12928 3A1A           8946         F8            mov	-8[bp],ax
12929                                           !BCC_EOS
12930                                           ! 2152         }
12931                                           ! 2153       if(lcount>length) {
12932                       00003A1D            .2C3:
12933                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12934 3A1D           8B46         F8            mov	ax,-8[bp]
12935 3A20           31DB                       xor	bx,bx
12936                                           ! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12937 3A22           8D7E         0E            lea	di,$E[bp]
12938 3A25           E8         C6A3            call	lcmpul
12939 3A28           76           20            jbe 	.2C4
12940                       00003A2A            .2C5:
12941                                           ! 2154         lafter=lcount-length;
12942                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12943 3A2A           8B46         F8            mov	ax,-8[bp]
12944 3A2D           31DB                       xor	bx,bx
12945                                           ! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12946 3A2F           8D7E         0E            lea	di,$E[bp]
12947 3A32           E8         C6AC            call	lsubul
12948                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
12949 3A35           8946         F4            mov	-$C[bp],ax
12950                                           !BCC_EOS
12951                                           ! 2155         lcount=length;
12952                                           ! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12953 3A38           8B46         0E            mov	ax,$E[bp]
12954 3A3B           8946         F8            mov	-8[bp],ax
12955                                           !BCC_EOS
12956                                           ! 2156         length=0;
12957                                           ! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
12958 3A3E           31C0                       xor	ax,ax
12959 3A40           31DB                       xor	bx,bx
12960 3A42           8946         0E            mov	$E[bp],ax
12961 3A45           895E         10            mov	$10[bp],bx
12962                                           !BCC_EOS
12963                                           ! 2157         }
12964                                           ! 2158       else {
12965 3A48           EB           21            jmp .2C6
12966                       00003A4A            .2C4:
12967                                           ! 2159         lafter=0;
12968                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12969 3A4A           31C0                       xor	ax,ax
12970 3A4C           8946         F4            mov	-$C[bp],ax
12971                                           !BCC_EOS
12972                                           ! 2160         length-=lcount;
12973                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12974 3A4F           8B46         F8            mov	ax,-8[bp]
12975 3A52           31DB                       xor	bx,bx
12976                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
12977 3A54           53                         push	bx
12978 3A55           50                         push	ax
12979 3A56           8B46         0E            mov	ax,$E[bp]
12980 3A59           8B5E         10            mov	bx,$10[bp]
12981 3A5C           8D7E         DC            lea	di,-$24[bp]
12982 3A5F           E8         C67F            call	lsubul
12983 3A62           8946         0E            mov	$E[bp],ax
12984 3A65           895E         10            mov	$10[bp],bx
12985 3A68           83C4                   04  add	sp,*4
12986                                           !BCC_EOS
12987                                           ! 2161         }
12988                                           ! 2162       count = lcount;
12989                       00003A6B            .2C6:
12990                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
12991 3A6B           8B46         F8            mov	ax,-8[bp]
12992 3A6E           8946         F2            mov	-$E[bp],ax
12993                                           !BCC_EOS
12994                                           ! 2163       ;
12995                                           !BCC_EOS
12996                                           ! 2164       ;
12997                                           !BCC_EOS
12998                                           ! 2165       lmode = mode;
12999                                           ! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
13000 3A71           8A46         EE            mov	al,-$12[bp]
13001 3A74           8846         ED            mov	-$13[bp],al
13002                                           !BCC_EOS
13003                                           ! 2166       if (lbefore & 0x03) lmode=0x00;
13004                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
13005 3A77           8A46         F6            mov	al,-$A[bp]
13006 3A7A           24                     03  and	al,*3
13007 3A7C           84C0                       test	al,al
13008 3A7E           74           05            je  	.2C7
13009                       00003A80            .2C8:
13010                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
13011 3A80           30C0                       xor	al,al
13012 3A82           8846         ED            mov	-$13[bp],al
13013                                           !BCC_EOS
13014                                           ! 2167       if (lcount & 0x03) lmode=0x00;
13015                       00003A85            .2C7:
13016                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
13017 3A85           8A46         F8            mov	al,-8[bp]
13018 3A88           24                     03  and	al,*3
13019 3A8A           84C0                       test	al,al
13020 3A8C           74           05            je  	.2C9
13021                       00003A8E            .2CA:
13022                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
13023 3A8E           30C0                       xor	al,al
13024 3A90           8846         ED            mov	-$13[bp],al
13025                                           !BCC_EOS
13026                                           ! 2168       if (lafter & 0x03) lmode=0x00;
13027                       00003A93            .2C9:
13028                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
13029 3A93           8A46         F4            mov	al,-$C[bp]
13030 3A96           24                     03  and	al,*3
13031 3A98           84C0                       test	al,al
13032 3A9A           74           05            je  	.2CB
13033                       00003A9C            .2CC:
13034                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
13035 3A9C           30C0                       xor	al,al
13036 3A9E           8846         ED            mov	-$13[bp],al
13037                                           !BCC_EOS
13038                                           ! 2169       if (lcount & 0x01) {
13039                       00003AA1            .2CB:
13040                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
13041 3AA1           8A46         F8            mov	al,-8[bp]
13042 3AA4           24                     01  and	al,*1
13043 3AA6           84C0                       test	al,al
13044 3AA8           74           1E            je  	.2CD
13045                       00003AAA            .2CE:
13046                                           ! 2170         lcount+=1;
13047                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
13048 3AAA           8B46         F8            mov	ax,-8[bp]
13049 3AAD           40                         inc	ax
13050 3AAE           8946         F8            mov	-8[bp],ax
13051                                           !BCC_EOS
13052                                           ! 2171         if ((lafter > 0) && (lafter & 0x01)) {
13053                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
13054 3AB1           8B46         F4            mov	ax,-$C[bp]
13055 3AB4           85C0                       test	ax,ax
13056 3AB6           74           10            je  	.2CF
13057                       00003AB8            .2D1:
13058                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
13059 3AB8           8A46         F4            mov	al,-$C[bp]
13060 3ABB           24                     01  and	al,*1
13061 3ABD           84C0                       test	al,al
13062 3ABF           74           07            je  	.2CF
13063                       00003AC1            .2D0:
13064                                           ! 2172           lafter-=1;
13065                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
13066 3AC1           8B46         F4            mov	ax,-$C[bp]
13067 3AC4           48                         dec	ax
13068 3AC5           8946         F4            mov	-$C[bp],ax
13069                                           !BCC_EOS
13070                                           ! 2173           }
13071                                           ! 2174         }
13072                       00003AC8            .2CF:
13073                                           ! 2175       if (lmode == 0x01) {
13074                       00003AC8            .2CD:
13075                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
13076 3AC8           8A46         ED            mov	al,-$13[bp]
13077 3ACB           3C                     01  cmp	al,*1
13078 3ACD           75           20            jne 	.2D2
13079                       00003ACF            .2D3:
13080                                           ! 2176         lcount>>=2; lbefore>>=2; lafter>>=2;
13081                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
13082 3ACF           8B46         F8            mov	ax,-8[bp]
13083 3AD2           D1E8                       shr	ax,*1
13084 3AD4           D1E8                       shr	ax,*1
13085 3AD6           8946         F8            mov	-8[bp],ax
13086                                           !BCC_EOS
13087                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
13088 3AD9           8B46         F6            mov	ax,-$A[bp]
13089 3ADC           D1E8                       shr	ax,*1
13090 3ADE           D1E8                       shr	ax,*1
13091 3AE0           8946         F6            mov	-$A[bp],ax
13092                                           !BCC_EOS
13093                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
13094 3AE3           8B46         F4            mov	ax,-$C[bp]
13095 3AE6           D1E8                       shr	ax,*1
13096 3AE8           D1E8                       shr	ax,*1
13097 3AEA           8946         F4            mov	-$C[bp],ax
13098                                           !BCC_EOS
13099                                           ! 2177         }
13100                                           ! 2178       else {
13101 3AED           EB           18            jmp .2D4
13102                       00003AEF            .2D2:
13103                                           ! 2179         lcount>>=1; lbefore>>=1; lafter>>=1;
13104                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
13105 3AEF           8B46         F8            mov	ax,-8[bp]
13106 3AF2           D1E8                       shr	ax,*1
13107 3AF4           8946         F8            mov	-8[bp],ax
13108                                           !BCC_EOS
13109                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
13110 3AF7           8B46         F6            mov	ax,-$A[bp]
13111 3AFA           D1E8                       shr	ax,*1
13112 3AFC           8946         F6            mov	-$A[bp],ax
13113                                           !BCC_EOS
13114                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
13115 3AFF           8B46         F4            mov	ax,-$C[bp]
13116 3B02           D1E8                       shr	ax,*1
13117 3B04           8946         F4            mov	-$C[bp],ax
13118                                           !BCC_EOS
13119                                           ! 2180         }
13120                                           ! 2181        ;
13121                       00003B07            .2D4:
13122                                           !BCC_EOS
13123                                           ! 2182 #asm
13124                                           !BCC_EOS
13125                                           !BCC_ASM
13126                       0000002A            _ata_cmd_packet.cmdoff	set	$2A
13127                       0000000A            .ata_cmd_packet.cmdoff	set	$A
13128                       0000002C            _ata_cmd_packet.header	set	$2C
13129                       0000000C            .ata_cmd_packet.header	set	$C
13130                       00000012            _ata_cmd_packet.count	set	$12
13131                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
13132                       00000014            _ata_cmd_packet.lafter	set	$14
13133                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
13134                       0000001C            _ata_cmd_packet.iobase1	set	$1C
13135                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
13136                       00000011            _ata_cmd_packet.channel	set	$11
13137                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
13138                       00000028            _ata_cmd_packet.cmdseg	set	$28
13139                       00000008            .ata_cmd_packet.cmdseg	set	8
13140                       00000026            _ata_cmd_packet.cmdlen	set	$26
13141                       00000006            .ata_cmd_packet.cmdlen	set	6
13142                       0000000D            _ata_cmd_packet.lmode	set	$D
13143                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
13144                       00000024            _ata_cmd_packet.device	set	$24
13145                       00000004            .ata_cmd_packet.device	set	4
13146                       00000002            _ata_cmd_packet.loops	set	2
13147                       FFFFFFE2            .ata_cmd_packet.loops	set	-$1E
13148                       0000001E            _ata_cmd_packet.ebda_seg	set	$1E
13149                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
13150                       00000018            _ata_cmd_packet.lcount	set	$18
13151                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
13152                       00000008            _ata_cmd_packet.total	set	8
13153                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
13154                       0000000F            _ata_cmd_packet.status	set	$F
13155                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
13156                       0000000E            _ata_cmd_packet.mode	set	$E
13157                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
13158                       00000036            _ata_cmd_packet.bufoff	set	$36
13159                       00000016            .ata_cmd_packet.bufoff	set	$16
13160                       00000004            _ata_cmd_packet.transfer	set	4
13161                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
13162                       00000001            _ata_cmd_packet.sc	set	1
13163                       FFFFFFE1            .ata_cmd_packet.sc	set	-$1F
13164                       0000001A            _ata_cmd_packet.iobase2	set	$1A
13165                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
13166                       00000016            _ata_cmd_packet.lbefore	set	$16
13167                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
13168                       00000034            _ata_cmd_packet.bufseg	set	$34
13169                       00000014            .ata_cmd_packet.bufseg	set	$14
13170                       00000010            _ata_cmd_packet.slave	set	$10
13171                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
13172                       00000032            _ata_cmd_packet.inout	set	$32
13173                       00000012            .ata_cmd_packet.inout	set	$12
13174                       0000002E            _ata_cmd_packet.length	set	$2E
13175                       0000000E            .ata_cmd_packet.length	set	$E
13176 3B07           55                                 push bp
13177 3B08           89E5                               mov bp, sp
13178 3B0A           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
13179 3B0D           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
13180 3B10           E3           15                    jcxz ata_packet_no_before
13181 3B12           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
13182 3B15           80FC                   01          cmp ah, #0x01
13183 3B18           74           05                    je ata_packet_in_before_32
13184                       00003B1A            ata_packet_in_before_16:
13185 3B1A           ED                                 in ax, dx
13186 3B1B           E2           FD                    loop ata_packet_in_before_16
13187 3B1D           EB           08                    jmp ata_packet_no_before
13188                       00003B1F            ata_packet_in_before_32:
13189 3B1F     66    50                                 push eax
13190                       00003B21            ata_packet_in_before_32_loop:
13191 3B21     66    ED                                 in eax, dx
13192 3B23           E2           FC                    loop ata_packet_in_before_32_loop
13193 3B25     66    58                                 pop eax
13194                       00003B27            ata_packet_no_before:
13195 3B27           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
13196 3B2A           E3           17                    jcxz ata_packet_after
13197 3B2C           8B7E         38                    mov di, _ata_cmd_packet.bufoff + 2[bp]
13198 3B2F           8B46         36                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
13199 3B32           8EC0                               mov es, ax
13200 3B34           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
13201 3B37           80FC                   01          cmp ah, #0x01
13202 3B3A           74           04                    je ata_packet_in_32
13203                       00003B3C            ata_packet_in_16:
13204 3B3C           F3                                 rep
13205 3B3D           6D                                   insw ;; CX words transfered tp port(DX) to ES:[DI]
13206 3B3E           EB           03                    jmp ata_packet_after
13207                       00003B40            ata_packet_in_32:
13208 3B40           F3                                 rep
13209 3B41     66    6D                                   insd ;; CX dwords transfered to port(DX) to ES:[DI]
13210                       00003B43            ata_packet_after:
13211 3B43           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
13212 3B46           E3           15                    jcxz ata_packet_done
13213 3B48           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
13214 3B4B           80FC                   01          cmp ah, #0x01
13215 3B4E           74           05                    je ata_packet_in_after_32
13216                       00003B50            ata_packet_in_after_16:
13217 3B50           ED                                 in ax, dx
13218 3B51           E2           FD                    loop ata_packet_in_after_16
13219 3B53           EB           08                    jmp ata_packet_done
13220                       00003B55            ata_packet_in_after_32:
13221 3B55     66    50                                 push eax
13222                       00003B57            ata_packet_in_after_32_loop:
13223 3B57     66    ED                                 in eax, dx
13224 3B59           E2           FC                    loop ata_packet_in_after_32_loop
13225 3B5B     66    58                                 pop eax
13226                       00003B5D            ata_packet_done:
13227 3B5D           5D                                 pop bp
13228                                           ! 2235 endasm
13229                                           !BCC_ENDASM
13230                                           !BCC_EOS
13231                                           ! 2236       bufoff += count;
13232                                           ! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
13233 3B5E           8B46         16            mov	ax,$16[bp]
13234 3B61           0346         F2            add	ax,-$E[bp]
13235 3B64           8946         16            mov	$16[bp],ax
13236                                           !BCC_EOS
13237                                           ! 2237       transfer += count;
13238                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
13239 3B67           8B46         F2            mov	ax,-$E[bp]
13240 3B6A           31DB                       xor	bx,bx
13241                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
13242 3B6C           8D7E         E4            lea	di,-$1C[bp]
13243 3B6F           E8         C551            call	laddul
13244 3B72           8946         E4            mov	-$1C[bp],ax
13245 3B75           895E         E6            mov	-$1A[bp],bx
13246                                           !BCC_EOS
13247                                           ! 2238       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
13248                                           ! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
13249 3B78           FF76         E6            push	-$1A[bp]
13250 3B7B           FF76         E4            push	-$1C[bp]
13251                                           ! Debug: list * unsigned long = const $256 (used reg = )
13252 3B7E           B8                   0256  mov	ax,#$256
13253 3B81           50                         push	ax
13254                                           ! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
13255 3B82           FF76         FE            push	-2[bp]
13256                                           ! Debug: func () void = write_dword+0 (used reg = )
13257 3B85           E8         C513            call	_write_dword
13258 3B88           83C4                   08  add	sp,*8
13259                                           !BCC_EOS
13260                                           ! 2239       }
13261                                           ! 2240     }
13262                       00003B8B            .2B7:
13263 3B8B           E9         FD91            br 	.2B8
13264                       00003B8E            .2D5:
13265                       00003B8E            .2B6:
13266 3B8E           83C4                   04  add	sp,*4
13267                                           ! 2241   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
13268                       00003B91            .2B5:
13269                                           ! 2242          != 0x40 ) {
13270                                           ! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
13271 3B91           8A46         EF            mov	al,-$11[bp]
13272 3B94           24                     E9  and	al,#$E9
13273                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
13274 3B96           3C                     40  cmp	al,*$40
13275 3B98           74           07            je  	.2D6
13276                       00003B9A            .2D7:
13277                                           ! 2243     ;
13278                                           !BCC_EOS
13279                                           ! 2244     return 4;
13280 3B9A           B8                   0004  mov	ax,*4
13281 3B9D           89EC                       mov	sp,bp
13282 3B9F           5D                         pop	bp
13283 3BA0           C3                         ret
13284                                           !BCC_EOS
13285                                           ! 2245     }
13286                                           ! 2246   outb(iobase2+6, 0x08);
13287                       00003BA1            .2D6:
13288                                           ! Debug: list int = const 8 (used reg = )
13289 3BA1           B8                   0008  mov	ax,*8
13290 3BA4           50                         push	ax
13291                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
13292 3BA5           8B46         FA            mov	ax,-6[bp]
13293                                           ! Debug: list unsigned int = ax+6 (used reg = )
13294 3BA8           05                   0006  add	ax,*6
13295 3BAB           50                         push	ax
13296                                           ! Debug: func () void = outb+0 (used reg = )
13297 3BAC           E8         C9A5            call	_outb
13298 3BAF           83C4                   04  add	sp,*4
13299                                           !BCC_EOS
13300                                           ! 2247   return 0;
13301 3BB2           31C0                       xor	ax,ax
13302 3BB4           89EC                       mov	sp,bp
13303 3BB6           5D                         pop	bp
13304 3BB7           C3                         ret
13305                                           !BCC_EOS
13306                                           ! 2248 }
13307                                           ! 2249   Bit16u
13308                                           ! Register BX used in function ata_cmd_packet
13309                                           ! 2250 atapi_get_sense(device, seg, asc, ascq)
13310                                           ! 2251   Bit16u device;
13311                                           export	_atapi_get_sense
13312                       00003BB8            _atapi_get_sense:
13313                                           !BCC_EOS
13314                                           ! 2252 {
13315                                           ! 2253   Bit8u atacmd[12];
13316                                           !BCC_EOS
13317                                           ! 2254   Bit8u buffer[18];
13318                                           !BCC_EOS
13319                                           ! 2255   Bit8u i;
13320                                           !BCC_EOS
13321                                           ! 2256   memsetb(get_SS(),atacmd,0,12);
13322 3BB8           55                         push	bp
13323 3BB9           89E5                       mov	bp,sp
13324 3BBB           83C4                   E0  add	sp,*-$20
13325                                           ! Debug: list int = const $C (used reg = )
13326 3BBE           B8                   000C  mov	ax,*$C
13327 3BC1           50                         push	ax
13328                                           ! Debug: list int = const 0 (used reg = )
13329 3BC2           31C0                       xor	ax,ax
13330 3BC4           50                         push	ax
13331                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
13332 3BC5           8D5E         F4            lea	bx,-$C[bp]
13333 3BC8           53                         push	bx
13334                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13335 3BC9           E8         CA81            call	_get_SS
13336                                           ! Debug: list unsigned short = ax+0 (used reg = )
13337 3BCC           50                         push	ax
13338                                           ! Debug: func () void = memsetb+0 (used reg = )
13339 3BCD           E8         C430            call	_memsetb
13340 3BD0           83C4                   08  add	sp,*8
13341                                           !BCC_EOS
13342                                           ! 2257   atacmd[0]=0x03;
13343                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
13344 3BD3           B0                     03  mov	al,*3
13345 3BD5           8846         F4            mov	-$C[bp],al
13346                                           !BCC_EOS
13347                                           ! 2258   atacmd[4]=sizeof(buffer);
13348                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
13349 3BD8           B0                     12  mov	al,*$12
13350 3BDA           8846         F8            mov	-8[bp],al
13351                                           !BCC_EOS
13352                                           ! 2259   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
13353                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
13354 3BDD           8D5E         E2            lea	bx,-$1E[bp]
13355 3BE0           53                         push	bx
13356                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13357 3BE1           E8         CA69            call	_get_SS
13358                                           ! Debug: list unsigned short = ax+0 (used reg = )
13359 3BE4           50                         push	ax
13360                                           ! Debug: list int = const 1 (used reg = )
13361 3BE5           B8                   0001  mov	ax,*1
13362 3BE8           50                         push	ax
13363                                           ! Debug: list long = const $12 (used reg = )
13364 3BE9           B8                   0012  mov	ax,*$12
13365 3BEC           31DB                       xor	bx,bx
13366 3BEE           53                         push	bx
13367 3BEF           50                         push	ax
13368                                           ! Debug: list int = const 0 (used reg = )
13369 3BF0           31C0                       xor	ax,ax
13370 3BF2           50                         push	ax
13371                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
13372 3BF3           8D5E         F4            lea	bx,-$C[bp]
13373 3BF6           53                         push	bx
13374                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13375 3BF7           E8         CA53            call	_get_SS
13376                                           ! Debug: list unsigned short = ax+0 (used reg = )
13377 3BFA           50                         push	ax
13378                                           ! Debug: list int = const $C (used reg = )
13379 3BFB           B8                   000C  mov	ax,*$C
13380 3BFE           50                         push	ax
13381                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
13382 3BFF           FF76         04            push	4[bp]
13383                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13384 3C02           E8         FAD4            call	_ata_cmd_packet
13385 3C05           83C4                   14  add	sp,*$14
13386                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13387 3C08           85C0                       test	ax,ax
13388 3C0A           74           07            je  	.2D8
13389                       00003C0C            .2D9:
13390                                           ! 2260     return 0x0002;
13391 3C0C           B8                   0002  mov	ax,*2
13392 3C0F           89EC                       mov	sp,bp
13393 3C11           5D                         pop	bp
13394 3C12           C3                         ret
13395                                           !BCC_EOS
13396                                           ! 2261   write_byte(seg,asc,buffer[12]);
13397                       00003C13            .2D8:
13398                                           ! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
13399 3C13           8A46         EE            mov	al,-$12[bp]
13400 3C16           30E4                       xor	ah,ah
13401 3C18           50                         push	ax
13402                                           ! Debug: list int asc = [S+$24+6] (used reg = )
13403 3C19           FF76         08            push	8[bp]
13404                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13405 3C1C           FF76         06            push	6[bp]
13406                                           ! Debug: func () void = write_byte+0 (used reg = )
13407 3C1F           E8         C9F8            call	_write_byte
13408 3C22           83C4                   06  add	sp,*6
13409                                           !BCC_EOS
13410                                           ! 2262   write_byte(seg,ascq,buffer[13]);
13411                                           ! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
13412 3C25           8A46         EF            mov	al,-$11[bp]
13413 3C28           30E4                       xor	ah,ah
13414 3C2A           50                         push	ax
13415                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
13416 3C2B           FF76         0A            push	$A[bp]
13417                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13418 3C2E           FF76         06            push	6[bp]
13419                                           ! Debug: func () void = write_byte+0 (used reg = )
13420 3C31           E8         C9E6            call	_write_byte
13421 3C34           83C4                   06  add	sp,*6
13422                                           !BCC_EOS
13423                                           ! 2263   return 0;
13424 3C37           31C0                       xor	ax,ax
13425 3C39           89EC                       mov	sp,bp
13426 3C3B           5D                         pop	bp
13427 3C3C           C3                         ret
13428                                           !BCC_EOS
13429                                           ! 2264 }
13430                                           ! 2265   Bit16u
13431                                           ! Register BX used in function atapi_get_sense
13432                                           ! 2266 atapi_is_ready(device)
13433                                           ! 2267   Bit16u device;
13434                                           export	_atapi_is_ready
13435                       00003C3D            _atapi_is_ready:
13436                                           !BCC_EOS
13437                                           ! 2268 {
13438                                           ! 2269   Bit8u packet[12];
13439                                           !BCC_EOS
13440                                           ! 2270   Bit8u buf[8];
13441                                           !BCC_EOS
13442                                           ! 2271   Bit32u block_len;
13443                                           !BCC_EOS
13444                                           ! 2272   Bit32u sectors;
13445                                           !BCC_EOS
13446                                           ! 2273   Bit32u timeout;
13447                                           !BCC_EOS
13448                                           ! 2274   Bit32u time;
13449                                           !BCC_EOS
13450                                           ! 2275   Bit8u asc, ascq;
13451                                           !BCC_EOS
13452                                           ! 2276   Bit8u in_progress;
13453                                           !BCC_EOS
13454                                           ! 2277   Bit16u ebda_seg = read_word(0x0040,0x000E);
13455 3C3D           55                         push	bp
13456 3C3E           89E5                       mov	bp,sp
13457 3C40           83C4                   D6  add	sp,*-$2A
13458                                           ! Debug: list int = const $E (used reg = )
13459 3C43           B8                   000E  mov	ax,*$E
13460 3C46           50                         push	ax
13461                                           ! Debug: list int = const $40 (used reg = )
13462 3C47           B8                   0040  mov	ax,*$40
13463 3C4A           50                         push	ax
13464                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13465 3C4B           E8         C9B9            call	_read_word
13466 3C4E           83C4                   04  add	sp,*4
13467                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
13468 3C51           8946         D6            mov	-$2A[bp],ax
13469                                           !BCC_EOS
13470                                           ! 2278   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
13471                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13472 3C54           8B46         04            mov	ax,4[bp]
13473 3C57           B9                   001E  mov	cx,*$1E
13474 3C5A           F7E9                       imul	cx
13475 3C5C           89C3                       mov	bx,ax
13476                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13477                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13478 3C5E           81C3                 0142  add	bx,#$142
13479 3C62           53                         push	bx
13480                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13481 3C63           FF76         D6            push	-$2A[bp]
13482                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13483 3C66           E8         C98B            call	_read_byte
13484 3C69           83C4                   04  add	sp,*4
13485                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13486 3C6C           3C                     03  cmp	al,*3
13487 3C6E           74           15            je  	.2DA
13488                       00003C70            .2DB:
13489                                           ! 2279     bios_printf(2, "not implemented for non-ATAPI device\n");
13490                                           ! Debug: list * char = .2DC+0 (used reg = )
13491 3C70           BB                   DA38  mov	bx,#.2DC
13492 3C73           53                         push	bx
13493                                           ! Debug: list int = const 2 (used reg = )
13494 3C74           B8                   0002  mov	ax,*2
13495 3C77           50                         push	ax
13496                                           ! Debug: func () void = bios_printf+0 (used reg = )
13497 3C78           E8         CD9E            call	_bios_printf
13498 3C7B           83C4                   04  add	sp,*4
13499                                           !BCC_EOS
13500                                           ! 2280     return -1;
13501 3C7E           B8                   FFFF  mov	ax,#$FFFF
13502 3C81           89EC                       mov	sp,bp
13503 3C83           5D                         pop	bp
13504 3C84           C3                         ret
13505                                           !BCC_EOS
13506                                           ! 2281   }
13507                                           ! 2282   ;
13508                       00003C85            .2DA:
13509                                           !BCC_EOS
13510                                           ! 2283   memsetb(get_SS(),packet, 0, sizeof packet);
13511                                           ! Debug: list int = const $C (used reg = )
13512 3C85           B8                   000C  mov	ax,*$C
13513 3C88           50                         push	ax
13514                                           ! Debug: list int = const 0 (used reg = )
13515 3C89           31C0                       xor	ax,ax
13516 3C8B           50                         push	ax
13517                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
13518 3C8C           8D5E         F4            lea	bx,-$C[bp]
13519 3C8F           53                         push	bx
13520                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13521 3C90           E8         C9BA            call	_get_SS
13522                                           ! Debug: list unsigned short = ax+0 (used reg = )
13523 3C93           50                         push	ax
13524                                           ! Debug: func () void = memsetb+0 (used reg = )
13525 3C94           E8         C369            call	_memsetb
13526 3C97           83C4                   08  add	sp,*8
13527                                           !BCC_EOS
13528                                           ! 2284   packet[0] = 0x25;
13529                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
13530 3C9A           B0                     25  mov	al,*$25
13531 3C9C           8846         F4            mov	-$C[bp],al
13532                                           !BCC_EOS
13533                                           ! 2285   timeout = 5000;
13534                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
13535 3C9F           B8                   1388  mov	ax,#$1388
13536 3CA2           31DB                       xor	bx,bx
13537 3CA4           8946         E0            mov	-$20[bp],ax
13538 3CA7           895E         E2            mov	-$1E[bp],bx
13539                                           !BCC_EOS
13540                                           ! 2286   time = 0;
13541                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
13542 3CAA           31C0                       xor	ax,ax
13543 3CAC           31DB                       xor	bx,bx
13544 3CAE           8946         DC            mov	-$24[bp],ax
13545 3CB1           895E         DE            mov	-$22[bp],bx
13546                                           !BCC_EOS
13547                                           ! 2287   in_progress = 0;
13548                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13549 3CB4           30C0                       xor	al,al
13550 3CB6           8846         D9            mov	-$27[bp],al
13551                                           !BCC_EOS
13552                                           ! 2288   while (time < timeout) {
13553 3CB9           E9         00AB            br 	.2DE
13554                       00003CBC            .2DF:
13555                                           ! 2289     if
13556                                           ! 2289  (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
13557                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
13558 3CBC           8D5E         EC            lea	bx,-$14[bp]
13559 3CBF           53                         push	bx
13560                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13561 3CC0           E8         C98A            call	_get_SS
13562                                           ! Debug: list unsigned short = ax+0 (used reg = )
13563 3CC3           50                         push	ax
13564                                           ! Debug: list int = const 1 (used reg = )
13565 3CC4           B8                   0001  mov	ax,*1
13566 3CC7           50                         push	ax
13567                                           ! Debug: list long = const 8 (used reg = )
13568 3CC8           B8                   0008  mov	ax,*8
13569 3CCB           31DB                       xor	bx,bx
13570 3CCD           53                         push	bx
13571 3CCE           50                         push	ax
13572                                           ! Debug: list int = const 0 (used reg = )
13573 3CCF           31C0                       xor	ax,ax
13574 3CD1           50                         push	ax
13575                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
13576 3CD2           8D5E         F4            lea	bx,-$C[bp]
13577 3CD5           53                         push	bx
13578                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13579 3CD6           E8         C974            call	_get_SS
13580                                           ! Debug: list unsigned short = ax+0 (used reg = )
13581 3CD9           50                         push	ax
13582                                           ! Debug: list int = const $C (used reg = )
13583 3CDA           B8                   000C  mov	ax,*$C
13584 3CDD           50                         push	ax
13585                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
13586 3CDE           FF76         04            push	4[bp]
13587                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13588 3CE1           E8         F9F5            call	_ata_cmd_packet
13589 3CE4           83C4                   14  add	sp,*$14
13590                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13591 3CE7           85C0                       test	ax,ax
13592 3CE9           75           06            jne 	.2E0
13593                       00003CEB            .2E1:
13594                                           ! 2290       goto ok;
13595 3CEB           83C4                   00  add	sp,#..FFFA+$2C
13596 3CEE           E9         008D            br 	.FFFA
13597                                           !BCC_EOS
13598                                           ! 2291     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
13599                       00003CF1            .2E0:
13600                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
13601 3CF1           8D5E         DA            lea	bx,-$26[bp]
13602 3CF4           53                         push	bx
13603                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
13604 3CF5           8D5E         DB            lea	bx,-$25[bp]
13605 3CF8           53                         push	bx
13606                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13607 3CF9           E8         C951            call	_get_SS
13608                                           ! Debug: list unsigned short = ax+0 (used reg = )
13609 3CFC           50                         push	ax
13610                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
13611 3CFD           FF76         04            push	4[bp]
13612                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
13613 3D00           E8         FEB5            call	_atapi_get_sense
13614 3D03           83C4                   08  add	sp,*8
13615                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13616 3D06           85C0                       test	ax,ax
13617 3D08           75           41            jne 	.2E2
13618                       00003D0A            .2E3:
13619                                           ! 2292       if (asc == 0x3a) {
13620                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
13621 3D0A           8A46         DB            mov	al,-$25[bp]
13622 3D0D           3C                     3A  cmp	al,*$3A
13623 3D0F           75           07            jne 	.2E4
13624                       00003D11            .2E5:
13625                                           ! 2293         ;
13626                                           !BCC_EOS
13627                                           ! 2294         return -1;
13628 3D11           B8                   FFFF  mov	ax,#$FFFF
13629 3D14           89EC                       mov	sp,bp
13630 3D16           5D                         pop	bp
13631 3D17           C3                         ret
13632                                           !BCC_EOS
13633                                           ! 2295       }
13634                                           ! 2296       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
13635                       00003D18            .2E4:
13636                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
13637 3D18           8A46         DB            mov	al,-$25[bp]
13638 3D1B           3C                     04  cmp	al,*4
13639 3D1D           75           2C            jne 	.2E6
13640                       00003D1F            .2E9:
13641                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
13642 3D1F           8A46         DA            mov	al,-$26[bp]
13643 3D22           3C                     01  cmp	al,*1
13644 3D24           75           25            jne 	.2E6
13645                       00003D26            .2E8:
13646 3D26           8A46         D9            mov	al,-$27[bp]
13647 3D29           84C0                       test	al,al
13648 3D2B           75           1E            jne 	.2E6
13649                       00003D2D            .2E7:
13650                                           ! 2297         bios_printf(2, "Waiting for device to detect medium... ");
13651                                           ! Debug: list * char = .2EA+0 (used reg = )
13652 3D2D           BB                   DA10  mov	bx,#.2EA
13653 3D30           53                         push	bx
13654                                           ! Debug: list int = const 2 (used reg = )
13655 3D31           B8                   0002  mov	ax,*2
13656 3D34           50                         push	ax
13657                                           ! Debug: func () void = bios_printf+0 (used reg = )
13658 3D35           E8         CCE1            call	_bios_printf
13659 3D38           83C4                   04  add	sp,*4
13660                                           !BCC_EOS
13661                                           ! 2298         timeout = 30000;
13662                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
13663 3D3B           B8                   7530  mov	ax,#$7530
13664 3D3E           31DB                       xor	bx,bx
13665 3D40           8946         E0            mov	-$20[bp],ax
13666 3D43           895E         E2            mov	-$1E[bp],bx
13667                                           !BCC_EOS
13668                                           ! 2299         in_progress = 1;
13669                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13670 3D46           B0                     01  mov	al,*1
13671 3D48           8846         D9            mov	-$27[bp],al
13672                                           !BCC_EOS
13673                                           ! 2300       }
13674                                           ! 2301     }
13675                       00003D4B            .2E6:
13676                                           ! 2302     time += 100;
13677                       00003D4B            .2E2:
13678                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
13679 3D4B           B8                   0064  mov	ax,*$64
13680 3D4E           31DB                       xor	bx,bx
13681 3D50           53                         push	bx
13682 3D51           50                         push	ax
13683 3D52           8B46         DC            mov	ax,-$24[bp]
13684 3D55           8B5E         DE            mov	bx,-$22[bp]
13685 3D58           8D7E         D2            lea	di,-$2E[bp]
13686 3D5B           E8         C365            call	laddul
13687 3D5E           8946         DC            mov	-$24[bp],ax
13688 3D61           895E         DE            mov	-$22[bp],bx
13689 3D64           83C4                   04  add	sp,*4
13690                                           !BCC_EOS
13691                                           ! 2303   }
13692                                           ! 2304   ;
13693                       00003D67            .2DE:
13694                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
13695 3D67           8B46         E0            mov	ax,-$20[bp]
13696 3D6A           8B5E         E2            mov	bx,-$1E[bp]
13697 3D6D           8D7E         DC            lea	di,-$24[bp]
13698 3D70           E8         C358            call	lcmpul
13699 3D73         0F87         FF45            bhi 	.2DF
13700                       00003D77            .2EB:
13701                       00003D77            .2DD:
13702                                           !BCC_EOS
13703                                           ! 2305   return -1;
13704 3D77           B8                   FFFF  mov	ax,#$FFFF
13705 3D7A           89EC                       mov	sp,bp
13706 3D7C           5D                         pop	bp
13707 3D7D           C3                         ret
13708                                           !BCC_EOS
13709                                           ! 2306 ok:
13710                       00003D7E            .FFFA:
13711                       FFFFFFD4            ..FFFA	=	-$2C
13712                                           ! 2307   block_len = (Bit32u) buf[4] << 24
13713                                           ! 2308     | (Bit32u) buf[5] << 16
13714                                           ! 2309     | (Bit32u) buf[6] << 8
13715                                           ! 2310     | (Bit32u) buf[7] << 0;
13716                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
13717 3D7E           8A46         F3            mov	al,-$D[bp]
13718 3D81           30E4                       xor	ah,ah
13719 3D83           31DB                       xor	bx,bx
13720                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13721 3D85           53                         push	bx
13722 3D86           50                         push	ax
13723                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
13724 3D87           8A46         F2            mov	al,-$E[bp]
13725 3D8A           30E4                       xor	ah,ah
13726 3D8C           31DB                       xor	bx,bx
13727                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13728 3D8E           88DF                       mov	bh,bl
13729 3D90           88E3                       mov	bl,ah
13730 3D92           88C4                       mov	ah,al
13731 3D94           30C0                       xor	al,al
13732 3D96           53                         push	bx
13733 3D97           50                         push	ax
13734                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
13735 3D98           8A46         F1            mov	al,-$F[bp]
13736 3D9B           30E4                       xor	ah,ah
13737 3D9D           31DB                       xor	bx,bx
13738                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13739 3D9F           93                         xchg	bx,ax
13740 3DA0           31C0                       xor	ax,ax
13741 3DA2           53                         push	bx
13742 3DA3           50                         push	ax
13743                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
13744 3DA4           8A46         F0            mov	al,-$10[bp]
13745 3DA7           30E4                       xor	ah,ah
13746 3DA9           31DB                       xor	bx,bx
13747                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13748 3DAB           88C4                       mov	ah,al
13749 3DAD           30C0                       xor	al,al
13750 3DAF           93                         xchg	bx,ax
13751 3DB0           31C0                       xor	ax,ax
13752                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13753 3DB2           8D7E         CA            lea	di,-$36[bp]
13754 3DB5           E8         C34F            call	lorul
13755 3DB8           83C4                   04  add	sp,*4
13756                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13757 3DBB           8D7E         CE            lea	di,-$32[bp]
13758 3DBE           E8         C346            call	lorul
13759 3DC1           83C4                   04  add	sp,*4
13760                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13761 3DC4           8D7E         D2            lea	di,-$2E[bp]
13762 3DC7           E8         C33D            call	lorul
13763 3DCA           83C4                   04  add	sp,*4
13764                                           ! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13765 3DCD           8946         E8            mov	-$18[bp],ax
13766 3DD0           895E         EA            mov	-$16[bp],bx
13767                                           !BCC_EOS
13768                                           ! 2311   ;
13769                                           !BCC_EOS
13770                                           ! 2312   if (block_len!= 2048 && block_len!= 512)
13771                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13772                                           ! Debug: expression subtree swapping
13773 3DD3           B8                   0800  mov	ax,#$800
13774 3DD6           31DB                       xor	bx,bx
13775 3DD8           53                         push	bx
13776 3DD9           50                         push	ax
13777 3DDA           8B46         E8            mov	ax,-$18[bp]
13778 3DDD           8B5E         EA            mov	bx,-$16[bp]
13779 3DE0           8D7E         D2            lea	di,-$2E[bp]
13780 3DE3           E8         C2E5            call	lcmpul
13781 3DE6           8D66         D6            lea	sp,-$2A[bp]
13782 3DE9           74           33            je  	.2EC
13783                       00003DEB            .2EE:
13784                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13785                                           ! Debug: expression subtree swapping
13786 3DEB           B8                   0200  mov	ax,#$200
13787 3DEE           31DB                       xor	bx,bx
13788 3DF0           53                         push	bx
13789 3DF1           50                         push	ax
13790 3DF2           8B46         E8            mov	ax,-$18[bp]
13791 3DF5           8B5E         EA            mov	bx,-$16[bp]
13792 3DF8           8D7E         D2            lea	di,-$2E[bp]
13793 3DFB           E8         C2CD            call	lcmpul
13794 3DFE           8D66         D6            lea	sp,-$2A[bp]
13795 3E01           74           1B            je  	.2EC
13796                       00003E03            .2ED:
13797                                           ! 2313   {
13798                                           ! 2314     bios_printf(2, "Unsupported sector size %u\n", block_len);
13799                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13800 3E03           FF76         EA            push	-$16[bp]
13801 3E06           FF76         E8            push	-$18[bp]
13802                                           ! Debug: list * char = .2EF+0 (used reg = )
13803 3E09           BB                   D9F4  mov	bx,#.2EF
13804 3E0C           53                         push	bx
13805                                           ! Debug: list int = const 2 (used reg = )
13806 3E0D           B8                   0002  mov	ax,*2
13807 3E10           50                         push	ax
13808                                           ! Debug: func () void = bios_printf+0 (used reg = )
13809 3E11           E8         CC05            call	_bios_printf
13810 3E14           83C4                   08  add	sp,*8
13811                                           !BCC_EOS
13812                                           ! 2315     return -1;
13813 3E17           B8                   FFFF  mov	ax,#$FFFF
13814 3E1A           89EC                       mov	sp,bp
13815 3E1C           5D                         pop	bp
13816 3E1D           C3                         ret
13817                                           !BCC_EOS
13818                                           ! 2316   }
13819                                           ! 2317   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
13820                       00003E1E            .2EC:
13821                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13822 3E1E           FF76         EA            push	-$16[bp]
13823 3E21           FF76         E8            push	-$18[bp]
13824                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13825 3E24           8B46         04            mov	ax,4[bp]
13826 3E27           B9                   001E  mov	cx,*$1E
13827 3E2A           F7E9                       imul	cx
13828 3E2C           89C3                       mov	bx,ax
13829                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
13830                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
13831 3E2E           81C3                 0148  add	bx,#$148
13832 3E32           53                         push	bx
13833                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13834 3E33           FF76         D6            push	-$2A[bp]
13835                                           ! Debug: func () void = write_dword+0 (used reg = )
13836 3E36           E8         C262            call	_write_dword
13837 3E39           83C4                   08  add	sp,*8
13838                                           !BCC_EOS
13839                                           ! 2318   sectors = (Bit32u) buf[0] << 24
13840                                           ! 2319     | (Bit32u) buf[1] << 16
13841                                           ! 2320     | (Bit32u) buf[2] << 8
13842                                           ! 2321     | (Bit32u) buf[3] << 0;
13843                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
13844 3E3C           8A46         EF            mov	al,-$11[bp]
13845 3E3F           30E4                       xor	ah,ah
13846 3E41           31DB                       xor	bx,bx
13847                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13848 3E43           53                         push	bx
13849 3E44           50                         push	ax
13850                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
13851 3E45           8A46         EE            mov	al,-$12[bp]
13852 3E48           30E4                       xor	ah,ah
13853 3E4A           31DB                       xor	bx,bx
13854                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13855 3E4C           88DF                       mov	bh,bl
13856 3E4E           88E3                       mov	bl,ah
13857 3E50           88C4                       mov	ah,al
13858 3E52           30C0                       xor	al,al
13859 3E54           53                         push	bx
13860 3E55           50                         push	ax
13861                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
13862 3E56           8A46         ED            mov	al,-$13[bp]
13863 3E59           30E4                       xor	ah,ah
13864 3E5B           31DB                       xor	bx,bx
13865                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13866 3E5D           93                         xchg	bx,ax
13867 3E5E           31C0                       xor	ax,ax
13868 3E60           53                         push	bx
13869 3E61           50                         push	ax
13870                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
13871 3E62           8A46         EC            mov	al,-$14[bp]
13872 3E65           30E4                       xor	ah,ah
13873 3E67           31DB                       xor	bx,bx
13874                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13875 3E69           88C4                       mov	ah,al
13876 3E6B           30C0                       xor	al,al
13877 3E6D           93                         xchg	bx,ax
13878 3E6E           31C0                       xor	ax,ax
13879                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13880 3E70           8D7E         CA            lea	di,-$36[bp]
13881 3E73           E8         C291            call	lorul
13882 3E76           83C4                   04  add	sp,*4
13883                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13884 3E79           8D7E         CE            lea	di,-$32[bp]
13885 3E7C           E8         C288            call	lorul
13886 3E7F           83C4                   04  add	sp,*4
13887                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13888 3E82           8D7E         D2            lea	di,-$2E[bp]
13889 3E85           E8         C27F            call	lorul
13890 3E88           83C4                   04  add	sp,*4
13891                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13892 3E8B           8946         E4            mov	-$1C[bp],ax
13893 3E8E           895E         E6            mov	-$1A[bp],bx
13894                                           !BCC_EOS
13895                                           ! 2322   ;
13896                                           !BCC_EOS
13897                                           ! 2323   if (block_len == 2048)
13898                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13899                                           ! Debug: expression subtree swapping
13900 3E91           B8                   0800  mov	ax,#$800
13901 3E94           31DB                       xor	bx,bx
13902 3E96           53                         push	bx
13903 3E97           50                         push	ax
13904 3E98           8B46         E8            mov	ax,-$18[bp]
13905 3E9B           8B5E         EA            mov	bx,-$16[bp]
13906 3E9E           8D7E         D2            lea	di,-$2E[bp]
13907 3EA1           E8         C227            call	lcmpul
13908 3EA4           8D66         D6            lea	sp,-$2A[bp]
13909 3EA7           75           12            jne 	.2F0
13910                       00003EA9            .2F1:
13911                                           ! 2324     sectors <<= 2;
13912                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13913 3EA9           8B46         E4            mov	ax,-$1C[bp]
13914 3EAC           8B5E         E6            mov	bx,-$1A[bp]
13915 3EAF           BF                   0002  mov	di,*2
13916 3EB2           E8         C292            call	lslul
13917 3EB5           8946         E4            mov	-$1C[bp],ax
13918 3EB8           895E         E6            mov	-$1A[bp],bx
13919                                           !BCC_EOS
13920                                           ! 2325   if (sectors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
13921                       00003EBB            .2F0:
13922                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13923 3EBB           8B46         04            mov	ax,4[bp]
13924 3EBE           B9                   001E  mov	cx,*$1E
13925 3EC1           F7E9                       imul	cx
13926 3EC3           89C3                       mov	bx,ax
13927                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13928                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13929 3EC5           81C3                 0158  add	bx,#$158
13930 3EC9           53                         push	bx
13931                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13932 3ECA           FF76         D6            push	-$2A[bp]
13933                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
13934 3ECD           E8         C1B3            call	_read_dword
13935 3ED0           89D3                       mov	bx,dx
13936 3ED2           83C4                   04  add	sp,*4
13937                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13938                                           ! Debug: expression subtree swapping
13939 3ED5           8D7E         E4            lea	di,-$1C[bp]
13940 3ED8           E8         C1F0            call	lcmpul
13941 3EDB           74           24            je  	.2F2
13942                       00003EDD            .2F3:
13943                                           ! 2326     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
13944                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
13945 3EDD           8B46         E4            mov	ax,-$1C[bp]
13946 3EE0           8B5E         E6            mov	bx,-$1A[bp]
13947 3EE3           88E0                       mov	al,ah
13948 3EE5           88DC                       mov	ah,bl
13949 3EE7           88FB                       mov	bl,bh
13950 3EE9           28FF                       sub	bh,bh
13951 3EEB           BF                   0003  mov	di,*3
13952 3EEE           E8         C238            call	lsrul
13953                                           ! Debug: list unsigned long = bx+0 (used reg = )
13954 3EF1           53                         push	bx
13955 3EF2           50                         push	ax
13956                                           ! Debug: list * char = .2F4+0 (used reg = )
13957 3EF3           BB                   D9DE  mov	bx,#.2F4
13958 3EF6           53                         push	bx
13959                                           ! Debug: list int = const 2 (used reg = )
13960 3EF7           B8                   0002  mov	ax,*2
13961 3EFA           50                         push	ax
13962                                           ! Debug: func () void = bios_printf+0 (used reg = )
13963 3EFB           E8         CB1B            call	_bios_printf
13964 3EFE           83C4                   08  add	sp,*8
13965                                           !BCC_EOS
13966                                           ! 2327   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
13967                       00003F01            .2F2:
13968                                           ! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
13969 3F01           FF76         E6            push	-$1A[bp]
13970 3F04           FF76         E4            push	-$1C[bp]
13971                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13972 3F07           8B46         04            mov	ax,4[bp]
13973 3F0A           B9                   001E  mov	cx,*$1E
13974 3F0D           F7E9                       imul	cx
13975 3F0F           89C3                       mov	bx,ax
13976                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13977                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13978 3F11           81C3                 0158  add	bx,#$158
13979 3F15           53                         push	bx
13980                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13981 3F16           FF76         D6            push	-$2A[bp]
13982                                           ! Debug: func () void = write_dword+0 (used reg = )
13983 3F19           E8         C17F            call	_write_dword
13984 3F1C           83C4                   08  add	sp,*8
13985                                           !BCC_EOS
13986                                           ! 2328   return 0;
13987 3F1F           31C0                       xor	ax,ax
13988 3F21           89EC                       mov	sp,bp
13989 3F23           5D                         pop	bp
13990 3F24           C3                         ret
13991                                           !BCC_EOS
13992                                           ! 2329 }
13993                                           ! 2330   Bit16u
13994                                           ! Register BX used in function atapi_is_ready
13995                                           ! 2331 atapi_is_cdrom(device)
13996                                           ! 2332   Bit8u device;
13997                                           export	_atapi_is_cdrom
13998                       00003F25            _atapi_is_cdrom:
13999                                           !BCC_EOS
14000                                           ! 2333 {
14001                                           ! 2334   Bit16u ebda_seg=read_word(0x0040,0x000E);
14002 3F25           55                         push	bp
14003 3F26           89E5                       mov	bp,sp
14004 3F28           4C                         dec	sp
14005 3F29           4C                         dec	sp
14006                                           ! Debug: list int = const $E (used reg = )
14007 3F2A           B8                   000E  mov	ax,*$E
14008 3F2D           50                         push	ax
14009                                           ! Debug: list int = const $40 (used reg = )
14010 3F2E           B8                   0040  mov	ax,*$40
14011 3F31           50                         push	ax
14012                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14013 3F32           E8         C6D2            call	_read_word
14014 3F35           83C4                   04  add	sp,*4
14015                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14016 3F38           8946         FE            mov	-2[bp],ax
14017                                           !BCC_EOS
14018                                           ! 2335   if (device >= (4*2))
14019                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
14020 3F3B           8A46         04            mov	al,4[bp]
14021 3F3E           3C                     08  cmp	al,*8
14022 3F40           72           06            jb  	.2F5
14023                       00003F42            .2F6:
14024                                           ! 2336     return 0;
14025 3F42           31C0                       xor	ax,ax
14026 3F44           89EC                       mov	sp,bp
14027 3F46           5D                         pop	bp
14028 3F47           C3                         ret
14029                                           !BCC_EOS
14030                                           ! 2337   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
14031                       00003F48            .2F5:
14032                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
14033 3F48           8A46         04            mov	al,4[bp]
14034 3F4B           30E4                       xor	ah,ah
14035 3F4D           B9                   001E  mov	cx,*$1E
14036 3F50           F7E9                       imul	cx
14037 3F52           89C3                       mov	bx,ax
14038                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
14039                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
14040 3F54           81C3                 0142  add	bx,#$142
14041 3F58           53                         push	bx
14042                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
14043 3F59           FF76         FE            push	-2[bp]
14044                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14045 3F5C           E8         C695            call	_read_byte
14046 3F5F           83C4                   04  add	sp,*4
14047                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
14048 3F62           3C                     03  cmp	al,*3
14049 3F64           74           06            je  	.2F7
14050                       00003F66            .2F8:
14051                                           ! 2338     return 0;
14052 3F66           31C0                       xor	ax,ax
14053 3F68           89EC                       mov	sp,bp
14054 3F6A           5D                         pop	bp
14055 3F6B           C3                         ret
14056                                           !BCC_EOS
14057                                           ! 2339   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
14058                       00003F6C            .2F7:
14059                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
14060 3F6C           8A46         04            mov	al,4[bp]
14061 3F6F           30E4                       xor	ah,ah
14062 3F71           B9                   001E  mov	cx,*$1E
14063 3F74           F7E9                       imul	cx
14064 3F76           89C3                       mov	bx,ax
14065                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
14066                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
14067 3F78           81C3                 0143  add	bx,#$143
14068 3F7C           53                         push	bx
14069                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
14070 3F7D           FF76         FE            push	-2[bp]
14071                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14072 3F80           E8         C671            call	_read_byte
14073 3F83           83C4                   04  add	sp,*4
14074                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
14075 3F86           3C                     05  cmp	al,*5
14076 3F88           74           06            je  	.2F9
14077                       00003F8A            .2FA:
14078                                           ! 2340     return 0;
14079 3F8A           31C0                       xor	ax,ax
14080 3F8C           89EC                       mov	sp,bp
14081 3F8E           5D                         pop	bp
14082 3F8F           C3                         ret
14083                                           !BCC_EOS
14084                                           ! 2341   return 1;
14085                       00003F90            .2F9:
14086 3F90           B8                   0001  mov	ax,*1
14087 3F93           89EC                       mov	sp,bp
14088 3F95           5D                         pop	bp
14089 3F96           C3                         ret
14090                                           !BCC_EOS
14091                                           ! 2342 }
14092                                           ! 2343   void
14093                                           ! Register BX used in function atapi_is_cdrom
14094                                           ! 2344 cdemu_init()
14095                                           ! 2345 {
14096                                           export	_cdemu_init
14097                       00003F97            _cdemu_init:
14098                                           ! 2346   Bit16u ebda_seg=read_word(0x0040,0x000E);
14099 3F97           55                         push	bp
14100 3F98           89E5                       mov	bp,sp
14101 3F9A           4C                         dec	sp
14102 3F9B           4C                         dec	sp
14103                                           ! Debug: list int = const $E (used reg = )
14104 3F9C           B8                   000E  mov	ax,*$E
14105 3F9F           50                         push	ax
14106                                           ! Debug: list int = const $40 (used reg = )
14107 3FA0           B8                   0040  mov	ax,*$40
14108 3FA3           50                         push	ax
14109                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14110 3FA4           E8         C660            call	_read_word
14111 3FA7           83C4                   04  add	sp,*4
14112                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14113 3FAA           8946         FE            mov	-2[bp],ax
14114                                           !BCC_EOS
14115                                           ! 2347   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
14116                                           ! Debug: list int = const 0 (used reg = )
14117 3FAD           31C0                       xor	ax,ax
14118 3FAF           50                         push	ax
14119                                           ! Debug: list * unsigned char = const $25A (used reg = )
14120 3FB0           B8                   025A  mov	ax,#$25A
14121 3FB3           50                         push	ax
14122                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
14123 3FB4           FF76         FE            push	-2[bp]
14124                                           ! Debug: func () void = write_byte+0 (used reg = )
14125 3FB7           E8         C660            call	_write_byte
14126 3FBA           83C4                   06  add	sp,*6
14127                                           !BCC_EOS
14128                                           ! 2348 }
14129 3FBD           89EC                       mov	sp,bp
14130 3FBF           5D                         pop	bp
14131 3FC0           C3                         ret
14132                                           ! 2349   Bit8u
14133                                           ! 2350 cdemu_isactive()
14134                                           ! 2351 {
14135                                           export	_cdemu_isactive
14136                       00003FC1            _cdemu_isactive:
14137                                           ! 2352   Bit16u ebda_seg=read_word(0x0040,0x000E);
14138 3FC1           55                         push	bp
14139 3FC2           89E5                       mov	bp,sp
14140 3FC4           4C                         dec	sp
14141 3FC5           4C                         dec	sp
14142                                           ! Debug: list int = const $E (used reg = )
14143 3FC6           B8                   000E  mov	ax,*$E
14144 3FC9           50                         push	ax
14145                                           ! Debug: list int = const $40 (used reg = )
14146 3FCA           B8                   0040  mov	ax,*$40
14147 3FCD           50                         push	ax
14148                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14149 3FCE           E8         C636            call	_read_word
14150 3FD1           83C4                   04  add	sp,*4
14151                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14152 3FD4           8946         FE            mov	-2[bp],ax
14153                                           !BCC_EOS
14154                                           ! 2353   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
14155                                           ! Debug: list * unsigned char = const $25A (used reg = )
14156 3FD7           B8                   025A  mov	ax,#$25A
14157 3FDA           50                         push	ax
14158                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
14159 3FDB           FF76         FE            push	-2[bp]
14160                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14161 3FDE           E8         C613            call	_read_byte
14162 3FE1           83C4                   04  add	sp,*4
14163                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
14164 3FE4           89EC                       mov	sp,bp
14165 3FE6           5D                         pop	bp
14166 3FE7           C3                         ret
14167                                           !BCC_EOS
14168                                           ! 2354 }
14169                                           ! 2355   Bit8u
14170                                           ! 2356 cdemu_emulated_drive()
14171                                           ! 2357 {
14172                                           export	_cdemu_emulated_drive
14173                       00003FE8            _cdemu_emulated_drive:
14174                                           ! 2358   Bit16u ebda_seg=read_word(0x0040,0x000E);
14175 3FE8           55                         push	bp
14176 3FE9           89E5                       mov	bp,sp
14177 3FEB           4C                         dec	sp
14178 3FEC           4C                         dec	sp
14179                                           ! Debug: list int = const $E (used reg = )
14180 3FED           B8                   000E  mov	ax,*$E
14181 3FF0           50                         push	ax
14182                                           ! Debug: list int = const $40 (used reg = )
14183 3FF1           B8                   0040  mov	ax,*$40
14184 3FF4           50                         push	ax
14185                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14186 3FF5           E8         C60F            call	_read_word
14187 3FF8           83C4                   04  add	sp,*4
14188                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14189 3FFB           8946         FE            mov	-2[bp],ax
14190                                           !BCC_EOS
14191                                           ! 2359   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
14192                                           ! Debug: list * unsigned char = const $25C (used reg = )
14193 3FFE           B8                   025C  mov	ax,#$25C
14194 4001           50                         push	ax
14195                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
14196 4002           FF76         FE            push	-2[bp]
14197                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14198 4005           E8         C5EC            call	_read_byte
14199 4008           83C4                   04  add	sp,*4
14200                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
14201 400B           89EC                       mov	sp,bp
14202 400D           5D                         pop	bp
14203 400E           C3                         ret
14204                                           !BCC_EOS
14205                                           ! 2360 }
14206                                           ! 2361 static char isotag[6]="CD001";
14207                                           
14208                       0000400F            _isotag:
14209                       0000400F            .2FB:
14210 400F                        43            .ascii	"CD001"
14211 4014                        00            .byte	0
14212                                           !BCC_EOS
14213                                           ! 2362 static char eltorito[24]="EL T
14214                                           ! 2362 ORITO SPECIFICATION";
14215                       00004015            _eltorito:
14216                       00004015            .2FC:
14217 4015                        45            .ascii	"EL TORITO SPECIFICATION"
14218 402C                        00            .byte	0
14219                                           !BCC_EOS
14220                                           ! 2363   Bit16u
14221                                           ! 2364 cdrom_boot()
14222                                           ! 2365 {
14223                                           
14224                                           export	_cdrom_boot
14225                       0000402D            _cdrom_boot:
14226                                           ! 2366   Bit16u ebda_seg=read_word(0x0040,0x000E);
14227 402D           55                         push	bp
14228 402E           89E5                       mov	bp,sp
14229 4030           4C                         dec	sp
14230 4031           4C                         dec	sp
14231                                           ! Debug: list int = const $E (used reg = )
14232 4032           B8                   000E  mov	ax,*$E
14233 4035           50                         push	ax
14234                                           ! Debug: list int = const $40 (used reg = )
14235 4036           B8                   0040  mov	ax,*$40
14236 4039           50                         push	ax
14237                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14238 403A           E8         C5CA            call	_read_word
14239 403D           83C4                   04  add	sp,*4
14240                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14241 4040           8946         FE            mov	-2[bp],ax
14242                                           !BCC_EOS
14243                                           ! 2367   Bit8u atacmd[12], buffer[2048];
14244                                           !BCC_EOS
14245                                           ! 2368   Bit32u lba;
14246                                           !BCC_EOS
14247                                           ! 2369   Bit16u boot_segment, nbsectors, i, error;
14248                                           !BCC_EOS
14249                                           ! 2370   Bit8u device;
14250                                           !BCC_EOS
14251                                           ! 2371   for (device=0; device<(4*2);device++) {
14252 4043           81C4                 F7E6  add	sp,#-$81A
14253                                           ! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
14254 4047           30C0                       xor	al,al
14255 4049           8886       F7E5            mov	-$81B[bp],al
14256                                           !BCC_EOS
14257                                           !BCC_EOS
14258 404D           EB           1B            jmp .2FF
14259                       0000404F            .300:
14260                                           ! 2372     if (atapi_is_cdrom(device)) break;
14261                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14262 404F           8A86       F7E5            mov	al,-$81B[bp]
14263 4053           30E4                       xor	ah,ah
14264 4055           50                         push	ax
14265                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
14266 4056           E8         FECC            call	_atapi_is_cdrom
14267 4059           44                         inc	sp
14268 405A           44                         inc	sp
14269 405B           85C0                       test	ax,ax
14270 405D           74           02            je  	.301
14271                       0000405F            .302:
14272 405F           EB           11            jmp .2FD
14273                                           !BCC_EOS
14274                                           ! 2373     }
14275                       00004061            .301:
14276                                           ! 2374   if(device >= (4*2)) return 2;
14277                       00004061            .2FE:
14278                                           ! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
14279 4061           8A86       F7E5            mov	al,-$81B[bp]
14280 4065           40                         inc	ax
14281 4066           8886       F7E5            mov	-$81B[bp],al
14282                       0000406A            .2FF:
14283                                           ! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14284 406A           8A86       F7E5            mov	al,-$81B[bp]
14285 406E           3C                     08  cmp	al,*8
14286 4070           72           DD            jb 	.300
14287                       00004072            .303:
14288                       00004072            .2FD:
14289                                           ! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14290 4072           8A86       F7E5            mov	al,-$81B[bp]
14291 4076           3C                     08  cmp	al,*8
14292 4078           72           07            jb  	.304
14293                       0000407A            .305:
14294 407A           B8                   0002  mov	ax,*2
14295 407D           89EC                       mov	sp,bp
14296 407F           5D                         pop	bp
14297 4080           C3                         ret
14298                                           !BCC_EOS
14299                                           ! 2375   if(error = atapi_is_ready(device) != 0)
14300                       00004081            .304:
14301                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14302 4081           8A86       F7E5            mov	al,-$81B[bp]
14303 4085           30E4                       xor	ah,ah
14304 4087           50                         push	ax
14305                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
14306 4088           E8         FBB2            call	_atapi_is_ready
14307 408B           44                         inc	sp
14308 408C           44                         inc	sp
14309                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14310 408D           85C0                       test	ax,ax
14311 408F           74           04            je 	.308
14312 4091           B0                     01  mov	al,*1
14313 4093           EB           02            jmp	.309
14314                       00004095            .308:
14315 4095           30C0                       xor	al,al
14316                       00004097            .309:
14317                                           ! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14318 4097           30E4                       xor	ah,ah
14319 4099           8986       F7E6            mov	-$81A[bp],ax
14320 409D           85C0                       test	ax,ax
14321 409F           74           12            je  	.306
14322                       000040A1            .307:
14323                                           ! 2376     bios_printf(4, "ata_is_ready returned %d\n",error);
14324                                           ! Debug: list unsigned short error = [S+$81E-$81C] (used reg = )
14325 40A1           FFB6       F7E6            push	-$81A[bp]
14326                                           ! Debug: list * char = .30A+0 (used reg = )
14327 40A5           BB                   D9C4  mov	bx,#.30A
14328 40A8           53                         push	bx
14329                                           ! Debug: list int = const 4 (used reg = )
14330 40A9           B8                   0004  mov	ax,*4
14331 40AC           50                         push	ax
14332                                           ! Debug: func () void = bios_printf+0 (used reg = )
14333 40AD           E8         C969            call	_bios_printf
14334 40B0           83C4                   06  add	sp,*6
14335                                           !BCC_EOS
14336                                           ! 2377   memsetb(get_SS(),atacmd,0,12);
14337                       000040B3            .306:
14338                                           ! Debug: list int = const $C (used reg = )
14339 40B3           B8                   000C  mov	ax,*$C
14340 40B6           50                         push	ax
14341                                           ! Debug: list int = const 0 (used reg = )
14342 40B7           31C0                       xor	ax,ax
14343 40B9           50                         push	ax
14344                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14345 40BA           8D5E         F2            lea	bx,-$E[bp]
14346 40BD           53                         push	bx
14347                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14348 40BE           E8         C58C            call	_get_SS
14349                                           ! Debug: list unsigned short = ax+0 (used reg = )
14350 40C1           50                         push	ax
14351                                           ! Debug: func () void = memsetb+0 (used reg = )
14352 40C2           E8         BF3B            call	_memsetb
14353 40C5           83C4                   08  add	sp,*8
14354                                           !BCC_EOS
14355                                           ! 2378   atacmd[0]=0x28;
14356                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14357 40C8           B0                     28  mov	al,*$28
14358 40CA           8846         F2            mov	-$E[bp],al
14359                                           !BCC_EOS
14360                                           ! 2379   atacmd[7]=(0x01 & 0xff00) >> 8;
14361                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14362 40CD           30C0                       xor	al,al
14363 40CF           8846         F9            mov	-7[bp],al
14364                                           !BCC_EOS
14365                                           ! 2380   atacmd[8]=(0x01 & 0x00ff);
14366                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14367 40D2           B0                     01  mov	al,*1
14368 40D4           8846         FA            mov	-6[bp],al
14369                                           !BCC_EOS
14370                                           ! 2381   atacmd[2]=(0x11 & 0xff000000) >> 24;
14371                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14372 40D7           30C0                       xor	al,al
14373 40D9           8846         F4            mov	-$C[bp],al
14374                                           !BCC_EOS
14375                                           ! 2382   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
14376                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14377 40DC           30C0                       xor	al,al
14378 40DE           8846         F5            mov	-$B[bp],al
14379                                           !BCC_EOS
14380                                           ! 2383   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
14381                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14382 40E1           30C0                       xor	al,al
14383 40E3           8846         F6            mov	-$A[bp],al
14384                                           !BCC_EOS
14385                                           ! 2384   atacmd[5]=(0x11 & 0x000000ff);
14386                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14387 40E6           B0                     11  mov	al,*$11
14388 40E8           8846         F7            mov	-9[bp],al
14389                                           !BCC_EOS
14390                                           ! 2385   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14391                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14392 40EB           8D9E       F7F2            lea	bx,-$80E[bp]
14393 40EF           53                         push	bx
14394                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14395 40F0           E8         C55A            call	_get_SS
14396                                           ! Debug: list unsigned short = ax+0 (used reg = )
14397 40F3           50                         push	ax
14398                                           ! Debug: list int = const 1 (used reg = )
14399 40F4           B8                   0001  mov	ax,*1
14400 40F7           50                         push	ax
14401                                           ! Debug: list long = const $800 (used reg = )
14402 40F8           B8                   0800  mov	ax,#$800
14403 40FB           31DB                       xor	bx,bx
14404 40FD           53                         push	bx
14405 40FE           50                         push	ax
14406                                           ! Debug: list int = const 0 (used reg = )
14407 40FF           31C0                       xor	ax,ax
14408 4101           50                         push	ax
14409                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14410 4102           8D5E         F2            lea	bx,-$E[bp]
14411 4105           53                         push	bx
14412                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14413 4106           E8         C544            call	_get_SS
14414                                           ! Debug: list unsigned short = ax+0 (used reg = )
14415 4109           50                         push	ax
14416                                           ! Debug: list int = const $C (used reg = )
14417 410A           B8                   000C  mov	ax,*$C
14418 410D           50                         push	ax
14419                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14420 410E           8A86       F7E5            mov	al,-$81B[bp]
14421 4112           30E4                       xor	ah,ah
14422 4114           50                         push	ax
14423                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14424 4115           E8         F5C1            call	_ata_cmd_packet
14425 4118           83C4                   14  add	sp,*$14
14426                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14427 411B           8986       F7E6            mov	-$81A[bp],ax
14428                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14429 411F           85C0                       test	ax,ax
14430 4121           74           07            je  	.30B
14431                       00004123            .30C:
14432                                           ! 2386     return 3;
14433 4123           B8                   0003  mov	ax,*3
14434 4126           89EC                       mov	sp,bp
14435 4128           5D                         pop	bp
14436 4129           C3                         ret
14437                                           !BCC_EOS
14438                                           ! 2387   if(buffer[0]!=0)return 4;
14439                       0000412A            .30B:
14440                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
14441 412A           8A86       F7F2            mov	al,-$80E[bp]
14442 412E           84C0                       test	al,al
14443 4130           74           07            je  	.30D
14444                       00004132            .30E:
14445 4132           B8                   0004  mov	ax,*4
14446 4135           89EC                       mov	sp,bp
14447 4137           5D                         pop	bp
14448 4138           C3                         ret
14449                                           !BCC_EOS
14450                                           ! 2388   for(i=0;i<5;i++){
14451                       00004139            .30D:
14452                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14453 4139           31C0                       xor	ax,ax
14454 413B           8986       F7E8            mov	-$818[bp],ax
14455                                           !BCC_EOS
14456                                           !BCC_EOS
14457 413F           EB           48            jmp .311
14458                       00004141            .312:
14459                                           ! 2389     if(read_byte(get_SS(),&buffer[1+i])!=read_byte(0xf000,&isotag[i]))return 5;
14460                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
14461 4141           8B9E       F7E8            mov	bx,-$818[bp]
14462                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
14463                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
14464 4145           81C3                 400F  add	bx,#_isotag
14465 4149           53                         push	bx
14466                                           ! Debug: list unsigned int = const $F000 (used reg = )
14467 414A           B8                   F000  mov	ax,#$F000
14468 414D           50                         push	ax
14469                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14470 414E           E8         C4A3            call	_read_byte
14471 4151           83C4                   04  add	sp,*4
14472 4154           50                         push	ax
14473                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
14474                                           ! Debug: expression subtree swapping
14475 4155           8B86       F7E8            mov	ax,-$818[bp]
14476                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14477 4159           40                         inc	ax
14478 415A           89EB                       mov	bx,bp
14479 415C           01C3                       add	bx,ax
14480                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14481                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14482 415E           81C3                 F7F2  add	bx,#-$80E
14483 4162           53                         push	bx
14484                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14485 4163           E8         C4E7            call	_get_SS
14486                                           ! Debug: list unsigned short = ax+0 (used reg = )
14487 4166           50                         push	ax
14488                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14489 4167           E8         C48A            call	_read_byte
14490 416A           83C4                   04  add	sp,*4
14491                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14492 416D           3A86       F7E2            cmp	al,-$81E[bp]
14493 4171           8DA6       F7E4            lea	sp,-$81C[bp]
14494 4175         0F84         0007            beq 	.313
14495                       00004179            .314:
14496 4179           B8                   0005  mov	ax,*5
14497 417C           89EC                       mov	sp,bp
14498 417E           5D                         pop	bp
14499 417F           C3                         ret
14500                                           !BCC_EOS
14501                                           ! 2390    }
14502                       00004180            .313:
14503                                           ! 2391   for(i=0;i<23;i++)
14504                       00004180            .310:
14505                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14506 4180           8B86       F7E8            mov	ax,-$818[bp]
14507 4184           40                         inc	ax
14508 4185           8986       F7E8            mov	-$818[bp],ax
14509                       00004189            .311:
14510                                           ! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
14511 4189           8B86       F7E8            mov	ax,-$818[bp]
14512 418D           3D                   0005  cmp	ax,*5
14513 4190           72           AF            jb 	.312
14514                       00004192            .315:
14515                       00004192            .30F:
14516                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14517 4192           31C0                       xor	ax,ax
14518 4194           8986       F7E8            mov	-$818[bp],ax
14519                                           !BCC_EOS
14520                                           !BCC_EOS
14521                                           ! 2392     if(read_byte(get_SS(),&buffer[7+i])!=read_byte(0xf000,&eltorito[i]))return 6;
14522 4198           EB           48            jmp .318
14523                       0000419A            .319:
14524                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
14525 419A           8B9E       F7E8            mov	bx,-$818[bp]
14526                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
14527                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
14528 419E           81C3                 4015  add	bx,#_eltorito
14529 41A2           53                         push	bx
14530                                           ! Debug: list unsigned int = const $F000 (used reg = )
14531 41A3           B8                   F000  mov	ax,#$F000
14532 41A6           50                         push	ax
14533                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14534 41A7           E8         C44A            call	_read_byte
14535 41AA           83C4                   04  add	sp,*4
14536 41AD           50                         push	ax
14537                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
14538                                           ! Debug: expression subtree swapping
14539 41AE           8B86       F7E8            mov	ax,-$818[bp]
14540                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14541 41B2           05                   0007  add	ax,*7
14542 41B5           89EB                       mov	bx,bp
14543 41B7           01C3                       add	bx,ax
14544                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14545                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14546 41B9           81C3                 F7F2  add	bx,#-$80E
14547 41BD           53                         push	bx
14548                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14549 41BE           E8         C48C            call	_get_SS
14550                                           ! Debug: list unsigned short = ax+0 (used reg = )
14551 41C1           50                         push	ax
14552                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14553 41C2           E8         C42F            call	_read_byte
14554 41C5           83C4                   04  add	sp,*4
14555                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14556 41C8           3A86       F7E2            cmp	al,-$81E[bp]
14557 41CC           8DA6       F7E4            lea	sp,-$81C[bp]
14558 41D0           74           07            je  	.31A
14559                       000041D2            .31B:
14560 41D2           B8                   0006  mov	ax,*6
14561 41D5           89EC                       mov	sp,bp
14562 41D7           5D                         pop	bp
14563 41D8           C3                         ret
14564                                           !BCC_EOS
14565                                           ! 2393   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
14566                       000041D9            .31A:
14567                       000041D9            .317:
14568                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14569 41D9           8B86       F7E8            mov	ax,-$818[bp]
14570 41DD           40                         inc	ax
14571 41DE           8986       F7E8            mov	-$818[bp],ax
14572                       000041E2            .318:
14573                                           ! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
14574 41E2           8B86       F7E8            mov	ax,-$818[bp]
14575 41E6           3D                   0017  cmp	ax,*$17
14576 41E9           72           AF            jb 	.319
14577                       000041EB            .31C:
14578                       000041EB            .316:
14579                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
14580 41EB           8A86       F839            mov	al,-$7C7[bp]
14581 41EF           30E4                       xor	ah,ah
14582 41F1           31DB                       xor	bx,bx
14583 41F3           53                         push	bx
14584 41F4           50                         push	ax
14585                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
14586 41F5           8A86       F83A            mov	al,-$7C6[bp]
14587 41F9           30E4                       xor	ah,ah
14588 41FB           B9                   0100  mov	cx,#$100
14589 41FE           F7E9                       imul	cx
14590                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14591 4200           31DB                       xor	bx,bx
14592 4202           53                         push	bx
14593 4203           50                         push	ax
14594                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
14595 4204           8A86       F83B            mov	al,-$7C5[bp]
14596 4208           30E4                       xor	ah,ah
14597 420A           31DB                       xor	bx,bx
14598                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14599 420C           53                         push	bx
14600 420D           50                         push	ax
14601 420E           31C0                       xor	ax,ax
14602 4210           BB                   0001  mov	bx,*1
14603 4213           53                         push	bx
14604 4214           50                         push	ax
14605 4215           8B86       F7D8            mov	ax,-$828[bp]
14606 4219           8B9E       F7DA            mov	bx,-$826[bp]
14607 421D           8DBE       F7D4            lea	di,-$82C[bp]
14608 4221           E8         BEC5            call	lmulul
14609 4224           83C4                   08  add	sp,*8
14610 4227           53                         push	bx
14611 4228           50                         push	ax
14612                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
14613 4229           8A86       F83C            mov	al,-$7C4[bp]
14614 422D           30E4                       xor	ah,ah
14615 422F           31DB                       xor	bx,bx
14616                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14617 4231           53                         push	bx
14618 4232           50                         push	ax
14619 4233           31C0                       xor	ax,ax
14620 4235           BB                   0100  mov	bx,#$100
14621 4238           53                         push	bx
14622 4239           50                         push	ax
14623 423A           8B86       F7D4            mov	ax,-$82C[bp]
14624 423E           8B9E       F7D6            mov	bx,-$82A[bp]
14625 4242           8DBE       F7D0            lea	di,-$830[bp]
14626 4246           E8         BEA0            call	lmulul
14627 4249           83C4                   08  add	sp,*8
14628                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14629 424C           8DBE       F7D8            lea	di,-$828[bp]
14630 4250           E8         BE70            call	laddul
14631 4253           83C4                   04  add	sp,*4
14632                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14633 4256           8DBE       F7DC            lea	di,-$824[bp]
14634 425A           E8         BE66            call	laddul
14635 425D           83C4                   04  add	sp,*4
14636                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14637 4260           8DBE       F7E0            lea	di,-$820[bp]
14638 4264           E8         BE5C            call	laddul
14639 4267           83C4                   04  add	sp,*4
14640                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14641 426A           8986       F7EE            mov	-$812[bp],ax
14642 426E           899E       F7F0            mov	-$810[bp],bx
14643                                           !BCC_EOS
14644                                           ! 2394   memsetb(get_SS(),atacmd,0,12);
14645                                           ! Debug: list int = const $C (used reg = )
14646 4272           B8                   000C  mov	ax,*$C
14647 4275           50                         push	ax
14648                                           ! Debug: list int = const 0 (used reg = )
14649 4276           31C0                       xor	ax,ax
14650 4278           50                         push	ax
14651                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14652 4279           8D5E         F2            lea	bx,-$E[bp]
14653 427C           53                         push	bx
14654                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14655 427D           E8         C3CD            call	_get_SS
14656                                           ! Debug: list unsigned short = ax+0 (used reg = )
14657 4280           50                         push	ax
14658                                           ! Debug: func () void = memsetb+0 (used reg = )
14659 4281           E8         BD7C            call	_memsetb
14660 4284           83C4                   08  add	sp,*8
14661                                           !BCC_EOS
14662                                           ! 2395   atacmd[0]=0x28;
14663                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14664 4287           B0                     28  mov	al,*$28
14665 4289           8846         F2            mov	-$E[bp],al
14666                                           !BCC_EOS
14667                                           ! 2396   atacmd[7]=(0x01 & 0xff00) >> 8;
14668                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14669 428C           30C0                       xor	al,al
14670 428E           8846         F9            mov	-7[bp],al
14671                                           !BCC_EOS
14672                                           ! 2397   atacmd[8]=(0x01 & 0x00ff);
14673                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14674 4291           B0                     01  mov	al,*1
14675 4293           8846         FA            mov	-6[bp],al
14676                                           !BCC_EOS
14677                                           ! 2398   atacmd[2]=(lba & 0xff000000) >> 24;
14678                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14679                                           ! Debug: expression subtree swapping
14680 4296           31C0                       xor	ax,ax
14681 4298           BB                   FF00  mov	bx,#$FF00
14682 429B           8DBE       F7EE            lea	di,-$812[bp]
14683 429F           E8         BE19            call	landul
14684                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14685 42A2           93                         xchg	bx,ax
14686 42A3           88E0                       mov	al,ah
14687 42A5           30E4                       xor	ah,ah
14688 42A7           31DB                       xor	bx,bx
14689                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14690 42A9           8846         F4            mov	-$C[bp],al
14691                                           !BCC_EOS
14692                                           ! 2399   atacmd[3]=(lba & 0x00ff0000) >> 16;
14693                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14694                                           ! Debug: expression subtree swapping
14695 42AC           31C0                       xor	ax,ax
14696 42AE           BB                   00FF  mov	bx,#$FF
14697 42B1           8DBE       F7EE            lea	di,-$812[bp]
14698 42B5           E8         BE03            call	landul
14699                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14700 42B8           93                         xchg	bx,ax
14701 42B9           31DB                       xor	bx,bx
14702                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14703 42BB           8846         F5            mov	-$B[bp],al
14704                                           !BCC_EOS
14705                                           ! 2400   atacmd[4]=(lba & 0x0000ff00) >> 8;
14706                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14707                                           ! Debug: expression subtree swapping
14708 42BE           B8                   FF00  mov	ax,#$FF00
14709 42C1           31DB                       xor	bx,bx
14710 42C3           8DBE       F7EE            lea	di,-$812[bp]
14711 42C7           E8         BDF1            call	landul
14712                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14713 42CA           88E0                       mov	al,ah
14714 42CC           88DC                       mov	ah,bl
14715 42CE           88FB                       mov	bl,bh
14716 42D0           28FF                       sub	bh,bh
14717                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14718 42D2           8846         F6            mov	-$A[bp],al
14719                                           !BCC_EOS
14720                                           ! 2401   atacmd[5]=(lba & 0x000000ff);
14721                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14722                                           ! Debug: expression subtree swapping
14723 42D5           B8                   00FF  mov	ax,#$FF
14724 42D8           31DB                       xor	bx,bx
14725 42DA           8DBE       F7EE            lea	di,-$812[bp]
14726 42DE           E8         BDDA            call	landul
14727                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14728 42E1           8846         F7            mov	-9[bp],al
14729                                           !BCC_EOS
14730                                           ! 2402   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14731                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14732 42E4           8D9E       F7F2            lea	bx,-$80E[bp]
14733 42E8           53                         push	bx
14734                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14735 42E9           E8         C361            call	_get_SS
14736                                           ! Debug: list unsigned short = ax+0 (used reg = )
14737 42EC           50                         push	ax
14738                                           ! Debug: list int = const 1 (used reg = )
14739 42ED           B8                   0001  mov	ax,*1
14740 42F0           50                         push	ax
14741                                           ! Debug: list long = const $800 (used reg = )
14742 42F1           B8                   0800  mov	ax,#$800
14743 42F4           31DB                       xor	bx,bx
14744 42F6           53                         push	bx
14745 42F7           50                         push	ax
14746                                           ! Debug: list int = const 0 (used reg = )
14747 42F8           31C0                       xor	ax,ax
14748 42FA           50                         push	ax
14749                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14750 42FB           8D5E         F2            lea	bx,-$E[bp]
14751 42FE           53                         push	bx
14752                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14753 42FF           E8         C34B            call	_get_SS
14754                                           ! Debug: list unsigned short = ax+0 (used reg = )
14755 4302           50                         push	ax
14756                                           ! Debug: list int = const $C (used reg = )
14757 4303           B8                   000C  mov	ax,*$C
14758 4306           50                         push	ax
14759                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14760 4307           8A86       F7E5            mov	al,-$81B[bp]
14761 430B           30E4                       xor	ah,ah
14762 430D           50                         push	ax
14763                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14764 430E           E8         F3C8            call	_ata_cmd_packet
14765 4311           83C4                   14  add	sp,*$14
14766                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14767 4314           8986       F7E6            mov	-$81A[bp],ax
14768                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14769 4318           85C0                       test	ax,ax
14770 431A           74           07            je  	.31D
14771                       0000431C            .31E:
14772                                           ! 2403     return 7;
14773 431C           B8                   0007  mov	ax,*7
14774 431F           89EC                       mov	sp,bp
14775 4321           5D                         pop	bp
14776 4322           C3                         ret
14777                                           !BCC_EOS
14778                                           ! 2404   if(buffer[0x00]!=0x01)return 8;
14779                       00004323            .31D:
14780                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
14781 4323           8A86       F7F2            mov	al,-$80E[bp]
14782 4327           3C                     01  cmp	al,*1
14783 4329           74           07            je  	.31F
14784                       0000432B            .320:
14785 432B           B8                   0008  mov	ax,*8
14786 432E           89EC                       mov	sp,bp
14787 4330           5D                         pop	bp
14788 4331           C3                         ret
14789                                           !BCC_EOS
14790                                           ! 2405   if(buffer[0x01]!=0x00)return 9;
14791                       00004332            .31F:
14792                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
14793 4332           8A86       F7F3            mov	al,-$80D[bp]
14794 4336           84C0                       test	al,al
14795 4338           74           07            je  	.321
14796                       0000433A            .322:
14797 433A           B8                   0009  mov	ax,*9
14798 433D           89EC                       mov	sp,bp
14799 433F           5D                         pop	bp
14800 4340           C3                         ret
14801                                           !BCC_EOS
14802                                           ! 2406   if(buffer[0x1E]!=0x55)return 10;
14803                       00004341            .321:
14804                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
14805 4341           8A86       F810            mov	al,-$7F0[bp]
14806 4345           3C                     55  cmp	al,*$55
14807 4347           74           07            je  	.323
14808                       00004349            .324:
14809 4349           B8                   000A  mov	ax,*$A
14810 434C           89EC                       mov	sp,bp
14811 434E           5D                         pop	bp
14812 434F           C3                         ret
14813                                           !BCC_EOS
14814                                           ! 2407   if(buffer[0x1F]!=0xAA)return 10;
14815                       00004350            .323:
14816                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
14817 4350           8A86       F811            mov	al,-$7EF[bp]
14818 4354           3C                     AA  cmp	al,#$AA
14819 4356           74           07            je  	.325
14820                       00004358            .326:
14821 4358           B8                   000A  mov	ax,*$A
14822 435B           89EC                       mov	sp,bp
14823 435D           5D                         pop	bp
14824 435E           C3                         ret
14825                                           !BCC_EOS
14826                                           ! 2408   if(buffer[0x20]!=0x88)return 11;
14827                       0000435F            .325:
14828                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
14829 435F           8A86       F812            mov	al,-$7EE[bp]
14830 4363           3C                     88  cmp	al,#$88
14831 4365           74           07            je  	.327
14832                       00004367            .328:
14833 4367           B8                   000B  mov	ax,*$B
14834 436A           89EC                       mov	sp,bp
14835 436C           5D                         pop	bp
14836 436D           C3                         ret
14837                                           !BCC_EOS
14838                                           ! 2409   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
14839                       0000436E            .327:
14840                                           ! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
14841 436E           8A86       F813            mov	al,-$7ED[bp]
14842 4372           30E4                       xor	ah,ah
14843 4374           50                         push	ax
14844                                           ! Debug: list * unsigned char = const $25B (used reg = )
14845 4375           B8                   025B  mov	ax,#$25B
14846 4378           50                         push	ax
14847                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14848 4379           FF76         FE            push	-2[bp]
14849                                           ! Debug: func () void = write_byte+0 (used reg = )
14850 437C           E8         C29B            call	_write_byte
14851 437F           83C4                   06  add	sp,*6
14852                                           !BCC_EOS
14853                                           ! 2410   if(buffer[0x21]==0){
14854                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14855 4382           8A86       F813            mov	al,-$7ED[bp]
14856 4386           84C0                       test	al,al
14857 4388           75           13            jne 	.329
14858                       0000438A            .32A:
14859                                           ! 2411     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
14860                                           ! Debug: list int = const $E0 (used reg = )
14861 438A           B8                   00E0  mov	ax,#$E0
14862 438D           50                         push	ax
14863                                           ! Debug: list * unsigned char = const $25C (used reg = )
14864 438E           B8                   025C  mov	ax,#$25C
14865 4391           50                         push	ax
14866                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14867 4392           FF76         FE            push	-2[bp]
14868                                           ! Debug: func () void = write_byte+0 (used reg = )
14869 4395           E8         C282            call	_write_byte
14870 4398           83C4                   06  add	sp,*6
14871                                           !BCC_EOS
14872                                           ! 2412     }
14873                                           ! 2413   else if(buffer[0x21]<4)
14874 439B           EB           2B            jmp .32B
14875                       0000439D            .329:
14876                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14877 439D           8A86       F813            mov	al,-$7ED[bp]
14878 43A1           3C                     04  cmp	al,*4
14879 43A3           73           12            jae 	.32C
14880                       000043A5            .32D:
14881                                           ! 2414     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
14882                                           ! Debug: list int = const 0 (used reg = )
14883 43A5           31C0                       xor	ax,ax
14884 43A7           50                         push	ax
14885                                           ! Debug: list * unsigned char = const $25C (used reg = )
14886 43A8           B8                   025C  mov	ax,#$25C
14887 43AB           50                         push	ax
14888                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14889 43AC           FF76         FE            push	-2[bp]
14890                                           ! Debug: func () void = write_byte+0 (used reg = )
14891 43AF           E8         C268            call	_write_byte
14892 43B2           83C4                   06  add	sp,*6
14893                                           !BCC_EOS
14894                                           ! 2415   else
14895                                           ! 2416     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
14896 43B5           EB           11            jmp .32E
14897                       000043B7            .32C:
14898                                           ! Debug: list int = const $80 (used reg = )
14899 43B7           B8                   0080  mov	ax,#$80
14900 43BA           50                         push	ax
14901                                           ! Debug: list * unsigned char = const $25C (used reg = )
14902 43BB           B8                   025C  mov	ax,#$25C
14903 43BE           50                         push	ax
14904                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14905 43BF           FF76         FE            push	-2[bp]
14906                                           ! Debug: func () void = write_byte+0 (used reg = )
14907 43C2           E8         C255            call	_write_byte
14908 43C5           83C4                   06  add	sp,*6
14909                                           !BCC_EOS
14910                                           ! 2417   write_byte(ebda_seg,&((ebda_data_t 
14911                       000043C8            .32E:
14912                       000043C8            .32B:
14913                                           ! 2417 *) 0)->cdemu.controller_index,device/2);
14914                                           ! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14915 43C8           8A86       F7E5            mov	al,-$81B[bp]
14916 43CC           30E4                       xor	ah,ah
14917 43CE           D1E8                       shr	ax,*1
14918                                           ! Debug: list unsigned int = ax+0 (used reg = )
14919 43D0           50                         push	ax
14920                                           ! Debug: list * unsigned char = const $25D (used reg = )
14921 43D1           B8                   025D  mov	ax,#$25D
14922 43D4           50                         push	ax
14923                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14924 43D5           FF76         FE            push	-2[bp]
14925                                           ! Debug: func () void = write_byte+0 (used reg = )
14926 43D8           E8         C23F            call	_write_byte
14927 43DB           83C4                   06  add	sp,*6
14928                                           !BCC_EOS
14929                                           ! 2418   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
14930                                           ! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14931 43DE           8A86       F7E5            mov	al,-$81B[bp]
14932 43E2           30E4                       xor	ah,ah
14933 43E4           24                     01  and	al,*1
14934                                           ! Debug: list unsigned char = al+0 (used reg = )
14935 43E6           30E4                       xor	ah,ah
14936 43E8           50                         push	ax
14937                                           ! Debug: list * unsigned short = const $25E (used reg = )
14938 43E9           B8                   025E  mov	ax,#$25E
14939 43EC           50                         push	ax
14940                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14941 43ED           FF76         FE            push	-2[bp]
14942                                           ! Debug: func () void = write_byte+0 (used reg = )
14943 43F0           E8         C227            call	_write_byte
14944 43F3           83C4                   06  add	sp,*6
14945                                           !BCC_EOS
14946                                           ! 2419   boot_segment=buffer[0x23]*0x100+buffer[0x22];
14947                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
14948 43F6           8A86       F815            mov	al,-$7EB[bp]
14949 43FA           30E4                       xor	ah,ah
14950 43FC           B9                   0100  mov	cx,#$100
14951 43FF           F7E9                       imul	cx
14952                                           ! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
14953 4401           0286       F814            add	al,-$7EC[bp]
14954 4405           80D4                   00  adc	ah,*0
14955                                           ! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14956 4408           8986       F7EC            mov	-$814[bp],ax
14957                                           !BCC_EOS
14958                                           ! 2420   if(boot_segment==0x0000)boot_segment=0x07C0;
14959                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14960 440C           8B86       F7EC            mov	ax,-$814[bp]
14961 4410           85C0                       test	ax,ax
14962 4412           75           07            jne 	.32F
14963                       00004414            .330:
14964                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14965 4414           B8                   07C0  mov	ax,#$7C0
14966 4417           8986       F7EC            mov	-$814[bp],ax
14967                                           !BCC_EOS
14968                                           ! 2421   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
14969                       0000441B            .32F:
14970                                           ! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
14971 441B           FFB6       F7EC            push	-$814[bp]
14972                                           ! Debug: list * unsigned short = const $266 (used reg = )
14973 441F           B8                   0266  mov	ax,#$266
14974 4422           50                         push	ax
14975                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14976 4423           FF76         FE            push	-2[bp]
14977                                           ! Debug: func () void = write_word+0 (used reg = )
14978 4426           E8         C209            call	_write_word
14979 4429           83C4                   06  add	sp,*6
14980                                           !BCC_EOS
14981                                           ! 2422   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
14982                                           ! Debug: list int = const 0 (used reg = )
14983 442C           31C0                       xor	ax,ax
14984 442E           50                         push	ax
14985                                           ! Debug: list * unsigned short = const $264 (used reg = )
14986 442F           B8                   0264  mov	ax,#$264
14987 4432           50                         push	ax
14988                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14989 4433           FF76         FE            push	-2[bp]
14990                                           ! Debug: func () void = write_word+0 (used reg = )
14991 4436           E8         C1F9            call	_write_word
14992 4439           83C4                   06  add	sp,*6
14993                                           !BCC_EOS
14994                                           ! 2423   nbsectors=buffer[0x27]*0x100+buffer[0x26];
14995                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
14996 443C           8A86       F819            mov	al,-$7E7[bp]
14997 4440           30E4                       xor	ah,ah
14998 4442           B9                   0100  mov	cx,#$100
14999 4445           F7E9                       imul	cx
15000                                           ! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
15001 4447           0286       F818            add	al,-$7E8[bp]
15002 444B           80D4                   00  adc	ah,*0
15003                                           ! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
15004 444E           8986       F7EA            mov	-$816[bp],ax
15005                                           !BCC_EOS
15006                                           ! 2424   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
15007                                           ! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
15008 4452           FFB6       F7EA            push	-$816[bp]
15009                                           ! Debug: list * unsigned short = const $268 (used reg = )
15010 4456           B8                   0268  mov	ax,#$268
15011 4459           50                         push	ax
15012                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15013 445A           FF76         FE            push	-2[bp]
15014                                           ! Debug: func () void = write_word+0 (used reg = )
15015 445D           E8         C1D2            call	_write_word
15016 4460           83C4                   06  add	sp,*6
15017                                           !BCC_EOS
15018                                           ! 2425   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
15019                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
15020 4463           8A86       F81A            mov	al,-$7E6[bp]
15021 4467           30E4                       xor	ah,ah
15022 4469           31DB                       xor	bx,bx
15023 446B           53                         push	bx
15024 446C           50                         push	ax
15025                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
15026 446D           8A86       F81B            mov	al,-$7E5[bp]
15027 4471           30E4                       xor	ah,ah
15028 4473           B9                   0100  mov	cx,#$100
15029 4476           F7E9                       imul	cx
15030                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
15031 4478           31DB                       xor	bx,bx
15032 447A           53                         push	bx
15033 447B           50                         push	ax
15034                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
15035 447C           8A86       F81C            mov	al,-$7E4[bp]
15036 4480           30E4                       xor	ah,ah
15037 4482           31DB                       xor	bx,bx
15038                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
15039 4484           53                         push	bx
15040 4485           50                         push	ax
15041 4486           31C0                       xor	ax,ax
15042 4488           BB                   0001  mov	bx,*1
15043 448B           53                         push	bx
15044 448C           50                         push	ax
15045 448D           8B86       F7D8            mov	ax,-$828[bp]
15046 4491           8B9E       F7DA            mov	bx,-$826[bp]
15047 4495           8DBE       F7D4            lea	di,-$82C[bp]
15048 4499           E8         BC4D            call	lmulul
15049 449C           83C4                   08  add	sp,*8
15050 449F           53                         push	bx
15051 44A0           50                         push	ax
15052                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
15053 44A1           8A86       F81D            mov	al,-$7E3[bp]
15054 44A5           30E4                       xor	ah,ah
15055 44A7           31DB                       xor	bx,bx
15056                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
15057 44A9           53                         push	bx
15058 44AA           50                         push	ax
15059 44AB           31C0                       xor	ax,ax
15060 44AD           BB                   0100  mov	bx,#$100
15061 44B0           53                         push	bx
15062 44B1           50                         push	ax
15063 44B2           8B86       F7D4            mov	ax,-$82C[bp]
15064 44B6           8B9E       F7D6            mov	bx,-$82A[bp]
15065 44BA           8DBE       F7D0            lea	di,-$830[bp]
15066 44BE           E8         BC28            call	lmulul
15067 44C1           83C4                   08  add	sp,*8
15068                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
15069 44C4           8DBE       F7D8            lea	di,-$828[bp]
15070 44C8           E8         BBF8            call	laddul
15071 44CB           83C4                   04  add	sp,*4
15072                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
15073 44CE           8DBE       F7DC            lea	di,-$824[bp]
15074 44D2           E8         BBEE            call	laddul
15075 44D5           83C4                   04  add	sp,*4
15076                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
15077 44D8           8DBE       F7E0            lea	di,-$820[bp]
15078 44DC           E8         BBE4            call	laddul
15079 44DF           83C4                   04  add	sp,*4
15080                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
15081 44E2           8986       F7EE            mov	-$812[bp],ax
15082 44E6           899E       F7F0            mov	-$810[bp],bx
15083                                           !BCC_EOS
15084                                           ! 2426   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
15085                                           ! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
15086 44EA           FFB6       F7F0            push	-$810[bp]
15087 44EE           FFB6       F7EE            push	-$812[bp]
15088                                           ! Debug: list * unsigned long = const $260 (used reg = )
15089 44F2           B8                   0260  mov	ax,#$260
15090 44F5           50                         push	ax
15091                                           ! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
15092 44F6           FF76         FE            push	-2[bp]
15093                                           ! Debug: func () void = write_dword+0 (used reg = )
15094 44F9           E8         BB9F            call	_write_dword
15095 44FC           83C4                   08  add	sp,*8
15096                                           !BCC_EOS
15097                                           ! 2427   memsetb(get_SS(),atacmd,0,12);
15098                                           ! Debug: list int = const $C (used reg = )
15099 44FF           B8                   000C  mov	ax,*$C
15100 4502           50                         push	ax
15101                                           ! Debug: list int = const 0 (used reg = )
15102 4503           31C0                       xor	ax,ax
15103 4505           50                         push	ax
15104                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
15105 4506           8D5E         F2            lea	bx,-$E[bp]
15106 4509           53                         push	bx
15107                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
15108 450A           E8         C140            call	_get_SS
15109                                           ! Debug: list unsigned short = ax+0 (used reg = )
15110 450D           50                         push	ax
15111                                           ! Debug: func () void = memsetb+0 (used reg = )
15112 450E           E8         BAEF            call	_memsetb
15113 4511           83C4                   08  add	sp,*8
15114                                           !BCC_EOS
15115                                           ! 2428   atacmd[0]=0x28;
15116                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
15117 4514           B0                     28  mov	al,*$28
15118 4516           8846         F2            mov	-$E[bp],al
15119                                           !BCC_EOS
15120                                           ! 2429   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
15121                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
15122 4519           8B86       F7EA            mov	ax,-$816[bp]
15123                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
15124 451D           48                         dec	ax
15125 451E           D1E8                       shr	ax,*1
15126 4520           D1E8                       shr	ax,*1
15127                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
15128                                           ! Debug: expression subtree swapping
15129                                           ! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
15130 4522           40                         inc	ax
15131 4523           30C0                       xor	al,al
15132                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
15133 4525           88E0                       mov	al,ah
15134 4527           30E4                       xor	ah,ah
15135                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
15136 4529           8846         F9            mov	-7[bp],al
15137                                           !BCC_EOS
15138                                           ! 2430   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
15139                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
15140 452C           8B86       F7EA            mov	ax,-$816[bp]
15141                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
15142 4530           48                         dec	ax
15143 4531           D1E8                       shr	ax,*1
15144 4533           D1E8                       shr	ax,*1
15145                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
15146                                           ! Debug: expression subtree swapping
15147                                           ! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
15148 4535           40                         inc	ax
15149                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
15150 4536           8846         FA            mov	-6[bp],al
15151                                           !BCC_EOS
15152                                           ! 2431   atacmd[2]=(lba & 0xff000000) >> 24;
15153                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
15154                                           ! Debug: expression subtree swapping
15155 4539           31C0                       xor	ax,ax
15156 453B           BB                   FF00  mov	bx,#$FF00
15157 453E           8DBE       F7EE            lea	di,-$812[bp]
15158 4542           E8         BB76            call	landul
15159                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
15160 4545           93                         xchg	bx,ax
15161 4546           88E0                       mov	al,ah
15162 4548           30E4                       xor	ah,ah
15163 454A           31DB                       xor	bx,bx
15164                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
15165 454C           8846         F4            mov	-$C[bp],al
15166                                           !BCC_EOS
15167                                           ! 2432   atacmd[3]=(lba & 0x00ff0000) >> 16;
15168                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
15169                                           ! Debug: expression subtree swapping
15170 454F           31C0                       xor	ax,ax
15171 4551           BB                   00FF  mov	bx,#$FF
15172 4554           8DBE       F7EE            lea	di,-$812[bp]
15173 4558           E8         BB60            call	landul
15174                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
15175 455B           93                         xchg	bx,ax
15176 455C           31DB                       xor	bx,bx
15177                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
15178 455E           8846         F5            mov	-$B[bp],al
15179                                           !BCC_EOS
15180                                           ! 2433   atacmd[4]=(lba & 0x0000ff00) >> 8;
15181                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
15182                                           ! Debug: expression subtree swapping
15183 4561           B8                   FF00  mov	ax,#$FF00
15184 4564           31DB                       xor	bx,bx
15185 4566           8DBE       F7EE            lea	di,-$812[bp]
15186 456A           E8         BB4E            call	landul
15187                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
15188 456D           88E0                       mov	al,ah
15189 456F           88DC                       mov	ah,bl
15190 4571           88FB                       mov	bl,bh
15191 4573           28FF                       sub	bh,bh
15192                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
15193 4575           8846         F6            mov	-$A[bp],al
15194                                           !BCC_EOS
15195                                           ! 2434   atacmd[5]=(lba & 0x000000ff);
15196                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
15197                                           ! Debug: expression subtree swapping
15198 4578           B8                   00FF  mov	ax,#$FF
15199 457B           31DB                       xor	bx,bx
15200 457D           8DBE       F7EE            lea	di,-$812[bp]
15201 4581           E8         BB37            call	landul
15202                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
15203 4584           8846         F7            mov	-9[bp],al
15204                                           !BCC_EOS
15205                                           ! 2435   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
15206                                           ! Debug: list int = const 0 (used reg = )
15207 4587           31C0                       xor	ax,ax
15208 4589           50                         push	ax
15209                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15210 458A           FFB6       F7EC            push	-$814[bp]
15211                                           ! Debug: list int = const 1 (used reg = )
15212 458E           B8                   0001  mov	ax,*1
15213 4591           50                         push	ax
15214                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
15215 4592           8B86       F7EA            mov	ax,-$816[bp]
15216 4596           31DB                       xor	bx,bx
15217                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
15218 4598           53                         push	bx
15219 4599           50                         push	ax
15220 459A           B8                   0200  mov	ax,#$200
15221 459D           31DB                       xor	bx,bx
15222 459F           53                         push	bx
15223 45A0           50                         push	ax
15224 45A1           8B86       F7DA            mov	ax,-$826[bp]
15225 45A5           8B9E       F7DC            mov	bx,-$824[bp]
15226 45A9           8DBE       F7D6            lea	di,-$82A[bp]
15227 45AD           E8         BB39            call	lmulul
15228 45B0           83C4                   08  add	sp,*8
15229                                           ! Debug: list unsigned long = bx+0 (used reg = )
15230 45B3           53                         push	bx
15231 45B4           50                         push	ax
15232                                           ! Debug: list int = const 0 (used reg = )
15233 45B5           31C0                       xor	ax,ax
15234 45B7           50                         push	ax
15235                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
15236 45B8           8D5E         F2            lea	bx,-$E[bp]
15237 45BB           53                         push	bx
15238                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
15239 45BC           E8         C08E            call	_get_SS
15240                                           ! Debug: list unsigned short = ax+0 (used reg = )
15241 45BF           50                         push	ax
15242                                           ! Debug: list int = const $C (used reg = )
15243 45C0           B8                   000C  mov	ax,*$C
15244 45C3           50                         push	ax
15245                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
15246 45C4           8A86       F7E5            mov	al,-$81B[bp]
15247 45C8           30E4                       xor	ah,ah
15248 45CA           50                         push	ax
15249                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
15250 45CB           E8         F10B            call	_ata_cmd_packet
15251 45CE           83C4                   14  add	sp,*$14
15252                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
15253 45D1           8986       F7E6            mov	-$81A[bp],ax
15254                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
15255 45D5           85C0                       test	ax,ax
15256 45D7           74           07            je  	.331
15257                       000045D9            .332:
15258                                           ! 2436     return 12;
15259 45D9           B8                   000C  mov	ax,*$C
15260 45DC           89EC                       mov	sp,bp
15261 45DE           5D                         pop	bp
15262 45DF           C3                         ret
15263                                           !BCC_EOS
15264                                           ! 2437   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
15265                       000045E0            .331:
15266                                           ! Debug: list * unsigned char = const $25B (used reg = )
15267 45E0           B8                   025B  mov	ax,#$25B
15268 45E3           50                         push	ax
15269                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15270 45E4           FF76         FE            push	-2[bp]
15271                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15272 45E7           E8         C00A            call	_read_byte
15273 45EA           83C4                   04  add	sp,*4
15274 45ED           E9         0120            br 	.335
15275                                           ! 2438     case 0x01:
15276                                           ! 2439       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
15277                       000045F0            .336:
15278                                           ! Debug: list int = const $F (used reg = )
15279 45F0           B8                   000F  mov	ax,*$F
15280 45F3           50                         push	ax
15281                                           ! Debug: list * unsigned short = const $26E (used reg = )
15282 45F4           B8                   026E  mov	ax,#$26E
15283 45F7           50                         push	ax
15284                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15285 45F8           FF76         FE            push	-2[bp]
15286                                           ! Debug: func () void = write_word+0 (used reg = )
15287 45FB           E8         C034            call	_write_word
15288 45FE           83C4                   06  add	sp,*6
15289                                           !BCC_EOS
15290                                           ! 2440       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15291                                           ! Debug: list int = const $50 (used reg = )
15292 4601           B8                   0050  mov	ax,*$50
15293 4604           50                         push	ax
15294                                           ! Debug: list * unsigned short = const $26C (used reg = )
15295 4605           B8                   026C  mov	ax,#$26C
15296 4608           50                         push	ax
15297                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15298 4609           FF76         FE            push	-2[bp]
15299                                           ! Debug: func () void = write_word+0 (used reg = )
15300 460C           E8         C023            call	_write_word
15301 460F           83C4                   06  add	sp,*6
15302                                           !BCC_EOS
15303                                           ! 2441       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15304                                           ! Debug: list int = const 2 (used reg = )
15305 4612           B8                   0002  mov	ax,*2
15306 4615           50                         push	ax
15307                                           ! Debug: list * unsigned short = const $26A (used reg = )
15308 4616           B8                   026A  mov	ax,#$26A
15309 4619           50                         push	ax
15310                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15311 461A           FF76         FE            push	-2[bp]
15312                                           ! Debug: func () void = write_word+0 (used reg = )
15313 461D           E8         C012            call	_write_word
15314 4620           83C4                   06  add	sp,*6
15315                                           !BCC_EOS
15316                                           ! 2442       break;
15317 4623           E9         0102            br 	.333
15318                                           !BCC_EOS
15319                                           ! 2443     case 0x02:
15320                                           ! 2444       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
15321                       00004626            .337:
15322                                           ! Debug: list int = const $12 (used reg = )
15323 4626           B8                   0012  mov	ax,*$12
15324 4629           50                         push	ax
15325                                           ! Debug: list * unsigned short = const $26E (used reg = )
15326 462A           B8                   026E  mov	ax,#$26E
15327 462D           50                         push	ax
15328                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15329 462E           FF76         FE            push	-2[bp]
15330                                           ! Debug: func () void = write_word+0 (used reg = )
15331 4631           E8         BFFE            call	_write_word
15332 4634           83C4                   06  add	sp,*6
15333                                           !BCC_EOS
15334                                           ! 2445       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15335                                           ! Debug: list int = const $50 (used reg = )
15336 4637           B8                   0050  mov	ax,*$50
15337 463A           50                         push	ax
15338                                           ! Debug: list * unsigned short = const $26C (used reg = )
15339 463B           B8                   026C  mov	ax,#$26C
15340 463E           50                         push	ax
15341                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15342 463F           FF76         FE            push	-2[bp]
15343                                           ! Debug: func () void = write_word+0 (used reg = )
15344 4642           E8         BFED            call	_write_word
15345 4645           83C4                   06  add	sp,*6
15346                                           !BCC_EOS
15347                                           ! 2446       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15348                                           ! Debug: list int = const 2 (used reg = )
15349 4648           B8                   0002  mov	ax,*2
15350 464B           50                         push	ax
15351                                           ! Debug: list * unsigned short = const $26A (used reg = )
15352 464C           B8                   026A  mov	ax,#$26A
15353 464F           50                         push	ax
15354                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15355 4650           FF76         FE            push	-2[bp]
15356                                           ! Debug: func () void = write_word+0 (used reg = )
15357 4653           E8         BFDC            call	_write_word
15358 4656           83C4                   06  add	sp,*6
15359                                           !BCC_EOS
15360                                           ! 2447       break;
15361 4659           E9         00CC            br 	.333
15362                                           !BCC_EOS
15363                                           ! 2448     case 0x03:
15364                                           ! 2449       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
15365                       0000465C            .338:
15366                                           ! Debug: list int = const $24 (used reg = )
15367 465C           B8                   0024  mov	ax,*$24
15368 465F           50                         push	ax
15369                                           ! Debug: list * unsigned short = const $26E (used reg = )
15370 4660           B8                   026E  mov	ax,#$26E
15371 4663           50                         push	ax
15372                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15373 4664           FF76         FE            push	-2[bp]
15374                                           ! Debug: func () void = write_word+0 (used reg = )
15375 4667           E8         BFC8            call	_write_word
15376 466A           83C4                   06  add	sp,*6
15377                                           !BCC_EOS
15378                                           ! 2450       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15379                                           ! Debug: list int = const $50 (used reg = )
15380 466D           B8                   0050  mov	ax,*$50
15381 4670           50                         push	ax
15382                                           ! Debug: list * unsigned short = const $26C (used reg = )
15383 4671           B8                   026C  mov	ax,#$26C
15384 4674           50                         push	ax
15385                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15386 4675           FF76         FE            push	-2[bp]
15387                                           ! Debug: func () void = write_word+0 (used reg = )
15388 4678           E8         BFB7            call	_write_word
15389 467B           83C4                   06  add	sp,*6
15390                                           !BCC_EOS
15391                                           ! 2451       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15392                                           ! Debug: list int = const 2 (used reg = )
15393 467E           B8                   0002  mov	ax,*2
15394 4681           50                         push	ax
15395                                           ! Debug: list * unsigned short = const $26A (used reg = )
15396 4682           B8                   026A  mov	ax,#$26A
15397 4685           50                         push	ax
15398                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15399 4686           FF76         FE            push	-2[bp]
15400                                           ! Debug: func () void = write_word+0 (used reg = )
15401 4689           E8         BFA6            call	_write_word
15402 468C           83C4                   06  add	sp,*6
15403                                           !BCC_EOS
15404                                           ! 2452       break;
15405 468F           E9         0096            br 	.333
15406                                           !BCC_EOS
15407                                           ! 2453     case 0x04:
15408                                           ! 2454       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
15409                       00004692            .339:
15410                                           ! Debug: list int = const $1C4 (used reg = )
15411 4692           B8                   01C4  mov	ax,#$1C4
15412 4695           50                         push	ax
15413                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15414 4696           FFB6       F7EC            push	-$814[bp]
15415                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15416 469A           E8         BF57            call	_read_byte
15417 469D           83C4                   04  add	sp,*4
15418                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
15419 46A0           24                     3F  and	al,*$3F
15420                                           ! Debug: list unsigned char = al+0 (used reg = )
15421 46A2           30E4                       xor	ah,ah
15422 46A4           50                         push	ax
15423                                           ! Debug: list * unsigned short = const $26E (used reg = )
15424 46A5           B8                   026E  mov	ax,#$26E
15425 46A8           50                         push	ax
15426                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15427 46A9           FF76         FE            push	-2[bp]
15428                                           ! Debug: func () void = write_word+0 (used reg = )
15429 46AC           E8         BF83            call	_write_word
15430 46AF           83C4                   06  add	sp,*6
15431                                           !BCC_EOS
15432                                           ! 2455       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
15433                                           ! 2456           
15434                                           ! 2456     (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
15435                                           ! Debug: list int = const $1C5 (used reg = )
15436 46B2           B8                   01C5  mov	ax,#$1C5
15437 46B5           50                         push	ax
15438                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15439 46B6           FFB6       F7EC            push	-$814[bp]
15440                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15441 46BA           E8         BF37            call	_read_byte
15442 46BD           83C4                   04  add	sp,*4
15443 46C0           50                         push	ax
15444                                           ! Debug: list int = const $1C4 (used reg = )
15445 46C1           B8                   01C4  mov	ax,#$1C4
15446 46C4           50                         push	ax
15447                                           ! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
15448 46C5           FFB6       F7EC            push	-$814[bp]
15449                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15450 46C9           E8         BF28            call	_read_byte
15451 46CC           83C4                   04  add	sp,*4
15452                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
15453 46CF           30E4                       xor	ah,ah
15454 46D1           D1E0                       shl	ax,*1
15455 46D3           D1E0                       shl	ax,*1
15456                                           ! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
15457 46D5           0286       F7E2            add	al,0+..FFF9[bp]
15458 46D9           80D4                   00  adc	ah,*0
15459 46DC           44                         inc	sp
15460 46DD           44                         inc	sp
15461                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
15462                                           ! Debug: list unsigned int = ax+1 (used reg = )
15463 46DE           40                         inc	ax
15464 46DF           50                         push	ax
15465                                           ! Debug: list * unsigned short = const $26C (used reg = )
15466 46E0           B8                   026C  mov	ax,#$26C
15467 46E3           50                         push	ax
15468                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15469 46E4           FF76         FE            push	-2[bp]
15470                                           ! Debug: func () void = write_word+0 (used reg = )
15471 46E7           E8         BF48            call	_write_word
15472 46EA           83C4                   06  add	sp,*6
15473                                           !BCC_EOS
15474                                           ! 2457       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
15475                                           ! Debug: list int = const $1C3 (used reg = )
15476 46ED           B8                   01C3  mov	ax,#$1C3
15477 46F0           50                         push	ax
15478                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15479 46F1           FFB6       F7EC            push	-$814[bp]
15480                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15481 46F5           E8         BEFC            call	_read_byte
15482 46F8           83C4                   04  add	sp,*4
15483                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15484 46FB           30E4                       xor	ah,ah
15485                                           ! Debug: list unsigned int = ax+1 (used reg = )
15486 46FD           40                         inc	ax
15487 46FE           50                         push	ax
15488                                           ! Debug: list * unsigned short = const $26A (used reg = )
15489 46FF           B8                   026A  mov	ax,#$26A
15490 4702           50                         push	ax
15491                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15492 4703           FF76         FE            push	-2[bp]
15493                                           ! Debug: func () void = write_word+0 (used reg = )
15494 4706           E8         BF29            call	_write_word
15495 4709           83C4                   06  add	sp,*6
15496                                           !BCC_EOS
15497                                           ! 2458       break;
15498 470C           EB           1A            jmp .333
15499                                           !BCC_EOS
15500                                           ! 2459    }
15501                                           ! 2460   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
15502 470E           EB           18            jmp .333
15503                       00004710            .335:
15504 4710           2C                     01  sub	al,*1
15505 4712         0F84         FEDA            beq 	.336
15506 4716           2C                     01  sub	al,*1
15507 4718         0F84         FF0A            beq 	.337
15508 471C           2C                     01  sub	al,*1
15509 471E         0F84         FF3A            beq 	.338
15510 4722           2C                     01  sub	al,*1
15511 4724         0F84         FF6A            beq 	.339
15512                       00004728            .333:
15513                       FFFFF7E2            ..FFF9	=	-$81E
15514                                           ! Debug: list * unsigned char = const $25B (used reg = )
15515 4728           B8                   025B  mov	ax,#$25B
15516 472B           50                         push	ax
15517                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15518 472C           FF76         FE            push	-2[bp]
15519                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15520 472F           E8         BEC2            call	_read_byte
15521 4732           83C4                   04  add	sp,*4
15522                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15523 4735           84C0                       test	al,al
15524 4737           74           52            je  	.33A
15525                       00004739            .33B:
15526                                           ! 2461     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
15527                                           ! Debug: list * unsigned char = const $25C (used reg = )
15528 4739           B8                   025C  mov	ax,#$25C
15529 473C           50                         push	ax
15530                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15531 473D           FF76         FE            push	-2[bp]
15532                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15533 4740           E8         BEB1            call	_read_byte
15534 4743           83C4                   04  add	sp,*4
15535                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15536 4746           84C0                       test	al,al
15537 4748           75           23            jne 	.33C
15538                       0000474A            .33D:
15539                                           ! 2462       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
15540                                           ! Debug: list int = const $10 (used reg = )
15541 474A           B8                   0010  mov	ax,*$10
15542 474D           50                         push	ax
15543                                           ! Debug: list int = const $40 (used reg = )
15544 474E           B8                   0040  mov	ax,*$40
15545 4751           50                         push	ax
15546                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15547 4752           E8         BE9F            call	_read_byte
15548 4755           83C4                   04  add	sp,*4
15549                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
15550 4758           0C                     41  or	al,*$41
15551                                           ! Debug: list unsigned char = al+0 (used reg = )
15552 475A           30E4                       xor	ah,ah
15553 475C           50                         push	ax
15554                                           ! Debug: list int = const $10 (used reg = )
15555 475D           B8                   0010  mov	ax,*$10
15556 4760           50                         push	ax
15557                                           ! Debug: list int = const $40 (used reg = )
15558 4761           B8                   0040  mov	ax,*$40
15559 4764           50                         push	ax
15560                                           ! Debug: func () void = write_byte+0 (used reg = )
15561 4765           E8         BEB2            call	_write_byte
15562 4768           83C4                   06  add	sp,*6
15563                                           !BCC_EOS
15564                                           ! 2463     else
15565                                           ! 2464       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
15566 476B           EB           1E            jmp .33E
15567                       0000476D            .33C:
15568                                           ! Debug: list * unsigned char = const $232 (used reg = )
15569 476D           B8                   0232  mov	ax,#$232
15570 4770           50                         push	ax
15571                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15572 4771           FF76         FE            push	-2[bp]
15573                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15574 4774           E8         BE7D            call	_read_byte
15575 4777           83C4                   04  add	sp,*4
15576                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15577 477A           30E4                       xor	ah,ah
15578                                           ! Debug: list unsigned int = ax+1 (used reg = )
15579 477C           40                         inc	ax
15580 477D           50                         push	ax
15581                                           ! Debug: list * unsigned char = const $232 (used reg = )
15582 477E           B8                   0232  mov	ax,#$232
15583 4781           50                         push	ax
15584                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15585 4782           FF76         FE            push	-2[bp]
15586                                           ! Debug: func () void = write_byte+0 (used reg = )
15587 4785           E8         BE92            call	_write_byte
15588 4788           83C4                   06  add	sp,*6
15589                                           !BCC_EOS
15590                                           ! 2465    }
15591                       0000478B            .33E:
15592                                           ! 2466   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
15593                       0000478B            .33A:
15594                                           ! Debug: list * unsigned char = const $25B (used reg = )
15595 478B           B8                   025B  mov	ax,#$25B
15596 478E           50                         push	ax
15597                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15598 478F           FF76         FE            push	-2[bp]
15599                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15600 4792           E8         BE5F            call	_read_byte
15601 4795           83C4                   04  add	sp,*4
15602                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15603 4798           84C0                       test	al,al
15604 479A           74           11            je  	.33F
15605                       0000479C            .340:
15606                                           ! 2467     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
15607                                           ! Debug: list int = const 1 (used reg = )
15608 479C           B8                   0001  mov	ax,*1
15609 479F           50                         push	ax
15610                                           ! Debug: list * unsigned char = const $25A (used reg = )
15611 47A0           B8                   025A  mov	ax,#$25A
15612 47A3           50                         push	ax
15613                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15614 47A4           FF76         FE            push	-2[bp]
15615                                           ! Debug: func () void = write_byte+0 (used reg = )
15616 47A7           E8         BE70            call	_write_byte
15617 47AA           83C4                   06  add	sp,*6
15618                                           !BCC_EOS
15619                                           ! 2468   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
15620                       000047AD            .33F:
15621                                           ! Debug: list * unsigned char = const $25C (used reg = )
15622 47AD           B8                   025C  mov	ax,#$25C
15623 47B0           50                         push	ax
15624                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15625 47B1           FF76         FE            push	-2[bp]
15626                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15627 47B4           E8         BE3D            call	_read_byte
15628 47B7           83C4                   04  add	sp,*4
15629                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
15630 47BA           30E4                       xor	ah,ah
15631 47BC           B9                   0100  mov	cx,#$100
15632 47BF           F7E9                       imul	cx
15633                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
15634                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
15635 47C1           89EC                       mov	sp,bp
15636 47C3           5D                         pop	bp
15637 47C4           C3                         ret
15638                                           !BCC_EOS
15639                                           ! 2469 }
15640                                           ! 2470   void
15641                                           ! Register BX used in function cdrom_boot
15642                                           ! 2471 int14_function(regs, ds, iret_addr)
15643                                           ! 2472   pusha_regs_t regs;
15644                                           export	_int14_function
15645                       000047C5            _int14_function:
15646                                           !BCC_EOS
15647                                           ! 2473   Bit16u ds;
15648                                           !BCC_EOS
15649                                           ! 2474   iret_addr_t iret_addr;
15650                                           !BCC_EOS
15651                                           ! 2475 {
15652                                           ! 2476   Bit16u addr,timer,val16;
15653                                           !BCC_EOS
15654                                           ! 2477   Bit8u timeout;
15655                                           !BCC_EOS
15656                                           ! 2478 #asm
15657 47C5           55                         push	bp
15658 47C6           89E5                       mov	bp,sp
15659 47C8           83C4                   F8  add	sp,*-8
15660                                           !BCC_EOS
15661                                           !BCC_ASM
15662                       0000001C            _int14_function.ds	set	$1C
15663                       00000014            .int14_function.ds	set	$14
15664                       00000004            _int14_function.timer	set	4
15665                       FFFFFFFC            .int14_function.timer	set	-4
15666                       00000001            _int14_function.timeout	set	1
15667                       FFFFFFF9            .int14_function.timeout	set	-7
15668                       0000001E            _int14_function.iret_addr	set	$1E
15669                       00000016            .int14_function.iret_addr	set	$16
15670                       00000006            _int14_function.addr	set	6
15671                       FFFFFFFE            .int14_function.addr	set	-2
15672                       00000002            _int14_function.val16	set	2
15673                       FFFFFFFA            .int14_function.val16	set	-6
15674                       0000000C            _int14_function.regs	set	$C
15675                       00000004            .int14_function.regs	set	4
15676 47CB           FB                           sti
15677                                           ! 2480 endasm
15678                                           !BCC_ENDASM
15679                                           !BCC_EOS
15680                                           ! 2481   addr = read_word(0x0040, (regs.u.r16.dx << 1));
15681                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
15682 47CC           8B46         0E            mov	ax,$E[bp]
15683 47CF           D1E0                       shl	ax,*1
15684                                           ! Debug: list unsigned int = ax+0 (used reg = )
15685 47D1           50                         push	ax
15686                                           ! Debug: list int = const $40 (used reg = )
15687 47D2           B8                   0040  mov	ax,*$40
15688 47D5           50                         push	ax
15689                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15690 47D6           E8         BE2E            call	_read_word
15691 47D9           83C4                   04  add	sp,*4
15692                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
15693 47DC           8946         FE            mov	-2[bp],ax
15694                                           !BCC_EOS
15695                                           ! 2482   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
15696                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
15697                                           ! Debug: expression subtree swapping
15698 47DF           8B46         0E            mov	ax,$E[bp]
15699                                           ! Debug: list unsigned int = ax+$7C (used reg = )
15700 47E2           05                   007C  add	ax,*$7C
15701 47E5           50                         push	ax
15702                                           ! Debug: list int = const $40 (used reg = )
15703 47E6           B8                   0040  mov	ax,*$40
15704 47E9           50                         push	ax
15705                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15706 47EA           E8         BE07            call	_read_byte
15707 47ED           83C4                   04  add	sp,*4
15708                                           ! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
15709 47F0           8846         F9            mov	-7[bp],al
15710                                           !BCC_EOS
15711                                           ! 2483   if ((regs.u.r16.dx < 4) && (addr > 0)) {
15712                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
15713 47F3           8B46         0E            mov	ax,$E[bp]
15714 47F6           3D                   0004  cmp	ax,*4
15715 47F9         0F83         022C            bhis	.341
15716                       000047FD            .343:
15717                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
15718 47FD           8B46         FE            mov	ax,-2[bp]
15719 4800           85C0                       test	ax,ax
15720 4802         0F84         0223            beq 	.341
15721                       00004806            .342:
15722                                           ! 2484     switch (regs.u.r8.ah) {
15723 4806           8A46         13            mov	al,$13[bp]
15724 4809           E9         0203            br 	.346
15725                                           ! 2485       case 0:
15726                                           ! 2486         outb(addr+3, inb(addr+3) | 0x80);
15727                       0000480C            .347:
15728                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
15729 480C           8B46         FE            mov	ax,-2[bp]
15730                                           ! Debug: list unsigned int = ax+3 (used reg = )
15731 480F           05                   0003  add	ax,*3
15732 4812           50                         push	ax
15733                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15734 4813           E8         BD28            call	_inb
15735 4816           44                         inc	sp
15736 4817           44                         inc	sp
15737                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
15738 4818           0C                     80  or	al,#$80
15739                                           ! Debug: list unsigned char = al+0 (used reg = )
15740 481A           30E4                       xor	ah,ah
15741 481C           50                         push	ax
15742                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15743 481D           8B46         FE            mov	ax,-2[bp]
15744                                           ! Debug: list unsigned int = ax+3 (used reg = )
15745 4820           05                   0003  add	ax,*3
15746 4823           50                         push	ax
15747                                           ! Debug: func () void = outb+0 (used reg = )
15748 4824           E8         BD2D            call	_outb
15749 4827           83C4                   04  add	sp,*4
15750                                           !BCC_EOS
15751                                           ! 2487         if (regs.u.r8.al & 0xE0 == 0) {
15752                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
15753 482A           8A46         12            mov	al,$12[bp]
15754 482D           30C0                       xor	al,al
15755 482F           84C0                       test	al,al
15756 4831           74           1E            je  	.348
15757                       00004833            .349:
15758                                           ! 2488           outb(addr, 0x17);
15759                                           ! Debug: list int = const $17 (used reg = )
15760 4833           B8                   0017  mov	ax,*$17
15761 4836           50                         push	ax
15762                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15763 4837           FF76         FE            push	-2[bp]
15764                                           ! Debug: func () void = outb+0 (used reg = )
15765 483A           E8         BD17            call	_outb
15766 483D           83C4                   04  add	sp,*4
15767                                           !BCC_EOS
15768                                           ! 2489           outb(addr+1, 0x04);
15769                                           ! Debug: list int = const 4 (used reg = )
15770 4840           B8                   0004  mov	ax,*4
15771 4843           50                         push	ax
15772                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15773 4844           8B46         FE            mov	ax,-2[bp]
15774                                           ! Debug: list unsigned int = ax+1 (used reg = )
15775 4847           40                         inc	ax
15776 4848           50                         push	ax
15777                                           ! Debug: func () void = outb+0 (used reg = )
15778 4849           E8         BD08            call	_outb
15779 484C           83C4                   04  add	sp,*4
15780                                           !BCC_EOS
15781                                           ! 2490         } else {
15782 484F           EB           39            jmp .34A
15783                       00004851            .348:
15784                                           ! 2491           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
15785                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
15786 4851           8A46         12            mov	al,$12[bp]
15787 4854           24                     E0  and	al,#$E0
15788                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
15789 4856           30E4                       xor	ah,ah
15790 4858           B1                     05  mov	cl,*5
15791 485A           D3E8                       shr	ax,cl
15792                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
15793 485C           89C3                       mov	bx,ax
15794 485E           B8                   0600  mov	ax,#$600
15795 4861           89D9                       mov	cx,bx
15796 4863           D3F8                       sar	ax,cl
15797                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15798 4865           8946         FA            mov	-6[bp],ax
15799                                           !BCC_EOS
15800                                           ! 2492           outb(addr, val16 & 0xFF);
15801                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
15802 4868           8A46         FA            mov	al,-6[bp]
15803                                           ! Debug: list unsigned char = al+0 (used reg = )
15804 486B           30E4                       xor	ah,ah
15805 486D           50                         push	ax
15806                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15807 486E           FF76         FE            push	-2[bp]
15808                                           ! Debug: func () void = outb+0 (used reg = )
15809 4871           E8         BCE0            call	_outb
15810 4874           83C4                   04  add	sp,*4
15811                                           !BCC_EOS
15812                                           ! 2493           outb(addr+1, val16 >> 8);
15813                                           ! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
15814 4877           8B46         FA            mov	ax,-6[bp]
15815 487A           88E0                       mov	al,ah
15816 487C           30E4                       xor	ah,ah
15817                                           ! Debug: list unsigned int = ax+0 (used reg = )
15818 487E           50                         push	ax
15819                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15820 487F           8B46         FE            mov	ax,-2[bp]
15821                                           ! Debug: list unsigned int = ax+1 (used reg = )
15822 4882           40                         inc	ax
15823 4883           50                         push	ax
15824                                           ! Debug: func () void = outb+0 (used reg = )
15825 4884           E8         BCCD            call	_outb
15826 4887           83C4                   04  add	sp,*4
15827                                           !BCC_EOS
15828                                           ! 2494         }
15829                                           ! 2495         outb(addr+3, regs.u.r8.al & 0x1F);
15830                       0000488A            .34A:
15831                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
15832 488A           8A46         12            mov	al,$12[bp]
15833 488D           24                     1F  and	al,*$1F
15834                                           ! Debug: list unsigned char = al+0 (used reg = )
15835 488F           30E4                       xor	ah,ah
15836 4891           50                         push	ax
15837                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15838 4892           8B46         FE            mov	ax,-2[bp]
15839                                           ! Debug: list unsigned int = ax+3 (used reg = )
15840 4895           05                   0003  add	ax,*3
15841 4898           50                         push	ax
15842                                           ! Debug: func () void = outb+0 (used reg = )
15843 4899           E8         BCB8            call	_outb
15844 489C           83C4                   04  add	sp,*4
15845                                           !BCC_EOS
15846                                           ! 2496         regs.u.r8.ah = inb(addr+5);
15847                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15848 489F           8B46         FE            mov	ax,-2[bp]
15849                                           ! Debug: list unsigned int = ax+5 (used reg = )
15850 48A2           05                   0005  add	ax,*5
15851 48A5           50                         push	ax
15852                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15853 48A6           E8         BC95            call	_inb
15854 48A9           44                         inc	sp
15855 48AA           44                         inc	sp
15856                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15857 48AB           8846         13            mov	$13[bp],al
15858                                           !BCC_EOS
15859                                           ! 2497         regs.u.r8.al = inb(addr+6);
15860                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15861 48AE           8B46         FE            mov	ax,-2[bp]
15862                                           ! Debug: list unsigned int = ax+6 (used reg = )
15863 48B1           05                   0006  add	ax,*6
15864 48B4           50                         push	ax
15865                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15866 48B5           E8         BC86            call	_inb
15867 48B8           44                         inc	sp
15868 48B9           44                         inc	sp
15869                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15870 48BA           8846         12            mov	$12[bp],al
15871                                           !BCC_EOS
15872                                           ! 2498         iret_addr.flags.u.r8.flagsl &= 0xfe;
15873                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15874 48BD           8A46         1A            mov	al,$1A[bp]
15875 48C0           24                     FE  and	al,#$FE
15876 48C2           8846         1A            mov	$1A[bp],al
15877                                           !BCC_EOS
15878                                           ! 2499         break;
15879 48C5           E9         015F            br 	.344
15880                                           !BCC_EOS
15881                                           ! 2500       case 1:
15882                                           ! 2501         timer = read_word(0x0040, 0x006C);
15883                       000048C8            .34B:
15884                                           ! Debug: list int = const $6C (used reg = )
15885 48C8           B8                   006C  mov	ax,*$6C
15886 48CB           50                         push	ax
15887                                           ! Debug: list int = const $40 (used reg = )
15888 48CC           B8                   0040  mov	ax,*$40
15889 48CF           50                         push	ax
15890                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15891 48D0           E8         BD34            call	_read_word
15892 48D3           83C4                   04  add	sp,*4
15893                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15894 48D6           8946         FC            mov	-4[bp],ax
15895                                           !BCC_EOS
15896                                           ! 2502         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
15897 48D9           EB           26            jmp .34D
15898                       000048DB            .34E:
15899                                           ! 2503           val16 = read_word(0x0040, 0x006C);
15900                                           ! Debug: list int = const $6C (used reg = )
15901 48DB           B8                   006C  mov	ax,*$6C
15902 48DE           50                         push	ax
15903                                           ! Debug: list int = const $40 (used reg = )
15904 48DF           B8                   0040  mov	ax,*$40
15905 48E2           50                         push	ax
15906                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15907 48E3           E8         BD21            call	_read_word
15908 48E6           83C4                   04  add	sp,*4
15909                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15910 48E9           8946         FA            mov	-6[bp],ax
15911                                           !BCC_EOS
15912                                           ! 2504           if (val16 != timer) {
15913                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15914 48EC           8B46         FA            mov	ax,-6[bp]
15915 48EF           3B46         FC            cmp	ax,-4[bp]
15916 48F2           74           0D            je  	.34F
15917                       000048F4            .350:
15918                                           ! 2505             timer = val16;
15919                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15920 48F4           8B46         FA            mov	ax,-6[bp]
15921 48F7           8946         FC            mov	-4[bp],ax
15922                                           !BCC_EOS
15923                                           ! 2506             timeout--;
15924                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
15925 48FA           8A46         F9            mov	al,-7[bp]
15926 48FD           48                         dec	ax
15927 48FE           8846         F9            mov	-7[bp],al
15928                                           !BCC_EOS
15929                                           ! 2507             }
15930                                           ! 2508           }
15931                       00004901            .34F:
15932                                           ! 2509         if (timeout) outb(addr, regs.u.r8.al);
15933                       00004901            .34D:
15934                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15935 4901           8B46         FE            mov	ax,-2[bp]
15936                                           ! Debug: list unsigned int = ax+5 (used reg = )
15937 4904           05                   0005  add	ax,*5
15938 4907           50                         push	ax
15939                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15940 4908           E8         BC33            call	_inb
15941 490B           44                         inc	sp
15942 490C           44                         inc	sp
15943                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
15944 490D           24                     60  and	al,*$60
15945                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
15946 490F           3C                     60  cmp	al,*$60
15947 4911           74           07            je  	.351
15948                       00004913            .352:
15949 4913           8A46         F9            mov	al,-7[bp]
15950 4916           84C0                       test	al,al
15951 4918           75           C1            jne	.34E
15952                       0000491A            .351:
15953                       0000491A            .34C:
15954 491A           8A46         F9            mov	al,-7[bp]
15955 491D           84C0                       test	al,al
15956 491F           74           0F            je  	.353
15957                       00004921            .354:
15958                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
15959 4921           8A46         12            mov	al,$12[bp]
15960 4924           30E4                       xor	ah,ah
15961 4926           50                         push	ax
15962                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15963 4927           FF76         FE            push	-2[bp]
15964                                           ! Debug: func () void = outb+0 (used reg = )
15965 492A           E8         BC27            call	_outb
15966 492D           83C4                   04  add	sp,*4
15967                                           !BCC_EOS
15968                                           ! 2510         regs.u.r8.ah = inb(addr+5);
15969                       00004930            .353:
15970                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15971 4930           8B46         FE            mov	ax,-2[bp]
15972                                           ! Debug: list unsigned int = ax+5 (used reg = )
15973 4933           05                   0005  add	ax,*5
15974 4936           50                         push	ax
15975                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15976 4937           E8         BC04            call	_inb
15977 493A           44                         inc	sp
15978 493B           44                         inc	sp
15979                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15980 493C           8846         13            mov	$13[bp],al
15981                                           !BCC_EOS
15982                                           ! 2511         if (!timeout) regs.u.r8.ah |= 0x80;
15983 493F           8A46         F9            mov	al,-7[bp]
15984 4942           84C0                       test	al,al
15985 4944           75           08            jne 	.355
15986                       00004946            .356:
15987                                           ! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15988 4946           8A46         13            mov	al,$13[bp]
15989 4949           0C                     80  or	al,#$80
15990 494B           8846         13            mov	$13[bp],al
15991                                           !BCC_EOS
15992                                           ! 2512         iret_addr.flags.u.r8.flagsl &= 0xfe;
15993                       0000494E            .355:
15994                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15995 494E           8A46         1A            mov	al,$1A[bp]
15996 4951           24                     FE  and	al,#$FE
15997 4953           8846         1A            mov	$1A[bp],al
15998                                           !BCC_EOS
15999                                           ! 2513         break;
16000 4956           E9         00CE            br 	.344
16001                                           !BCC_EOS
16002                                           ! 2514       case 2:
16003                                           ! 2515 
16004                                           ! 2515         timer = read_word(0x0040, 0x006C);
16005                       00004959            .357:
16006                                           ! Debug: list int = const $6C (used reg = )
16007 4959           B8                   006C  mov	ax,*$6C
16008 495C           50                         push	ax
16009                                           ! Debug: list int = const $40 (used reg = )
16010 495D           B8                   0040  mov	ax,*$40
16011 4960           50                         push	ax
16012                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
16013 4961           E8         BCA3            call	_read_word
16014 4964           83C4                   04  add	sp,*4
16015                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
16016 4967           8946         FC            mov	-4[bp],ax
16017                                           !BCC_EOS
16018                                           ! 2516         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
16019 496A           EB           26            jmp .359
16020                       0000496C            .35A:
16021                                           ! 2517           val16 = read_word(0x0040, 0x006C);
16022                                           ! Debug: list int = const $6C (used reg = )
16023 496C           B8                   006C  mov	ax,*$6C
16024 496F           50                         push	ax
16025                                           ! Debug: list int = const $40 (used reg = )
16026 4970           B8                   0040  mov	ax,*$40
16027 4973           50                         push	ax
16028                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
16029 4974           E8         BC90            call	_read_word
16030 4977           83C4                   04  add	sp,*4
16031                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
16032 497A           8946         FA            mov	-6[bp],ax
16033                                           !BCC_EOS
16034                                           ! 2518           if (val16 != timer) {
16035                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
16036 497D           8B46         FA            mov	ax,-6[bp]
16037 4980           3B46         FC            cmp	ax,-4[bp]
16038 4983           74           0D            je  	.35B
16039                       00004985            .35C:
16040                                           ! 2519             timer = val16;
16041                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
16042 4985           8B46         FA            mov	ax,-6[bp]
16043 4988           8946         FC            mov	-4[bp],ax
16044                                           !BCC_EOS
16045                                           ! 2520             timeout--;
16046                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
16047 498B           8A46         F9            mov	al,-7[bp]
16048 498E           48                         dec	ax
16049 498F           8846         F9            mov	-7[bp],al
16050                                           !BCC_EOS
16051                                           ! 2521             }
16052                                           ! 2522           }
16053                       00004992            .35B:
16054                                           ! 2523         if (timeout) {
16055                       00004992            .359:
16056                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
16057 4992           8B46         FE            mov	ax,-2[bp]
16058                                           ! Debug: list unsigned int = ax+5 (used reg = )
16059 4995           05                   0005  add	ax,*5
16060 4998           50                         push	ax
16061                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16062 4999           E8         BBA2            call	_inb
16063 499C           44                         inc	sp
16064 499D           44                         inc	sp
16065                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
16066 499E           24                     01  and	al,*1
16067                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
16068 49A0           84C0                       test	al,al
16069 49A2           75           07            jne 	.35D
16070                       000049A4            .35E:
16071 49A4           8A46         F9            mov	al,-7[bp]
16072 49A7           84C0                       test	al,al
16073 49A9           75           C1            jne	.35A
16074                       000049AB            .35D:
16075                       000049AB            .358:
16076 49AB           8A46         F9            mov	al,-7[bp]
16077 49AE           84C0                       test	al,al
16078 49B0           74           12            je  	.35F
16079                       000049B2            .360:
16080                                           ! 2524           regs.u.r8.ah = 0;
16081                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
16082 49B2           30C0                       xor	al,al
16083 49B4           8846         13            mov	$13[bp],al
16084                                           !BCC_EOS
16085                                           ! 2525           regs.u.r8.al = inb(addr);
16086                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
16087 49B7           FF76         FE            push	-2[bp]
16088                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16089 49BA           E8         BB81            call	_inb
16090 49BD           44                         inc	sp
16091 49BE           44                         inc	sp
16092                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
16093 49BF           8846         12            mov	$12[bp],al
16094                                           !BCC_EOS
16095                                           ! 2526         } else {
16096 49C2           EB           0F            jmp .361
16097                       000049C4            .35F:
16098                                           ! 2527           regs.u.r8.ah = inb(addr+5);
16099                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
16100 49C4           8B46         FE            mov	ax,-2[bp]
16101                                           ! Debug: list unsigned int = ax+5 (used reg = )
16102 49C7           05                   0005  add	ax,*5
16103 49CA           50                         push	ax
16104                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16105 49CB           E8         BB70            call	_inb
16106 49CE           44                         inc	sp
16107 49CF           44                         inc	sp
16108                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
16109 49D0           8846         13            mov	$13[bp],al
16110                                           !BCC_EOS
16111                                           ! 2528           }
16112                                           ! 2529         iret_addr.flags.u.r8.flagsl &= 0xfe;
16113                       000049D3            .361:
16114                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
16115 49D3           8A46         1A            mov	al,$1A[bp]
16116 49D6           24                     FE  and	al,#$FE
16117 49D8           8846         1A            mov	$1A[bp],al
16118                                           !BCC_EOS
16119                                           ! 2530         break;
16120 49DB           EB           4A            jmp .344
16121                                           !BCC_EOS
16122                                           ! 2531       case 3:
16123                                           ! 2532         regs.u.r8.ah = inb(addr+5);
16124                       000049DD            .362:
16125                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
16126 49DD           8B46         FE            mov	ax,-2[bp]
16127                                           ! Debug: list unsigned int = ax+5 (used reg = )
16128 49E0           05                   0005  add	ax,*5
16129 49E3           50                         push	ax
16130                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16131 49E4           E8         BB57            call	_inb
16132 49E7           44                         inc	sp
16133 49E8           44                         inc	sp
16134                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
16135 49E9           8846         13            mov	$13[bp],al
16136                                           !BCC_EOS
16137                                           ! 2533         regs.u.r8.al = inb(addr+6);
16138                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
16139 49EC           8B46         FE            mov	ax,-2[bp]
16140                                           ! Debug: list unsigned int = ax+6 (used reg = )
16141 49EF           05                   0006  add	ax,*6
16142 49F2           50                         push	ax
16143                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16144 49F3           E8         BB48            call	_inb
16145 49F6           44                         inc	sp
16146 49F7           44                         inc	sp
16147                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
16148 49F8           8846         12            mov	$12[bp],al
16149                                           !BCC_EOS
16150                                           ! 2534         iret_addr.flags.u.r8.flagsl &= 0xfe;
16151                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
16152 49FB           8A46         1A            mov	al,$1A[bp]
16153 49FE           24                     FE  and	al,#$FE
16154 4A00           8846         1A            mov	$1A[bp],al
16155                                           !BCC_EOS
16156                                           ! 2535         break;
16157 4A03           EB           22            jmp .344
16158                                           !BCC_EOS
16159                                           ! 2536       default:
16160                                           ! 2537         iret_addr.flags.u.r8.flagsl |= 0x01;
16161                       00004A05            .363:
16162                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
16163 4A05           8A46         1A            mov	al,$1A[bp]
16164 4A08           0C                     01  or	al,*1
16165 4A0A           8846         1A            mov	$1A[bp],al
16166                                           !BCC_EOS
16167                                           ! 2538       }
16168                                           ! 2539   } else {
16169 4A0D           EB           18            jmp .344
16170                       00004A0F            .346:
16171 4A0F           2C                     00  sub	al,*0
16172 4A11         0F84         FDF7            beq 	.347
16173 4A15           2C                     01  sub	al,*1
16174 4A17         0F84         FEAD            beq 	.34B
16175 4A1B           2C                     01  sub	al,*1
16176 4A1D         0F84         FF38            beq 	.357
16177 4A21           2C                     01  sub	al,*1
16178 4A23           74           B8            je 	.362
16179 4A25           EB           DE            jmp	.363
16180                       00004A27            .344:
16181                       FFFFFFF6            ..FFF8	=	-$A
16182 4A27           EB           08            jmp .364
16183                       00004A29            .341:
16184                                           ! 2540     iret_addr.flags.u.r8.flagsl |= 0x01;
16185                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
16186 4A29           8A46         1A            mov	al,$1A[bp]
16187 4A2C           0C                     01  or	al,*1
16188 4A2E           8846         1A            mov	$1A[bp],al
16189                                           !BCC_EOS
16190                                           ! 2541     }
16191                                           ! 2542 }
16192                       00004A31            .364:
16193 4A31           89EC                       mov	sp,bp
16194 4A33           5D                         pop	bp
16195 4A34           C3                         ret
16196                                           ! 2543   void
16197                                           ! Register BX used in function int14_function
16198                                           ! 2544 int15_function(regs, ES, DS, FLAGS)
16199                                           ! 2545   pusha_regs_t regs;
16200                                           export	_int15_function
16201                       00004A35            _int15_function:
16202                                           !BCC_EOS
16203                                           ! 2546   Bit16u ES, DS, FLAGS;
16204                                           !BCC_EOS
16205                                           ! 2547 {
16206                                           ! 2548   Bit16u ebda_seg=read_word(0x0040,0x000E);
16207 4A35           55                         push	bp
16208 4A36           89E5                       mov	bp,sp
16209 4A38           4C                         dec	sp
16210 4A39           4C                         dec	sp
16211                                           ! Debug: list int = const $E (used reg = )
16212 4A3A           B8                   000E  mov	ax,*$E
16213 4A3D           50                         push	ax
16214                                           ! Debug: list int = const $40 (used reg = )
16215 4A3E           B8                   0040  mov	ax,*$40
16216 4A41           50                         push	ax
16217                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
16218 4A42           E8         BBC2            call	_read_word
16219 4A45           83C4                   04  add	sp,*4
16220                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
16221 4A48           8946         FE            mov	-2[bp],ax
16222                                           !BCC_EOS
16223                                           ! 2549   bx_bool prev_a20_enable;
16224                                           !BCC_EOS
16225                                           ! 2550   Bit16u base15_00;
16226                                           !BCC_EOS
16227                                           ! 2551   Bit8u base23_16;
16228                                           !BCC_EOS
16229                                           ! 2552   Bit16u ss;
16230                                           !BCC_EOS
16231                                           ! 2553   Bit16u CX,DX;
16232                                           !BCC_EOS
16233                                           ! 2554   Bit16u bRegister;
16234                                           !BCC_EOS
16235                                           ! 2555   Bit8u irqDisable;
16236                                           !BCC_EOS
16237                                           ! 2556 ;
16238 4A4B           83C4                   F0  add	sp,*-$10
16239                                           !BCC_EOS
16240                                           ! 2557   switch (regs.u.r8.ah) {
16241 4A4E           8A46         13            mov	al,$13[bp]
16242 4A51           E9         04C6            br 	.367
16243                                           ! 2558     case 0x24:
16244                                           ! 2559       switch (regs.u.r8.al) {
16245                       00004A54            .368:
16246 4A54           8A46         12            mov	al,$12[bp]
16247 4A57           E9         0089            br 	.36B
16248                                           ! 2560         case 0x00:
16249                                           ! 2561           set_enable_a20(0);
16250                       00004A5A            .36C:
16251                                           ! Debug: list int = const 0 (used reg = )
16252 4A5A           31C0                       xor	ax,ax
16253 4A5C           50                         push	ax
16254                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16255 4A5D           E8         CE8A            call	_set_enable_a20
16256 4A60           44                         inc	sp
16257 4A61           44                         inc	sp
16258                                           !BCC_EOS
16259                                           ! 2562           FLAGS &= 0xfffe;
16260                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16261 4A62           8B46         18            mov	ax,$18[bp]
16262 4A65           24                     FE  and	al,#$FE
16263 4A67           8946         18            mov	$18[bp],ax
16264                                           !BCC_EOS
16265                                           ! 2563           regs.u.r8.ah = 0;
16266                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16267 4A6A           30C0                       xor	al,al
16268 4A6C           8846         13            mov	$13[bp],al
16269                                           !BCC_EOS
16270                                           ! 2564           break;
16271 4A6F           E9         0087            br 	.369
16272                                           !BCC_EOS
16273                                           ! 2565         case 0x01:
16274                                           ! 2566           set_enable_a20(1);
16275                       00004A72            .36D:
16276                                           ! Debug: list int = const 1 (used reg = )
16277 4A72           B8                   0001  mov	ax,*1
16278 4A75           50                         push	ax
16279                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16280 4A76           E8         CE71            call	_set_enable_a20
16281 4A79           44                         inc	sp
16282 4A7A           44                         inc	sp
16283                                           !BCC_EOS
16284                                           ! 2567           FLAGS &= 0xfffe;
16285                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16286 4A7B           8B46         18            mov	ax,$18[bp]
16287 4A7E           24                     FE  and	al,#$FE
16288 4A80           8946         18            mov	$18[bp],ax
16289                                           !BCC_EOS
16290                                           ! 2568           regs.u.r8.ah = 0;
16291                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16292 4A83           30C0                       xor	al,al
16293 4A85           8846         13            mov	$13[bp],al
16294                                           !BCC_EOS
16295                                           ! 2569           break;
16296 4A88           EB           6F            jmp .369
16297                                           !BCC_EOS
16298                                           ! 2570         case 0x02:
16299                                           ! 2571           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
16300                       00004A8A            .36E:
16301                                           ! Debug: list int = const $92 (used reg = )
16302 4A8A           B8                   0092  mov	ax,#$92
16303 4A8D           50                         push	ax
16304                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16305 4A8E           E8         BAAD            call	_inb
16306 4A91           44                         inc	sp
16307 4A92           44                         inc	sp
16308                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
16309 4A93           30E4                       xor	ah,ah
16310 4A95           D1E8                       shr	ax,*1
16311                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
16312 4A97           24                     01  and	al,*1
16313                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
16314 4A99           8846         12            mov	$12[bp],al
16315                                           !BCC_EOS
16316                                           ! 2572           FLAGS &= 0xfffe;
16317                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16318 4A9C           8B46         18            mov	ax,$18[bp]
16319 4A9F           24                     FE  and	al,#$FE
16320 4AA1           8946         18            mov	$18[bp],ax
16321                                           !BCC_EOS
16322                                           ! 2573           regs.u.r8.ah = 0;
16323                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16324 4AA4           30C0                       xor	al,al
16325 4AA6           8846         13            mov	$13[bp],al
16326                                           !BCC_EOS
16327                                           ! 2574           break;
16328 4AA9           EB           4E            jmp .369
16329                                           !BCC_EOS
16330                                           ! 2575         case 0x03:
16331                                           ! 2576           FLAGS &= 0xfffe;
16332                       00004AAB            .36F:
16333                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16334 4AAB           8B46         18            mov	ax,$18[bp]
16335 4AAE           24                     FE  and	al,#$FE
16336 4AB0           8946         18            mov	$18[bp],ax
16337                                           !BCC_EOS
16338                                           ! 2577           regs.u.r8.ah = 0;
16339                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16340 4AB3           30C0                       xor	al,al
16341 4AB5           8846         13            mov	$13[bp],al
16342                                           !BCC_EOS
16343                                           ! 2578           regs.u.r16.bx = 3;
16344                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
16345 4AB8           B8                   0003  mov	ax,*3
16346 4ABB           8946         0C            mov	$C[bp],ax
16347                                           !BCC_EOS
16348                                           ! 2579           break;
16349 4ABE           EB           39            jmp .369
16350                                           !BCC_EOS
16351                                           ! 2580         default:
16352                                           ! 2581           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
16353                       00004AC0            .370:
16354                                           ! Debug: list unsigned char regs = [S+$14+$10] (used reg = )
16355 4AC0           8A46         12            mov	al,$12[bp]
16356 4AC3           30E4                       xor	ah,ah
16357 4AC5           50                         push	ax
16358                                           ! Debug: list * char = .371+0 (used reg = )
16359 4AC6           BB                   D984  mov	bx,#.371
16360 4AC9           53                         push	bx
16361                                           ! Debug: list int = const 4 (used reg = )
16362 4ACA           B8                   0004  mov	ax,*4
16363 4ACD           50                         push	ax
16364                                           ! Debug: func () void = bios_printf+0 (used reg = )
16365 4ACE           E8         BF48            call	_bios_printf
16366 4AD1           83C4                   06  add	sp,*6
16367                                           !BCC_EOS
16368                                           ! 2582           FLAGS |= 0x0001;
16369                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16370 4AD4           8B46         18            mov	ax,$18[bp]
16371 4AD7           0C                     01  or	al,*1
16372 4AD9           8946         18            mov	$18[bp],ax
16373                                           !BCC_EOS
16374                                           ! 2583           regs.u.r8.ah = 0x86;
16375                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16376 4ADC           B0                     86  mov	al,#$86
16377 4ADE           8846         13            mov	$13[bp],al
16378                                           !BCC_EOS
16379                                           ! 2584       }
16380                                           ! 2585       break;
16381 4AE1           EB           16            jmp .369
16382                       00004AE3            .36B:
16383 4AE3           2C                     00  sub	al,*0
16384 4AE5         0F84         FF71            beq 	.36C
16385 4AE9           2C                     01  sub	al,*1
16386 4AEB         0F84         FF83            beq 	.36D
16387 4AEF           2C                     01  sub	al,*1
16388 4AF1           74           97            je 	.36E
16389 4AF3           2C                     01  sub	al,*1
16390 4AF5           74           B4            je 	.36F
16391 4AF7           EB           C7            jmp	.370
16392                       00004AF9            .369:
16393 4AF9           E9         046F            br 	.365
16394                                           !BCC_EOS
16395                                           ! 2586     case 0x41:
16396                                           ! 2587       FLAGS |= 0x0001;
16397                       00004AFC            .372:
16398                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16399 4AFC           8B46         18            mov	ax,$18[bp]
16400 4AFF           0C                     01  or	al,*1
16401 4B01           8946         18            mov	$18[bp],ax
16402                                           !BCC_EOS
16403                                           ! 2588       regs.u.r8.ah = 0x86;
16404                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16405 4B04           B0                     86  mov	al,#$86
16406 4B06           8846         13            mov	$13[bp],al
16407                                           !BCC_EOS
16408                                           ! 2589       break;
16409 4B09           E9         045F            br 	.365
16410                                           !BCC_EOS
16411                                           ! 2590     case 0x4f:
16412                                           ! 2591       FLAGS |= 0x0001;
16413                       00004B0C            .373:
16414                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16415 4B0C           8B46         18            mov	ax,$18[bp]
16416 4B0F           0C                     01  or	al,*1
16417 4B11           8946         18            mov	$18[bp],ax
16418                                           !BCC_EOS
16419                                           ! 2592       break;
16420 4B14           E9         0454            br 	.365
16421                                           !BCC_EOS
16422                                           ! 2593     case 0x52:
16423                                           ! 2594       FLAGS &= 0xfffe;
16424                       00004B17            .374:
16425                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16426 4B17           8B46         18            mov	ax,$18[bp]
16427 4B1A           24                     FE  and	al,#$FE
16428 4B1C           8946         18            mov	$18[bp],ax
16429                                           !BCC_EOS
16430                                           ! 2595       regs.u.r8.ah = 0;
16431                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16432 4B1F           30C0                       xor	al,al
16433 4B21           8846         13            mov	$13[bp],al
16434                                           !BCC_EOS
16435                                           ! 2596       break;
16436 4B24           E9         0444            br 	.365
16437                                           !BCC_EOS
16438                                           ! 2597     case 0x83: {
16439                       00004B27            .375:
16440                                           ! 2598       if( regs.u.r8.al == 
16441                                           ! 2598 0 ) {
16442                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
16443 4B27           8A46         12            mov	al,$12[bp]
16444 4B2A           84C0                       test	al,al
16445 4B2C         0F85         00C1            bne 	.376
16446                       00004B30            .377:
16447                                           ! 2599         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
16448                                           ! Debug: list int = const $A0 (used reg = )
16449 4B30           B8                   00A0  mov	ax,#$A0
16450 4B33           50                         push	ax
16451                                           ! Debug: list int = const $40 (used reg = )
16452 4B34           B8                   0040  mov	ax,*$40
16453 4B37           50                         push	ax
16454                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16455 4B38           E8         BAB9            call	_read_byte
16456 4B3B           83C4                   04  add	sp,*4
16457                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
16458 4B3E           24                     01  and	al,*1
16459                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
16460 4B40           84C0                       test	al,al
16461 4B42         0F85         009C            bne 	.378
16462                       00004B46            .379:
16463                                           ! 2600           write_byte( 0x40, 0xA0, 1 );
16464                                           ! Debug: list int = const 1 (used reg = )
16465 4B46           B8                   0001  mov	ax,*1
16466 4B49           50                         push	ax
16467                                           ! Debug: list int = const $A0 (used reg = )
16468 4B4A           B8                   00A0  mov	ax,#$A0
16469 4B4D           50                         push	ax
16470                                           ! Debug: list int = const $40 (used reg = )
16471 4B4E           B8                   0040  mov	ax,*$40
16472 4B51           50                         push	ax
16473                                           ! Debug: func () void = write_byte+0 (used reg = )
16474 4B52           E8         BAC5            call	_write_byte
16475 4B55           83C4                   06  add	sp,*6
16476                                           !BCC_EOS
16477                                           ! 2601           write_word( 0x40, 0x98, ES );
16478                                           ! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
16479 4B58           FF76         14            push	$14[bp]
16480                                           ! Debug: list int = const $98 (used reg = )
16481 4B5B           B8                   0098  mov	ax,#$98
16482 4B5E           50                         push	ax
16483                                           ! Debug: list int = const $40 (used reg = )
16484 4B5F           B8                   0040  mov	ax,*$40
16485 4B62           50                         push	ax
16486                                           ! Debug: func () void = write_word+0 (used reg = )
16487 4B63           E8         BACC            call	_write_word
16488 4B66           83C4                   06  add	sp,*6
16489                                           !BCC_EOS
16490                                           ! 2602           write_word( 0x40, 0x9A, regs.u.r16.bx );
16491                                           ! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
16492 4B69           FF76         0C            push	$C[bp]
16493                                           ! Debug: list int = const $9A (used reg = )
16494 4B6C           B8                   009A  mov	ax,#$9A
16495 4B6F           50                         push	ax
16496                                           ! Debug: list int = const $40 (used reg = )
16497 4B70           B8                   0040  mov	ax,*$40
16498 4B73           50                         push	ax
16499                                           ! Debug: func () void = write_word+0 (used reg = )
16500 4B74           E8         BABB            call	_write_word
16501 4B77           83C4                   06  add	sp,*6
16502                                           !BCC_EOS
16503                                           ! 2603           write_word( 0x40, 0x9C, regs.u.r16.dx );
16504                                           ! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
16505 4B7A           FF76         0E            push	$E[bp]
16506                                           ! Debug: list int = const $9C (used reg = )
16507 4B7D           B8                   009C  mov	ax,#$9C
16508 4B80           50                         push	ax
16509                                           ! Debug: list int = const $40 (used reg = )
16510 4B81           B8                   0040  mov	ax,*$40
16511 4B84           50                         push	ax
16512                                           ! Debug: func () void = write_word+0 (used reg = )
16513 4B85           E8         BAAA            call	_write_word
16514 4B88           83C4                   06  add	sp,*6
16515                                           !BCC_EOS
16516                                           ! 2604           write_word( 0x40, 0x9E, regs.u.r16.cx );
16517                                           ! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
16518 4B8B           FF76         10            push	$10[bp]
16519                                           ! Debug: list int = const $9E (used reg = )
16520 4B8E           B8                   009E  mov	ax,#$9E
16521 4B91           50                         push	ax
16522                                           ! Debug: list int = const $40 (used reg = )
16523 4B92           B8                   0040  mov	ax,*$40
16524 4B95           50                         push	ax
16525                                           ! Debug: func () void = write_word+0 (used reg = )
16526 4B96           E8         BA99            call	_write_word
16527 4B99           83C4                   06  add	sp,*6
16528                                           !BCC_EOS
16529                                           ! 2605           FLAGS &= 0xfffe;
16530                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16531 4B9C           8B46         18            mov	ax,$18[bp]
16532 4B9F           24                     FE  and	al,#$FE
16533 4BA1           8946         18            mov	$18[bp],ax
16534                                           !BCC_EOS
16535                                           ! 2606           irqDisable = inb( 0xA1 );
16536                                           ! Debug: list int = const $A1 (used reg = )
16537 4BA4           B8                   00A1  mov	ax,#$A1
16538 4BA7           50                         push	ax
16539                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16540 4BA8           E8         B993            call	_inb
16541 4BAB           44                         inc	sp
16542 4BAC           44                         inc	sp
16543                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
16544 4BAD           8846         EF            mov	-$11[bp],al
16545                                           !BCC_EOS
16546                                           ! 2607           outb( 0xA1, irqDisable & 0xFE );
16547                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
16548 4BB0           8A46         EF            mov	al,-$11[bp]
16549 4BB3           24                     FE  and	al,#$FE
16550                                           ! Debug: list unsigned char = al+0 (used reg = )
16551 4BB5           30E4                       xor	ah,ah
16552 4BB7           50                         push	ax
16553                                           ! Debug: list int = const $A1 (used reg = )
16554 4BB8           B8                   00A1  mov	ax,#$A1
16555 4BBB           50                         push	ax
16556                                           ! Debug: func () void = outb+0 (used reg = )
16557 4BBC           E8         B995            call	_outb
16558 4BBF           83C4                   04  add	sp,*4
16559                                           !BCC_EOS
16560                                           ! 2608           bRegister = inb_cmos( 0xB );
16561                                           ! Debug: list int = const $B (used reg = )
16562 4BC2           B8                   000B  mov	ax,*$B
16563 4BC5           50                         push	ax
16564                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16565 4BC6           E8         B9BA            call	_inb_cmos
16566 4BC9           44                         inc	sp
16567 4BCA           44                         inc	sp
16568                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16569 4BCB           30E4                       xor	ah,ah
16570 4BCD           8946         F0            mov	-$10[bp],ax
16571                                           !BCC_EOS
16572                                           ! 2609           outb_cmos( 0xB, bRegister | 0x40 );
16573                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
16574 4BD0           8B46         F0            mov	ax,-$10[bp]
16575 4BD3           0C                     40  or	al,*$40
16576                                           ! Debug: list unsigned int = ax+0 (used reg = )
16577 4BD5           50                         push	ax
16578                                           ! Debug: list int = const $B (used reg = )
16579 4BD6           B8                   000B  mov	ax,*$B
16580 4BD9           50                         push	ax
16581                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16582 4BDA           E8         B997            call	_outb_cmos
16583 4BDD           83C4                   04  add	sp,*4
16584                                           !BCC_EOS
16585                                           ! 2610         } else {
16586 4BE0           EB           0D            jmp .37A
16587                       00004BE2            .378:
16588                                           ! 2611           ;
16589                                           !BCC_EOS
16590                                           ! 2612           FLAGS |= 0x0001;
16591                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16592 4BE2           8B46         18            mov	ax,$18[bp]
16593 4BE5           0C                     01  or	al,*1
16594 4BE7           8946         18            mov	$18[bp],ax
16595                                           !BCC_EOS
16596                                           ! 2613           regs.u.r8.ah = 0x86;
16597                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16598 4BEA           B0                     86  mov	al,#$86
16599 4BEC           8846         13            mov	$13[bp],al
16600                                           !BCC_EOS
16601                                           ! 2614         }
16602                                           ! 2615       } else if( regs.u.r8.al == 1 ) {
16603                       00004BEF            .37A:
16604 4BEF           EB           54            jmp .37B
16605                       00004BF1            .376:
16606                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
16607 4BF1           8A46         12            mov	al,$12[bp]
16608 4BF4           3C                     01  cmp	al,*1
16609 4BF6           75           39            jne 	.37C
16610                       00004BF8            .37D:
16611                                           ! 2616         write_byte( 0x40, 0xA0, 0 );
16612                                           ! Debug: list int = const 0 (used reg = )
16613 4BF8           31C0                       xor	ax,ax
16614 4BFA           50                         push	ax
16615                                           ! Debug: list int = const $A0 (used reg = )
16616 4BFB           B8                   00A0  mov	ax,#$A0
16617 4BFE           50                         push	ax
16618                                           ! Debug: list int = const $40 (used reg = )
16619 4BFF           B8                   0040  mov	ax,*$40
16620 4C02           50                         push	ax
16621                                           ! Debug: func () void = write_byte+0 (used reg = )
16622 4C03           E8         BA14            call	_write_byte
16623 4C06           83C4                   06  add	sp,*6
16624                                           !BCC_EOS
16625                                           ! 2617         FLAGS &= 0xfffe;
16626                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16627 4C09           8B46         18            mov	ax,$18[bp]
16628 4C0C           24                     FE  and	al,#$FE
16629 4C0E           8946         18            mov	$18[bp],ax
16630                                           !BCC_EOS
16631                                           ! 2618         bRegister = inb_cmos( 0xB );
16632                                           ! Debug: list int = const $B (used reg = )
16633 4C11           B8                   000B  mov	ax,*$B
16634 4C14           50                         push	ax
16635                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16636 4C15           E8         B96B            call	_inb_cmos
16637 4C18           44                         inc	sp
16638 4C19           44                         inc	sp
16639                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16640 4C1A           30E4                       xor	ah,ah
16641 4C1C           8946         F0            mov	-$10[bp],ax
16642                                           !BCC_EOS
16643                                           ! 2619         outb_cmos( 0xB, bRegister & ~0x40 );
16644                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
16645 4C1F           8B46         F0            mov	ax,-$10[bp]
16646 4C22           24                     BF  and	al,#$BF
16647                                           ! Debug: list unsigned int = ax+0 (used reg = )
16648 4C24           50                         push	ax
16649                                           ! Debug: list int = const $B (used reg = )
16650 4C25           B8                   000B  mov	ax,*$B
16651 4C28           50                         push	ax
16652                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16653 4C29           E8         B948            call	_outb_cmos
16654 4C2C           83C4                   04  add	sp,*4
16655                                           !BCC_EOS
16656                                           ! 2620       } else {
16657 4C2F           EB           14            jmp .37E
16658                       00004C31            .37C:
16659                                           ! 2621         ;
16660                                           !BCC_EOS
16661                                           ! 2622         FLAGS |= 0x0001;
16662                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16663 4C31           8B46         18            mov	ax,$18[bp]
16664 4C34           0C                     01  or	al,*1
16665 4C36           8946         18            mov	$18[bp],ax
16666                                           !BCC_EOS
16667                                           ! 2623         regs.u.r8.ah = 0x86;
16668                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16669 4C39           B0                     86  mov	al,#$86
16670 4C3B           8846         13            mov	$13[bp],al
16671                                           !BCC_EOS
16672                                           ! 2624         regs.u.r8.al--;
16673                                           ! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
16674 4C3E           8A46         12            mov	al,$12[bp]
16675 4C41           48                         dec	ax
16676 4C42           8846         12            mov	$12[bp],al
16677                                           !BCC_EOS
16678                                           ! 2625       }
16679                                           ! 2626       break;
16680                       00004C45            .37E:
16681                       00004C45            .37B:
16682 4C45           E9         0323            br 	.365
16683                                           !BCC_EOS
16684                                           ! 2627     }
16685                                           ! 2628     case 0x87:
16686                                           ! 2629 #asm
16687                       00004C48            .37F:
16688                                           !BCC_EOS
16689                                           !BCC_ASM
16690                       00000006            _int15_function.CX	set	6
16691                       FFFFFFF4            .int15_function.CX	set	-$C
16692                       0000002A            _int15_function.FLAGS	set	$2A
16693                       00000018            .int15_function.FLAGS	set	$18
16694                       00000001            _int15_function.irqDisable	set	1
16695                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16696                       00000028            _int15_function.DS	set	$28
16697                       00000016            .int15_function.DS	set	$16
16698                       00000004            _int15_function.DX	set	4
16699                       FFFFFFF2            .int15_function.DX	set	-$E
16700                       0000000B            _int15_function.base23_16	set	$B
16701                       FFFFFFF9            .int15_function.base23_16	set	-7
16702                       00000002            _int15_function.bRegister	set	2
16703                       FFFFFFF0            .int15_function.bRegister	set	-$10
16704                       00000026            _int15_function.ES	set	$26
16705                       00000014            .int15_function.ES	set	$14
16706                       00000010            _int15_function.ebda_seg	set	$10
16707                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16708                       0000000C            _int15_function.base15_00	set	$C
16709                       FFFFFFFA            .int15_function.base15_00	set	-6
16710                       00000008            _int15_function.ss	set	8
16711                       FFFFFFF6            .int15_function.ss	set	-$A
16712                       00000016            _int15_function.regs	set	$16
16713                       00000004            .int15_function.regs	set	4
16714                       0000000E            _int15_function.prev_a20_enable	set	$E
16715                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16716 4C48           FA                           cli
16717                                           ! 2631 endasm
16718                                           !BCC_ENDASM
16719                                           !BCC_EOS
16720                                           ! 2632       prev_a20_enable = set_enable_a20(1);
16721                                           ! Debug: list int = const 1 (used reg = )
16722 4C49           B8                   0001  mov	ax,*1
16723 4C4C           50                         push	ax
16724                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16725 4C4D           E8         CC9A            call	_set_enable_a20
16726 4C50           44                         inc	sp
16727 4C51           44                         inc	sp
16728                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
16729 4C52           8946         FC            mov	-4[bp],ax
16730                                           !BCC_EOS
16731                                           ! 2633       base15_00 = (ES << 4) + regs.u.r16.si;
16732                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16733 4C55           8B46         14            mov	ax,$14[bp]
16734 4C58           B1                     04  mov	cl,*4
16735 4C5A           D3E0                       shl	ax,cl
16736                                           ! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
16737 4C5C           0346         06            add	ax,6[bp]
16738                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16739 4C5F           8946         FA            mov	-6[bp],ax
16740                                           !BCC_EOS
16741                                           ! 2634       base23_16 = ES >> 12;
16742                                           ! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
16743 4C62           8B46         14            mov	ax,$14[bp]
16744 4C65           88E0                       mov	al,ah
16745 4C67           30E4                       xor	ah,ah
16746 4C69           B1                     04  mov	cl,*4
16747 4C6B           D3E8                       shr	ax,cl
16748                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16749 4C6D           8846         F9            mov	-7[bp],al
16750                                           !BCC_EOS
16751                                           ! 2635       if (base15_00 < (ES<<4))
16752                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16753 4C70           8B46         14            mov	ax,$14[bp]
16754 4C73           B1                     04  mov	cl,*4
16755 4C75           D3E0                       shl	ax,cl
16756                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16757 4C77           3B46         FA            cmp	ax,-6[bp]
16758 4C7A           76           07            jbe 	.380
16759                       00004C7C            .381:
16760                                           ! 2636         base23_16++;
16761                                           ! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
16762 4C7C           8A46         F9            mov	al,-7[bp]
16763 4C7F           40                         inc	ax
16764 4C80           8846         F9            mov	-7[bp],al
16765                                           !BCC_EOS
16766                                           ! 2637       write_word(ES, regs.u.r16.si+0x08+0, 47);
16767                       00004C83            .380:
16768                                           ! Debug: list int = const $2F (used reg = )
16769 4C83           B8                   002F  mov	ax,*$2F
16770 4C86           50                         push	ax
16771                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16772 4C87           8B46         06            mov	ax,6[bp]
16773                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
16774                                           ! Debug: list unsigned int = ax+8 (used reg = )
16775 4C8A           05                   0008  add	ax,*8
16776 4C8D           50                         push	ax
16777                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16778 4C8E           FF76         14            push	$14[bp]
16779                                           ! Debug: func () void = write_word+0 (used reg = )
16780 4C91           E8         B99E            call	_write_word
16781 4C94           83C4                   06  add	sp,*6
16782                                           !BCC_EOS
16783                                           ! 2638       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
16784                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16785 4C97           FF76         FA            push	-6[bp]
16786                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16787 4C9A           8B46         06            mov	ax,6[bp]
16788                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
16789                                           ! Debug: list unsigned int = ax+$A (used reg = )
16790 4C9D           05                   000A  add	ax,*$A
16791 4CA0           50                         push	ax
16792                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16793 4CA1           FF76         14            push	$14[bp]
16794                                           ! Debug: func () void = write_word+0 (used reg = )
16795 4CA4           E8         B98B            call	_write_word
16796 4CA7           83C4                   06  add	sp,*6
16797                                           !BCC_EOS
16798                                           ! 2639       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
16799                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16800 4CAA           8A46         F9            mov	al,-7[bp]
16801 4CAD           30E4                       xor	ah,ah
16802 4CAF           50                         push	ax
16803                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16804 4CB0           8B46         06            mov	ax,6[bp]
16805                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
16806                                           ! Debug: list unsigned int = ax+$C (used reg = )
16807 4CB3           05                   000C  add	ax,*$C
16808 4CB6           50                         push	ax
16809                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16810 4CB7           FF76         14            push	$14[bp]
16811                                           ! Debug: func () void = write_byte+0 (used reg = )
16812 4CBA           E8         B95D            call	_write_byte
16813 4CBD           83C4                   06  add	sp,*6
16814                                           !BCC_EOS
16815                                           ! 2640       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
16816                                           ! Debug: list int = const $93 (used reg = )
16817 4CC0           B8                   0093  mov	ax,#$93
16818 4CC3           50                         push	ax
16819                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16820 4CC4           8B46         06            mov	ax,6[bp]
16821                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
16822                                           ! Debug: list unsigned int = ax+$D (used reg = )
16823 4CC7           05                   000D  add	ax,*$D
16824 4CCA           50                         push	ax
16825                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16826 4CCB           FF76         14            push	$14[bp]
16827                                           ! Debug: func () void = write_byte+0 (used reg = )
16828 4CCE           E8         B949            call	_write_byte
16829 4CD1           83C4                   06  add	sp,*6
16830                                           !BCC_EOS
16831                                           ! 2641       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
16832                                           ! Debug: list int = const 0 (used reg = )
16833 4CD4           31C0                       xor	ax,ax
16834 4CD6           50                         push	ax
16835                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16836 4CD7           8B46         06            mov	ax,6[bp]
16837                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
16838                                           ! Debug: list unsigned int = ax+$E (used reg = )
16839 4CDA           05                   000E  add	ax,*$E
16840 4CDD           50                         push	ax
16841                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16842 4CDE           FF76         14            push	$14[bp]
16843                                           ! Debug: func () void = write_word+0 (used reg = )
16844 4CE1           E8         B94E            call	_write_word
16845 4CE4           83C4                   06  add	sp,*6
16846                                           !BCC_EOS
16847                                           ! 2642       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
16848                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16849 4CE7           B8                   FFFF  mov	ax,#$FFFF
16850 4CEA           50                         push	ax
16851                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16852 4CEB           8B46         06            mov	ax,6[bp]
16853                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
16854                                           ! Debug: list unsigned int = ax+$20 (used reg = )
16855 4CEE           05                   0020  add	ax,*$20
16856 4CF1           50                         push	ax
16857                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16858 4CF2           FF76         14            push	$14[bp]
16859                                           ! Debug: func () void = write_word+0 (used reg = )
16860 4CF5           E8         B93A            call	_write_word
16861 4CF8           83C4                   06  add	sp,*6
16862                                           !BCC_EOS
16863                                           ! 2643       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
16864                                           ! Debug: list int = const 0 (used reg = )
16865 4CFB           31C0                       xor	ax,ax
16866 4CFD           50                         push	ax
16867                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16868 4CFE           8B46         06            mov	ax,6[bp]
16869                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
16870                                           ! Debug: list unsigned int = ax+$22 (used reg = )
16871 4D01           05                   0022  add	ax,*$22
16872 4D04           50                         push	ax
16873                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16874 4D05           FF76         14            push	$14[bp]
16875                                           ! Debug: func () void = write_word+0 (used reg = )
16876 4D08           E8         B927            call	_write_word
16877 4D0B           83C4                   06  add	sp,*6
16878                                           !BCC_EOS
16879                                           ! 2644       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
16880                                           ! Debug: list int = const $F (used reg = )
16881 4D0E           B8                   000F  mov	ax,*$F
16882 4D11           50                         push	ax
16883                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16884 4D12           8B46         06            mov	ax,6[bp]
16885                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
16886                                           ! Debug: list unsigned int = ax+$24 (used reg = )
16887 4D15           05                   0024  add	ax,*$24
16888 4D18           50                         push	ax
16889                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16890 4D19           FF76         14            push	$14[bp]
16891                                           ! Debug: func () void = write_byte+0 (used reg = )
16892 4D1C           E8         B8FB            call	_write_byte
16893 4D1F           83C4                   06  add	sp,*6
16894                                           !BCC_EOS
16895                                           ! 2645       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
16896                                           ! Debug: list int = const $9B (used reg = )
16897 4D22           B8                   009B  mov	ax,#$9B
16898 4D25           50                         push	ax
16899                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16900 4D26           8B46         06            mov	ax,6[bp]
16901                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
16902                                           ! Debug: list unsigned int = ax+$25 (used reg = )
16903 4D29           05                   0025  add	ax,*$25
16904 4D2C           50                         push	ax
16905                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16906 4D2D           FF76         14            push	$14[bp]
16907                                           ! Debug: func () void = write_byte+0 (used reg = )
16908 4D30           E8         B8E7            call	_write_byte
16909 4D33           83C4                   06  add	sp,*6
16910                                           !BCC_EOS
16911                                           ! 2646       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
16912                                           ! Debug: list int = const 0 (used reg = )
16913 4D36           31C0                       xor	ax,ax
16914 4D38           50                         push	ax
16915                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16916 4D39           8B46         06            mov	ax,6[bp]
16917                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
16918                                           ! Debug: list unsigned int = ax+$26 (used reg = )
16919 4D3C           05                   0026  add	ax,*$26
16920 4D3F           50                         push	ax
16921                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16922 4D40           FF76         14            push	$14[bp]
16923                                           ! Debug: func () void = write_word+0 (used reg = )
16924 4D43           E8         B8EC            call	_write_word
16925 4D46           83C4                   06  add	sp,*6
16926                                           !BCC_EOS
16927                                           ! 2647       ss = get_SS();
16928                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
16929 4D49           E8         B901            call	_get_SS
16930                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
16931 4D4C           8946         F6            mov	-$A[bp],ax
16932                                           !BCC_EOS
16933                                           ! 2648       base15_00 = ss << 4;
16934                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
16935 4D4F           8B46         F6            mov	ax,-$A[bp]
16936 4D52           B1                     04  mov	cl,*4
16937 4D54           D3E0                       shl	ax,cl
16938                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16939 4D56           8946         FA            mov	-6[bp],ax
16940                                           !BCC_EOS
16941                                           ! 2649       base23_16 = ss >> 12;
16942                                           ! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
16943 4D59           8B46         F6            mov	ax,-$A[bp]
16944 4D5C           88E0                       mov	al,ah
16945 4D5E           30E4                       xor	ah,ah
16946 4D60           B1                     04  mov	cl,*4
16947 4D62           D3E8                       shr	ax,cl
16948                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16949 4D64           8846         F9            mov	-7[bp],al
16950                                           !BCC_EOS
16951                                           ! 2650       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
16952                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16953 4D67           B8                   FFFF  mov	ax,#$FFFF
16954 4D6A           50                         push	ax
16955                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16956 4D6B           8B46         06            mov	ax,6[bp]
16957                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
16958                                           ! Debug: list unsigned int = ax+$28 (used reg = )
16959 4D6E           05                   0028  add	ax,*$28
16960 4D71           50                         push	ax
16961                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16962 4D72           FF76         14            push	$14[bp]
16963                                           ! Debug: func () void = write_word+0 (used reg = )
16964 4D75           E8         B8BA            call	_write_word
16965 4D78           83C4                   06  add	sp,*6
16966                                           !BCC_EOS
16967                                           ! 2651       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
16968                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16969 4D7B           FF76         FA            push	-6[bp]
16970                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16971 4D7E           8B46         06            mov	ax,6[bp]
16972                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
16973                                           ! Debug: list unsigned int = ax+$2A (used reg = )
16974 4D81           05                   002A  add	ax,*$2A
16975 4D84           50                         push	ax
16976                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16977 4D85           FF76         14            push	$14[bp]
16978                                           ! Debug: func () void = write_word+0 (used reg = )
16979 4D88           E8         B8A7            call	_write_word
16980 4D8B           83C4                   06  add	sp,*6
16981                                           !BCC_EOS
16982                                           ! 2652       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
16983                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16984 4D8E           8A46         F9            mov	al,-7[bp]
16985 4D91           30E4                       xor	ah,ah
16986 4D93           50                         push	ax
16987                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16988 4D94           8B46         06            mov	ax,6[bp]
16989                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
16990                                           ! Debug: list unsigned int = ax+$2C (used reg = )
16991 4D97           05                   002C  add	ax,*$2C
16992 4D9A           50                         push	ax
16993                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16994 4D9B           FF76         14            push	$14[bp]
16995                                           ! Debug: func () void = write_byte+0 (used reg = )
16996 4D9E           E8         B879            call	_write_byte
16997 4DA1           83C4                   06  add	sp,*6
16998                                           !BCC_EOS
16999                                           ! 2653       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
17000                                           ! Debug: list int = const $93 (used reg = )
17001 4DA4           B8                   0093  mov	ax,#$93
17002 4DA7           50                         push	ax
17003                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
17004 4DA8           8B46         06            mov	ax,6[bp]
17005                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
17006                                           ! Debug: list unsigned int = ax+$2D (used reg = )
17007 4DAB           05                   002D  add	ax,*$2D
17008 4DAE           50                         push	ax
17009                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
17010 4DAF           FF76         14            push	$14[bp]
17011                                           ! Debug: func () void = write_byte+0 (used reg = )
17012 4DB2           E8         B865            call	_write_byte
17013 4DB5           83C4                   06  add	sp,*6
17014                                           !BCC_EOS
17015                                           ! 2654       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
17016                                           ! Debug: list int = const 0 (used reg = )
17017 4DB8           31C0                       xor	ax,ax
17018 4DBA           50                         push	ax
17019                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
17020 4DBB           8B46         06            mov	ax,6[bp]
17021                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
17022                                           ! Debug: list unsigned int = ax+$2E (used reg = )
17023 4DBE           05                   002E  add	ax,*$2E
17024 4DC1           50                         push	ax
17025                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
17026 4DC2           FF76         14            push	$14[bp]
17027                                           ! Debug: func () void = write_word+0 (used reg = )
17028 4DC5           E8         B86A            call	_write_word
17029 4DC8           83C4                   06  add	sp,*6
17030                                           !BCC_EOS
17031                                           ! 2655       CX = regs.u.r16.cx;
17032                                           ! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
17033 4DCB           8B46         10            mov	ax,$10[bp]
17034 4DCE           8946         F4            mov	-$C[bp],ax
17035                                           !BCC_EOS
17036                                           ! 2656 #asm
17037                                           !BCC_EOS
17038                                           !BCC_ASM
17039                       00000006            _int15_function.CX	set	6
17040                       FFFFFFF4            .int15_function.CX	set	-$C
17041                       0000002A            _int15_function.FLAGS	set	$2A
17042                       00000018            .int15_function.FLAGS	set	$18
17043                       00000001            _int15_function.irqDisable	set	1
17044                       FFFFFFEF            .int15_function.irqDisable	set	-$11
17045                       00000028            _int15_function.DS	set	$28
17046                       00000016            .int15_function.DS	set	$16
17047                       00000004            _int15_function.DX	set	4
17048                       FFFFFFF2            .int15_function.DX	set	-$E
17049                       0000000B            _int15_function.base23_16	set	$B
17050                       FFFFFFF9            .int15_function.base23_16	set	-7
17051                       00000002            _int15_function.bRegister	set	2
17052                       FFFFFFF0            .int15_function.bRegister	set	-$10
17053                       00000026            _int15_function.ES	set	$26
17054                       00000014            .int15_function.ES	set	$14
17055                       00000010            _int15_function.ebda_seg	set	$10
17056                       FFFFFFFE            .int15_function.ebda_seg	set	-2
17057                       0000000C            _int15_function.base15_00	set	$C
17058                       FFFFFFFA            .int15_function.base15_00	set	-6
17059                       00000008            _int15_function.ss	set	8
17060                       FFFFFFF6            .int15_function.ss	set	-$A
17061                       00000016            _int15_function.regs	set	$16
17062                       00000004            .int15_function.regs	set	4
17063                       0000000E            _int15_function.prev_a20_enable	set	$E
17064                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
17065 4DD1           89E3                             mov bx, sp
17066 4DD3           36                               SEG SS
17067 4DD4           8B4F         06                    mov cx, _int15_function.CX [bx]
17068 4DD7     66    50                               push eax
17069 4DD9     66    31C0                             xor eax, eax
17070 4DDC           8ED8                             mov ds, ax
17071 4DDE           8C16       0469                  mov 0x0469, ss
17072 4DE2           8926       0467                  mov 0x0467, sp
17073 4DE6           26                               SEG ES
17074 4DE7         0F0154         08                    lgdt [si + 0x08]
17075 4DEB           2E                               SEG CS
17076 4DEC         0F011E       F88C                    lidt [pmode_IDT_info]
17077                                                 ;; perhaps do something with IDT here
17078                                                 ;; set PE bit in CR0
17079 4DF1         0F20C0                             mov eax, cr0
17080 4DF4           0C                     01        or al, #0x01
17081 4DF6         0F22C0                             mov cr0, eax
17082                                                 ;; far jump to flush CPU queue after transition to protected mode
17083                                                 JMP_AP(0x0020, protected_mode)
 +a   4DF9                        EA              db 0xea
 +a   4DFA                      4DFE              dw  protected_mode
 +a   4DFC                      0020              dw 0x0020
17084                       00004DFE            protected_mode:
17085                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
17086 4DFE           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
17087 4E01           8ED0                             mov ss, ax
17088 4E03           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
17089 4E06           8ED8                             mov ds, ax
17090 4E08           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
17091 4E0B           8EC0                             mov es, ax
17092 4E0D           31F6                             xor si, si
17093 4E0F           31FF                             xor di, di
17094 4E11           FC                               cld
17095 4E12           F3                               rep
17096 4E13           A5                                 movsw ;; move CX words from DS:SI to ES:DI
17097                                                 ;; make sure DS and ES limits are 64KB
17098 4E14           B8                   0028        mov ax, #0x28
17099 4E17           8ED8                             mov ds, ax
17100 4E19           8EC0                             mov es, ax
17101                                                 ;; reset PG bit in CR0 ???
17102 4E1B         0F20C0                             mov eax, cr0
17103 4E1E           24                     FE        and al, #0xFE
17104 4E20         0F22C0                             mov cr0, eax
17105                                                 ;; far jump to flush CPU queue after transition to real mode
17106                                                 JMP_AP(0xf000, real_mode)
 +a   4E23                        EA              db 0xea
 +a   4E24                      4E28              dw  real_mode
 +a   4E26                      F000              dw 0xf000
17107                       00004E28            real_mode:
17108                                                 ;; restore IDT to normal real-mode defaults
17109 4E28           2E                               SEG CS
17110 4E29         0F011E       F891                    lidt [rmode_IDT_info]
17111 4E2E           31C0                             xor ax, ax
17112 4E30           8ED8                             mov ds, ax
17113 4E32           8E16       0469                  mov ss, 0x0469
17114 4E36           8B26       0467                  mov sp, 0x0467
17115 4E3A     66    58                               pop eax
17116                                           ! 2708 endasm
17117                                           !BCC_ENDASM
17118                                           !BCC_EOS
17119                                           ! 2709       set_enable_a20(prev_a20_enable);
17120                                           ! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
17121 4E3C           FF76         FC            push	-4[bp]
17122                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
17123 4E3F           E8         CAA8            call	_set_enable_a20
17124 4E42           44                         inc	sp
17125 4E43           44                         inc	sp
17126                                           !BCC_EOS
17127                                           ! 2710 #asm
17128                                           !BCC_EOS
17129                                           !BCC_ASM
17130                       00000006            _int15_function.CX	set	6
17131                       FFFFFFF4            .int15_function.CX	set	-$C
17132                       0000002A            _int15_function.FLAGS	set	$2A
17133                       00000018            .int15_function.FLAGS	set	$18
17134                       00000001            _int15_function.irqDisable	set	1
17135                       FFFFFFEF            .int15_function.irqDisable	set	-$11
17136                       00000028            _int15_function.DS	set	$28
17137                       00000016            .int15_function.DS	set	$16
17138                       00000004            _int15_function.DX	set	4
17139                       FFFFFFF2            .int15_function.DX	set	-$E
17140                       0000000B            _int15_function.base23_16	set	$B
17141                       FFFFFFF9            .int15_function.base23_16	set	-7
17142                       00000002            _int15_function.bRegister	set	2
17143                       FFFFFFF0            .int15_function.bRegister	set	-$10
17144                       00000026            _int15_function.ES	set	$26
17145                       00000014            .int15_function.ES	set	$14
17146                       00000010            _int15_function.ebda_seg	set	$10
17147                       FFFFFFFE            .int15_function.ebda_seg	set	-2
17148                       0000000C            _int15_function.base15_00	set	$C
17149                       FFFFFFFA            .int15_function.base15_00	set	-6
17150                       00000008            _int15_function.ss	set	8
17151                       FFFFFFF6            .int15_function.ss	set	-$A
17152                       00000016            _int15_function.regs	set	$16
17153                       00000004            .int15_function.regs	set	4
17154                       0000000E            _int15_function.prev_a20_enable	set	$E
17155                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
17156 4E44           FB                           sti
17157                                           ! 2712 endasm
17158                                           !BCC_ENDASM
17159                                           !BCC_EOS
17160                                           ! 2713       regs.u.r8.ah = 0;
17161                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
17162 4E45           30C0                       xor	al,al
17163 4E47           8846         13            mov	$13[bp],al
17164                                           !BCC_EOS
17165                                           ! 2714       FLAGS &= 0xfffe;
17166                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
17167 4E4A           8B46         18            mov	ax,$18[bp]
17168 4E4D           24                     FE  and	al,#$FE
17169 4E4F           8946         18            mov	$18[bp],ax
17170                                           !BCC_EOS
17171                                           ! 2715       break;
17172 4E52           E9         0116            br 	.365
17173                                           !BCC_EOS
17174                                           ! 2716     case 0x88:
17175                                           ! 2717       regs.u.r8.al = inb_cmos(0x30);
17176                       00004E55            .382:
17177                                           ! Debug: list int = const $30 (used reg = )
17178 4E55           B8                   0030  mov	ax,*$30
17179 4E58           50                         push	ax
17180                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17181 4E59           E8         B727            call	_inb_cmos
17182 4E5C           44                         inc	sp
17183 4E5D           44                         inc	sp
17184                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
17185 4E5E           8846         12            mov	$12[bp],al
17186                                           !BCC_EOS
17187                                           ! 2718       regs.u.r8.ah = inb_cmos(0x31);
17188                                           ! Debug: list int = const $31 (used reg = )
17189 4E61           B8                   0031  mov	ax,*$31
17190 4E64           50                         push	ax
17191                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17192 4E65           E8         B71B            call	_inb_cmos
17193 4E68           44                         inc	sp
17194 4E69           44                         inc	sp
17195                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
17196 4E6A           8846         13            mov	$13[bp],al
17197                                           !BCC_EOS
17198                                           ! 2719       if(regs.u.r16.ax > 0xffc0)
17199                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
17200 4E6D           8B46         12            mov	ax,$12[bp]
17201 4E70           3D                   FFC0  cmp	ax,#$FFC0
17202 4E73           76           06            jbe 	.383
17203                       00004E75            .384:
17204                                           ! 2720         regs.u.r16.ax = 0xffc0;
17205                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
17206 4E75           B8                   FFC0  mov	ax,#$FFC0
17207 4E78           8946         12            mov	$12[bp],ax
17208                                           !BCC_EOS
17209                                           ! 2721       FLAGS &= 0xfffe;
17210                       00004E7B            .383:
17211                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
17212 4E7B           8B46         18            mov	ax,$18[bp]
17213 4E7E           24                     FE  and	al,#$FE
17214 4E80           8946         18            mov	$18[bp],ax
17215                                           !BCC_EOS
17216                                           ! 2722       break;
17217 4E83           E9         00E5            br 	.365
17218                                           !BCC_EOS
17219                                           ! 2723     case 0x90:
17220                                           ! 2724       break;
17221                       00004E86            .385:
17222 4E86           E9         00E2            br 	.365
17223                                           !BCC_EOS
17224                                           ! 2725     case 0x91:
17225                                           ! 2726       break;
17226                       00004E89            .386:
17227 4E89           E9         00DF            br 	.365
17228                                           !BCC_EOS
17229                                           ! 2727     case 0xbf:
17230                                           ! 2728       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
17231                       00004E8C            .387:
17232                                           ! Debug: list * char = .388+0 (used reg = )
17233 4E8C           BB                   D955  mov	bx,#.388
17234 4E8F           53                         push	bx
17235                                           ! Debug: list int = const 4 (used reg = )
17236 4E90           B8                   0004  mov	ax,*4
17237 4E93           50                         push	ax
17238                                           ! Debug: func () void = bios_printf+0 (used reg = )
17239 4E94           E8         BB82            call	_bios_printf
17240 4E97           83C4                   04  add	sp,*4
17241                                           !BCC_EOS
17242                                           ! 2729       FLAGS |= 0x0001;
17243                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
17244 4E9A           8B46         18            mov	ax,$18[bp]
17245 4E9D           0C                     01  or	al,*1
17246 4E9F           8946         18            mov	$18[bp],ax
17247                                           !BCC_EOS
17248                                           ! 2730       regs.u.r8.ah = 0x86;
17249                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
17250 4EA2           B0                     86  mov	al,#$86
17251 4EA4           8846         13            mov	$13[bp],al
17252                                           !BCC_EOS
17253                                           ! 2731       break;
17254 4EA7           E9         00C1            br 	.365
17255                                           !BCC_EOS
17256                                           ! 2732     case 0xC0:
17257                                           ! 2733       FLAGS &= 0xfffe;
17258                       00004EAA            .389:
17259                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
17260 4EAA           8B46         18            mov	ax,$18[bp]
17261 4EAD           24                     FE  and	al,#$FE
17262 4EAF           8946         18            mov	$18[bp],ax
17263                                           !BCC_EOS
17264                                           ! 2734       regs.u.r8.ah = 0;
17265                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
17266 4EB2           30C0                       xor	al,al
17267 4EB4           8846         13            mov	$13[bp],al
17268                                           !BCC_EOS
17269                                           ! 2735       regs.u.r16.bx = 0xe6f5;
17270                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
17271 4EB7           B8                   E6F5  mov	ax,#$E6F5
17272 4EBA           8946         0C            mov	$C[bp],ax
17273                                           !BCC_EOS
17274                                           ! 2736       ES = 0xF000;
17275                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
17276 4EBD           B8                   F000  mov	ax,#$F000
17277 4EC0           8946         14            mov	$14[bp],ax
17278                                           !BCC_EOS
17279                                           ! 2737       break;
17280 4EC3           E9         00A5            br 	.365
17281                                           !BCC_EOS
17282                                           ! 2738     case 0xc1:
17283                                           ! 2739       ES = ebda_seg;
17284                       00004EC6            .38A:
17285                                           ! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
17286 4EC6           8B46         FE            mov	ax,-2[bp]
17287 4EC9           8946         14            mov	$14[bp],ax
17288                                           !BCC_EOS
17289                                           ! 2740       FL
17290                                           ! 2740 AGS &= 0xfffe;
17291                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
17292 4ECC           8B46         18            mov	ax,$18[bp]
17293 4ECF           24                     FE  and	al,#$FE
17294 4ED1           8946         18            mov	$18[bp],ax
17295                                           !BCC_EOS
17296                                           ! 2741       break;
17297 4ED4           E9         0094            br 	.365
17298                                           !BCC_EOS
17299                                           ! 2742     case 0xd8:
17300                                           ! 2743       bios_printf(8, "EISA BIOS not present\n");
17301                       00004ED7            .38B:
17302                                           ! Debug: list * char = .38C+0 (used reg = )
17303 4ED7           BB                   D93E  mov	bx,#.38C
17304 4EDA           53                         push	bx
17305                                           ! Debug: list int = const 8 (used reg = )
17306 4EDB           B8                   0008  mov	ax,*8
17307 4EDE           50                         push	ax
17308                                           ! Debug: func () void = bios_printf+0 (used reg = )
17309 4EDF           E8         BB37            call	_bios_printf
17310 4EE2           83C4                   04  add	sp,*4
17311                                           !BCC_EOS
17312                                           ! 2744       FLAGS |= 0x0001;
17313                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
17314 4EE5           8B46         18            mov	ax,$18[bp]
17315 4EE8           0C                     01  or	al,*1
17316 4EEA           8946         18            mov	$18[bp],ax
17317                                           !BCC_EOS
17318                                           ! 2745       regs.u.r8.ah = 0x86;
17319                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
17320 4EED           B0                     86  mov	al,#$86
17321 4EEF           8846         13            mov	$13[bp],al
17322                                           !BCC_EOS
17323                                           ! 2746       break;
17324 4EF2           E9         0076            br 	.365
17325                                           !BCC_EOS
17326                                           ! 2747     default:
17327                                           ! 2748       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17328                       00004EF5            .38D:
17329                                           ! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
17330 4EF5           FF76         0C            push	$C[bp]
17331                                           ! Debug: list unsigned short regs = [S+$16+$10] (used reg = )
17332 4EF8           FF76         12            push	$12[bp]
17333                                           ! Debug: list * char = .38E+0 (used reg = )
17334 4EFB           BB                   D904  mov	bx,#.38E
17335 4EFE           53                         push	bx
17336                                           ! Debug: list int = const 4 (used reg = )
17337 4EFF           B8                   0004  mov	ax,*4
17338 4F02           50                         push	ax
17339                                           ! Debug: func () void = bios_printf+0 (used reg = )
17340 4F03           E8         BB13            call	_bios_printf
17341 4F06           83C4                   08  add	sp,*8
17342                                           !BCC_EOS
17343                                           ! 2749       FLAGS |= 0x0001;
17344                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
17345 4F09           8B46         18            mov	ax,$18[bp]
17346 4F0C           0C                     01  or	al,*1
17347 4F0E           8946         18            mov	$18[bp],ax
17348                                           !BCC_EOS
17349                                           ! 2750       regs.u.r8.ah = 0x86;
17350                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
17351 4F11           B0                     86  mov	al,#$86
17352 4F13           8846         13            mov	$13[bp],al
17353                                           !BCC_EOS
17354                                           ! 2751       break;
17355 4F16           EB           53            jmp .365
17356                                           !BCC_EOS
17357                                           ! 2752     }
17358                                           ! 2753 }
17359 4F18           EB           51            jmp .365
17360                       00004F1A            .367:
17361 4F1A           2C                     24  sub	al,*$24
17362 4F1C         0F84         FB34            beq 	.368
17363 4F20           2C                     1D  sub	al,*$1D
17364 4F22         0F84         FBD6            beq 	.372
17365 4F26           2C                     0E  sub	al,*$E
17366 4F28         0F84         FBE0            beq 	.373
17367 4F2C           2C                     03  sub	al,*3
17368 4F2E         0F84         FBE5            beq 	.374
17369 4F32           2C                     31  sub	al,*$31
17370 4F34         0F84         FBEF            beq 	.375
17371 4F38           2C                     04  sub	al,*4
17372 4F3A         0F84         FD0A            beq 	.37F
17373 4F3E           2C                     01  sub	al,*1
17374 4F40         0F84         FF11            beq 	.382
17375 4F44           2C                     08  sub	al,*8
17376 4F46         0F84         FF3C            beq 	.385
17377 4F4A           2C                     01  sub	al,*1
17378 4F4C         0F84         FF39            beq 	.386
17379 4F50           2C                     2E  sub	al,*$2E
17380 4F52         0F84         FF36            beq 	.387
17381 4F56           2C                     01  sub	al,*1
17382 4F58         0F84         FF4E            beq 	.389
17383 4F5C           2C                     01  sub	al,*1
17384 4F5E         0F84         FF64            beq 	.38A
17385 4F62           2C                     17  sub	al,*$17
17386 4F64         0F84         FF6F            beq 	.38B
17387 4F68           E9         FF8A            br 	.38D
17388                       00004F6B            .365:
17389                       FFFFFFEC            ..FFF7	=	-$14
17390 4F6B           89EC                       mov	sp,bp
17391 4F6D           5D                         pop	bp
17392 4F6E           C3                         ret
17393                                           ! 2754   void
17394                                           ! Register BX used in function int15_function
17395                                           ! 2755 int15_function_mouse(regs, ES, DS, FLAGS)
17396                                           ! 2756   pusha_regs_t regs;
17397                                           export	_int15_function_mouse
17398                       00004F6F            _int15_function_mouse:
17399                                           !BCC_EOS
17400                                           ! 2757   Bit16u ES, DS, FLAGS;
17401                                           !BCC_EOS
17402                                           ! 2758 {
17403                                           ! 2759   Bit16u ebda_seg=read_word(0x0040,0x000E);
17404 4F6F           55                         push	bp
17405 4F70           89E5                       mov	bp,sp
17406 4F72           4C                         dec	sp
17407 4F73           4C                         dec	sp
17408                                           ! Debug: list int = const $E (used reg = )
17409 4F74           B8                   000E  mov	ax,*$E
17410 4F77           50                         push	ax
17411                                           ! Debug: list int = const $40 (used reg = )
17412 4F78           B8                   0040  mov	ax,*$40
17413 4F7B           50                         push	ax
17414                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
17415 4F7C           E8         B688            call	_read_word
17416 4F7F           83C4                   04  add	sp,*4
17417                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
17418 4F82           8946         FE            mov	-2[bp],ax
17419                                           !BCC_EOS
17420                                           ! 2760   Bit8u mouse_flags_1, mouse_flags_2;
17421                                           !BCC_EOS
17422                                           ! 2761   Bit16u mouse_driver_seg;
17423                                           !BCC_EOS
17424                                           ! 2762   Bit16u mouse_driver_offset;
17425                                           !BCC_EOS
17426                                           ! 2763   Bit8u comm_byte, prev_command_byte;
17427                                           !BCC_EOS
17428                                           ! 2764   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
17429                                           !BCC_EOS
17430                                           ! 2765 ;
17431 4F85           83C4                   F4  add	sp,*-$C
17432                                           !BCC_EOS
17433                                           ! 2766   switch (regs.u.r8.ah) {
17434 4F88           8A46         13            mov	al,$13[bp]
17435 4F8B           E9         0652            br 	.391
17436                                           ! 2767     case 0xC2:
17437                                           ! 2768       switch (regs.u.r8.al) {
17438                       00004F8E            .392:
17439 4F8E           8A46         12            mov	al,$12[bp]
17440 4F91           E9         0600            br 	.395
17441                                           ! 2769         case 0:
17442                                           ! 2770 ;
17443                       00004F94            .396:
17444                                           !BCC_EOS
17445                                           ! 2771           switch (regs.u.r8.bh) {
17446 4F94           8A46         0D            mov	al,$D[bp]
17447 4F97           E9         00E9            br 	.399
17448                                           ! 2772             case 0:
17449                                           ! 2773 ;
17450                       00004F9A            .39A:
17451                                           !BCC_EOS
17452                                           ! 2774               inhibit_mouse_int_and_events();
17453                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17454 4F9A           E8         0FEE            call	_inhibit_mouse_int_and_events
17455                                           !BCC_EOS
17456                                           ! 2775               ret = send_to_mouse_ctrl(0xF5);
17457                                           ! Debug: list int = const $F5 (used reg = )
17458 4F9D           B8                   00F5  mov	ax,#$F5
17459 4FA0           50                         push	ax
17460                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17461 4FA1           E8         1138            call	_send_to_mouse_ctrl
17462 4FA4           44                         inc	sp
17463 4FA5           44                         inc	sp
17464                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17465 4FA6           8846         F5            mov	-$B[bp],al
17466                                           !BCC_EOS
17467                                           ! 2776               if (ret == 0) {
17468                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17469 4FA9           8A46         F5            mov	al,-$B[bp]
17470 4FAC           84C0                       test	al,al
17471 4FAE           75           2B            jne 	.39B
17472                       00004FB0            .39C:
17473                                           ! 2777                 ret = get_mouse_data(&mouse_data1);
17474                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17475 4FB0           8D5E         F4            lea	bx,-$C[bp]
17476 4FB3           53                         push	bx
17477                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17478 4FB4           E8         116F            call	_get_mouse_data
17479 4FB7           44                         inc	sp
17480 4FB8           44                         inc	sp
17481                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17482 4FB9           8846         F5            mov	-$B[bp],al
17483                                           !BCC_EOS
17484                                           ! 2778                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
17485                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17486 4FBC           8A46         F5            mov	al,-$B[bp]
17487 4FBF           84C0                       test	al,al
17488 4FC1           74           07            je  	.39E
17489                       00004FC3            .39F:
17490                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17491 4FC3           8A46         F4            mov	al,-$C[bp]
17492 4FC6           3C                     FA  cmp	al,#$FA
17493 4FC8           75           11            jne 	.39D
17494                       00004FCA            .39E:
17495                                           ! 2779                   FLAGS &= 0xfffe;
17496                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17497 4FCA           8B46         18            mov	ax,$18[bp]
17498 4FCD           24                     FE  and	al,#$FE
17499 4FCF           8946         18            mov	$18[bp],ax
17500                                           !BCC_EOS
17501                                           ! 2780                   regs.u.r8.ah = 0;
17502                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17503 4FD2           30C0                       xor	al,al
17504 4FD4           8846         13            mov	$13[bp],al
17505                                           !BCC_EOS
17506                                           ! 2781                   return;
17507 4FD7           89EC                       mov	sp,bp
17508 4FD9           5D                         pop	bp
17509 4FDA           C3                         ret
17510                                           !BCC_EOS
17511                                           ! 2782                   }
17512                                           ! 2783                 }
17513                       00004FDB            .39D:
17514                                           ! 2784               FLAGS |= 0x0001;
17515                       00004FDB            .39B:
17516                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17517 4FDB           8B46         18            mov	ax,$18[bp]
17518 4FDE           0C                     01  or	al,*1
17519 4FE0           8946         18            mov	$18[bp],ax
17520                                           !BCC_EOS
17521                                           ! 2785               regs.u.r8.ah = ret;
17522                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17523 4FE3           8A46         F5            mov	al,-$B[bp]
17524 4FE6           8846         13            mov	$13[bp],al
17525                                           !BCC_EOS
17526                                           ! 2786               return;
17527 4FE9           89EC                       mov	sp,bp
17528 4FEB           5D                         pop	bp
17529 4FEC           C3                         ret
17530                                           !BCC_EOS
17531                                           ! 2787               break;
17532 4FED           E9         00A1            br 	.397
17533                                           !BCC_EOS
17534                                           ! 2788             case 1:
17535                                           ! 2789 ;
17536                       00004FF0            .3A0:
17537                                           !BCC_EOS
17538                                           ! 2790               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17539                                           ! Debug: list int = const $27 (used reg = )
17540 4FF0           B8                   0027  mov	ax,*$27
17541 4FF3           50                         push	ax
17542                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17543 4FF4           FF76         FE            push	-2[bp]
17544                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17545 4FF7           E8         B5FA            call	_read_byte
17546 4FFA           83C4                   04  add	sp,*4
17547                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17548 4FFD           8846         FC            mov	-4[bp],al
17549                                           !BCC_EOS
17550                                           ! 2791               if ( (mouse_flags_2 & 0x80) == 0 ) {
17551                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17552 5000           8A46         FC            mov	al,-4[bp]
17553 5003           24                     80  and	al,#$80
17554                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17555 5005           84C0                       test	al,al
17556 5007           75           11            jne 	.3A1
17557                       00005009            .3A2:
17558                                           ! 2792                 ;
17559                                           !BCC_EOS
17560                                           ! 2793                 FLAGS |= 0x0001;
17561                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17562 5009           8B46         18            mov	ax,$18[bp]
17563 500C           0C                     01  or	al,*1
17564 500E           8946         18            mov	$18[bp],ax
17565                                           !BCC_EOS
17566                                           ! 2794                 regs.u.r8.ah = 5;
17567                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
17568 5011           B0                     05  mov	al,*5
17569 5013           8846         13            mov	$13[bp],al
17570                                           !BCC_EOS
17571                                           ! 2795                 return;
17572 5016           89EC                       mov	sp,bp
17573 5018           5D                         pop	bp
17574 5019           C3                         ret
17575                                           !BCC_EOS
17576                                           ! 2796                 }
17577                                           ! 2797               inhibit_mouse_int_and_events();
17578                       0000501A            .3A1:
17579                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17580 501A           E8         0F6E            call	_inhibit_mouse_int_and_events
17581                                           !BCC_EOS
17582                                           ! 2798               ret = send_to_mouse_ctrl(0xF4);
17583                                           ! Debug: list int = const $F4 (used reg = )
17584 501D           B8                   00F4  mov	ax,#$F4
17585 5020           50                         push	ax
17586                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17587 5021           E8         10B8            call	_send_to_mouse_ctrl
17588 5024           44                         inc	sp
17589 5025           44                         inc	sp
17590                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17591 5026           8846         F5            mov	-$B[bp],al
17592                                           !BCC_EOS
17593                                           ! 2799               if (ret == 0) {
17594                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17595 5029           8A46         F5            mov	al,-$B[bp]
17596 502C           84C0                       test	al,al
17597 502E           75           2E            jne 	.3A3
17598                       00005030            .3A4:
17599                                           ! 2800                 ret = get_mouse_data(&mouse_data1);
17600                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17601 5030           8D5E         F4            lea	bx,-$C[bp]
17602 5033           53                         push	bx
17603                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17604 5034           E8         10EF            call	_get_mouse_data
17605 5037           44                         inc	sp
17606 5038           44                         inc	sp
17607                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17608 5039           8846         F5            mov	-$B[bp],al
17609                                           !BCC_EOS
17610                                           ! 2801                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
17611                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17612 503C           8A46         F5            mov	al,-$B[bp]
17613 503F           84C0                       test	al,al
17614 5041           75           1B            jne 	.3A5
17615                       00005043            .3A7:
17616                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17617 5043           8A46         F4            mov	al,-$C[bp]
17618 5046           3C                     FA  cmp	al,#$FA
17619 5048           75           14            jne 	.3A5
17620                       0000504A            .3A6:
17621                                           ! 2802                   enable_mouse_int_and_events();
17622                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17623 504A           E8         0FEB            call	_enable_mouse_int_and_events
17624                                           !BCC_EOS
17625                                           ! 2803                   FLAGS &= 0xfffe;
17626                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17627 504D           8B46         18            mov	ax,$18[bp]
17628 5050           24                     FE  and	al,#$FE
17629 5052           8946         18            mov	$18[bp],ax
17630                                           !BCC_EOS
17631                                           ! 2804                   regs.u.r8.ah = 0;
17632                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17633 5055           30C0                       xor	al,al
17634 5057           8846         13            mov	$13[bp],al
17635                                           !BCC_EOS
17636                                           ! 2805                   return;
17637 505A           89EC                       mov	sp,bp
17638 505C           5D                         pop	bp
17639 505D           C3                         ret
17640                                           !BCC_EOS
17641                                           ! 2806                   }
17642                                           ! 2807                 }
17643                       0000505E            .3A5:
17644                                           ! 2808               FLAGS |= 0x0001;
17645                       0000505E            .3A3:
17646                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17647 505E           8B46         18            mov	ax,$18[bp]
17648 5061           0C                     01  or	al,*1
17649 5063           8946         18            mov	$18[bp],ax
17650                                           !BCC_EOS
17651                                           ! 2809               
17652                                           ! 2809 regs.u.r8.ah = ret;
17653                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17654 5066           8A46         F5            mov	al,-$B[bp]
17655 5069           8846         13            mov	$13[bp],al
17656                                           !BCC_EOS
17657                                           ! 2810               return;
17658 506C           89EC                       mov	sp,bp
17659 506E           5D                         pop	bp
17660 506F           C3                         ret
17661                                           !BCC_EOS
17662                                           ! 2811             default:
17663                                           ! 2812               ;
17664                       00005070            .3A8:
17665                                           !BCC_EOS
17666                                           ! 2813               FLAGS |= 0x0001;
17667                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17668 5070           8B46         18            mov	ax,$18[bp]
17669 5073           0C                     01  or	al,*1
17670 5075           8946         18            mov	$18[bp],ax
17671                                           !BCC_EOS
17672                                           ! 2814               regs.u.r8.ah = 1;
17673                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
17674 5078           B0                     01  mov	al,*1
17675 507A           8846         13            mov	$13[bp],al
17676                                           !BCC_EOS
17677                                           ! 2815               return;
17678 507D           89EC                       mov	sp,bp
17679 507F           5D                         pop	bp
17680 5080           C3                         ret
17681                                           !BCC_EOS
17682                                           ! 2816             }
17683                                           ! 2817           break;
17684 5081           EB           0E            jmp .397
17685                       00005083            .399:
17686 5083           2C                     00  sub	al,*0
17687 5085         0F84         FF11            beq 	.39A
17688 5089           2C                     01  sub	al,*1
17689 508B         0F84         FF61            beq 	.3A0
17690 508F           EB           DF            jmp	.3A8
17691                       00005091            .397:
17692 5091           E9         0525            br 	.393
17693                                           !BCC_EOS
17694                                           ! 2818         case 1:
17695                                           ! 2819         case 5:
17696                       00005094            .3A9:
17697                                           ! 2820 ;
17698                       00005094            .3AA:
17699                                           !BCC_EOS
17700                                           ! 2821           if (regs.u.r8.al == 5) {
17701                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
17702 5094           8A46         12            mov	al,$12[bp]
17703 5097           3C                     05  cmp	al,*5
17704 5099           75           5E            jne 	.3AB
17705                       0000509B            .3AC:
17706                                           ! 2822             if (regs.u.r8.bh != 3) {
17707                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
17708 509B           8A46         0D            mov	al,$D[bp]
17709 509E           3C                     03  cmp	al,*3
17710 50A0           74           11            je  	.3AD
17711                       000050A2            .3AE:
17712                                           ! 2823               FLAGS |= 0x0001;
17713                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17714 50A2           8B46         18            mov	ax,$18[bp]
17715 50A5           0C                     01  or	al,*1
17716 50A7           8946         18            mov	$18[bp],ax
17717                                           !BCC_EOS
17718                                           ! 2824               regs.u.r8.ah = 0x02;
17719                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
17720 50AA           B0                     02  mov	al,*2
17721 50AC           8846         13            mov	$13[bp],al
17722                                           !BCC_EOS
17723                                           ! 2825               return;
17724 50AF           89EC                       mov	sp,bp
17725 50B1           5D                         pop	bp
17726 50B2           C3                         ret
17727                                           !BCC_EOS
17728                                           ! 2826             }
17729                                           ! 2827             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17730                       000050B3            .3AD:
17731                                           ! Debug: list int = const $27 (used reg = )
17732 50B3           B8                   0027  mov	ax,*$27
17733 50B6           50                         push	ax
17734                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17735 50B7           FF76         FE            push	-2[bp]
17736                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17737 50BA           E8         B537            call	_read_byte
17738 50BD           83C4                   04  add	sp,*4
17739                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17740 50C0           8846         FC            mov	-4[bp],al
17741                                           !BCC_EOS
17742                                           ! 2828             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
17743                                           ! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17744 50C3           8A46         FC            mov	al,-4[bp]
17745 50C6           30C0                       xor	al,al
17746                                           ! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
17747 50C8           0A46         0D            or	al,$D[bp]
17748                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17749 50CB           8846         FC            mov	-4[bp],al
17750                                           !BCC_EOS
17751                                           ! 2829             mouse_flags_1 = 0x00;
17752                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17753 50CE           30C0                       xor	al,al
17754 50D0           8846         FD            mov	-3[bp],al
17755                                           !BCC_EOS
17756                                           ! 2830             write_byte(ebda_seg, 0x0026, mouse_flags_1);
17757                                           ! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17758 50D3           8A46         FD            mov	al,-3[bp]
17759 50D6           30E4                       xor	ah,ah
17760 50D8           50                         push	ax
17761                                           ! Debug: list int = const $26 (used reg = )
17762 50D9           B8                   0026  mov	ax,*$26
17763 50DC           50                         push	ax
17764                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17765 50DD           FF76         FE            push	-2[bp]
17766                                           ! Debug: func () void = write_byte+0 (used reg = )
17767 50E0           E8         B537            call	_write_byte
17768 50E3           83C4                   06  add	sp,*6
17769                                           !BCC_EOS
17770                                           ! 2831             write_byte(ebda_seg, 0x0027, mouse_flags_2);
17771                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17772 50E6           8A46         FC            mov	al,-4[bp]
17773 50E9           30E4                       xor	ah,ah
17774 50EB           50                         push	ax
17775                                           ! Debug: list int = const $27 (used reg = )
17776 50EC           B8                   0027  mov	ax,*$27
17777 50EF           50                         push	ax
17778                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17779 50F0           FF76         FE            push	-2[bp]
17780                                           ! Debug: func () void = write_byte+0 (used reg = )
17781 50F3           E8         B524            call	_write_byte
17782 50F6           83C4                   06  add	sp,*6
17783                                           !BCC_EOS
17784                                           ! 2832           }
17785                                           ! 2833           inhibit_mouse_int_and_events();
17786                       000050F9            .3AB:
17787                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17788 50F9           E8         0E8F            call	_inhibit_mouse_int_and_events
17789                                           !BCC_EOS
17790                                           ! 2834           ret = send_to_mouse_ctrl(0xFF);
17791                                           ! Debug: list int = const $FF (used reg = )
17792 50FC           B8                   00FF  mov	ax,#$FF
17793 50FF           50                         push	ax
17794                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17795 5100           E8         0FD9            call	_send_to_mouse_ctrl
17796 5103           44                         inc	sp
17797 5104           44                         inc	sp
17798                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17799 5105           8846         F5            mov	-$B[bp],al
17800                                           !BCC_EOS
17801                                           ! 2835           if (ret == 0) {
17802                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17803 5108           8A46         F5            mov	al,-$B[bp]
17804 510B           84C0                       test	al,al
17805 510D         0F85         0089            bne 	.3AF
17806                       00005111            .3B0:
17807                                           ! 2836             ret = get_mouse_data(&mouse_data3);
17808                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
17809 5111           8D5E         F2            lea	bx,-$E[bp]
17810 5114           53                         push	bx
17811                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17812 5115           E8         100E            call	_get_mouse_data
17813 5118           44                         inc	sp
17814 5119           44                         inc	sp
17815                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17816 511A           8846         F5            mov	-$B[bp],al
17817                                           !BCC_EOS
17818                                           ! 2837             if (mouse_data3 == 0xfe) {
17819                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17820 511D           8A46         F2            mov	al,-$E[bp]
17821 5120           3C                     FE  cmp	al,#$FE
17822 5122           75           0C            jne 	.3B1
17823                       00005124            .3B2:
17824                                           ! 2838               FLAGS |= 0x0001;
17825                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17826 5124           8B46         18            mov	ax,$18[bp]
17827 5127           0C                     01  or	al,*1
17828 5129           8946         18            mov	$18[bp],ax
17829                                           !BCC_EOS
17830                                           ! 2839               return;
17831 512C           89EC                       mov	sp,bp
17832 512E           5D                         pop	bp
17833 512F           C3                         ret
17834                                           !BCC_EOS
17835                                           ! 2840             }
17836                                           ! 2841             if (mouse_data3 != 0xfa)
17837                       00005130            .3B1:
17838                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17839 5130           8A46         F2            mov	al,-$E[bp]
17840 5133           3C                     FA  cmp	al,#$FA
17841 5135           74           14            je  	.3B3
17842                       00005137            .3B4:
17843                                           ! 2842               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
17844                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17845 5137           8A46         F2            mov	al,-$E[bp]
17846 513A           30E4                       xor	ah,ah
17847 513C           50                         push	ax
17848                                           ! Debug: list * char = .3B5+0 (used reg = )
17849 513D           BB                   D8D9  mov	bx,#.3B5
17850 5140           53                         push	bx
17851                                           ! Debug: list int = const 7 (used reg = )
17852 5141           B8                   0007  mov	ax,*7
17853 5144           50                         push	ax
17854                                           ! Debug: func () void = bios_printf+0 (used reg = )
17855 5145           E8         B8D1            call	_bios_printf
17856 5148           83C4                   06  add	sp,*6
17857                                           !BCC_EOS
17858                                           ! 2843             if ( ret == 0 ) {
17859                       0000514B            .3B3:
17860                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17861 514B           8A46         F5            mov	al,-$B[bp]
17862 514E           84C0                       test	al,al
17863 5150           75           48            jne 	.3B6
17864                       00005152            .3B7:
17865                                           ! 2844               ret = get_mouse_data(&mouse_data1);
17866                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17867 5152           8D5E         F4            lea	bx,-$C[bp]
17868 5155           53                         push	bx
17869                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17870 5156           E8         0FCD            call	_get_mouse_data
17871 5159           44                         inc	sp
17872 515A           44                         inc	sp
17873                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17874 515B           8846         F5            mov	-$B[bp],al
17875                                           !BCC_EOS
17876                                           ! 2845               if ( ret == 0 ) {
17877                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17878 515E           8A46         F5            mov	al,-$B[bp]
17879 5161           84C0                       test	al,al
17880 5163           75           35            jne 	.3B8
17881                       00005165            .3B9:
17882                                           ! 2846                 ret = get_mouse_data(&mouse_data2);
17883                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17884 5165           8D5E         F3            lea	bx,-$D[bp]
17885 5168           53                         push	bx
17886                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17887 5169           E8         0FBA            call	_get_mouse_data
17888 516C           44                         inc	sp
17889 516D           44                         inc	sp
17890                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17891 516E           8846         F5            mov	-$B[bp],al
17892                                           !BCC_EOS
17893                                           ! 2847                 if ( ret == 0 ) {
17894                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17895 5171           8A46         F5            mov	al,-$B[bp]
17896 5174           84C0                       test	al,al
17897 5176         0F85         0020            bne 	.3BA
17898                       0000517A            .3BB:
17899                                           ! 2848                   enable_mouse_int_and_events();
17900                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17901 517A           E8         0EBB            call	_enable_mouse_int_and_events
17902                                           !BCC_EOS
17903                                           ! 2849                   FLAGS &= 0xfffe;
17904                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17905 517D           8B46         18            mov	ax,$18[bp]
17906 5180           24                     FE  and	al,#$FE
17907 5182           8946         18            mov	$18[bp],ax
17908                                           !BCC_EOS
17909                                           ! 2850                   regs.u.r8.ah = 0;
17910                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17911 5185           30C0                       xor	al,al
17912 5187           8846         13            mov	$13[bp],al
17913                                           !BCC_EOS
17914                                           ! 2851                   regs.u.r8.bl = mouse_data1;
17915                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
17916 518A           8A46         F4            mov	al,-$C[bp]
17917 518D           8846         0C            mov	$C[bp],al
17918                                           !BCC_EOS
17919                                           ! 2852                   regs.u.r8.bh = mouse_data2;
17920                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
17921 5190           8A46         F3            mov	al,-$D[bp]
17922 5193           8846         0D            mov	$D[bp],al
17923                                           !BCC_EOS
17924                                           ! 2853                   return;
17925 5196           89EC                       mov	sp,bp
17926 5198           5D                         pop	bp
17927 5199           C3                         ret
17928                                           !BCC_EOS
17929                                           ! 2854                   }
17930                                           ! 2855                 }
17931                       0000519A            .3BA:
17932                                           ! 2856               }
17933                       0000519A            .3B8:
17934                                           ! 2857             }
17935                       0000519A            .3B6:
17936                                           ! 2858           FLAGS |= 0x0001;
17937                       0000519A            .3AF:
17938                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17939 519A           8B46         18            mov	ax,$18[bp]
17940 519D           0C                     01  or	al,*1
17941 519F           8946         18            mov	$18[bp],ax
17942                                           !BCC_EOS
17943                                           ! 2859           regs.u.r8.ah = ret;
17944                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17945 51A2           8A46         F5            mov	al,-$B[bp]
17946 51A5           8846         13            mov	$13[bp],al
17947                                           !BCC_EOS
17948                                           ! 2860           return;
17949 51A8           89EC                       mov	sp,bp
17950 51AA           5D                         pop	bp
17951 51AB           C3                         ret
17952                                           !BCC_EOS
17953                                           ! 2861         case 2:
17954                                           ! 2862 ;
17955                       000051AC            .3BC:
17956                                           !BCC_EOS
17957                                           ! 2863           switch (regs.u.r8.bh) {
17958 51AC           8A46         0D            mov	al,$D[bp]
17959 51AF           EB           38            jmp .3BF
17960                                           ! 2864             case 0: mouse_data1 = 10; break;
17961                       000051B1            .3C0:
17962                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17963 51B1           B0                     0A  mov	al,*$A
17964 51B3           8846         F4            mov	-$C[bp],al
17965                                           !BCC_EOS
17966 51B6           EB           54            jmp .3BD
17967                                           !BCC_EOS
17968                                           ! 2865             case 1: mouse_data1 = 20; break;
17969                       000051B8            .3C1:
17970                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17971 51B8           B0                     14  mov	al,*$14
17972 51BA           8846         F4            mov	-$C[bp],al
17973                                           !BCC_EOS
17974 51BD           EB           4D            jmp .3BD
17975                                           !BCC_EOS
17976                                           ! 2866             case 2: mouse_data1 = 40; break;
17977                       000051BF            .3C2:
17978                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17979 51BF           B0                     28  mov	al,*$28
17980 51C1           8846         F4            mov	-$C[bp],al
17981                                           !BCC_EOS
17982 51C4           EB           46            jmp .3BD
17983                                           !BCC_EOS
17984                                           ! 2867             case 3: mouse_data1 = 60; break;
17985                       000051C6            .3C3:
17986                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17987 51C6           B0                     3C  mov	al,*$3C
17988 51C8           8846         F4            mov	-$C[bp],al
17989                                           !BCC_EOS
17990 51CB           EB           3F            jmp .3BD
17991                                           !BCC_EOS
17992                                           ! 2868             case 4: mouse_data1 = 80; break;
17993                       000051CD            .3C4:
17994                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17995 51CD           B0                     50  mov	al,*$50
17996 51CF           8846         F4            mov	-$C[bp],al
17997                                           !BCC_EOS
17998 51D2           EB           38            jmp .3BD
17999                                           !BCC_EOS
18000                                           ! 2869             case 5: mouse_data1 = 100; break;
18001                       000051D4            .3C5:
18002                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18003 51D4           B0                     64  mov	al,*$64
18004 51D6           8846         F4            mov	-$C[bp],al
18005                                           !BCC_EOS
18006 51D9           EB           31            jmp .3BD
18007                                           !BCC_EOS
18008                                           ! 2870             case 6: mouse_data1 = 200; break;
18009                       000051DB            .3C6:
18010                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18011 51DB           B0                     C8  mov	al,#$C8
18012 51DD           8846         F4            mov	-$C[bp],al
18013                                           !BCC_EOS
18014 51E0           EB           2A            jmp .3BD
18015                                           !BCC_EOS
18016                                           ! 2871   
18017                                           ! 2871           default: mouse_data1 = 0;
18018                       000051E2            .3C7:
18019                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18020 51E2           30C0                       xor	al,al
18021 51E4           8846         F4            mov	-$C[bp],al
18022                                           !BCC_EOS
18023                                           ! 2872           }
18024                                           ! 2873           if (mouse_data1 > 0) {
18025 51E7           EB           23            jmp .3BD
18026                       000051E9            .3BF:
18027 51E9           2C                     00  sub	al,*0
18028 51EB           72           F5            jb 	.3C7
18029 51ED           3C                     06  cmp	al,*6
18030 51EF           77           19            ja  	.3C8
18031 51F1           30E4                       xor	ah,ah
18032 51F3           D1E0                       shl	ax,*1
18033 51F5           89C3                       mov	bx,ax
18034 51F7           2E                         seg	cs
18035 51F8           FFA7       51FC            br	.3C9[bx]
18036                       000051FC            .3C9:
18037 51FC                      51B1            .word	.3C0
18038 51FE                      51B8            .word	.3C1
18039 5200                      51BF            .word	.3C2
18040 5202                      51C6            .word	.3C3
18041 5204                      51CD            .word	.3C4
18042 5206                      51D4            .word	.3C5
18043 5208                      51DB            .word	.3C6
18044                       0000520A            .3C8:
18045 520A           EB           D6            jmp	.3C7
18046                       0000520C            .3BD:
18047                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18048 520C           8A46         F4            mov	al,-$C[bp]
18049 520F           84C0                       test	al,al
18050 5211           74           57            je  	.3CA
18051                       00005213            .3CB:
18052                                           ! 2874             ret = send_to_mouse_ctrl(0xF3);
18053                                           ! Debug: list int = const $F3 (used reg = )
18054 5213           B8                   00F3  mov	ax,#$F3
18055 5216           50                         push	ax
18056                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18057 5217           E8         0EC2            call	_send_to_mouse_ctrl
18058 521A           44                         inc	sp
18059 521B           44                         inc	sp
18060                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18061 521C           8846         F5            mov	-$B[bp],al
18062                                           !BCC_EOS
18063                                           ! 2875             if (ret == 0) {
18064                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18065 521F           8A46         F5            mov	al,-$B[bp]
18066 5222           84C0                       test	al,al
18067 5224           75           35            jne 	.3CC
18068                       00005226            .3CD:
18069                                           ! 2876               ret = get_mouse_data(&mouse_data2);
18070                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18071 5226           8D5E         F3            lea	bx,-$D[bp]
18072 5229           53                         push	bx
18073                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18074 522A           E8         0EF9            call	_get_mouse_data
18075 522D           44                         inc	sp
18076 522E           44                         inc	sp
18077                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18078 522F           8846         F5            mov	-$B[bp],al
18079                                           !BCC_EOS
18080                                           ! 2877               ret = send_to_mouse_ctrl(mouse_data1);
18081                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18082 5232           8A46         F4            mov	al,-$C[bp]
18083 5235           30E4                       xor	ah,ah
18084 5237           50                         push	ax
18085                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18086 5238           E8         0EA1            call	_send_to_mouse_ctrl
18087 523B           44                         inc	sp
18088 523C           44                         inc	sp
18089                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18090 523D           8846         F5            mov	-$B[bp],al
18091                                           !BCC_EOS
18092                                           ! 2878               ret = get_mouse_data(&mouse_data2);
18093                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18094 5240           8D5E         F3            lea	bx,-$D[bp]
18095 5243           53                         push	bx
18096                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18097 5244           E8         0EDF            call	_get_mouse_data
18098 5247           44                         inc	sp
18099 5248           44                         inc	sp
18100                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18101 5249           8846         F5            mov	-$B[bp],al
18102                                           !BCC_EOS
18103                                           ! 2879               FLAGS &= 0xfffe;
18104                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18105 524C           8B46         18            mov	ax,$18[bp]
18106 524F           24                     FE  and	al,#$FE
18107 5251           8946         18            mov	$18[bp],ax
18108                                           !BCC_EOS
18109                                           ! 2880               regs.u.r8.ah = 0;
18110                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18111 5254           30C0                       xor	al,al
18112 5256           8846         13            mov	$13[bp],al
18113                                           !BCC_EOS
18114                                           ! 2881             } else {
18115 5259           EB           0D            jmp .3CE
18116                       0000525B            .3CC:
18117                                           ! 2882               FLAGS |= 0x0001;
18118                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18119 525B           8B46         18            mov	ax,$18[bp]
18120 525E           0C                     01  or	al,*1
18121 5260           8946         18            mov	$18[bp],ax
18122                                           !BCC_EOS
18123                                           ! 2883               regs.u.r8.ah = 0x86;
18124                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18125 5263           B0                     86  mov	al,#$86
18126 5265           8846         13            mov	$13[bp],al
18127                                           !BCC_EOS
18128                                           ! 2884             }
18129                                           ! 2885           } else {
18130                       00005268            .3CE:
18131 5268           EB           0D            jmp .3CF
18132                       0000526A            .3CA:
18133                                           ! 2886             FLAGS |= 0x0001;
18134                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18135 526A           8B46         18            mov	ax,$18[bp]
18136 526D           0C                     01  or	al,*1
18137 526F           8946         18            mov	$18[bp],ax
18138                                           !BCC_EOS
18139                                           ! 2887             regs.u.r8.ah = 0x86;
18140                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18141 5272           B0                     86  mov	al,#$86
18142 5274           8846         13            mov	$13[bp],al
18143                                           !BCC_EOS
18144                                           ! 2888           }
18145                                           ! 2889           break;
18146                       00005277            .3CF:
18147 5277           E9         033F            br 	.393
18148                                           !BCC_EOS
18149                                           ! 2890         case 3:
18150                                           ! 2891 ;
18151                       0000527A            .3D0:
18152                                           !BCC_EOS
18153                                           ! 2892           comm_byte = inhibit_mouse_int_and_events();
18154                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18155 527A           E8         0D0E            call	_inhibit_mouse_int_and_events
18156                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18157 527D           8846         F7            mov	-9[bp],al
18158                                           !BCC_EOS
18159                                           ! 2893           if (regs.u.r8.bh < 4) {
18160                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
18161 5280           8A46         0D            mov	al,$D[bp]
18162 5283           3C                     04  cmp	al,*4
18163 5285         0F83         008D            bhis	.3D1
18164                       00005289            .3D2:
18165                                           ! 2894             ret = send_to_mouse_ctrl(0xE8);
18166                                           ! Debug: list int = const $E8 (used reg = )
18167 5289           B8                   00E8  mov	ax,#$E8
18168 528C           50                         push	ax
18169                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18170 528D           E8         0E4C            call	_send_to_mouse_ctrl
18171 5290           44                         inc	sp
18172 5291           44                         inc	sp
18173                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18174 5292           8846         F5            mov	-$B[bp],al
18175                                           !BCC_EOS
18176                                           ! 2895             if (ret == 0) {
18177                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18178 5295           8A46         F5            mov	al,-$B[bp]
18179 5298           84C0                       test	al,al
18180 529A           75           6B            jne 	.3D3
18181                       0000529C            .3D4:
18182                                           ! 2896               ret = get_mouse_data(&mouse_data1);
18183                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18184 529C           8D5E         F4            lea	bx,-$C[bp]
18185 529F           53                         push	bx
18186                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18187 52A0           E8         0E83            call	_get_mouse_data
18188 52A3           44                         inc	sp
18189 52A4           44                         inc	sp
18190                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18191 52A5           8846         F5            mov	-$B[bp],al
18192                                           !BCC_EOS
18193                                           ! 2897               if (mouse_data1 != 0xfa)
18194                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18195 52A8           8A46         F4            mov	al,-$C[bp]
18196 52AB           3C                     FA  cmp	al,#$FA
18197 52AD           74           14            je  	.3D5
18198                       000052AF            .3D6:
18199                                           ! 2898                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18200                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18201 52AF           8A46         F4            mov	al,-$C[bp]
18202 52B2           30E4                       xor	ah,ah
18203 52B4           50                         push	ax
18204                                           ! Debug: list * char = .3D7+0 (used reg = )
18205 52B5           BB                   D8AD  mov	bx,#.3D7
18206 52B8           53                         push	bx
18207                                           ! Debug: list int = const 7 (used reg = )
18208 52B9           B8                   0007  mov	ax,*7
18209 52BC           50                         push	ax
18210                                           ! Debug: func () void = bios_printf+0 (used reg = )
18211 52BD           E8         B759            call	_bios_printf
18212 52C0           83C4                   06  add	sp,*6
18213                                           !BCC_EOS
18214                                           ! 2899               ret = send_to_mouse_ctrl(regs.u.r8.bh);
18215                       000052C3            .3D5:
18216                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18217 52C3           8A46         0D            mov	al,$D[bp]
18218 52C6           30E4                       xor	ah,ah
18219 52C8           50                         push	ax
18220                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18221 52C9           E8         0E10            call	_send_to_mouse_ctrl
18222 52CC           44                         inc	sp
18223 52CD           44                         inc	sp
18224                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18225 52CE           8846         F5            mov	-$B[bp],al
18226                                           !BCC_EOS
18227                                           ! 2900               ret = get_mouse_data(&mouse_data1);
18228                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18229 52D1           8D5E         F4            lea	bx,-$C[bp]
18230 52D4           53                         push	bx
18231                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18232 52D5           E8         0E4E            call	_get_mouse_data
18233 52D8           44                         inc	sp
18234 52D9           44                         inc	sp
18235                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18236 52DA           8846         F5            mov	-$B[bp],al
18237                                           !BCC_EOS
18238                                           ! 2901               if (mouse_data1 != 0xfa)
18239                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18240 52DD           8A46         F4            mov	al,-$C[bp]
18241 52E0           3C                     FA  cmp	al,#$FA
18242 52E2           74           14            je  	.3D8
18243                       000052E4            .3D9:
18244                                           ! 2902                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18245                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18246 52E4           8A46         F4            mov	al,-$C[bp]
18247 52E7           30E4                       xor	ah,ah
18248 52E9           50                         push	ax
18249                                           ! Debug: list * char = .3DA+0 (used reg = )
18250 52EA           BB                   D881  mov	bx,#.3DA
18251 52ED           53                         push	bx
18252                                           ! Debug: list int = const 7 (used reg = )
18253 52EE           B8                   0007  mov	ax,*7
18254 52F1           50                         push	ax
18255                                           ! Debug: func () void = bios_printf+0 (used reg = )
18256 52F2           E8         B724            call	_bios_printf
18257 52F5           83C4                   06  add	sp,*6
18258                                           !BCC_EOS
18259                                           ! 2903               FLAGS &= 0xfffe;
18260                       000052F8            .3D8:
18261                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18262 52F8           8B46         18            mov	ax,$18[bp]
18263 52FB           24                     FE  and	al,#$FE
18264 52FD           8946         18            mov	$18[bp],ax
18265                                           !BCC_EOS
18266                                           ! 2904               regs.u.r8.ah = 0;
18267                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18268 5300           30C0                       xor	al,al
18269 5302           8846         13            mov	$13[bp],al
18270                                           !BCC_EOS
18271                                           ! 2905             } else {
18272 5305           EB           0D            jmp .3DB
18273                       00005307            .3D3:
18274                                           ! 2906               FLAGS |= 0x0001;
18275                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18276 5307           8B46         18            mov	ax,$18[bp]
18277 530A           0C                     01  or	al,*1
18278 530C           8946         18            mov	$18[bp],ax
18279                                           !BCC_EOS
18280                                           ! 2907               regs.u.r8.ah = 0x86;
18281                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18282 530F           B0                     86  mov	al,#$86
18283 5311           8846         13            mov	$13[bp],al
18284                                           !BCC_EOS
18285                                           ! 2908             }
18286                                           ! 2909           } else {
18287                       00005314            .3DB:
18288 5314           EB           0D            jmp .3DC
18289                       00005316            .3D1:
18290                                           ! 2910             FLAGS |= 0x0001;
18291                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18292 5316           8B46         18            mov	ax,$18[bp]
18293 5319           0C                     01  or	al,*1
18294 531B           8946         18            mov	$18[bp],ax
18295                                           !BCC_EOS
18296                                           ! 2911             regs.u.r8.ah = 0x86;
18297                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18298 531E           B0                     86  mov	al,#$86
18299 5320           8846         13            mov	$13[bp],al
18300                                           !BCC_EOS
18301                                           ! 2912           }
18302                                           ! 2913           set_kbd_command_byte(comm_byte);
18303                       00005323            .3DC:
18304                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18305 5323           8A46         F7            mov	al,-9[bp]
18306 5326           30E4                       xor	ah,ah
18307 5328           50                         push	ax
18308                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18309 5329           E8         0E3B            call	_set_kbd_command_byte
18310 532C           44                         inc	sp
18311 532D           44                         inc	sp
18312                                           !BCC_EOS
18313                                           ! 2914           break;
18314 532E           E9         0288            br 	.393
18315                                           !BCC_EOS
18316                                           ! 2915         case 4:
18317                                           ! 2916 ;
18318                       00005331            .3DD:
18319                                           !BCC_EOS
18320                                           ! 2917           inhibit_mouse_int_and_events();
18321                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18322 5331           E8         0C57            call	_inhibit_mouse_int_and_events
18323                                           !BCC_EOS
18324                                           ! 2918           ret = send_to_mouse_ctrl(0xF2);
18325                                           ! Debug: list int = const $F2 (used reg = )
18326 5334           B8                   00F2  mov	ax,#$F2
18327 5337           50                         push	ax
18328                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18329 5338           E8         0DA1            call	_send_to_mouse_ctrl
18330 533B           44                         inc	sp
18331 533C           44                         inc	sp
18332                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18333 533D           8846         F5            mov	-$B[bp],al
18334                                           !BCC_EOS
18335                                           ! 2919           if (ret == 0) {
18336                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18337 5340           8A46         F5            mov	al,-$B[bp]
18338 5343           84C0                       test	al,al
18339 5345           75           2D            jne 	.3DE
18340                       00005347            .3DF:
18341                                           ! 2920             ret = get_mouse_data(&mouse_data1);
18342                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18343 5347           8D5E         F4            lea	bx,-$C[bp]
18344 534A           53                         push	bx
18345                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18346 534B           E8         0DD8            call	_get_mouse_data
18347 534E           44                         inc	sp
18348 534F           44                         inc	sp
18349                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18350 5350           8846         F5            mov	-$B[bp],al
18351                                           !BCC_EOS
18352                                           ! 2921             ret = get_mouse_data(&mouse_data2);
18353                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18354 5353           8D5E         F3            lea	bx,-$D[bp]
18355 5356           53                         push	bx
18356                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18357 5357           E8         0DCC            call	_get_mouse_data
18358 535A           44                         inc	sp
18359 535B           44                         inc	sp
18360                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18361 535C           8846         F5            mov	-$B[bp],al
18362                                           !BCC_EOS
18363                                           ! 2922             FLAGS &= 0xfffe;
18364                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18365 535F           8B46         18            mov	ax,$18[bp]
18366 5362           24                     FE  and	al,#$FE
18367 5364           8946         18            mov	$18[bp],ax
18368                                           !BCC_EOS
18369                                           ! 2923             regs.u.r8.ah = 0;
18370                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18371 5367           30C0                       xor	al,al
18372 5369           8846         13            mov	$13[bp],al
18373                                           !BCC_EOS
18374                                           ! 2924             regs.u.r8.bh = mouse_data2;
18375                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
18376 536C           8A46         F3            mov	al,-$D[bp]
18377 536F           8846         0D            mov	$D[bp],al
18378                                           !BCC_EOS
18379                                           ! 2925           } else {
18380 5372           EB           0D            jmp .3E0
18381                       00005374            .3DE:
18382                                           ! 2926             FLAGS |= 0x0001;
18383                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18384 5374           8B46         18            mov	ax,$18[bp]
18385 5377           0C                     01  or	al,*1
18386 5379           8946         18            mov	$18[bp],ax
18387                                           !BCC_EOS
18388                                           ! 2927             regs.u.r8.ah = 0x86;
18389                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18390 537C           B0                     86  mov	al,#$86
18391 537E           8846         13            mov	$13[bp],al
18392                                           !BCC_EOS
18393                                           ! 2928           }
18394                                           ! 2929           break;
18395                       00005381            .3E0:
18396 5381           E9         0235            br 	.393
18397                                           !BCC_EOS
18398                                           ! 2930         case 6:
18399                                           ! 2931 ;
18400                       00005384            .3E1:
18401                                           !BCC_EOS
18402                                           ! 2932           switch (regs.u.r8.bh) {
18403 5384           8A46         0D            mov	al,$D[bp]
18404 5387           E9         015A            br 	.3E4
18405                                           ! 2933             case 0:
18406                                           ! 2934           
18407                                           ! 2934     comm_byte = inhibit_mouse_int_and_events();
18408                       0000538A            .3E5:
18409                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18410 538A           E8         0BFE            call	_inhibit_mouse_int_and_events
18411                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18412 538D           8846         F7            mov	-9[bp],al
18413                                           !BCC_EOS
18414                                           ! 2935               ret = send_to_mouse_ctrl(0xE9);
18415                                           ! Debug: list int = const $E9 (used reg = )
18416 5390           B8                   00E9  mov	ax,#$E9
18417 5393           50                         push	ax
18418                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18419 5394           E8         0D45            call	_send_to_mouse_ctrl
18420 5397           44                         inc	sp
18421 5398           44                         inc	sp
18422                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18423 5399           8846         F5            mov	-$B[bp],al
18424                                           !BCC_EOS
18425                                           ! 2936               if (ret == 0) {
18426                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18427 539C           8A46         F5            mov	al,-$B[bp]
18428 539F           84C0                       test	al,al
18429 53A1         0F85         0095            bne 	.3E6
18430                       000053A5            .3E7:
18431                                           ! 2937                 ret = get_mouse_data(&mouse_data1);
18432                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18433 53A5           8D5E         F4            lea	bx,-$C[bp]
18434 53A8           53                         push	bx
18435                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18436 53A9           E8         0D7A            call	_get_mouse_data
18437 53AC           44                         inc	sp
18438 53AD           44                         inc	sp
18439                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18440 53AE           8846         F5            mov	-$B[bp],al
18441                                           !BCC_EOS
18442                                           ! 2938                 if (mouse_data1 != 0xfa)
18443                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18444 53B1           8A46         F4            mov	al,-$C[bp]
18445 53B4           3C                     FA  cmp	al,#$FA
18446 53B6           74           14            je  	.3E8
18447                       000053B8            .3E9:
18448                                           ! 2939                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18449                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18450 53B8           8A46         F4            mov	al,-$C[bp]
18451 53BB           30E4                       xor	ah,ah
18452 53BD           50                         push	ax
18453                                           ! Debug: list * char = .3EA+0 (used reg = )
18454 53BE           BB                   D855  mov	bx,#.3EA
18455 53C1           53                         push	bx
18456                                           ! Debug: list int = const 7 (used reg = )
18457 53C2           B8                   0007  mov	ax,*7
18458 53C5           50                         push	ax
18459                                           ! Debug: func () void = bios_printf+0 (used reg = )
18460 53C6           E8         B650            call	_bios_printf
18461 53C9           83C4                   06  add	sp,*6
18462                                           !BCC_EOS
18463                                           ! 2940                 if (ret == 0) {
18464                       000053CC            .3E8:
18465                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18466 53CC           8A46         F5            mov	al,-$B[bp]
18467 53CF           84C0                       test	al,al
18468 53D1           75           67            jne 	.3EB
18469                       000053D3            .3EC:
18470                                           ! 2941                   ret = get_mouse_data(&mouse_data1);
18471                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18472 53D3           8D5E         F4            lea	bx,-$C[bp]
18473 53D6           53                         push	bx
18474                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18475 53D7           E8         0D4C            call	_get_mouse_data
18476 53DA           44                         inc	sp
18477 53DB           44                         inc	sp
18478                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18479 53DC           8846         F5            mov	-$B[bp],al
18480                                           !BCC_EOS
18481                                           ! 2942                   if ( ret == 0 ) {
18482                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18483 53DF           8A46         F5            mov	al,-$B[bp]
18484 53E2           84C0                       test	al,al
18485 53E4           75           54            jne 	.3ED
18486                       000053E6            .3EE:
18487                                           ! 2943                     ret = get_mouse_data(&mouse_data2);
18488                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18489 53E6           8D5E         F3            lea	bx,-$D[bp]
18490 53E9           53                         push	bx
18491                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18492 53EA           E8         0D39            call	_get_mouse_data
18493 53ED           44                         inc	sp
18494 53EE           44                         inc	sp
18495                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18496 53EF           8846         F5            mov	-$B[bp],al
18497                                           !BCC_EOS
18498                                           ! 2944                     if ( ret == 0 ) {
18499                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18500 53F2           8A46         F5            mov	al,-$B[bp]
18501 53F5           84C0                       test	al,al
18502 53F7           75           41            jne 	.3EF
18503                       000053F9            .3F0:
18504                                           ! 2945                       ret = get_mouse_data(&mouse_data3);
18505                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
18506 53F9           8D5E         F2            lea	bx,-$E[bp]
18507 53FC           53                         push	bx
18508                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18509 53FD           E8         0D26            call	_get_mouse_data
18510 5400           44                         inc	sp
18511 5401           44                         inc	sp
18512                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18513 5402           8846         F5            mov	-$B[bp],al
18514                                           !BCC_EOS
18515                                           ! 2946                       if ( ret == 0 ) {
18516                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18517 5405           8A46         F5            mov	al,-$B[bp]
18518 5408           84C0                       test	al,al
18519 540A           75           2E            jne 	.3F1
18520                       0000540C            .3F2:
18521                                           ! 2947                         FLAGS &= 0xfffe;
18522                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18523 540C           8B46         18            mov	ax,$18[bp]
18524 540F           24                     FE  and	al,#$FE
18525 5411           8946         18            mov	$18[bp],ax
18526                                           !BCC_EOS
18527                                           ! 2948                         regs.u.r8.ah = 0;
18528                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18529 5414           30C0                       xor	al,al
18530 5416           8846         13            mov	$13[bp],al
18531                                           !BCC_EOS
18532                                           ! 2949                         regs.u.r8.bl = mouse_data1;
18533                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
18534 5419           8A46         F4            mov	al,-$C[bp]
18535 541C           8846         0C            mov	$C[bp],al
18536                                           !BCC_EOS
18537                                           ! 2950                         regs.u.r8.cl = mouse_data2;
18538                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
18539 541F           8A46         F3            mov	al,-$D[bp]
18540 5422           8846         10            mov	$10[bp],al
18541                                           !BCC_EOS
18542                                           ! 2951                         regs.u.r8.dl = mouse_data3;
18543                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
18544 5425           8A46         F2            mov	al,-$E[bp]
18545 5428           8846         0E            mov	$E[bp],al
18546                                           !BCC_EOS
18547                                           ! 2952                         set_kbd_command_byte(comm_byte);
18548                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18549 542B           8A46         F7            mov	al,-9[bp]
18550 542E           30E4                       xor	ah,ah
18551 5430           50                         push	ax
18552                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18553 5431           E8         0D33            call	_set_kbd_command_byte
18554 5434           44                         inc	sp
18555 5435           44                         inc	sp
18556                                           !BCC_EOS
18557                                           ! 2953                         return;
18558 5436           89EC                       mov	sp,bp
18559 5438           5D                         pop	bp
18560 5439           C3                         ret
18561                                           !BCC_EOS
18562                                           ! 2954                         }
18563                                           ! 2955                       }
18564                       0000543A            .3F1:
18565                                           ! 2956                     }
18566                       0000543A            .3EF:
18567                                           ! 2957                   }
18568                       0000543A            .3ED:
18569                                           ! 2958                 }
18570                       0000543A            .3EB:
18571                                           ! 2959               FLAGS |= 0x0001;
18572                       0000543A            .3E6:
18573                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18574 543A           8B46         18            mov	ax,$18[bp]
18575 543D           0C                     01  or	al,*1
18576 543F           8946         18            mov	$18[bp],ax
18577                                           !BCC_EOS
18578                                           ! 2960               regs.u.r8.ah = ret;
18579                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
18580 5442           8A46         F5            mov	al,-$B[bp]
18581 5445           8846         13            mov	$13[bp],al
18582                                           !BCC_EOS
18583                                           ! 2961               set_kbd_command_byte(comm_byte);
18584                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18585 5448           8A46         F7            mov	al,-9[bp]
18586 544B           30E4                       xor	ah,ah
18587 544D           50                         push	ax
18588                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18589 544E           E8         0D16            call	_set_kbd_command_byte
18590 5451           44                         inc	sp
18591 5452           44                         inc	sp
18592                                           !BCC_EOS
18593                                           ! 2962               return;
18594 5453           89EC                       mov	sp,bp
18595 5455           5D                         pop	bp
18596 5456           C3                         ret
18597                                           !BCC_EOS
18598                                           ! 2963             case 1:
18599                                           ! 2964             case 2:
18600                       00005457            .3F3:
18601                                           ! 2965               comm_byte = inhibit_mouse_int_and_events();
18602                       00005457            .3F4:
18603                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18604 5457           E8         0B31            call	_inhibit_mouse_int_and_events
18605                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18606 545A           8846         F7            mov	-9[bp],al
18607                                           !BCC_EOS
18608                                           ! 2966               if (regs.u.r8.bh == 1) {
18609                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
18610 545D           8A46         0D            mov	al,$D[bp]
18611 5460           3C                     01  cmp	al,*1
18612 5462           75           0E            jne 	.3F5
18613                       00005464            .3F6:
18614                                           ! 2967                 ret = send_to_mouse_ctrl(0xE6);
18615                                           ! Debug: list int = const $E6 (used reg = )
18616 5464           B8                   00E6  mov	ax,#$E6
18617 5467           50                         push	ax
18618                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18619 5468           E8         0C71            call	_send_to_mouse_ctrl
18620 546B           44                         inc	sp
18621 546C           44                         inc	sp
18622                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18623 546D           8846         F5            mov	-$B[bp],al
18624                                           !BCC_EOS
18625                                           ! 2968               } else {
18626 5470           EB           0C            jmp .3F7
18627                       00005472            .3F5:
18628                                           ! 2969                 ret = send_to_mouse_ctrl(0xE7);
18629                                           ! Debug: list int = const $E7 (used reg = )
18630 5472           B8                   00E7  mov	ax,#$E7
18631 5475           50                         push	ax
18632                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18633 5476           E8         0C63            call	_send_to_mouse_ctrl
18634 5479           44                         inc	sp
18635 547A           44                         inc	sp
18636                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18637 547B           8846         F5            mov	-$B[bp],al
18638                                           !BCC_EOS
18639                                           ! 2970               }
18640                                           ! 2971               if (ret == 0) {
18641                       0000547E            .3F7:
18642                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18643 547E           8A46         F5            mov	al,-$B[bp]
18644 5481           84C0                       test	al,al
18645 5483           75           19            jne 	.3F8
18646                       00005485            .3F9:
18647                                           ! 2972                 get_mouse_data(&mouse_data1);
18648                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18649 5485           8D5E         F4            lea	bx,-$C[bp]
18650 5488           53                         push	bx
18651                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18652 5489           E8         0C9A            call	_get_mouse_data
18653 548C           44                         inc	sp
18654 548D           44                         inc	sp
18655                                           !BCC_EOS
18656                                           ! 2973                 ret = (mouse_data1 != 0xFA);
18657                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18658 548E           8A46         F4            mov	al,-$C[bp]
18659 5491           3C                     FA  cmp	al,#$FA
18660 5493           74           04            je 	.3FA
18661 5495           B0                     01  mov	al,*1
18662 5497           EB           02            jmp	.3FB
18663                       00005499            .3FA:
18664 5499           30C0                       xor	al,al
18665                       0000549B            .3FB:
18666                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18667 549B           8846         F5            mov	-$B[bp],al
18668                                           !BCC_EOS
18669                                           ! 2974               }
18670                                           ! 2975               if (ret == 0) {
18671                       0000549E            .3F8:
18672                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18673 549E           8A46         F5            mov	al,-$B[bp]
18674 54A1           84C0                       test	al,al
18675 54A3           75           0F            jne 	.3FC
18676                       000054A5            .3FD:
18677                                           ! 2976                 FLAGS &= 0xfffe;
18678                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18679 54A5           8B46         18            mov	ax,$18[bp]
18680 54A8           24                     FE  and	al,#$FE
18681 54AA           8946         18            mov	$18[bp],ax
18682                                           !BCC_EOS
18683                                           ! 2977                 regs.u.r8.ah = 0;
18684                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18685 54AD           30C0                       xor	al,al
18686 54AF           8846         13            mov	$13[bp],al
18687                                           !BCC_EOS
18688                                           ! 2978               } else {
18689 54B2           EB           0D            jmp .3FE
18690                       000054B4            .3FC:
18691                                           ! 2979                 FLAGS |= 0x0001;
18692                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18693 54B4           8B46         18            mov	ax,$18[bp]
18694 54B7           0C                     01  or	al,*1
18695 54B9           8946         18            mov	$18[bp],ax
18696                                           !BCC_EOS
18697                                           ! 2980                 regs.u.r8.ah = 0x86;
18698                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18699 54BC           B0                     86  mov	al,#$86
18700 54BE           8846         13            mov	$13[bp],al
18701                                           !BCC_EOS
18702                                           ! 2981               }
18703                                           ! 2982               set_kbd_command_byte(comm_byte);
18704                       000054C1            .3FE:
18705                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18706 54C1           8A46         F7            mov	al,-9[bp]
18707 54C4           30E4                       xor	ah,ah
18708 54C6           50                         push	ax
18709                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18710 54C7           E8         0C9D            call	_set_kbd_command_byte
18711 54CA           44                         inc	sp
18712 54CB           44                         inc	sp
18713                                           !BCC_EOS
18714                                           ! 2983               break;
18715 54CC           EB           2A            jmp .3E2
18716                                           !BCC_EOS
18717                                           ! 2984             default:
18718                                           ! 2985               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
18719                       000054CE            .3FF:
18720                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18721 54CE           8A46         0D            mov	al,$D[bp]
18722 54D1           30E4                       xor	ah,ah
18723 54D3           50                         push	ax
18724                                           ! Debug: list * char = .400+0 (used reg = )
18725 54D4           BB                   D83B  mov	bx,#.400
18726 54D7           53                         push	bx
18727                                           ! Debug: list int = const 7 (used reg = )
18728 54D8           B8                   0007  mov	ax,*7
18729 54DB           50                         push	ax
18730                                           ! Debug: func () void = bios_printf+0 (used reg = )
18731 54DC           E8         B53A            call	_bios_printf
18732 54DF           83C4                   06  add	sp,*6
18733                                           !BCC_EOS
18734                                           ! 2986             }
18735                                           ! 2987           break;
18736 54E2           EB           14            jmp .3E2
18737                       000054E4            .3E4:
18738 54E4           2C                     00  sub	al,*0
18739 54E6         0F84         FEA0            beq 	.3E5
18740 54EA           2C                     01  sub	al,*1
18741 54EC         0F84         FF67            beq 	.3F3
18742 54F0           2C                     01  sub	al,*1
18743 54F2         0F84         FF61            beq 	.3F4
18744 54F6           EB           D6            jmp	.3FF
18745                       000054F8            .3E2:
18746 54F8           E9         00BE            br 	.393
18747                                           !BCC_EOS
18748                                           ! 2988 
18749                                           ! 2988         case 7:
18750                                           ! 2989 ;
18751                       000054FB            .401:
18752                                           !BCC_EOS
18753                                           ! 2990           mouse_driver_seg = ES;
18754                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18755 54FB           8B46         14            mov	ax,$14[bp]
18756 54FE           8946         FA            mov	-6[bp],ax
18757                                           !BCC_EOS
18758                                           ! 2991           mouse_driver_offset = regs.u.r16.bx;
18759                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18760 5501           8B46         0C            mov	ax,$C[bp]
18761 5504           8946         F8            mov	-8[bp],ax
18762                                           !BCC_EOS
18763                                           ! 2992           write_word(ebda_seg, 0x0022, mouse_driver_offset);
18764                                           ! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18765 5507           FF76         F8            push	-8[bp]
18766                                           ! Debug: list int = const $22 (used reg = )
18767 550A           B8                   0022  mov	ax,*$22
18768 550D           50                         push	ax
18769                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18770 550E           FF76         FE            push	-2[bp]
18771                                           ! Debug: func () void = write_word+0 (used reg = )
18772 5511           E8         B11E            call	_write_word
18773 5514           83C4                   06  add	sp,*6
18774                                           !BCC_EOS
18775                                           ! 2993           write_word(ebda_seg, 0x0024, mouse_driver_seg);
18776                                           ! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18777 5517           FF76         FA            push	-6[bp]
18778                                           ! Debug: list int = const $24 (used reg = )
18779 551A           B8                   0024  mov	ax,*$24
18780 551D           50                         push	ax
18781                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18782 551E           FF76         FE            push	-2[bp]
18783                                           ! Debug: func () void = write_word+0 (used reg = )
18784 5521           E8         B10E            call	_write_word
18785 5524           83C4                   06  add	sp,*6
18786                                           !BCC_EOS
18787                                           ! 2994           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
18788                                           ! Debug: list int = const $27 (used reg = )
18789 5527           B8                   0027  mov	ax,*$27
18790 552A           50                         push	ax
18791                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
18792 552B           FF76         FE            push	-2[bp]
18793                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18794 552E           E8         B0C3            call	_read_byte
18795 5531           83C4                   04  add	sp,*4
18796                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18797 5534           8846         FC            mov	-4[bp],al
18798                                           !BCC_EOS
18799                                           ! 2995           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
18800                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18801 5537           8B46         F8            mov	ax,-8[bp]
18802 553A           85C0                       test	ax,ax
18803 553C           75           1D            jne 	.402
18804                       0000553E            .404:
18805                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18806 553E           8B46         FA            mov	ax,-6[bp]
18807 5541           85C0                       test	ax,ax
18808 5543           75           16            jne 	.402
18809                       00005545            .403:
18810                                           ! 2996             if ( (mouse_flags_2 & 0x80) != 0 ) {
18811                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18812 5545           8A46         FC            mov	al,-4[bp]
18813 5548           24                     80  and	al,#$80
18814                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
18815 554A           84C0                       test	al,al
18816 554C           74           0B            je  	.405
18817                       0000554E            .406:
18818                                           ! 2997               mouse_flags_2 &= ~0x80;
18819                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18820 554E           8A46         FC            mov	al,-4[bp]
18821 5551           24                     7F  and	al,*$7F
18822 5553           8846         FC            mov	-4[bp],al
18823                                           !BCC_EOS
18824                                           ! 2998               inhibit_mouse_int_and_events();
18825                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18826 5556           E8         0A32            call	_inhibit_mouse_int_and_events
18827                                           !BCC_EOS
18828                                           ! 2999               }
18829                                           ! 3000             }
18830                       00005559            .405:
18831                                           ! 3001           else {
18832 5559           EB           08            jmp .407
18833                       0000555B            .402:
18834                                           ! 3002             mouse_flags_2 |= 0x80;
18835                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18836 555B           8A46         FC            mov	al,-4[bp]
18837 555E           0C                     80  or	al,#$80
18838 5560           8846         FC            mov	-4[bp],al
18839                                           !BCC_EOS
18840                                           ! 3003             }
18841                                           ! 3004           write_byte(ebda_seg, 0x0027, mouse_flags_2);
18842                       00005563            .407:
18843                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18844 5563           8A46         FC            mov	al,-4[bp]
18845 5566           30E4                       xor	ah,ah
18846 5568           50                         push	ax
18847                                           ! Debug: list int = const $27 (used reg = )
18848 5569           B8                   0027  mov	ax,*$27
18849 556C           50                         push	ax
18850                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18851 556D           FF76         FE            push	-2[bp]
18852                                           ! Debug: func () void = write_byte+0 (used reg = )
18853 5570           E8         B0A7            call	_write_byte
18854 5573           83C4                   06  add	sp,*6
18855                                           !BCC_EOS
18856                                           ! 3005           FLAGS &= 0xfffe;
18857                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18858 5576           8B46         18            mov	ax,$18[bp]
18859 5579           24                     FE  and	al,#$FE
18860 557B           8946         18            mov	$18[bp],ax
18861                                           !BCC_EOS
18862                                           ! 3006           regs.u.r8.ah = 0;
18863                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18864 557E           30C0                       xor	al,al
18865 5580           8846         13            mov	$13[bp],al
18866                                           !BCC_EOS
18867                                           ! 3007           break;
18868 5583           EB           34            jmp .393
18869                                           !BCC_EOS
18870                                           ! 3008         default:
18871                                           ! 3009 ;
18872                       00005585            .408:
18873                                           !BCC_EOS
18874                                           ! 3010           regs.u.r8.ah = 1;
18875                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
18876 5585           B0                     01  mov	al,*1
18877 5587           8846         13            mov	$13[bp],al
18878                                           !BCC_EOS
18879                                           ! 3011           FLAGS |= 0x0001;
18880                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18881 558A           8B46         18            mov	ax,$18[bp]
18882 558D           0C                     01  or	al,*1
18883 558F           8946         18            mov	$18[bp],ax
18884                                           !BCC_EOS
18885                                           ! 3012         }
18886                                           ! 3013       break;
18887 5592           EB           25            jmp .393
18888                       00005594            .395:
18889 5594           2C                     00  sub	al,*0
18890 5596           72           ED            jb 	.408
18891 5598           3C                     07  cmp	al,*7
18892 559A           77           1B            ja  	.409
18893 559C           30E4                       xor	ah,ah
18894 559E           D1E0                       shl	ax,*1
18895 55A0           89C3                       mov	bx,ax
18896 55A2           2E                         seg	cs
18897 55A3           FFA7       55A7            br	.40A[bx]
18898                       000055A7            .40A:
18899 55A7                      4F94            .word	.396
18900 55A9                      5094            .word	.3A9
18901 55AB                      51AC            .word	.3BC
18902 55AD                      527A            .word	.3D0
18903 55AF                      5331            .word	.3DD
18904 55B1                      5094            .word	.3AA
18905 55B3                      5384            .word	.3E1
18906 55B5                      54FB            .word	.401
18907                       000055B7            .409:
18908 55B7           EB           CC            jmp	.408
18909                       000055B9            .393:
18910 55B9           EB           2D            jmp .38F
18911                                           !BCC_EOS
18912                                           ! 3014     default:
18913                                           ! 3015       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
18914                       000055BB            .40B:
18915                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
18916 55BB           FF76         0C            push	$C[bp]
18917                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
18918 55BE           FF76         12            push	$12[bp]
18919                                           ! Debug: list * char = .40C+0 (used reg = )
18920 55C1           BB                   D801  mov	bx,#.40C
18921 55C4           53                         push	bx
18922                                           ! Debug: list int = const 4 (used reg = )
18923 55C5           B8                   0004  mov	ax,*4
18924 55C8           50                         push	ax
18925                                           ! Debug: func () void = bios_printf+0 (used reg = )
18926 55C9           E8         B44D            call	_bios_printf
18927 55CC           83C4                   08  add	sp,*8
18928                                           !BCC_EOS
18929                                           ! 3016       FLAGS |= 0x0001;
18930                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18931 55CF           8B46         18            mov	ax,$18[bp]
18932 55D2           0C                     01  or	al,*1
18933 55D4           8946         18            mov	$18[bp],ax
18934                                           !BCC_EOS
18935                                           ! 3017       regs.u.r8.ah = 0x86;
18936                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18937 55D7           B0                     86  mov	al,#$86
18938 55D9           8846         13            mov	$13[bp],al
18939                                           !BCC_EOS
18940                                           ! 3018       break;
18941 55DC           EB           0A            jmp .38F
18942                                           !BCC_EOS
18943                                           ! 3019     }
18944                                           ! 3020 }
18945 55DE           EB           08            jmp .38F
18946                       000055E0            .391:
18947 55E0           2C                     C2  sub	al,#$C2
18948 55E2         0F84         F9A8            beq 	.392
18949 55E6           EB           D3            jmp	.40B
18950                       000055E8            .38F:
18951                       FFFFFFF0            ..FFF6	=	-$10
18952 55E8           89EC                       mov	sp,bp
18953 55EA           5D                         pop	bp
18954 55EB           C3                         ret
18955                                           ! 3021 void set_e820_range(ES, DI, start, end, type)
18956                                           ! Register BX used in function int15_function_mouse
18957                                           ! 3022      Bit16u ES;
18958                                           export	_set_e820_range
18959                       000055EC            _set_e820_range:
18960                                           !BCC_EOS
18961                                           ! 3023      Bit16u DI;
18962                                           !BCC_EOS
18963                                           ! 3024      Bit32u start;
18964                                           !BCC_EOS
18965                                           ! 3025      Bit32u end;
18966                                           !BCC_EOS
18967                                           ! 3026      Bit16u type;
18968                                           !BCC_EOS
18969                                           ! 3027 {
18970                                           ! 3028     write_word(ES, DI, start);
18971 55EC           55                         push	bp
18972 55ED           89E5                       mov	bp,sp
18973                                           ! Debug: list unsigned long start = [S+2+6] (used reg = )
18974 55EF           FF76         0A            push	$A[bp]
18975 55F2           FF76         08            push	8[bp]
18976                                           ! Debug: list unsigned short DI = [S+6+4] (used reg = )
18977 55F5           FF76         06            push	6[bp]
18978                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18979 55F8           FF76         04            push	4[bp]
18980                                           ! Debug: func () void = write_word+0 (used reg = )
18981 55FB           E8         B034            call	_write_word
18982 55FE           89EC                       mov	sp,bp
18983                                           !BCC_EOS
18984                                           ! 3029     write_word(ES, DI+2, start >> 16);
18985                                           ! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
18986 5600           8B46         08            mov	ax,8[bp]
18987 5603           8B5E         0A            mov	bx,$A[bp]
18988 5606           93                         xchg	bx,ax
18989 5607           31DB                       xor	bx,bx
18990                                           ! Debug: list unsigned long = bx+0 (used reg = )
18991 5609           53                         push	bx
18992 560A           50                         push	ax
18993                                           ! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
18994 560B           8B46         06            mov	ax,6[bp]
18995                                           ! Debug: list unsigned int = ax+2 (used reg = )
18996 560E           40                         inc	ax
18997 560F           40                         inc	ax
18998 5610           50                         push	ax
18999                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
19000 5611           FF76         04            push	4[bp]
19001                                           ! Debug: func () void = write_word+0 (used reg = )
19002 5614           E8         B01B            call	_write_word
19003 5617           89EC                       mov	sp,bp
19004                                           !BCC_EOS
19005                                           ! 3030     write_word(ES, DI+4, 0x00);
19006                                           ! Debug: list int = const 0 (used reg = )
19007 5619           31C0                       xor	ax,ax
19008 561B           50                         push	ax
19009                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
19010 561C           8B46         06            mov	ax,6[bp]
19011                                           ! Debug: list unsigned int = ax+4 (used reg = )
19012 561F           05                   0004  add	ax,*4
19013 5622           50                         push	ax
19014                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19015 5623           FF76         04            push	4[bp]
19016                                           ! Debug: func () void = write_word+0 (used reg = )
19017 5626           E8         B009            call	_write_word
19018 5629           89EC                       mov	sp,bp
19019                                           !BCC_EOS
19020                                           ! 3031     write_word(ES, DI+6, 0x00);
19021                                           ! Debug: list int = const 0 (used reg = )
19022 562B           31C0                       xor	ax,ax
19023 562D           50                         push	ax
19024                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
19025 562E           8B46         06            mov	ax,6[bp]
19026                                           ! Debug: list unsigned int = ax+6 (used reg = )
19027 5631           05                   0006  add	ax,*6
19028 5634           50                         push	ax
19029                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19030 5635           FF76         04            push	4[bp]
19031                                           ! Debug: func () void = write_word+0 (used reg = )
19032 5638           E8         AFF7            call	_write_word
19033 563B           89EC                       mov	sp,bp
19034                                           !BCC_EOS
19035                                           ! 3032     end -= start;
19036                                           ! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
19037 563D           8B46         0C            mov	ax,$C[bp]
19038 5640           8B5E         0E            mov	bx,$E[bp]
19039 5643           8D7E         08            lea	di,8[bp]
19040 5646           E8         AA98            call	lsubul
19041 5649           8946         0C            mov	$C[bp],ax
19042 564C           895E         0E            mov	$E[bp],bx
19043                                           !BCC_EOS
19044                                           ! 3033     write_word(ES, DI+8, end);
19045                                           ! Debug: list unsigned long end = [S+2+$A] (used reg = )
19046 564F           FF76         0E            push	$E[bp]
19047 5652           FF76         0C            push	$C[bp]
19048                                           ! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
19049 5655           8B46         06            mov	ax,6[bp]
19050                                           ! Debug: list unsigned int = ax+8 (used reg = )
19051 5658           05                   0008  add	ax,*8
19052 565B           50                         push	ax
19053                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
19054 565C           FF76         04            push	4[bp]
19055                                           ! Debug: func () void = write_word+0 (used reg = )
19056 565F           E8         AFD0            call	_write_word
19057 5662           89EC                       mov	sp,bp
19058                                           !BCC_EOS
19059                                           ! 3034     write_word(ES, DI+10, end >> 16);
19060                                           ! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
19061 5664           8B46         0C            mov	ax,$C[bp]
19062 5667           8B5E         0E            mov	bx,$E[bp]
19063 566A           93                         xchg	bx,ax
19064 566B           31DB                       xor	bx,bx
19065                                           ! Debug: list unsigned long = bx+0 (used reg = )
19066 566D           53                         push	bx
19067 566E           50                         push	ax
19068                                           ! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
19069 566F           8B46         06            mov	ax,6[bp]
19070                                           ! Debug: list unsigned int = ax+$A (used reg = )
19071 5672           05                   000A  add	ax,*$A
19072 5675           50                         push	ax
19073                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
19074 5676           FF76         04            push	4[bp]
19075                                           ! Debug: func () void = write_word+0 (used reg = )
19076 5679           E8         AFB6            call	_write_word
19077 567C           89EC                       mov	sp,bp
19078                                           !BCC_EOS
19079                                           ! 3035     write_word(ES, DI+12, 0x0000);
19080                                           ! Debug: list int = const 0 (used reg = )
19081 567E           31C0                       xor	ax,ax
19082 5680           50                         push	ax
19083                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
19084 5681           8B46         06            mov	ax,6[bp]
19085                                           ! Debug: list unsigned int = ax+$C (used reg = )
19086 5684           05                   000C  add	ax,*$C
19087 5687           50                         push	ax
19088                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19089 5688           FF76         04            push	4[bp]
19090                                           ! Debug: func () void = write_word+0 (used reg = )
19091 568B           E8         AFA4            call	_write_word
19092 568E           89EC                       mov	sp,bp
19093                                           !BCC_EOS
19094                                           ! 3036     write_word(ES, DI+14, 0x0000);
19095                                           ! Debug: list int = const 0 (used reg = )
19096 5690           31C0                       xor	ax,ax
19097 5692           50                         push	ax
19098                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
19099 5693           8B46         06            mov	ax,6[bp]
19100                                           ! Debug: list unsigned int = ax+$E (used reg = )
19101 5696           05                   000E  add	ax,*$E
19102 5699           50                         push	ax
19103                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19104 569A           FF76         04            push	4[bp]
19105                                           ! Debug: func () void = write_word+0 (used reg = )
19106 569D           E8         AF92            call	_write_word
19107 56A0           89EC                       mov	sp,bp
19108                                           !BCC_EOS
19109                                           ! 3037     write_word(ES, DI+16, type);
19110                                           ! Debug: list unsigned short type = [S+2+$E] (used reg = )
19111 56A2           FF76         10            push	$10[bp]
19112                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
19113 56A5           8B46         06            mov	ax,6[bp]
19114                                           ! Debug: list unsigned int = ax+$10 (used reg = )
19115 56A8           05                   0010  add	ax,*$10
19116 56AB           50                         push	ax
19117                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19118 56AC           FF76         04            push	4[bp]
19119                                           ! Debug: func () void = write_word+0 (used reg = )
19120 56AF           E8         AF80            call	_write_word
19121 56B2           89EC                       mov	sp,bp
19122                                           !BCC_EOS
19123                                           ! 3038     write_word(ES, DI+18, 0x0);
19124                                           ! Debug: list int = const 0 (used reg = )
19125 56B4           31C0                       xor	ax,ax
19126 56B6           50                         push	ax
19127                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
19128 56B7           8B46         06            mov	ax,6[bp]
19129                                           ! Debug: list unsigned int = ax+$12 (used reg = )
19130 56BA           05                   0012  add	ax,*$12
19131 56BD           50                         push	ax
19132                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
19133 56BE           FF76         04            push	4[bp]
19134                                           ! Debug: func () void = write_word+0 (used reg = )
19135 56C1           E8         AF6E            call	_write_word
19136 56C4           89EC                       mov	sp,bp
19137                                           !BCC_EOS
19138                                           ! 3039 }
19139 56C6           5D                         pop	bp
19140 56C7           C3                         ret
19141                                           ! 3040   void
19142                                           ! Register BX used in function set_e820_range
19143                                           ! 3041 int15_function32(regs, ES, DS, FLAGS)
19144                                           ! 3042   pushad_regs_t regs;
19145                                           export	_int15_function32
19146                       000056C8            _int15_function32:
19147                                           !BCC_EOS
19148                                           ! 3043   Bit16u ES, DS, FLAGS;
19149                                           !BCC_EOS
19150                                           ! 3044 {
19151                                           ! 3045   Bit32u extended_memory_size=0;
19152 56C8           55                         push	bp
19153 56C9           89E5                       mov	bp,sp
19154 56CB           83C4                   FC  add	sp,*-4
19155                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
19156 56CE           31C0                       xor	ax,ax
19157 56D0           31DB                       xor	bx,bx
19158 56D2           8946         FC            mov	-4[bp],ax
19159 56D5           895E         FE            mov	-2[bp],bx
19160                                           !BCC_EOS
19161                                           ! 3046   Bit16u CX,DX;
19162                                           !BCC_EOS
19163                                           ! 3047   Bit16u off, e820_table_size;
19164                                           !BCC_EOS
19165                                           ! 3048   Bit32u base, type, size;
19166                                           !BCC_EOS
19167                                           ! 3049 ;
19168 56D8           83C4                   EC  add	sp,*-$14
19169                                           !BCC_EOS
19170                                           ! 3050   switch (regs.u.r8.ah) {
19171 56DB           8A46         21            mov	al,$21[bp]
19172 56DE           E9         0355            br 	.40F
19173                                           ! 3051     case 0x86:
19174                                           ! 3052       CX = regs.u.r16.cx;
19175                       000056E1            .410:
19176                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
19177 56E1           8B46         1C            mov	ax,$1C[bp]
19178 56E4           8946         FA            mov	-6[bp],ax
19179                                           !BCC_EOS
19180                                           ! 3053       DX = regs.u.r16.dx;
19181                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
19182 56E7           8B46         18            mov	ax,$18[bp]
19183 56EA           8946         F8            mov	-8[bp],ax
19184                                           !BCC_EOS
19185                                           ! 3054 #asm
19186                                           !BCC_EOS
19187                                           !BCC_ASM
19188                       00000012            _int15_function32.CX	set	$12
19189                       FFFFFFFA            .int15_function32.CX	set	-6
19190                       00000014            _int15_function32.extended_memory_size	set	$14
19191                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
19192                       00000040            _int15_function32.FLAGS	set	$40
19193                       00000028            .int15_function32.FLAGS	set	$28
19194                       00000004            _int15_function32.type	set	4
19195                       FFFFFFEC            .int15_function32.type	set	-$14
19196                       0000003E            _int15_function32.DS	set	$3E
19197                       00000026            .int15_function32.DS	set	$26
19198                       00000010            _int15_function32.DX	set	$10
19199                       FFFFFFF8            .int15_function32.DX	set	-8
19200                       00000000            _int15_function32.size	set	0
19201                       FFFFFFE8            .int15_function32.size	set	-$18
19202                       0000003C            _int15_function32.ES	set	$3C
19203                       00000024            .int15_function32.ES	set	$24
19204                       0000000C            _int15_function32.e820_table_size	set	$C
19205                       FFFFFFF4            .int15_function32.e820_table_size	set	-$C
19206                       00000008            _int15_function32.base	set	8
19207                       FFFFFFF0            .int15_function32.base	set	-$10
19208                       0000001C            _int15_function32.regs	set	$1C
19209                       00000004            .int15_function32.regs	set	4
19210                       0000000E            _int15_function32.off	set	$E
19211                       FFFFFFF6            .int15_function32.off	set	-$A
19212 56ED           FB                               sti
19213                                                 ;; Get the count in eax
19214 56EE           89E3                             mov bx, sp
19215 56F0           36                         SEG SS
19216 56F1           8B47         12                  mov ax, _int15_function32.CX [bx]
19217 56F4     66    C1E0                   10        shl eax, #16
19218 56F8           36                         SEG SS
19219 56F9           8B47         10                  mov ax, _int15_function32.DX [bx]
19220                                                 ;; convert to numbers of 15usec ticks
19221 56FC     66    BB               0000000F        mov ebx, #15
19222 5702     66    31D2                             xor edx, edx
19223 5705     66    F7F3                             div eax, ebx
19224 5708     66    89C1                             mov ecx, eax
19225                                                 ;; wait for ecx number of refresh requests
19226 570B           E4                     61        in al, #0x61
19227 570D           24                     10        and al,#0x10
19228 570F           88C4                             mov ah, al
19229 5711     66    09C9                             or ecx, ecx
19230 5714           74           0E                  je int1586_tick_end
19231                       00005716            int1586_tick:
19232 5716           E4                     61        in al, #0x61
19233 5718           24                     10        and al,#0x10
19234 571A           38E0                             cmp al, ah
19235 571C           74           F8                  je int1586_tick
19236 571E           88C4                             mov ah, al
19237 5720     66    49                               dec ecx
19238 5722           75           F2                  jnz int1586_tick
19239                       00005724            int1586_tick_end:
19240                                           ! 3083 endasm
19241                                           !BCC_ENDASM
19242                                           !BCC_EOS
19243                                           ! 3084       break;
19244 5724           E9         031D            br 	.40D
19245                                           !BCC_EOS
19246                                           ! 3085     case 0xe8:
19247                                           ! 3086         switch(regs.u.r8.al)
19248                       00005727            .411:
19249 5727           8A46         20            mov	al,$20[bp]
19250                                           ! 3087         {
19251 572A           E9         02D4            br 	.414
19252                                           ! 3088        case 0x20: {
19253                       0000572D            .415:
19254                                           ! 3089             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
19255                                           ! Debug: list int = const 0 (used reg = )
19256 572D           31C0                       xor	ax,ax
19257 572F           50                         push	ax
19258                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19259 5730           B8                   EA10  mov	ax,#$EA10
19260 5733           50                         push	ax
19261                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
19262 5734           E8         AED0            call	_read_word
19263 5737           83C4                   04  add	sp,*4
19264                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
19265 573A           B9                   0014  mov	cx,*$14
19266 573D           F7E9                       imul	cx
19267                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19268 573F           8946         F4            mov	-$C[bp],ax
19269                                           !BCC_EOS
19270                                           ! 3090             if (regs.u.r32.edx != 0x534D4150)
19271                                           ! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
19272                                           ! Debug: expression subtree swapping
19273 5742           B8                   4150  mov	ax,#$4150
19274 5745           BB                   534D  mov	bx,#$534D
19275 5748           53                         push	bx
19276 5749           50                         push	ax
19277 574A           8B46         18            mov	ax,$18[bp]
19278 574D           8B5E         1A            mov	bx,$1A[bp]
19279 5750           8D7E         E4            lea	di,-2+..FFF5[bp]
19280 5753           E8         A975            call	lcmpul
19281 5756           8D66         E8            lea	sp,2+..FFF5[bp]
19282 5759           74           06            je  	.416
19283                       0000575B            .417:
19284                                           ! 3091                 goto int15_unimplemented;
19285 575B           83C4                   00  add	sp,#..FFF4-..FFF5
19286 575E           E9         02B0            br 	.FFF4
19287                                           !BCC_EOS
19288                                           ! 3092             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
19289                       00005761            .416:
19290                                           ! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
19291 5761           8B46         14            mov	ax,$14[bp]
19292 5764           BB                   0014  mov	bx,*$14
19293 5767           E8         A9FF            call	idiv_u
19294                                           ! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
19295 576A           B9                   0014  mov	cx,*$14
19296 576D           F7E9                       imul	cx
19297                                           ! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
19298 576F           3B46         14            cmp	ax,$14[bp]
19299 5772         0F85         0084            bne 	.418
19300                       00005776            .419:
19301                                           ! 3093                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
19302                                           ! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
19303 5776           8B46         14            mov	ax,$14[bp]
19304                                           ! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
19305 5779           05                   0014  add	ax,*$14
19306 577C           3B46         F4            cmp	ax,-$C[bp]
19307 577F           77           1B            ja  	.41A
19308                       00005781            .41B:
19309                                           ! 3094                     memcpyb(ES, regs.u.r16.di,
19310                                           ! 3095                             (Bit16u)(0x000EA100 >> 4), 0x8 + regs.u.r16.bx, 0x14);
19311                                           ! Debug: list int = const $14 (used reg = )
19312 5781           B8                   0014  mov	ax,*$14
19313 5784           50                         push	ax
19314                                           ! Debug: add unsigned short regs = [S+$1C+$12] to int = const 8 (used reg = )
19315                                           ! Debug: expression subtree swapping
19316 5785           8B46         14            mov	ax,$14[bp]
19317                                           ! Debug: list unsigned int = ax+8 (used reg = )
19318 5788           05                   0008  add	ax,*8
19319 578B           50                         push	ax
19320                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19321 578C           B8                   EA10  mov	ax,#$EA10
19322 578F           50                         push	ax
19323                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
19324 5790           FF76         04            push	4[bp]
19325                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
19326 5793           FF76         24            push	$24[bp]
19327                                           ! Debug: func () void = memcpyb+0 (used reg = )
19328 5796           E8         A88B            call	_memcpyb
19329 5799           83C4                   0A  add	sp,*$A
19330                                           !BCC_EOS
19331                                           ! 3096                 regs.u.r32.ebx += 0x14;
19332                       0000579C            .41A:
19333                                           ! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
19334 579C           B8                   0014  mov	ax,*$14
19335 579F           31DB                       xor	bx,bx
19336 57A1           53                         push	bx
19337 57A2           50                         push	ax
19338 57A3           8B46         14            mov	ax,$14[bp]
19339 57A6           8B5E         16            mov	bx,$16[bp]
19340 57A9           8D7E         E4            lea	di,-2+..FFF5[bp]
19341 57AC           E8         A914            call	laddul
19342 57AF           8946         14            mov	$14[bp],ax
19343 57B2           895E         16            mov	$16[bp],bx
19344 57B5           83C4                   04  add	sp,*4
19345                                           !BCC_EOS
19346                                           ! 3097                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
19347                                           ! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19348 57B8           8B46         F4            mov	ax,-$C[bp]
19349 57BB           31DB                       xor	bx,bx
19350 57BD           53                         push	bx
19351 57BE           50                         push	ax
19352                                           ! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
19353                                           ! Debug: expression subtree swapping
19354 57BF           B8                   0014  mov	ax,*$14
19355 57C2           31DB                       xor	bx,bx
19356 57C4           8D7E         14            lea	di,$14[bp]
19357 57C7           E8         A8F9            call	laddul
19358                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
19359 57CA           53                         push	bx
19360 57CB           50                         push	ax
19361 57CC           B8                   0001  mov	ax,*1
19362 57CF           31DB                       xor	bx,bx
19363 57D1           53                         push	bx
19364 57D2           50                         push	ax
19365 57D3           8B46         E0            mov	ax,-6+..FFF5[bp]
19366 57D6           8B5E         E2            mov	bx,-4+..FFF5[bp]
19367 57D9           8D7E         DC            lea	di,-$A+..FFF5[bp]
19368 57DC           E8         A902            call	lsubul
19369 57DF           83C4                   08  add	sp,*8
19370                                           ! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
19371 57E2           8D7E         E4            lea	di,-2+..FFF5[bp]
19372 57E5           E8         A8E3            call	lcmpul
19373 57E8           8D66         E8            lea	sp,2+..FFF5[bp]
19374 57EB           76           0A            jbe 	.41C
19375                       000057ED            .41D:
19376                                           ! 3098                     regs.u.r32.ebx = 0;
19377                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
19378 57ED           31C0                       xor	ax,ax
19379 57EF           31DB                       xor	bx,bx
19380 57F1           8946         14            mov	$14[bp],ax
19381 57F4           895E         16            mov	$16[bp],bx
19382                                           !BCC_EOS
19383                                           ! 3099             } else if (regs.u.r16.bx == 1) {
19384                       000057F7            .41C:
19385 57F7           E9         00BB            br 	.41E
19386                       000057FA            .418:
19387                                           ! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
19388 57FA           8B46         14            mov	ax,$14[bp]
19389 57FD           3D                   0001  cmp	ax,*1
19390 5800         0F85         00AB            bne 	.41F
19391                       00005804            .420:
19392                                           ! 3100                 for (off = 0; off < e820_table_size; off += 0x14) {
19393                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
19394 5804           31C0                       xor	ax,ax
19395 5806           8946         F6            mov	-$A[bp],ax
19396                                           !BCC_EOS
19397                                           !BCC_EOS
19398 5809           EB           62            jmp .423
19399                       0000580B            .424:
19400                                           ! 3101                     base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
19401                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
19402                                           ! Debug: expression subtree swapping
19403 580B           8B46         F6            mov	ax,-$A[bp]
19404                                           ! Debug: list unsigned int = ax+8 (used reg = )
19405 580E           05                   0008  add	ax,*8
19406 5811           50                         push	ax
19407                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19408 5812           B8                   EA10  mov	ax,#$EA10
19409 5815           50                         push	ax
19410                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19411 5816           E8         A86A            call	_read_dword
19412 5819           89D3                       mov	bx,dx
19413 581B           83C4                   04  add	sp,*4
19414                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19415 581E           8946         F0            mov	-$10[bp],ax
19416 5821           895E         F2            mov	-$E[bp],bx
19417                                           !BCC_EOS
19418                                           ! 3102                     type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
19419                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
19420                                           ! Debug: expression subtree swapping
19421 5824           8B46         F6            mov	ax,-$A[bp]
19422                                           ! Debug: list unsigned int = ax+$18 (used reg = )
19423 5827           05                   0018  add	ax,*$18
19424 582A           50                         push	ax
19425                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19426 582B           B8                   EA10  mov	ax,#$EA10
19427 582E           50                         push	ax
19428                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19429 582F           E8         A851            call	_read_dword
19430 5832           89D3                       mov	bx,dx
19431 5834           83C4                   04  add	sp,*4
19432                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
19433 5837           8946         EC            mov	-$14[bp],ax
19434 583A           895E         EE            mov	-$12[bp],bx
19435                                           !BCC_EOS
19436                                           ! 3103                     if ((base >= 0x100000) && (type == 1))
19437                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
19438 583D           31C0                       xor	ax,ax
19439 583F           BB                   0010  mov	bx,*$10
19440 5842           8D7E         F0            lea	di,-$10[bp]
19441 5845           E8         A883            call	lcmpul
19442 5848           77           1A            ja  	.425
19443                       0000584A            .427:
19444                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
19445                                           ! Debug: expression subtree swapping
19446 584A           B8                   0001  mov	ax,*1
19447 584D           31DB                       xor	bx,bx
19448 584F           53                         push	bx
19449 5850           50                         push	ax
19450 5851           8B46         EC            mov	ax,-$14[bp]
19451 5854           8B5E         EE            mov	bx,-$12[bp]
19452 5857           8D7E         E4            lea	di,-2+..FFF5[bp]
19453 585A           E8         A86E            call	lcmpul
19454 585D           8D66         E8            lea	sp,2+..FFF5[bp]
19455 5860           75           02            jne 	.425
19456                       00005862            .426:
19457                                           ! 3104                         break;
19458 5862           EB           11            jmp .421
19459                                           !BCC_EOS
19460                                           ! 3105                 }
19461                       00005864            .425:
19462                                           ! 3106                 if (off == e820_table_size) {
19463                       00005864            .422:
19464                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19465 5864           8B46         F6            mov	ax,-$A[bp]
19466 5867           05                   0014  add	ax,*$14
19467 586A           8946         F6            mov	-$A[bp],ax
19468                       0000586D            .423:
19469                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19470 586D           8B46         F6            mov	ax,-$A[bp]
19471 5870           3B46         F4            cmp	ax,-$C[bp]
19472 5873           72           96            jb 	.424
19473                       00005875            .428:
19474                       00005875            .421:
19475                                           ! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19476 5875           8B46         F6            mov	ax,-$A[bp]
19477 5878           3B46         F4            cmp	ax,-$C[bp]
19478 587B           75           0B            jne 	.429
19479                       0000587D            .42A:
19480                                           ! 3107                     FLAGS |= 0x0001;
19481                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19482 587D           8B46         28            mov	ax,$28[bp]
19483 5880           0C                     01  or	al,*1
19484 5882           8946         28            mov	$28[bp],ax
19485                                           !BCC_EOS
19486                                           ! 3108                     break;
19487 5885           E9         0187            br 	.412
19488                                           !BCC_EOS
19489                                           ! 3109                 }
19490                                           ! 3110                 memcpyb(ES, regs.u.r16.di, (Bit16u)(0x000EA100 >> 4), 0x8 + off, 0x14);
19491                       00005888            .429:
19492                                           ! Debug: list int = const $14 (used reg = )
19493 5888           B8                   0014  mov	ax,*$14
19494 588B           50                         push	ax
19495                                           ! Debug: add unsigned short off = [S+$1C-$C] to int = const 8 (used reg = )
19496                                           ! Debug: expression subtree swapping
19497 588C           8B46         F6            mov	ax,-$A[bp]
19498                                           ! Debug: list unsigned int = ax+8 (used reg = )
19499 588F           05                   0008  add	ax,*8
19500 5892           50                         push	ax
19501                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19502 5893           B8                   EA10  mov	ax,#$EA10
19503 5896           50                         push	ax
19504                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
19505 5897           FF76         04            push	4[bp]
19506                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
19507 589A           FF76         24            push	$24[bp]
19508                                           ! Debug: func () void = memcpyb+0 (used reg = )
19509 589D           E8         A784            call	_memcpyb
19510 58A0           83C4                   0A  add	sp,*$A
19511                                           !BCC_EOS
19512                                           ! 3111                 regs.u.r32.ebx = 0;
19513                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
19514 58A3           31C0                       xor	ax,ax
19515 58A5           31DB                       xor	bx,bx
19516 58A7           8946         14            mov	$14[bp],ax
19517 58AA           895E         16            mov	$16[bp],bx
19518                                           !BCC_EOS
19519                                           ! 3112             } else {
19520 58AD           EB           06            jmp .42B
19521                       000058AF            .41F:
19522                                           ! 3113                 goto int15_unimplemented;
19523 58AF           83C4                   00  add	sp,#..FFF4-..FFF5
19524 58B2           E9         015C            br 	.FFF4
19525                                           !BCC_EOS
19526                                           ! 3114             }
19527                                           ! 3115             regs.u.r32.eax = 0x534D4150;
19528                       000058B5            .42B:
19529                       000058B5            .41E:
19530                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
19531 58B5           B8                   4150  mov	ax,#$4150
19532 58B8           BB                   534D  mov	bx,#$534D
19533 58BB           8946         20            mov	$20[bp],ax
19534 58BE           895E         22            mov	$22[bp],bx
19535                                           !BCC_EOS
19536                                           ! 3116             regs.u.r32.ecx = 0x14;
19537                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
19538 58C1           B8                   0014  mov	ax,*$14
19539 58C4           31DB                       xor	bx,bx
19540 58C6           8946         1C            mov	$1C[bp],ax
19541 58C9           895E         1E            mov	$1E[bp],bx
19542                                           !BCC_EOS
19543                                           ! 3117             FLAGS &= 0xfffe;
19544                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19545 58CC           8B46         28            mov	ax,$28[bp]
19546 58CF           24                     FE  and	al,#$FE
19547 58D1           8946         28            mov	$28[bp],ax
19548                                           !BCC_EOS
19549                                           ! 3118             break;
19550 58D4           E9         0138            br 	.412
19551                                           !BCC_EOS
19552                                           ! 3119         }
19553                                           ! 3120         case 0x01: {
19554                       000058D7            .42C:
19555                                           ! 3121             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
19556                                           ! Debug: list int = const 0 (used reg = )
19557 58D7           31C0                       xor	ax,ax
19558 58D9           50                         push	ax
19559                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19560 58DA           B8                   EA10  mov	ax,#$EA10
19561 58DD           50                         push	ax
19562                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
19563 58DE           E8         AD26            call	_read_word
19564 58E1           83C4                   04  add	sp,*4
19565                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
19566 58E4           B9                   0014  mov	cx,*$14
19567 58E7           F7E9                       imul	cx
19568                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19569 58E9           8946         F4            mov	-$C[bp],ax
19570                                           !BCC_EOS
19571                                           ! 3122             FLAGS &= 0xfffe;
19572                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19573 58EC           8B46         28            mov	ax,$28[bp]
19574 58EF           24                     FE  and	al,#$FE
19575 58F1           8946         28            mov	$28[bp],ax
19576                                           !BCC_EOS
19577                                           ! 3123             regs.u.r8.cl = inb_cmos(0x30);
19578                                           ! Debug: list int = const $30 (used reg = )
19579 58F4           B8                   0030  mov	ax,*$30
19580 58F7           50                         push	ax
19581                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19582 58F8           E8         AC88            call	_inb_cmos
19583 58FB           44                         inc	sp
19584 58FC           44                         inc	sp
19585                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
19586 58FD           8846         1C            mov	$1C[bp],al
19587                                           !BCC_EOS
19588                                           ! 3124       
19589                                           ! 3124       regs.u.r8.ch = inb_cmos(0x31);
19590                                           ! Debug: list int = const $31 (used reg = )
19591 5900           B8                   0031  mov	ax,*$31
19592 5903           50                         push	ax
19593                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19594 5904           E8         AC7C            call	_inb_cmos
19595 5907           44                         inc	sp
19596 5908           44                         inc	sp
19597                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
19598 5909           8846         1D            mov	$1D[bp],al
19599                                           !BCC_EOS
19600                                           ! 3125             if (regs.u.r16.cx > (15*1024))
19601                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19602 590C           8B46         1C            mov	ax,$1C[bp]
19603 590F           3D                   3C00  cmp	ax,#$3C00
19604 5912           76           06            jbe 	.42D
19605                       00005914            .42E:
19606                                           ! 3126                 regs.u.r16.cx = 15*1024;
19607                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19608 5914           B8                   3C00  mov	ax,#$3C00
19609 5917           8946         1C            mov	$1C[bp],ax
19610                                           !BCC_EOS
19611                                           ! 3127             for (off = 0; off < e820_table_size; off += 0x14) {
19612                       0000591A            .42D:
19613                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
19614 591A           31C0                       xor	ax,ax
19615 591C           8946         F6            mov	-$A[bp],ax
19616                                           !BCC_EOS
19617                                           !BCC_EOS
19618 591F           EB           62            jmp .431
19619                       00005921            .432:
19620                                           ! 3128                 base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
19621                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
19622                                           ! Debug: expression subtree swapping
19623 5921           8B46         F6            mov	ax,-$A[bp]
19624                                           ! Debug: list unsigned int = ax+8 (used reg = )
19625 5924           05                   0008  add	ax,*8
19626 5927           50                         push	ax
19627                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19628 5928           B8                   EA10  mov	ax,#$EA10
19629 592B           50                         push	ax
19630                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19631 592C           E8         A754            call	_read_dword
19632 592F           89D3                       mov	bx,dx
19633 5931           83C4                   04  add	sp,*4
19634                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19635 5934           8946         F0            mov	-$10[bp],ax
19636 5937           895E         F2            mov	-$E[bp],bx
19637                                           !BCC_EOS
19638                                           ! 3129                 type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
19639                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
19640                                           ! Debug: expression subtree swapping
19641 593A           8B46         F6            mov	ax,-$A[bp]
19642                                           ! Debug: list unsigned int = ax+$18 (used reg = )
19643 593D           05                   0018  add	ax,*$18
19644 5940           50                         push	ax
19645                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19646 5941           B8                   EA10  mov	ax,#$EA10
19647 5944           50                         push	ax
19648                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19649 5945           E8         A73B            call	_read_dword
19650 5948           89D3                       mov	bx,dx
19651 594A           83C4                   04  add	sp,*4
19652                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
19653 594D           8946         EC            mov	-$14[bp],ax
19654 5950           895E         EE            mov	-$12[bp],bx
19655                                           !BCC_EOS
19656                                           ! 3130                 if ((base >= 0x100000) && (type == 1))
19657                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
19658 5953           31C0                       xor	ax,ax
19659 5955           BB                   0010  mov	bx,*$10
19660 5958           8D7E         F0            lea	di,-$10[bp]
19661 595B           E8         A76D            call	lcmpul
19662 595E           77           1A            ja  	.433
19663                       00005960            .435:
19664                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
19665                                           ! Debug: expression subtree swapping
19666 5960           B8                   0001  mov	ax,*1
19667 5963           31DB                       xor	bx,bx
19668 5965           53                         push	bx
19669 5966           50                         push	ax
19670 5967           8B46         EC            mov	ax,-$14[bp]
19671 596A           8B5E         EE            mov	bx,-$12[bp]
19672 596D           8D7E         E4            lea	di,-2+..FFF5[bp]
19673 5970           E8         A758            call	lcmpul
19674 5973           8D66         E8            lea	sp,2+..FFF5[bp]
19675 5976           75           02            jne 	.433
19676                       00005978            .434:
19677                                           ! 3131                     break;
19678 5978           EB           11            jmp .42F
19679                                           !BCC_EOS
19680                                           ! 3132             }
19681                       0000597A            .433:
19682                                           ! 3133             regs.u.r16.dx = 0;
19683                       0000597A            .430:
19684                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19685 597A           8B46         F6            mov	ax,-$A[bp]
19686 597D           05                   0014  add	ax,*$14
19687 5980           8946         F6            mov	-$A[bp],ax
19688                       00005983            .431:
19689                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19690 5983           8B46         F6            mov	ax,-$A[bp]
19691 5986           3B46         F4            cmp	ax,-$C[bp]
19692 5989           72           96            jb 	.432
19693                       0000598B            .436:
19694                       0000598B            .42F:
19695                                           ! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
19696 598B           31C0                       xor	ax,ax
19697 598D           8946         18            mov	$18[bp],ax
19698                                           !BCC_EOS
19699                                           ! 3134             if (off != e820_table_size) {
19700                                           ! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19701 5990           8B46         F6            mov	ax,-$A[bp]
19702 5993           3B46         F4            cmp	ax,-$C[bp]
19703 5996           74           54            je  	.437
19704                       00005998            .438:
19705                                           ! 3135                 size = base + read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x8 + off);
19706                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
19707                                           ! Debug: expression subtree swapping
19708 5998           8B46         F6            mov	ax,-$A[bp]
19709                                           ! Debug: list unsigned int = ax+$10 (used reg = )
19710 599B           05                   0010  add	ax,*$10
19711 599E           50                         push	ax
19712                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19713 599F           B8                   EA10  mov	ax,#$EA10
19714 59A2           50                         push	ax
19715                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19716 59A3           E8         A6DD            call	_read_dword
19717 59A6           89D3                       mov	bx,dx
19718 59A8           83C4                   04  add	sp,*4
19719                                           ! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19720                                           ! Debug: expression subtree swapping
19721 59AB           8D7E         F0            lea	di,-$10[bp]
19722 59AE           E8         A712            call	laddul
19723                                           ! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
19724 59B1           8946         E8            mov	-$18[bp],ax
19725 59B4           895E         EA            mov	-$16[bp],bx
19726                                           !BCC_EOS
19727                                           ! 3136                 if (size > 0x1000000) {
19728                                           ! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19729 59B7           31C0                       xor	ax,ax
19730 59B9           BB                   0100  mov	bx,#$100
19731 59BC           8D7E         E8            lea	di,-$18[bp]
19732 59BF           E8         A709            call	lcmpul
19733 59C2           73           28            jae 	.439
19734                       000059C4            .43A:
19735                                           ! 3137                     size -= 0x1000000;
19736                                           ! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19737 59C4           31C0                       xor	ax,ax
19738 59C6           BB                   0100  mov	bx,#$100
19739 59C9           53                         push	bx
19740 59CA           50                         push	ax
19741 59CB           8B46         E8            mov	ax,-$18[bp]
19742 59CE           8B5E         EA            mov	bx,-$16[bp]
19743 59D1           8D7E         E4            lea	di,-2+..FFF5[bp]
19744 59D4           E8         A70A            call	lsubul
19745 59D7           8946         E8            mov	-$18[bp],ax
19746 59DA           895E         EA            mov	-$16[bp],bx
19747 59DD           83C4                   04  add	sp,*4
19748                                           !BCC_EOS
19749                                           ! 3138                     regs.u.r16.dx = (Bit16u)(size >> 16);
19750                                           ! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
19751 59E0           8B46         E8            mov	ax,-$18[bp]
19752 59E3           8B5E         EA            mov	bx,-$16[bp]
19753 59E6           93                         xchg	bx,ax
19754 59E7           31DB                       xor	bx,bx
19755                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
19756                                           ! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
19757 59E9           8946         18            mov	$18[bp],ax
19758                                           !BCC_EOS
19759                                           ! 3139                 }
19760                                           ! 3140             }
19761                       000059EC            .439:
19762                                           ! 3141             regs.u.r16.ax = regs.u.r16.cx;
19763                       000059EC            .437:
19764                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
19765 59EC           8B46         1C            mov	ax,$1C[bp]
19766 59EF           8946         20            mov	$20[bp],ax
19767                                           !BCC_EOS
19768                                           ! 3142             regs.u.r16.bx = regs.u.r16.dx;
19769                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
19770 59F2           8B46         18            mov	ax,$18[bp]
19771 59F5           8946         14            mov	$14[bp],ax
19772                                           !BCC_EOS
19773                                           ! 3143             break;
19774 59F8           EB           15            jmp .412
19775                                           !BCC_EOS
19776                                           ! 3144         }
19777                                           ! 3145         default:
19778                                           ! 3146             goto int15_unimplemented;
19779                       000059FA            .43B:
19780 59FA           83C4                   00  add	sp,#..FFF4-..FFF5
19781 59FD           EB           12            jmp .FFF4
19782                                           !BCC_EOS
19783                                           ! 3147         }
19784                                           ! 3148         break;
19785 59FF           EB           0E            jmp .412
19786                       00005A01            .414:
19787 5A01           2C                     01  sub	al,*1
19788 5A03         0F84         FED0            beq 	.42C
19789 5A07           2C                     1F  sub	al,*$1F
19790 5A09         0F84         FD20            beq 	.415
19791 5A0D           EB           EB            jmp	.43B
19792                       00005A0F            .412:
19793 5A0F           EB           33            jmp .40D
19794                                           !BCC_EOS
19795                                           ! 3149     int15_unimplemented:
19796                       00005A11            .FFF4:
19797                                           ! 3150     default:
19798                                           ! 3151       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
19799                       00005A11            .43C:
19800                                           ! Debug: list unsigned short regs = [S+$1A+$12] (used reg = )
19801 5A11           FF76         14            push	$14[bp]
19802                                           ! Debug: list unsigned short regs = [S+$1C+$1E] (used reg = )
19803 5A14           FF76         20            push	$20[bp]
19804                                           ! Debug: list * char = .43D+0 (used reg = )
19805 5A17           BB                   D7C7  mov	bx,#.43D
19806 5A1A           53                         push	bx
19807                                           ! Debug: list int = const 4 (used reg = )
19808 5A1B           B8                   0004  mov	ax,*4
19809 5A1E           50                         push	ax
19810                                           ! Debug: func () void = bios_printf+0 (used reg = )
19811 5A1F           E8         AFF7            call	_bios_printf
19812 5A22           83C4                   08  add	sp,*8
19813                                           !BCC_EOS
19814                                           ! 3152       FLAGS |= 0x0001;
19815                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19816 5A25           8B46         28            mov	ax,$28[bp]
19817 5A28           0C                     01  or	al,*1
19818 5A2A           8946         28            mov	$28[bp],ax
19819                                           !BCC_EOS
19820                                           ! 3153       regs.u.r8.ah = 0x86;
19821                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
19822 5A2D           B0                     86  mov	al,#$86
19823 5A2F           8846         21            mov	$21[bp],al
19824                                           !BCC_EOS
19825                                           ! 3154       break;
19826 5A32           EB           10            jmp .40D
19827                                           !BCC_EOS
19828                                           ! 3155     }
19829                                           ! 3156 }
19830 5A34           EB           0E            jmp .40D
19831                       00005A36            .40F:
19832 5A36           2C                     86  sub	al,#$86
19833 5A38         0F84         FCA5            beq 	.410
19834 5A3C           2C                     62  sub	al,*$62
19835 5A3E         0F84         FCE5            beq 	.411
19836 5A42           EB           CD            jmp	.43C
19837                       00005A44            .40D:
19838                       FFFFFFE6            ..FFF5	=	-$1A
19839                       FFFFFFE6            ..FFF4	=	-$1A
19840 5A44           89EC                       mov	sp,bp
19841 5A46           5D                         pop	bp
19842 5A47           C3                         ret
19843                                           ! 3157   void
19844                                           ! Register BX used in function int15_function32
19845                                           ! 3158 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
19846                                           ! 3159   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
19847                                           export	_int16_function
19848                       00005A48            _int16_function:
19849                                           !BCC_EOS
19850                                           ! 3160 {
19851                                           ! 3161   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
19852                                           !BCC_EOS
19853                                           ! 3162   Bit16u kbd_code, max;
19854                                           !BCC_EOS
19855                                           ! 3163   ;
19856 5A48           55                         push	bp
19857 5A49           89E5                       mov	bp,sp
19858 5A4B           83C4                   F6  add	sp,*-$A
19859                                           !BCC_EOS
19860                                           ! 3164   shift_flags = read_byte(0x0040, 0x17);
19861                                           ! Debug: list int = const $17 (used reg = )
19862 5A4E           B8                   0017  mov	ax,*$17
19863 5A51           50                         push	ax
19864                                           ! Debug: list int = const $40 (used reg = )
19865 5A52           B8                   0040  mov	ax,*$40
19866 5A55           50                         push	ax
19867                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19868 5A56           E8         AB9B            call	_read_byte
19869 5A59           83C4                   04  add	sp,*4
19870                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
19871 5A5C           8846         FD            mov	-3[bp],al
19872                                           !BCC_EOS
19873                                           ! 3165   led_flags = read_byte(0x0040, 0x97);
19874                                           ! Debug: list int = const $97 (used reg = )
19875 5A5F           B8                   0097  mov	ax,#$97
19876 5A62           50                         push	ax
19877                                           ! Debug: list int = const $40 (used reg = )
19878 5A63           B8                   0040  mov	ax,*$40
19879 5A66           50                         push	ax
19880                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19881 5A67           E8         AB8A            call	_read_byte
19882 5A6A           83C4                   04  add	sp,*4
19883                                           ! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
19884 5A6D           8846         FC            mov	-4[bp],al
19885                                           !BCC_EOS
19886                                           ! 3166   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
19887                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
19888 5A70           8A46         FC            mov	al,-4[bp]
19889 5A73           24                     07  and	al,*7
19890 5A75           50                         push	ax
19891                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
19892 5A76           8A46         FD            mov	al,-3[bp]
19893 5A79           30E4                       xor	ah,ah
19894 5A7B           B1                     04  mov	cl,*4
19895 5A7D           D3E8                       shr	ax,cl
19896                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
19897 5A7F           24                     07  and	al,*7
19898                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
19899 5A81           3246         F4            xor	al,-$C[bp]
19900 5A84           44                         inc	sp
19901 5A85           44                         inc	sp
19902                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
19903 5A86           84C0                       test	al,al
19904 5A88         0F84         00A3            beq 	.43E
19905                       00005A8C            .43F:
19906                                           ! 3167 #asm
19907                                           !BCC_EOS
19908                                           !BCC_ASM
19909                       00000012            _int16_function.BP	set	$12
19910                       00000008            .int16_function.BP	set	8
19911                       00000005            _int16_function.count	set	5
19912                       FFFFFFFB            .int16_function.count	set	-5
19913                       0000001A            _int16_function.CX	set	$1A
19914                       00000010            .int16_function.CX	set	$10
19915                       00000008            _int16_function.ascii_code	set	8
19916                       FFFFFFFE            .int16_function.ascii_code	set	-2
19917                       0000000E            _int16_function.DI	set	$E
19918                       00000004            .int16_function.DI	set	4
19919                       0000001E            _int16_function.FLAGS	set	$1E
19920                       00000014            .int16_function.FLAGS	set	$14
19921                       00000002            _int16_function.kbd_code	set	2
19922                       FFFFFFF8            .int16_function.kbd_code	set	-8
19923                       00000009            _int16_function.scan_code	set	9
19924                       FFFFFFFF            .int16_function.scan_code	set	-1
19925                       00000018            _int16_function.DX	set	$18
19926                       0000000E            .int16_function.DX	set	$E
19927                       00000006            _int16_function.led_flags	set	6
19928                       FFFFFFFC            .int16_function.led_flags	set	-4
19929                       00000010            _int16_function.SI	set	$10
19930                       00000006            .int16_function.SI	set	6
19931                       0000001C            _int16_function.AX	set	$1C
19932                       00000012            .int16_function.AX	set	$12
19933                       00000014            _int16_function.SP	set	$14
19934                       0000000A            .int16_function.SP	set	$A
19935                       00000016            _int16_function.BX	set	$16
19936                       0000000C            .int16_function.BX	set	$C
19937                       00000007            _int16_function.shift_flags	set	7
19938                       FFFFFFFD            .int16_function.shift_flags	set	-3
19939                       00000000            _int16_function.max	set	0
19940                       FFFFFFF6            .int16_function.max	set	-$A
19941 5A8C           FA                             cli
19942                                           ! 3169 endasm
19943                                           !BCC_ENDASM
19944                                           !BCC_EOS
19945                                           ! 3170     outb(0x60, 0xed);
19946                                           ! Debug: list int = const $ED (used reg = )
19947 5A8D           B8                   00ED  mov	ax,#$ED
19948 5A90           50                         push	ax
19949                                           ! Debug: list int = const $60 (used reg = )
19950 5A91           B8                   0060  mov	ax,*$60
19951 5A94           50                         push	ax
19952                                           ! Debug: func () void = outb+0 (used reg = )
19953 5A95           E8         AABC            call	_outb
19954 5A98           83C4                   04  add	sp,*4
19955                                           !BCC_EOS
19956                                           ! 3171     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
19957 5A9B           EB           0E            jmp .441
19958                       00005A9D            .442:
19959                                           ! Debug: list int = const $21 (used reg = )
19960 5A9D           B8                   0021  mov	ax,*$21
19961 5AA0           50                         push	ax
19962                                           ! Debug: list int = const $80 (used reg = )
19963 5AA1           B8                   0080  mov	ax,#$80
19964 5AA4           50                         push	ax
19965                                           ! Debug: func () void = outb+0 (used reg = )
19966 5AA5           E8         AAAC            call	_outb
19967 5AA8           83C4                   04  add	sp,*4
19968                                           !BCC_EOS
19969                                           ! 3172     if ((inb(0x60) == 0xfa)) {
19970                       00005AAB            .441:
19971                                           ! Debug: list int = const $64 (used reg = )
19972 5AAB           B8                   0064  mov	ax,*$64
19973 5AAE           50                         push	ax
19974                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19975 5AAF           E8         AA8C            call	_inb
19976 5AB2           44                         inc	sp
19977 5AB3           44                         inc	sp
19978                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19979 5AB4           24                     01  and	al,*1
19980                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19981 5AB6           84C0                       test	al,al
19982 5AB8           74           E3            je 	.442
19983                       00005ABA            .443:
19984                       00005ABA            .440:
19985                                           ! Debug: list int = const $60 (used reg = )
19986 5ABA           B8                   0060  mov	ax,*$60
19987 5ABD           50                         push	ax
19988                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19989 5ABE           E8         AA7D            call	_inb
19990 5AC1           44                         inc	sp
19991 5AC2           44                         inc	sp
19992                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
19993 5AC3           3C                     FA  cmp	al,#$FA
19994 5AC5           75           67            jne 	.444
19995                       00005AC7            .445:
19996                                           ! 3173       led_flags &= 0xf8;
19997                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
19998 5AC7           8A46         FC            mov	al,-4[bp]
19999 5ACA           24                     F8  and	al,#$F8
20000 5ACC           8846         FC            mov	-4[bp],al
20001                                           !BCC_EOS
20002                                           ! 3174       led_flags |= ((shift_flags >> 4) & 0x07);
20003                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
20004 5ACF           8A46         FD            mov	al,-3[bp]
20005 5AD2           30E4                       xor	ah,ah
20006 5AD4           B1                     04  mov	cl,*4
20007 5AD6           D3E8                       shr	ax,cl
20008                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
20009 5AD8           24                     07  and	al,*7
20010                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
20011 5ADA           0A46         FC            or	al,-4[bp]
20012 5ADD           8846         FC            mov	-4[bp],al
20013                                           !BCC_EOS
20014                                           ! 3175       outb(0x60, led_flags & 0x07);
20015                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
20016 5AE0           8A46         FC            mov	al,-4[bp]
20017 5AE3           24                     07  and	al,*7
20018                                           ! Debug: list unsigned char = al+0 (used reg = )
20019 5AE5           30E4                       xor	ah,ah
20020 5AE7           50                         push	ax
20021                                           ! Debug: list int = const $60 (used reg = )
20022 5AE8           B8                   0060  mov	ax,*$60
20023 5AEB           50                         push	ax
20024                                           ! Debug: func () void = outb+0 (used reg = )
20025 5AEC           E8         AA65            call	_outb
20026 5AEF           83C4                   04  add	sp,*4
20027                                           !BCC_EOS
20028                                           ! 3176       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
20029 5AF2           EB           0E            jmp .447
20030                       00005AF4            .448:
20031                                           ! Debug: list int = const $21 (used reg = )
20032 5AF4           B8                   0021  mov	ax,*$21
20033 5AF7           50                         push	ax
20034                                           ! Debug: list int = const $80 (used reg = )
20035 5AF8           B8                   0080  mov	ax,#$80
20036 5AFB           50                         push	ax
20037                                           ! Debug: func () void = outb+0 (used reg = )
20038 5AFC           E8         AA55            call	_outb
20039 5AFF           83C4                   04  add	sp,*4
20040                                           !BCC_EOS
20041                                           ! 3177       inb(0x60);
20042                       00005B02            .447:
20043                                           ! Debug: list int = const $64 (used reg = )
20044 5B02           B8                   0064  mov	ax,*$64
20045 5B05           50                         push	ax
20046                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20047 5B06           E8         AA35            call	_inb
20048 5B09           44                         inc	sp
20049 5B0A           44                         inc	sp
20050                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20051 5B0B           24                     01  and	al,*1
20052                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20053 5B0D           84C0                       test	al,al
20054 5B0F           74           E3            je 	.448
20055                       00005B11            .449:
20056                       00005B11            .446:
20057                                           ! Debug: list int = const $60 (used reg = )
20058 5B11           B8                   0060  mov	ax,*$60
20059 5B14           50                         push	ax
20060                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20061 5B15           E8         AA26            call	_inb
20062 5B18           44                         inc	sp
20063 5B19           44                         inc	sp
20064                                           !BCC_EOS
20065                                           ! 3178       write_byte(0x0040, 0x97, led_flags);
20066                                           ! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
20067 5B1A           8A46         FC            mov	al,-4[bp]
20068 5B1D           30E4                       xor	ah,ah
20069 5B1F           50                         push	ax
20070                                           ! Debug: list int = const $97 (used reg = )
20071 5B20           B8                   0097  mov	ax,#$97
20072 5B23           50                         push	ax
20073                                           ! Debug: list int = const $40 (used reg = )
20074 5B24           B8                   0040  mov	ax,*$40
20075 5B27           50                         push	ax
20076                                           ! Debug: func () void = write_byte+0 (used reg = )
20077 5B28           E8         AAEF            call	_write_byte
20078 5B2B           83C4                   06  add	sp,*6
20079                                           !BCC_EOS
20080                                           ! 3179     }
20081                                           ! 3180 #asm
20082                       00005B2E            .444:
20083                                           !BCC_EOS
20084                                           !BCC_ASM
20085                       00000012            _int16_function.BP	set	$12
20086                       00000008            .int16_function.BP	set	8
20087                       00000005            _int16_function.count	set	5
20088                       FFFFFFFB            .int16_function.count	set	-5
20089                       0000001A            _int16_function.CX	set	$1A
20090                       00000010            .int16_function.CX	set	$10
20091                       00000008            _int16_function.ascii_code	set	8
20092                       FFFFFFFE            .int16_function.ascii_code	set	-2
20093                       0000000E            _int16_function.DI	set	$E
20094                       00000004            .int16_function.DI	set	4
20095                       0000001E            _int16_function.FLAGS	set	$1E
20096                       00000014            .int16_function.FLAGS	set	$14
20097                       00000002            _int16_function.kbd_code	set	2
20098                       FFFFFFF8            .int16_function.kbd_code	set	-8
20099                       00000009            _int16_function.scan_code	set	9
20100                       FFFFFFFF            .int16_function.scan_code	set	-1
20101                       00000018            _int16_function.DX	set	$18
20102                       0000000E            .int16_function.DX	set	$E
20103                       00000006            _int16_function.led_flags	set	6
20104                       FFFFFFFC            .int16_function.led_flags	set	-4
20105                       00000010            _int16_function.SI	set	$10
20106                       00000006            .int16_function.SI	set	6
20107                       0000001C            _int16_function.AX	set	$1C
20108                       00000012            .int16_function.AX	set	$12
20109                       00000014            _int16_function.SP	set	$14
20110                       0000000A            .int16_function.SP	set	$A
20111                       00000016            _int16_function.BX	set	$16
20112                       0000000C            .int16_function.BX	set	$C
20113                       00000007            _int16_function.shift_flags	set	7
20114                       FFFFFFFD            .int16_function.shift_flags	set	-3
20115                       00000000            _int16_function.max	set	0
20116                       FFFFFFF6            .int16_function.max	set	-$A
20117 5B2E           FB                             sti
20118                                           ! 3182 endasm
20119                                           !BCC_ENDASM
20120                                           !BCC_EOS
20121                                           ! 3183   }
20122                                           ! 3184   switch (( AX >> 8 )) {
20123                       00005B2F            .43E:
20124                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
20125 5B2F           8B46         12            mov	ax,$12[bp]
20126 5B32           88E0                       mov	al,ah
20127 5B34           30E4                       xor	ah,ah
20128 5B36           E9         0303            br 	.44C
20129                                           ! 3185     case 0x00:
20130                                           ! 3186       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20131                       00005B39            .44D:
20132                                           ! Debug: list int = const 1 (used reg = )
20133 5B39           B8                   0001  mov	ax,*1
20134 5B3C           50                         push	ax
20135                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20136 5B3D           8D5E         FE            lea	bx,-2[bp]
20137 5B40           53                         push	bx
20138                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20139 5B41           8D5E         FF            lea	bx,-1[bp]
20140 5B44           53                         push	bx
20141                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20142 5B45           E8         0342            call	_dequeue_key
20143 5B48           83C4                   06  add	sp,*6
20144 5B4B           85C0                       test	ax,ax
20145 5B4D           75           0E            jne 	.44E
20146                       00005B4F            .44F:
20147                                           ! 3187         bios_printf(
20148                                           ! 3187 (2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
20149                                           ! Debug: list * char = .450+0 (used reg = )
20150 5B4F           BB                   D7A3  mov	bx,#.450
20151 5B52           53                         push	bx
20152                                           ! Debug: list int = const 7 (used reg = )
20153 5B53           B8                   0007  mov	ax,*7
20154 5B56           50                         push	ax
20155                                           ! Debug: func () void = bios_printf+0 (used reg = )
20156 5B57           E8         AEBF            call	_bios_printf
20157 5B5A           83C4                   04  add	sp,*4
20158                                           !BCC_EOS
20159                                           ! 3188         }
20160                                           ! 3189       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20161                       00005B5D            .44E:
20162                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20163 5B5D           8A46         FF            mov	al,-1[bp]
20164 5B60           84C0                       test	al,al
20165 5B62           74           0E            je  	.451
20166                       00005B64            .453:
20167                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20168 5B64           8A46         FE            mov	al,-2[bp]
20169 5B67           3C                     F0  cmp	al,#$F0
20170 5B69           75           07            jne 	.451
20171                       00005B6B            .452:
20172                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20173 5B6B           30C0                       xor	al,al
20174 5B6D           8846         FE            mov	-2[bp],al
20175                                           !BCC_EOS
20176                                           ! 3190       else if (ascii_code == 0xE0) ascii_code = 0;
20177 5B70           EB           0C            jmp .454
20178                       00005B72            .451:
20179                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20180 5B72           8A46         FE            mov	al,-2[bp]
20181 5B75           3C                     E0  cmp	al,#$E0
20182 5B77           75           05            jne 	.455
20183                       00005B79            .456:
20184                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20185 5B79           30C0                       xor	al,al
20186 5B7B           8846         FE            mov	-2[bp],al
20187                                           !BCC_EOS
20188                                           ! 3191       AX = (scan_code << 8) | ascii_code;
20189                       00005B7E            .455:
20190                       00005B7E            .454:
20191                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20192 5B7E           8A46         FF            mov	al,-1[bp]
20193 5B81           30E4                       xor	ah,ah
20194 5B83           88C4                       mov	ah,al
20195 5B85           30C0                       xor	al,al
20196                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20197 5B87           0A46         FE            or	al,-2[bp]
20198                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20199 5B8A           8946         12            mov	$12[bp],ax
20200                                           !BCC_EOS
20201                                           ! 3192       break;
20202 5B8D           E9         02F6            br 	.44A
20203                                           !BCC_EOS
20204                                           ! 3193     case 0x01:
20205                                           ! 3194       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20206                       00005B90            .457:
20207                                           ! Debug: list int = const 0 (used reg = )
20208 5B90           31C0                       xor	ax,ax
20209 5B92           50                         push	ax
20210                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20211 5B93           8D5E         FE            lea	bx,-2[bp]
20212 5B96           53                         push	bx
20213                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20214 5B97           8D5E         FF            lea	bx,-1[bp]
20215 5B9A           53                         push	bx
20216                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20217 5B9B           E8         02EC            call	_dequeue_key
20218 5B9E           83C4                   06  add	sp,*6
20219 5BA1           85C0                       test	ax,ax
20220 5BA3           75           0C            jne 	.458
20221                       00005BA5            .459:
20222                                           ! 3195         FLAGS |= 0x0040;
20223                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20224 5BA5           8B46         14            mov	ax,$14[bp]
20225 5BA8           0C                     40  or	al,*$40
20226 5BAA           8946         14            mov	$14[bp],ax
20227                                           !BCC_EOS
20228                                           ! 3196         return;
20229 5BAD           89EC                       mov	sp,bp
20230 5BAF           5D                         pop	bp
20231 5BB0           C3                         ret
20232                                           !BCC_EOS
20233                                           ! 3197         }
20234                                           ! 3198       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20235                       00005BB1            .458:
20236                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20237 5BB1           8A46         FF            mov	al,-1[bp]
20238 5BB4           84C0                       test	al,al
20239 5BB6           74           0E            je  	.45A
20240                       00005BB8            .45C:
20241                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20242 5BB8           8A46         FE            mov	al,-2[bp]
20243 5BBB           3C                     F0  cmp	al,#$F0
20244 5BBD           75           07            jne 	.45A
20245                       00005BBF            .45B:
20246                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20247 5BBF           30C0                       xor	al,al
20248 5BC1           8846         FE            mov	-2[bp],al
20249                                           !BCC_EOS
20250                                           ! 3199       else if (ascii_code == 0xE0) ascii_code = 0;
20251 5BC4           EB           0C            jmp .45D
20252                       00005BC6            .45A:
20253                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20254 5BC6           8A46         FE            mov	al,-2[bp]
20255 5BC9           3C                     E0  cmp	al,#$E0
20256 5BCB           75           05            jne 	.45E
20257                       00005BCD            .45F:
20258                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20259 5BCD           30C0                       xor	al,al
20260 5BCF           8846         FE            mov	-2[bp],al
20261                                           !BCC_EOS
20262                                           ! 3200       AX = (scan_code << 8) | ascii_code;
20263                       00005BD2            .45E:
20264                       00005BD2            .45D:
20265                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20266 5BD2           8A46         FF            mov	al,-1[bp]
20267 5BD5           30E4                       xor	ah,ah
20268 5BD7           88C4                       mov	ah,al
20269 5BD9           30C0                       xor	al,al
20270                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20271 5BDB           0A46         FE            or	al,-2[bp]
20272                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20273 5BDE           8946         12            mov	$12[bp],ax
20274                                           !BCC_EOS
20275                                           ! 3201       FLAGS &= 0xffbf;
20276                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20277 5BE1           8B46         14            mov	ax,$14[bp]
20278 5BE4           24                     BF  and	al,#$BF
20279 5BE6           8946         14            mov	$14[bp],ax
20280                                           !BCC_EOS
20281                                           ! 3202       break;
20282 5BE9           E9         029A            br 	.44A
20283                                           !BCC_EOS
20284                                           ! 3203     case 0x02:
20285                                           ! 3204       shift_flags = read_byte(0x0040, 0x17);
20286                       00005BEC            .460:
20287                                           ! Debug: list int = const $17 (used reg = )
20288 5BEC           B8                   0017  mov	ax,*$17
20289 5BEF           50                         push	ax
20290                                           ! Debug: list int = const $40 (used reg = )
20291 5BF0           B8                   0040  mov	ax,*$40
20292 5BF3           50                         push	ax
20293                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20294 5BF4           E8         A9FD            call	_read_byte
20295 5BF7           83C4                   04  add	sp,*4
20296                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20297 5BFA           8846         FD            mov	-3[bp],al
20298                                           !BCC_EOS
20299                                           ! 3205       AX = ((AX & 0xff00) | (shift_flags));
20300                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20301 5BFD           8B46         12            mov	ax,$12[bp]
20302 5C00           30C0                       xor	al,al
20303                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20304 5C02           0A46         FD            or	al,-3[bp]
20305                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20306 5C05           8946         12            mov	$12[bp],ax
20307                                           !BCC_EOS
20308                                           ! 3206       break;
20309 5C08           E9         027B            br 	.44A
20310                                           !BCC_EOS
20311                                           ! 3207     case 0x05:
20312                                           ! 3208       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
20313                       00005C0B            .461:
20314                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
20315 5C0B           8A46         10            mov	al,$10[bp]
20316                                           ! Debug: list unsigned char = al+0 (used reg = )
20317 5C0E           30E4                       xor	ah,ah
20318 5C10           50                         push	ax
20319                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
20320 5C11           8B46         10            mov	ax,$10[bp]
20321 5C14           88E0                       mov	al,ah
20322 5C16           30E4                       xor	ah,ah
20323                                           ! Debug: list unsigned int = ax+0 (used reg = )
20324 5C18           50                         push	ax
20325                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20326 5C19           E8         0C1C            call	_enqueue_key
20327 5C1C           83C4                   04  add	sp,*4
20328 5C1F           85C0                       test	ax,ax
20329 5C21           75           0C            jne 	.462
20330                       00005C23            .463:
20331                                           ! 3209         AX = ((AX & 0xff00) | (1));
20332                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20333 5C23           8B46         12            mov	ax,$12[bp]
20334 5C26           30C0                       xor	al,al
20335                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
20336 5C28           0C                     01  or	al,*1
20337                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20338 5C2A           8946         12            mov	$12[bp],ax
20339                                           !BCC_EOS
20340                                           ! 3210         }
20341                                           ! 3211       else {
20342 5C2D           EB           0A            jmp .464
20343                       00005C2F            .462:
20344                                           ! 3212         AX = ((AX & 0xff00) | (0));
20345                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20346 5C2F           8B46         12            mov	ax,$12[bp]
20347 5C32           30C0                       xor	al,al
20348                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
20349 5C34           0C                     00  or	al,*0
20350                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20351 5C36           8946         12            mov	$12[bp],ax
20352                                           !BCC_EOS
20353                                           ! 3213         }
20354                                           ! 3214       break;
20355                       00005C39            .464:
20356 5C39           E9         024A            br 	.44A
20357                                           !BCC_EOS
20358                                           ! 3215     case 0x09:
20359                                           ! 3216       AX = ((AX & 0xff00) | (0x30));
20360                       00005C3C            .465:
20361                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20362 5C3C           8B46         12            mov	ax,$12[bp]
20363 5C3F           30C0                       xor	al,al
20364                                           ! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
20365 5C41           0C                     30  or	al,*$30
20366                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20367 5C43           8946         12            mov	$12[bp],ax
20368                                           !BCC_EOS
20369                                           ! 3217       break;
20370 5C46           E9         023D            br 	.44A
20371                                           !BCC_EOS
20372                                           ! 3218     case 0x0A:
20373                                           ! 3219       count = 2;
20374                       00005C49            .466:
20375                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
20376 5C49           B0                     02  mov	al,*2
20377 5C4B           8846         FB            mov	-5[bp],al
20378                                           !BCC_EOS
20379                                           ! 3220       kbd_code = 0x0;
20380                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20381 5C4E           31C0                       xor	ax,ax
20382 5C50           8946         F8            mov	-8[bp],ax
20383                                           !BCC_EOS
20384                                           ! 3221       outb(0x60, 0xf2);
20385                                           ! Debug: list int = const $F2 (used reg = )
20386 5C53           B8                   00F2  mov	ax,#$F2
20387 5C56           50                         push	ax
20388                                           ! Debug: list int = const $60 (used reg = )
20389 5C57           B8                   0060  mov	ax,*$60
20390 5C5A           50                         push	ax
20391                                           ! Debug: func () void = outb+0 (used reg = )
20392 5C5B           E8         A8F6            call	_outb
20393 5C5E           83C4                   04  add	sp,*4
20394                                           !BCC_EOS
20395                                           ! 3222       max=0xffff;
20396                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20397 5C61           B8                   FFFF  mov	ax,#$FFFF
20398 5C64           8946         F6            mov	-$A[bp],ax
20399                                           !BCC_EOS
20400                                           ! 3223       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20401 5C67           EB           0D            jmp .468
20402                       00005C69            .469:
20403                                           ! Debug: list int = const 0 (used reg = )
20404 5C69           31C0                       xor	ax,ax
20405 5C6B           50                         push	ax
20406                                           ! Debug: list int = const $80 (used reg = )
20407 5C6C           B8                   0080  mov	ax,#$80
20408 5C6F           50                         push	ax
20409                                           ! Debug: func () void = outb+0 (used reg = )
20410 5C70           E8         A8E1            call	_outb
20411 5C73           83C4                   04  add	sp,*4
20412                                           !BCC_EOS
20413                                           ! 3224       if (max>0x0) {
20414                       00005C76            .468:
20415                                           ! Debug: list int = const $64 (used reg = )
20416 5C76           B8                   0064  mov	ax,*$64
20417 5C79           50                         push	ax
20418                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20419 5C7A           E8         A8C1            call	_inb
20420 5C7D           44                         inc	sp
20421 5C7E           44                         inc	sp
20422                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20423 5C7F           24                     01  and	al,*1
20424                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20425 5C81           84C0                       test	al,al
20426 5C83           75           0B            jne 	.46A
20427                       00005C85            .46B:
20428                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20429 5C85           8B46         F6            mov	ax,-$A[bp]
20430 5C88           48                         dec	ax
20431 5C89           8946         F6            mov	-$A[bp],ax
20432                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20433 5C8C           85C0                       test	ax,ax
20434 5C8E           75           D9            jne	.469
20435                       00005C90            .46A:
20436                       00005C90            .467:
20437                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20438 5C90           8B46         F6            mov	ax,-$A[bp]
20439 5C93           85C0                       test	ax,ax
20440 5C95           74           6D            je  	.46C
20441                       00005C97            .46D:
20442                                           ! 3225         if ((inb(0x60) == 0xfa)) {
20443                                           ! Debug: list int = const $60 (used reg = )
20444 5C97           B8                   0060  mov	ax,*$60
20445 5C9A           50                         push	ax
20446                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20447 5C9B           E8         A8A0            call	_inb
20448 5C9E           44                         inc	sp
20449 5C9F           44                         inc	sp
20450                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
20451 5CA0           3C                     FA  cmp	al,#$FA
20452 5CA2           75           60            jne 	.46E
20453                       00005CA4            .46F:
20454                                           ! 3226           do {
20455                       00005CA4            .472:
20456                                           ! 3227             max=0xffff;
20457                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20458 5CA4           B8                   FFFF  mov	ax,#$FFFF
20459 5CA7           8946         F6            mov	-$A[bp],ax
20460                                           !BCC_EOS
20461                                           ! 3228             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20462 5CAA           EB           0D            jmp .474
20463                       00005CAC            .475:
20464                                           ! Debug: list int = const 0 (used reg = )
20465 5CAC           31C0                       xor	ax,ax
20466 5CAE           50                         push	ax
20467                                           ! Debug: list int = const $80 (used reg = )
20468 5CAF           B8                   0080  mov	ax,#$80
20469 5CB2           50                         push	ax
20470                                           ! Debug: func () void = outb+0 (used reg = )
20471 5CB3           E8         A89E            call	_outb
20472 5CB6           83C4                   04  add	sp,*4
20473                                           !BCC_EOS
20474                                           ! 3229             if (max>0x0) {
20475                       00005CB9            .474:
20476                                           ! Debug: list int = const $64 (used reg = )
20477 5CB9           B8                   0064  mov	ax,*$64
20478 5CBC           50                         push	ax
20479                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20480 5CBD           E8         A87E            call	_inb
20481 5CC0           44                         inc	sp
20482 5CC1           44                         inc	sp
20483                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20484 5CC2           24                     01  and	al,*1
20485                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20486 5CC4           84C0                       test	al,al
20487 5CC6           75           0B            jne 	.476
20488                       00005CC8            .477:
20489                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20490 5CC8           8B46         F6            mov	ax,-$A[bp]
20491 5CCB           48                         dec	ax
20492 5CCC           8946         F6            mov	-$A[bp],ax
20493                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20494 5CCF           85C0                       test	ax,ax
20495 5CD1           75           D9            jne	.475
20496                       00005CD3            .476:
20497                       00005CD3            .473:
20498                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20499 5CD3           8B46         F6            mov	ax,-$A[bp]
20500 5CD6           85C0                       test	ax,ax
20501 5CD8           74           1F            je  	.478
20502                       00005CDA            .479:
20503                                           ! 3230               kbd_code >>= 8;
20504                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20505 5CDA           8B46         F8            mov	ax,-8[bp]
20506 5CDD           88E0                       mov	al,ah
20507 5CDF           30E4                       xor	ah,ah
20508 5CE1           8946         F8            mov	-8[bp],ax
20509                                           !BCC_EOS
20510                                           ! 3231               kbd_code |= (inb(0x60) << 8);
20511                                           ! Debug: list int = const $60 (used reg = )
20512 5CE4           B8                   0060  mov	ax,*$60
20513 5CE7           50                         push	ax
20514                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20515 5CE8           E8         A853            call	_inb
20516 5CEB           44                         inc	sp
20517 5CEC           44                         inc	sp
20518                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
20519 5CED           30E4                       xor	ah,ah
20520 5CEF           88C4                       mov	ah,al
20521 5CF1           30C0                       xor	al,al
20522                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20523 5CF3           0B46         F8            or	ax,-8[bp]
20524 5CF6           8946         F8            mov	-8[bp],ax
20525                                           !BCC_EOS
20526                                           ! 3232             }
20527                                           ! 3233           } while (--count>0);
20528                       00005CF9            .478:
20529                       00005CF9            .471:
20530                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
20531 5CF9           8A46         FB            mov	al,-5[bp]
20532 5CFC           48                         dec	ax
20533 5CFD           8846         FB            mov	-5[bp],al
20534                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20535 5D00           84C0                       test	al,al
20536 5D02           75           A0            jne	.472
20537                       00005D04            .47A:
20538                                           !BCC_EOS
20539                                           ! 3234         }
20540                       00005D04            .470:
20541                                           ! 3235       }
20542                       00005D04            .46E:
20543                                           ! 3236       BX=kbd_code;
20544                       00005D04            .46C:
20545                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
20546 5D04           8B46         F8            mov	ax,-8[bp]
20547 5D07           8946         0C            mov	$C[bp],ax
20548                                           !BCC_EOS
20549                                           ! 3237       break;
20550 5D0A           E9         0179            br 	.44A
20551                                           !BCC_EOS
20552                                           ! 3238     case 0x10:
20553                                           ! 3239       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20554                       00005D0D            .47B:
20555                                           ! Debug: list int = const 1 (used reg = )
20556 5D0D           B8                   0001  mov	ax,*1
20557 5D10           50                         push	ax
20558                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20559 5D11           8D5E         FE            lea	bx,-2[bp]
20560 5D14           53                         push	bx
20561                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20562 5D15           8D5E         FF            lea	bx,-1[bp]
20563 5D18           53                         push	bx
20564                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20565 5D19           E8         016E            call	_dequeue_key
20566 5D1C           83C4                   06  add	sp,*6
20567 5D1F           85C0                       test	ax,ax
20568 5D21           75           0E            jne 	.47C
20569                       00005D23            .47D:
20570                                           ! 3240         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
20571                                           ! Debug: list * char = .47E+0 (used reg = )
20572 5D23           BB                   D77F  mov	bx,#.47E
20573 5D26           53                         push	bx
20574                                           ! Debug: list int = const 7 (used reg = )
20575 5D27           B8                   0007  mov	ax,*7
20576 5D2A           50                         push	ax
20577                                           ! Debug: func () void = bios_printf+0 (used reg = )
20578 5D2B           E8         ACEB            call	_bios_printf
20579 5D2E           83C4                   04  add	sp,*4
20580                                           !BCC_EOS
20581                                           ! 3241         }
20582                                           ! 3242       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20583                       00005D31            .47C:
20584                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20585 5D31           8A46         FF            mov	al,-1[bp]
20586 5D34           84C0                       test	al,al
20587 5D36           74           0C            je  	.47F
20588                       00005D38            .481:
20589                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20590 5D38           8A46         FE            mov	al,-2[bp]
20591 5D3B           3C                     F0  cmp	al,#$F0
20592 5D3D           75           05            jne 	.47F
20593                       00005D3F            .480:
20594                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20595 5D3F           30C0                       xor	al,al
20596 5D41           8846         FE            mov	-2[bp],al
20597                                           !BCC_EOS
20598                                           ! 3243       AX = (scan_code << 8) | ascii_code;
20599                       00005D44            .47F:
20600                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20601 5D44           8A46         FF            mov	al,-1[bp]
20602 5D47           30E4                       xor	ah,ah
20603 5D49           88C4                       mov	ah,al
20604 5D4B           30C0                       xor	al,al
20605                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20606 5D4D           0A46         FE            or	al,-2[bp]
20607                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20608 5D50           8946         12            mov	$12[bp],ax
20609                                           !BCC_EOS
20610                                           ! 3244       break;
20611 5D53           E9         0130            br 	.44A
20612                                           !BCC_EOS
20613                                           ! 3245     case 0x11:
20614                                           ! 3246       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20615                       00005D56            .482:
20616                                           ! Debug: list int = const 0 (used reg = )
20617 5D56           31C0                       xor	ax,ax
20618 5D58           50                         push	ax
20619                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20620 5D59           8D5E         FE            lea	bx,-2[bp]
20621 5D5C           53                         push	bx
20622                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20623 5D5D           8D5E         FF            lea	bx,-1[bp]
20624 5D60           53                         push	bx
20625                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20626 5D61           E8         0126            call	_dequeue_key
20627 5D64           83C4                   06  add	sp,*6
20628 5D67           85C0                       test	ax,ax
20629 5D69           75           0C            jne 	.483
20630                       00005D6B            .484:
20631                                           ! 3247         FLAGS |= 0x0040;
20632                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20633 5D6B           8B46         14            mov	ax,$14[bp]
20634 5D6E           0C                     40  or	al,*$40
20635 5D70           8946         14            mov	$14[bp],ax
20636                                           !BCC_EOS
20637                                           ! 3248         return;
20638 5D73           89EC                       mov	sp,bp
20639 5D75           5D                         pop	bp
20640 5D76           C3                         ret
20641                                           !BCC_EOS
20642                                           ! 3249         }
20643                                           ! 3250       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20644                       00005D77            .483:
20645                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20646 5D77           8A46         FF            mov	al,-1[bp]
20647 5D7A           84C0                       test	al,al
20648 5D7C           74           0C            je  	.485
20649                       00005D7E            .487:
20650                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20651 5D7E           8A46         FE            mov	al,-2[bp]
20652 5D81           3C                     F0  cmp	al,#$F0
20653 5D83           75           05            jne 	.485
20654                       00005D85            .486:
20655                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20656 5D85           30C0                       xor	al,al
20657 5D87           8846         FE            mov	-2[bp],al
20658                                           !BCC_EOS
20659                                           ! 3251       AX = (scan_code << 8) | ascii_code;
20660                       00005D8A            .485:
20661                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20662 5D8A           8A46         FF            mov	al,-1[bp]
20663 5D8D           30E4                       xor	ah,ah
20664 5D8F           88C4                       mov	ah,al
20665 5D91           30C0                       xor	al,al
20666                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20667 5D93           0A46         FE            or	al,-2[bp]
20668                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20669 5D96           8946         12            mov	$12[bp],ax
20670                                           !BCC_EOS
20671                                           ! 3252       FLAGS &= 0xffbf;
20672                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20673 5D99           8B46         14            mov	ax,$14[bp]
20674 5D9C           24                     BF  and	al,#$BF
20675 5D9E           8946         14            mov	$14[bp],ax
20676                                           !BCC_EOS
20677                                           ! 3253       break;
20678 5DA1           E9         00E2            br 	.44A
20679                                           !BCC_EOS
20680                                           ! 3254     case 0x12:
20681                                           ! 3255       shift_flags = read_byte(0x0040, 
20682                       00005DA4            .488:
20683                                           ! 3255 0x17);
20684                                           ! Debug: list int = const $17 (used reg = )
20685 5DA4           B8                   0017  mov	ax,*$17
20686 5DA7           50                         push	ax
20687                                           ! Debug: list int = const $40 (used reg = )
20688 5DA8           B8                   0040  mov	ax,*$40
20689 5DAB           50                         push	ax
20690                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20691 5DAC           E8         A845            call	_read_byte
20692 5DAF           83C4                   04  add	sp,*4
20693                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20694 5DB2           8846         FD            mov	-3[bp],al
20695                                           !BCC_EOS
20696                                           ! 3256       AX = ((AX & 0xff00) | (shift_flags));
20697                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20698 5DB5           8B46         12            mov	ax,$12[bp]
20699 5DB8           30C0                       xor	al,al
20700                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20701 5DBA           0A46         FD            or	al,-3[bp]
20702                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20703 5DBD           8946         12            mov	$12[bp],ax
20704                                           !BCC_EOS
20705                                           ! 3257       shift_flags = read_byte(0x0040, 0x18) & 0x73;
20706                                           ! Debug: list int = const $18 (used reg = )
20707 5DC0           B8                   0018  mov	ax,*$18
20708 5DC3           50                         push	ax
20709                                           ! Debug: list int = const $40 (used reg = )
20710 5DC4           B8                   0040  mov	ax,*$40
20711 5DC7           50                         push	ax
20712                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20713 5DC8           E8         A829            call	_read_byte
20714 5DCB           83C4                   04  add	sp,*4
20715                                           ! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
20716 5DCE           24                     73  and	al,*$73
20717                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20718 5DD0           8846         FD            mov	-3[bp],al
20719                                           !BCC_EOS
20720                                           ! 3258       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
20721                                           ! Debug: list int = const $96 (used reg = )
20722 5DD3           B8                   0096  mov	ax,#$96
20723 5DD6           50                         push	ax
20724                                           ! Debug: list int = const $40 (used reg = )
20725 5DD7           B8                   0040  mov	ax,*$40
20726 5DDA           50                         push	ax
20727                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20728 5DDB           E8         A816            call	_read_byte
20729 5DDE           83C4                   04  add	sp,*4
20730                                           ! Debug: and int = const $C to unsigned char = al+0 (used reg = )
20731 5DE1           24                     0C  and	al,*$C
20732                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20733 5DE3           0A46         FD            or	al,-3[bp]
20734 5DE6           8846         FD            mov	-3[bp],al
20735                                           !BCC_EOS
20736                                           ! 3259       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
20737                                           ! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
20738 5DE9           8A46         FD            mov	al,-3[bp]
20739 5DEC           30E4                       xor	ah,ah
20740 5DEE           88C4                       mov	ah,al
20741 5DF0           30C0                       xor	al,al
20742 5DF2           50                         push	ax
20743                                           ! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
20744 5DF3           8A46         12            mov	al,$12[bp]
20745                                           ! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20746 5DF6           30E4                       xor	ah,ah
20747 5DF8           0B46         F4            or	ax,0+..FFF3[bp]
20748 5DFB           44                         inc	sp
20749 5DFC           44                         inc	sp
20750                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20751 5DFD           8946         12            mov	$12[bp],ax
20752                                           !BCC_EOS
20753                                           ! 3260       ;
20754                                           !BCC_EOS
20755                                           ! 3261       break;
20756 5E00           E9         0083            br 	.44A
20757                                           !BCC_EOS
20758                                           ! 3262     case 0x92:
20759                                           ! 3263       AX = ((AX & 0x00ff) | ((0x80) << 8));
20760                       00005E03            .489:
20761                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20762 5E03           8A46         12            mov	al,$12[bp]
20763                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
20764 5E06           30E4                       xor	ah,ah
20765 5E08           0D                   8000  or	ax,#-$8000
20766                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20767 5E0B           8946         12            mov	$12[bp],ax
20768                                           !BCC_EOS
20769                                           ! 3264       break;
20770 5E0E           EB           76            jmp .44A
20771                                           !BCC_EOS
20772                                           ! 3265     case 0xA2:
20773                                           ! 3266       break;
20774                       00005E10            .48A:
20775 5E10           EB           74            jmp .44A
20776                                           !BCC_EOS
20777                                           ! 3267     case 0x6F:
20778                                           ! 3268       if (( AX & 0x00ff ) == 0x08)
20779                       00005E12            .48B:
20780                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20781 5E12           8A46         12            mov	al,$12[bp]
20782                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
20783 5E15           3C                     08  cmp	al,*8
20784 5E17           75           0B            jne 	.48C
20785                       00005E19            .48D:
20786                                           ! 3269         AX = ((AX & 0x00ff) | ((0x02) << 8));
20787                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20788 5E19           8A46         12            mov	al,$12[bp]
20789                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
20790 5E1C           30E4                       xor	ah,ah
20791 5E1E           0D                   0200  or	ax,#$200
20792                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20793 5E21           8946         12            mov	$12[bp],ax
20794                                           !BCC_EOS
20795                                           ! 3270     default:
20796                       00005E24            .48C:
20797                                           ! 3271       bios_printf(4, "KBD: unsupported int 16h function %02x\n", ( AX >> 8 ));
20798                       00005E24            .48E:
20799                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
20800 5E24           8B46         12            mov	ax,$12[bp]
20801 5E27           88E0                       mov	al,ah
20802 5E29           30E4                       xor	ah,ah
20803                                           ! Debug: list unsigned int = ax+0 (used reg = )
20804 5E2B           50                         push	ax
20805                                           ! Debug: list * char = .48F+0 (used reg = )
20806 5E2C           BB                   D757  mov	bx,#.48F
20807 5E2F           53                         push	bx
20808                                           ! Debug: list int = const 4 (used reg = )
20809 5E30           B8                   0004  mov	ax,*4
20810 5E33           50                         push	ax
20811                                           ! Debug: func () void = bios_printf+0 (used reg = )
20812 5E34           E8         ABE2            call	_bios_printf
20813 5E37           83C4                   06  add	sp,*6
20814                                           !BCC_EOS
20815                                           ! 3272     }
20816                                           ! 3273 }
20817 5E3A           EB           4A            jmp .44A
20818                       00005E3C            .44C:
20819 5E3C           2D                   0000  sub	ax,*0
20820 5E3F           7C           E3            jl 	.48E
20821 5E41           3D                   0012  cmp	ax,*$12
20822 5E44           77           2F            ja  	.490
20823 5E46           D1E0                       shl	ax,*1
20824 5E48           89C3                       mov	bx,ax
20825 5E4A           2E                         seg	cs
20826 5E4B           FFA7       5E4F            br	.491[bx]
20827                       00005E4F            .491:
20828 5E4F                      5B39            .word	.44D
20829 5E51                      5B90            .word	.457
20830 5E53                      5BEC            .word	.460
20831 5E55                      5E24            .word	.48E
20832 5E57                      5E24            .word	.48E
20833 5E59                      5C0B            .word	.461
20834 5E5B                      5E24            .word	.48E
20835 5E5D                      5E24            .word	.48E
20836 5E5F                      5E24            .word	.48E
20837 5E61                      5C3C            .word	.465
20838 5E63                      5C49            .word	.466
20839 5E65                      5E24            .word	.48E
20840 5E67                      5E24            .word	.48E
20841 5E69                      5E24            .word	.48E
20842 5E6B                      5E24            .word	.48E
20843 5E6D                      5E24            .word	.48E
20844 5E6F                      5D0D            .word	.47B
20845 5E71                      5D56            .word	.482
20846 5E73                      5DA4            .word	.488
20847                       00005E75            .490:
20848 5E75           2D                   006F  sub	ax,*$6F
20849 5E78           74           98            je 	.48B
20850 5E7A           2D                   0023  sub	ax,*$23
20851 5E7D           74           84            je 	.489
20852 5E7F           2D                   0010  sub	ax,*$10
20853 5E82           74           8C            je 	.48A
20854 5E84           EB           9E            jmp	.48E
20855                       00005E86            .44A:
20856                       FFFFFFF4            ..FFF3	=	-$C
20857 5E86           89EC                       mov	sp,bp
20858 5E88           5D                         pop	bp
20859 5E89           C3                         ret
20860                                           ! 3274   unsigned int
20861                                           ! Register BX used in function int16_function
20862                                           ! 3275 dequeue_key(scan_code, ascii_code, incr)
20863                                           ! 3276   Bit8u *scan_code;
20864                                           export	_dequeue_key
20865                       00005E8A            _dequeue_key:
20866                                           !BCC_EOS
20867                                           ! 3277   Bit8u *ascii_code;
20868                                           !BCC_EOS
20869                                           ! 3278   unsigned int incr;
20870                                           !BCC_EOS
20871                                           ! 3279 {
20872                                           ! 3280   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
20873                                           !BCC_EOS
20874                                           ! 3281   Bit16u ss;
20875                                           !BCC_EOS
20876                                           ! 3282   Bit8u acode, scode;
20877                                           !BCC_EOS
20878                                           ! 3283   buffer_start = read_word(0x0040, 0x0080);
20879 5E8A           55                         push	bp
20880 5E8B           89E5                       mov	bp,sp
20881 5E8D           83C4                   F4  add	sp,*-$C
20882                                           ! Debug: list int = const $80 (used reg = )
20883 5E90           B8                   0080  mov	ax,#$80
20884 5E93           50                         push	ax
20885                                           ! Debug: list int = const $40 (used reg = )
20886 5E94           B8                   0040  mov	ax,*$40
20887 5E97           50                         push	ax
20888                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20889 5E98           E8         A76C            call	_read_word
20890 5E9B           83C4                   04  add	sp,*4
20891                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
20892 5E9E           8946         FE            mov	-2[bp],ax
20893                                           !BCC_EOS
20894                                           ! 3284   buffer_end = read_word(0x0040, 0x0082);
20895                                           ! Debug: list int = const $82 (used reg = )
20896 5EA1           B8                   0082  mov	ax,#$82
20897 5EA4           50                         push	ax
20898                                           ! Debug: list int = const $40 (used reg = )
20899 5EA5           B8                   0040  mov	ax,*$40
20900 5EA8           50                         push	ax
20901                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20902 5EA9           E8         A75B            call	_read_word
20903 5EAC           83C4                   04  add	sp,*4
20904                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
20905 5EAF           8946         FC            mov	-4[bp],ax
20906                                           !BCC_EOS
20907                                           ! 3285   buffer_head = read_word(0x0040, 0x001a);
20908                                           ! Debug: list int = const $1A (used reg = )
20909 5EB2           B8                   001A  mov	ax,*$1A
20910 5EB5           50                         push	ax
20911                                           ! Debug: list int = const $40 (used reg = )
20912 5EB6           B8                   0040  mov	ax,*$40
20913 5EB9           50                         push	ax
20914                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20915 5EBA           E8         A74A            call	_read_word
20916 5EBD           83C4                   04  add	sp,*4
20917                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
20918 5EC0           8946         FA            mov	-6[bp],ax
20919                                           !BCC_EOS
20920                                           ! 3286   buffer_tail = read_word(0x0040, 0x001c);
20921                                           ! Debug: list int = const $1C (used reg = )
20922 5EC3           B8                   001C  mov	ax,*$1C
20923 5EC6           50                         push	ax
20924                                           ! Debug: list int = const $40 (used reg = )
20925 5EC7           B8                   0040  mov	ax,*$40
20926 5ECA           50                         push	ax
20927                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20928 5ECB           E8         A739            call	_read_word
20929 5ECE           83C4                   04  add	sp,*4
20930                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20931 5ED1           8946         F8            mov	-8[bp],ax
20932                                           !BCC_EOS
20933                                           ! 3287   if (buffer_head != buffer_tail) {
20934                                           ! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20935 5ED4           8B46         FA            mov	ax,-6[bp]
20936 5ED7           3B46         F8            cmp	ax,-8[bp]
20937 5EDA         0F84         0083            beq 	.492
20938                       00005EDE            .493:
20939                                           ! 3288     ss = get_SS();
20940                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
20941 5EDE           E8         A76C            call	_get_SS
20942                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
20943 5EE1           8946         F6            mov	-$A[bp],ax
20944                                           !BCC_EOS
20945                                           ! 3289     acode = read_byte(0x0040, buffer_head);
20946                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
20947 5EE4           FF76         FA            push	-6[bp]
20948                                           ! Debug: list int = const $40 (used reg = )
20949 5EE7           B8                   0040  mov	ax,*$40
20950 5EEA           50                         push	ax
20951                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20952 5EEB           E8         A706            call	_read_byte
20953 5EEE           83C4                   04  add	sp,*4
20954                                           ! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
20955 5EF1           8846         F5            mov	-$B[bp],al
20956                                           !BCC_EOS
20957                                           ! 3290     scode = read_byte(0x0040, buffer_head+1);
20958                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
20959 5EF4           8B46         FA            mov	ax,-6[bp]
20960                                           ! Debug: list unsigned int = ax+1 (used reg = )
20961 5EF7           40                         inc	ax
20962 5EF8           50                         push	ax
20963                                           ! Debug: list int = const $40 (used reg = )
20964 5EF9           B8                   0040  mov	ax,*$40
20965 5EFC           50                         push	ax
20966                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20967 5EFD           E8         A6F4            call	_read_byte
20968 5F00           83C4                   04  add	sp,*4
20969                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
20970 5F03           8846         F4            mov	-$C[bp],al
20971                                           !BCC_EOS
20972                                           ! 3291     write_byte(ss, ascii_code, acode);
20973                                           ! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
20974 5F06           8A46         F5            mov	al,-$B[bp]
20975 5F09           30E4                       xor	ah,ah
20976 5F0B           50                         push	ax
20977                                           ! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
20978 5F0C           FF76         06            push	6[bp]
20979                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20980 5F0F           FF76         F6            push	-$A[bp]
20981                                           ! Debug: func () void = write_byte+0 (used reg = )
20982 5F12           E8         A705            call	_write_byte
20983 5F15           83C4                   06  add	sp,*6
20984                                           !BCC_EOS
20985                                           ! 3292     write_byte(ss, scan_code, scode);
20986                                           ! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
20987 5F18           8A46         F4            mov	al,-$C[bp]
20988 5F1B           30E4                       xor	ah,ah
20989 5F1D           50                         push	ax
20990                                           ! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
20991 5F1E           FF76         04            push	4[bp]
20992                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20993 5F21           FF76         F6            push	-$A[bp]
20994                                           ! Debug: func () void = write_byte+0 (used reg = )
20995 5F24           E8         A6F3            call	_write_byte
20996 5F27           83C4                   06  add	sp,*6
20997                                           !BCC_EOS
20998                                           ! 3293     if (incr) {
20999 5F2A           8B46         08            mov	ax,8[bp]
21000 5F2D           85C0                       test	ax,ax
21001 5F2F           74           27            je  	.494
21002                       00005F31            .495:
21003                                           ! 3294       buffer_head += 2;
21004                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
21005 5F31           8B46         FA            mov	ax,-6[bp]
21006 5F34           40                         inc	ax
21007 5F35           40                         inc	ax
21008 5F36           8946         FA            mov	-6[bp],ax
21009                                           !BCC_EOS
21010                                           ! 3295       if (buffer_head >= buffer_end)
21011                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
21012 5F39           8B46         FA            mov	ax,-6[bp]
21013 5F3C           3B46         FC            cmp	ax,-4[bp]
21014 5F3F           72           06            jb  	.496
21015                       00005F41            .497:
21016                                           ! 3296         buffer_head = buffer_start;
21017                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
21018 5F41           8B46         FE            mov	ax,-2[bp]
21019 5F44           8946         FA            mov	-6[bp],ax
21020                                           !BCC_EOS
21021                                           ! 3297       write_word(0x0040, 0x001a, buffer_head);
21022                       00005F47            .496:
21023                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
21024 5F47           FF76         FA            push	-6[bp]
21025                                           ! Debug: list int = const $1A (used reg = )
21026 5F4A           B8                   001A  mov	ax,*$1A
21027 5F4D           50                         push	ax
21028                                           ! Debug: list int = const $40 (used reg = )
21029 5F4E           B8                   0040  mov	ax,*$40
21030 5F51           50                         push	ax
21031                                           ! Debug: func () void = write_word+0 (used reg = )
21032 5F52           E8         A6DD            call	_write_word
21033 5F55           83C4                   06  add	sp,*6
21034                                           !BCC_EOS
21035                                           ! 3298       }
21036                                           ! 3299     return(1);
21037                       00005F58            .494:
21038 5F58           B8                   0001  mov	ax,*1
21039 5F5B           89EC                       mov	sp,bp
21040 5F5D           5D                         pop	bp
21041 5F5E           C3                         ret
21042                                           !BCC_EOS
21043                                           ! 3300     }
21044                                           ! 3301   else {
21045 5F5F           EB           06            jmp .498
21046                       00005F61            .492:
21047                                           ! 3302     return(0);
21048 5F61           31C0                       xor	ax,ax
21049 5F63           89EC                       mov	sp,bp
21050 5F65           5D                         pop	bp
21051 5F66           C3                         ret
21052                                           !BCC_EOS
21053                                           ! 3303     }
21054                                           ! 3304 }
21055                       00005F67            .498:
21056 5F67           89EC                       mov	sp,bp
21057 5F69           5D                         pop	bp
21058 5F6A           C3                         ret
21059                                           ! 3305 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
21060                                           
21061                       00005F6B            _panic_msg_keyb_buffer_full:
21062                       00005F6B            .499:
21063 5F6B                        25            .ascii	"%s: keyboard input buffer full"
21064 5F89                        0A            .byte	$A
21065 5F8A                        00            .byte	0
21066                                           !BCC_EOS
21067                                           ! 3306   Bit8u
21068                                           ! 3307 inhibit_mouse_int_and_events()
21069                                           ! 3308 {
21070                                           
21071                                           export	_inhibit_mouse_int_and_events
21072                       00005F8B            _inhibit_mouse_int_and_events:
21073                                           ! 3309   Bit8u command_byte, prev_command_byte;
21074                                           !BCC_EOS
21075                                           ! 3310   if ( inb(0x64) & 0x02 )
21076 5F8B           55                         push	bp
21077 5F8C           89E5                       mov	bp,sp
21078 5F8E           4C                         dec	sp
21079 5F8F           4C                         dec	sp
21080                                           ! Debug: list int = const $64 (used reg = )
21081 5F90           B8                   0064  mov	ax,*$64
21082 5F93           50                         push	ax
21083                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21084 5F94           E8         A5A7            call	_inb
21085 5F97           44                         inc	sp
21086 5F98           44                         inc	sp
21087                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21088 5F99           24                     02  and	al,*2
21089 5F9B           84C0                       test	al,al
21090 5F9D           74           12            je  	.49A
21091                       00005F9F            .49B:
21092                                           ! 3311     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
21093                                           ! Debug: list * char = .49C+0 (used reg = )
21094 5F9F           BB                   D74C  mov	bx,#.49C
21095 5FA2           53                         push	bx
21096                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21097 5FA3           BB                   5F6B  mov	bx,#_panic_msg_keyb_buffer_full
21098 5FA6           53                         push	bx
21099                                           ! Debug: list int = const 7 (used reg = )
21100 5FA7           B8                   0007  mov	ax,*7
21101 5FAA           50                         push	ax
21102                                           ! Debug: func () void = bios_printf+0 (used reg = )
21103 5FAB           E8         AA6B            call	_bios_printf
21104 5FAE           83C4                   06  add	sp,*6
21105                                           !BCC_EOS
21106                                           ! 3312   outb(0x64, 0x20);
21107                       00005FB1            .49A:
21108                                           ! Debug: list int = const $20 (used reg = )
21109 5FB1           B8                   0020  mov	ax,*$20
21110 5FB4           50                         push	ax
21111                                           ! Debug: list int = const $64 (used reg = )
21112 5FB5           B8                   0064  mov	ax,*$64
21113 5FB8           50                         push	ax
21114                                           ! Debug: func () void = outb+0 (used reg = )
21115 5FB9           E8         A598            call	_outb
21116 5FBC           83C4                   04  add	sp,*4
21117                                           !BCC_EOS
21118                                           ! 3313   while ( (inb(0x64) & 0x01) != 0x01 );
21119 5FBF           EB           00            jmp .49E
21120                       00005FC1            .49F:
21121                                           !BCC_EOS
21122                                           ! 3314   prev_command_byte = inb(0x60);
21123                       00005FC1            .49E:
21124                                           ! Debug: list int = const $64 (used reg = )
21125 5FC1           B8                   0064  mov	ax,*$64
21126 5FC4           50                         push	ax
21127                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21128 5FC5           E8         A576            call	_inb
21129 5FC8           44                         inc	sp
21130 5FC9           44                         inc	sp
21131                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
21132 5FCA           24                     01  and	al,*1
21133                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
21134 5FCC           3C                     01  cmp	al,*1
21135 5FCE           75           F1            jne	.49F
21136                       00005FD0            .4A0:
21137                       00005FD0            .49D:
21138                                           ! Debug: list int = const $60 (used reg = )
21139 5FD0           B8                   0060  mov	ax,*$60
21140 5FD3           50                         push	ax
21141                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21142 5FD4           E8         A567            call	_inb
21143 5FD7           44                         inc	sp
21144 5FD8           44                         inc	sp
21145                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
21146 5FD9           8846         FE            mov	-2[bp],al
21147                                           !BCC_EOS
21148                                           ! 3315   command_byte = prev_command_byte;
21149                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
21150 5FDC           8A46         FE            mov	al,-2[bp]
21151 5FDF           8846         FF            mov	-1[bp],al
21152                                           !BCC_EOS
21153                                           ! 3316   if ( inb(0x64) & 0x02 )
21154                                           ! Debug: list int = const $64 (used reg = )
21155 5FE2           B8                   0064  mov	ax,*$64
21156 5FE5           50                         push	ax
21157                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21158 5FE6           E8         A555            call	_inb
21159 5FE9           44                         inc	sp
21160 5FEA           44                         inc	sp
21161                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21162 5FEB           24                     02  and	al,*2
21163 5FED           84C0                       test	al,al
21164 5FEF           74           12            je  	.4A1
21165                       00005FF1            .4A2:
21166                                           ! 3317     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
21167                                           ! Debug: list * char = .4A3+0 (used reg = )
21168 5FF1           BB                   D741  mov	bx,#.4A3
21169 5FF4           53                         push	bx
21170                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21171 5FF5           BB                   5F6B  mov	bx,#_panic_msg_keyb_buffer_full
21172 5FF8           53                         push	bx
21173                                           ! Debug: list int = const 7 (used reg = )
21174 5FF9           B8                   0007  mov	ax,*7
21175 5FFC           50                         push	ax
21176                                           ! Debug: func () void = bios_printf+0 (used reg = )
21177 5FFD           E8         AA19            call	_bios_printf
21178 6000           83C4                   06  add	sp,*6
21179                                           !BCC_EOS
21180                                           ! 3318   command_byte &= 0xfd;
21181                       00006003            .4A1:
21182                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
21183 6003           8A46         FF            mov	al,-1[bp]
21184 6006           24                     FD  and	al,#$FD
21185 6008           8846         FF            mov	-1[bp],al
21186                                           !BCC_EOS
21187                                           ! 3319   command_byte |= 0x20;
21188                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
21189 600B           8A46         FF            mov	al,-1[bp]
21190 600E           0C                     20  or	al,*$20
21191 6010           8846         FF            mov	-1[bp],al
21192                                           !BCC_EOS
21193                                           ! 3320   outb(0x64, 0x60);
21194                                           ! Debug: list int = const $60 (used reg = )
21195 6013           B8                   0060  mov	ax,*$60
21196 6016           50                         push	ax
21197                                           ! Debug: list int = const $64 (used reg = )
21198 6017           B8                   0064  mov	ax,*$64
21199 601A           50                         push	ax
21200                                           ! Debug: func () void = outb+0 (used reg = )
21201 601B           E8         A536            call	_outb
21202 601E           83C4                   04  add	sp,*4
21203                                           !BCC_EOS
21204                                           ! 3321   outb(0x60, command_byte);
21205                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21206 6021           8A46         FF            mov	al,-1[bp]
21207 6024           30E4                       xor	ah,ah
21208 6026           50                         push	ax
21209                                           ! Debug: list int = const $60 (used reg = )
21210 6027           B8                   0060  mov	ax,*$60
21211 602A           50                         push	ax
21212                                           ! Debug: func () void = outb+0 (used reg = )
21213 602B           E8         A526            call	_outb
21214 602E           83C4                   04  add	sp,*4
21215                                           !BCC_EOS
21216                                           ! 3322   return(prev_command_byte);
21217 6031           8A46         FE            mov	al,-2[bp]
21218 6034           89EC                       mov	sp,bp
21219 6036           5D                         pop	bp
21220 6037           C3                         ret
21221                                           !BCC_EOS
21222                                           ! 3323 }
21223                                           ! 3324   void
21224                                           ! Register BX used in function inhibit_mouse_int_and_events
21225                                           ! 3325 enable_mouse_int_and_events()
21226                                           ! 3326 {
21227                                           export	_enable_mouse_int_and_events
21228                       00006038            _enable_mouse_int_and_events:
21229                                           ! 3327   Bit8u command_byte;
21230                                           !BCC_EOS
21231                                           ! 3328   if ( inb(0x64) & 0x
21232 6038           55                         push	bp
21233 6039           89E5                       mov	bp,sp
21234 603B           4C                         dec	sp
21235 603C           4C                         dec	sp
21236                                           ! 3328 02 )
21237                                           ! Debug: list int = const $64 (used reg = )
21238 603D           B8                   0064  mov	ax,*$64
21239 6040           50                         push	ax
21240                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21241 6041           E8         A4FA            call	_inb
21242 6044           44                         inc	sp
21243 6045           44                         inc	sp
21244                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21245 6046           24                     02  and	al,*2
21246 6048           84C0                       test	al,al
21247 604A           74           12            je  	.4A4
21248                       0000604C            .4A5:
21249                                           ! 3329     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
21250                                           ! Debug: list * char = .4A6+0 (used reg = )
21251 604C           BB                   D737  mov	bx,#.4A6
21252 604F           53                         push	bx
21253                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21254 6050           BB                   5F6B  mov	bx,#_panic_msg_keyb_buffer_full
21255 6053           53                         push	bx
21256                                           ! Debug: list int = const 7 (used reg = )
21257 6054           B8                   0007  mov	ax,*7
21258 6057           50                         push	ax
21259                                           ! Debug: func () void = bios_printf+0 (used reg = )
21260 6058           E8         A9BE            call	_bios_printf
21261 605B           83C4                   06  add	sp,*6
21262                                           !BCC_EOS
21263                                           ! 3330   outb(0x64, 0x20);
21264                       0000605E            .4A4:
21265                                           ! Debug: list int = const $20 (used reg = )
21266 605E           B8                   0020  mov	ax,*$20
21267 6061           50                         push	ax
21268                                           ! Debug: list int = const $64 (used reg = )
21269 6062           B8                   0064  mov	ax,*$64
21270 6065           50                         push	ax
21271                                           ! Debug: func () void = outb+0 (used reg = )
21272 6066           E8         A4EB            call	_outb
21273 6069           83C4                   04  add	sp,*4
21274                                           !BCC_EOS
21275                                           ! 3331   while ( (inb(0x64) & 0x01) != 0x01 );
21276 606C           EB           00            jmp .4A8
21277                       0000606E            .4A9:
21278                                           !BCC_EOS
21279                                           ! 3332   command_byte = inb(0x60);
21280                       0000606E            .4A8:
21281                                           ! Debug: list int = const $64 (used reg = )
21282 606E           B8                   0064  mov	ax,*$64
21283 6071           50                         push	ax
21284                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21285 6072           E8         A4C9            call	_inb
21286 6075           44                         inc	sp
21287 6076           44                         inc	sp
21288                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
21289 6077           24                     01  and	al,*1
21290                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
21291 6079           3C                     01  cmp	al,*1
21292 607B           75           F1            jne	.4A9
21293                       0000607D            .4AA:
21294                       0000607D            .4A7:
21295                                           ! Debug: list int = const $60 (used reg = )
21296 607D           B8                   0060  mov	ax,*$60
21297 6080           50                         push	ax
21298                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21299 6081           E8         A4BA            call	_inb
21300 6084           44                         inc	sp
21301 6085           44                         inc	sp
21302                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
21303 6086           8846         FF            mov	-1[bp],al
21304                                           !BCC_EOS
21305                                           ! 3333   if ( inb(0x64) & 0x02 )
21306                                           ! Debug: list int = const $64 (used reg = )
21307 6089           B8                   0064  mov	ax,*$64
21308 608C           50                         push	ax
21309                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21310 608D           E8         A4AE            call	_inb
21311 6090           44                         inc	sp
21312 6091           44                         inc	sp
21313                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21314 6092           24                     02  and	al,*2
21315 6094           84C0                       test	al,al
21316 6096           74           12            je  	.4AB
21317                       00006098            .4AC:
21318                                           ! 3334     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
21319                                           ! Debug: list * char = .4AD+0 (used reg = )
21320 6098           BB                   D72D  mov	bx,#.4AD
21321 609B           53                         push	bx
21322                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21323 609C           BB                   5F6B  mov	bx,#_panic_msg_keyb_buffer_full
21324 609F           53                         push	bx
21325                                           ! Debug: list int = const 7 (used reg = )
21326 60A0           B8                   0007  mov	ax,*7
21327 60A3           50                         push	ax
21328                                           ! Debug: func () void = bios_printf+0 (used reg = )
21329 60A4           E8         A972            call	_bios_printf
21330 60A7           83C4                   06  add	sp,*6
21331                                           !BCC_EOS
21332                                           ! 3335   command_byte |= 0x02;
21333                       000060AA            .4AB:
21334                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
21335 60AA           8A46         FF            mov	al,-1[bp]
21336 60AD           0C                     02  or	al,*2
21337 60AF           8846         FF            mov	-1[bp],al
21338                                           !BCC_EOS
21339                                           ! 3336   command_byte &= 0xdf;
21340                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
21341 60B2           8A46         FF            mov	al,-1[bp]
21342 60B5           24                     DF  and	al,#$DF
21343 60B7           8846         FF            mov	-1[bp],al
21344                                           !BCC_EOS
21345                                           ! 3337   outb(0x64, 0x60);
21346                                           ! Debug: list int = const $60 (used reg = )
21347 60BA           B8                   0060  mov	ax,*$60
21348 60BD           50                         push	ax
21349                                           ! Debug: list int = const $64 (used reg = )
21350 60BE           B8                   0064  mov	ax,*$64
21351 60C1           50                         push	ax
21352                                           ! Debug: func () void = outb+0 (used reg = )
21353 60C2           E8         A48F            call	_outb
21354 60C5           83C4                   04  add	sp,*4
21355                                           !BCC_EOS
21356                                           ! 3338   outb(0x60, command_byte);
21357                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21358 60C8           8A46         FF            mov	al,-1[bp]
21359 60CB           30E4                       xor	ah,ah
21360 60CD           50                         push	ax
21361                                           ! Debug: list int = const $60 (used reg = )
21362 60CE           B8                   0060  mov	ax,*$60
21363 60D1           50                         push	ax
21364                                           ! Debug: func () void = outb+0 (used reg = )
21365 60D2           E8         A47F            call	_outb
21366 60D5           83C4                   04  add	sp,*4
21367                                           !BCC_EOS
21368                                           ! 3339 }
21369 60D8           89EC                       mov	sp,bp
21370 60DA           5D                         pop	bp
21371 60DB           C3                         ret
21372                                           ! 3340   Bit8u
21373                                           ! Register BX used in function enable_mouse_int_and_events
21374                                           ! 3341 send_to_mouse_ctrl(sendbyte)
21375                                           ! 3342   Bit8u sendbyte;
21376                                           export	_send_to_mouse_ctrl
21377                       000060DC            _send_to_mouse_ctrl:
21378                                           !BCC_EOS
21379                                           ! 3343 {
21380                                           ! 3344   Bit8u response;
21381                                           !BCC_EOS
21382                                           ! 3345   if ( inb(0x64) & 0x02 )
21383 60DC           55                         push	bp
21384 60DD           89E5                       mov	bp,sp
21385 60DF           4C                         dec	sp
21386 60E0           4C                         dec	sp
21387                                           ! Debug: list int = const $64 (used reg = )
21388 60E1           B8                   0064  mov	ax,*$64
21389 60E4           50                         push	ax
21390                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21391 60E5           E8         A456            call	_inb
21392 60E8           44                         inc	sp
21393 60E9           44                         inc	sp
21394                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21395 60EA           24                     02  and	al,*2
21396 60EC           84C0                       test	al,al
21397 60EE           74           12            je  	.4AE
21398                       000060F0            .4AF:
21399                                           ! 3346     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
21400                                           ! Debug: list * char = .4B0+0 (used reg = )
21401 60F0           BB                   D723  mov	bx,#.4B0
21402 60F3           53                         push	bx
21403                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21404 60F4           BB                   5F6B  mov	bx,#_panic_msg_keyb_buffer_full
21405 60F7           53                         push	bx
21406                                           ! Debug: list int = const 7 (used reg = )
21407 60F8           B8                   0007  mov	ax,*7
21408 60FB           50                         push	ax
21409                                           ! Debug: func () void = bios_printf+0 (used reg = )
21410 60FC           E8         A91A            call	_bios_printf
21411 60FF           83C4                   06  add	sp,*6
21412                                           !BCC_EOS
21413                                           ! 3347   outb(0x64, 0xD4);
21414                       00006102            .4AE:
21415                                           ! Debug: list int = const $D4 (used reg = )
21416 6102           B8                   00D4  mov	ax,#$D4
21417 6105           50                         push	ax
21418                                           ! Debug: list int = const $64 (used reg = )
21419 6106           B8                   0064  mov	ax,*$64
21420 6109           50                         push	ax
21421                                           ! Debug: func () void = outb+0 (used reg = )
21422 610A           E8         A447            call	_outb
21423 610D           83C4                   04  add	sp,*4
21424                                           !BCC_EOS
21425                                           ! 3348   outb(0x60, sendbyte);
21426                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
21427 6110           8A46         04            mov	al,4[bp]
21428 6113           30E4                       xor	ah,ah
21429 6115           50                         push	ax
21430                                           ! Debug: list int = const $60 (used reg = )
21431 6116           B8                   0060  mov	ax,*$60
21432 6119           50                         push	ax
21433                                           ! Debug: func () void = outb+0 (used reg = )
21434 611A           E8         A437            call	_outb
21435 611D           83C4                   04  add	sp,*4
21436                                           !BCC_EOS
21437                                           ! 3349   return(0);
21438 6120           30C0                       xor	al,al
21439 6122           89EC                       mov	sp,bp
21440 6124           5D                         pop	bp
21441 6125           C3                         ret
21442                                           !BCC_EOS
21443                                           ! 3350 }
21444                                           ! 3351   Bit8u
21445                                           ! Register BX used in function send_to_mouse_ctrl
21446                                           ! 3352 get_mouse_data(data)
21447                                           ! 3353   Bit8u *data;
21448                                           export	_get_mouse_data
21449                       00006126            _get_mouse_data:
21450                                           !BCC_EOS
21451                                           ! 3354 {
21452                                           ! 3355   Bit8u response;
21453                                           !BCC_EOS
21454                                           ! 3356   Bit16u ss;
21455                                           !BCC_EOS
21456                                           ! 3357   while ( (inb(0x64) & 0x21) != 0x21 ) {
21457 6126           55                         push	bp
21458 6127           89E5                       mov	bp,sp
21459 6129           83C4                   FC  add	sp,*-4
21460 612C           EB           00            jmp .4B2
21461                       0000612E            .4B3:
21462                                           ! 3358     }
21463                                           ! 3359   response = inb(0x60);
21464                       0000612E            .4B2:
21465                                           ! Debug: list int = const $64 (used reg = )
21466 612E           B8                   0064  mov	ax,*$64
21467 6131           50                         push	ax
21468                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21469 6132           E8         A409            call	_inb
21470 6135           44                         inc	sp
21471 6136           44                         inc	sp
21472                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
21473 6137           24                     21  and	al,*$21
21474                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
21475 6139           3C                     21  cmp	al,*$21
21476 613B           75           F1            jne	.4B3
21477                       0000613D            .4B4:
21478                       0000613D            .4B1:
21479                                           ! Debug: list int = const $60 (used reg = )
21480 613D           B8                   0060  mov	ax,*$60
21481 6140           50                         push	ax
21482                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21483 6141           E8         A3FA            call	_inb
21484 6144           44                         inc	sp
21485 6145           44                         inc	sp
21486                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
21487 6146           8846         FF            mov	-1[bp],al
21488                                           !BCC_EOS
21489                                           ! 3360   ss = get_SS();
21490                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21491 6149           E8         A501            call	_get_SS
21492                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
21493 614C           8946         FC            mov	-4[bp],ax
21494                                           !BCC_EOS
21495                                           ! 3361   write_byte(ss, data, response);
21496                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
21497 614F           8A46         FF            mov	al,-1[bp]
21498 6152           30E4                       xor	ah,ah
21499 6154           50                         push	ax
21500                                           ! Debug: list * unsigned char data = [S+8+2] (used reg = )
21501 6155           FF76         04            push	4[bp]
21502                                           ! Debug: list unsigned short ss = [S+$A-6] (used reg = )
21503 6158           FF76         FC            push	-4[bp]
21504                                           ! Debug: func () void = write_byte+0 (used reg = )
21505 615B           E8         A4BC            call	_write_byte
21506 615E           83C4                   06  add	sp,*6
21507                                           !BCC_EOS
21508                                           ! 3362   return(0);
21509 6161           30C0                       xor	al,al
21510 6163           89EC                       mov	sp,bp
21511 6165           5D                         pop	bp
21512 6166           C3                         ret
21513                                           !BCC_EOS
21514                                           ! 3363 }
21515                                           ! 3364   void
21516                                           ! 3365 set_kbd_command_byte(command_byte)
21517                                           ! 3366   Bit8u command_byte;
21518                                           export	_set_kbd_command_byte
21519                       00006167            _set_kbd_command_byte:
21520                                           !BCC_EOS
21521                                           ! 3367 {
21522                                           ! 3368   if ( inb(0x64) & 0x02 )
21523 6167           55                         push	bp
21524 6168           89E5                       mov	bp,sp
21525                                           ! Debug: list int = const $64 (used reg = )
21526 616A           B8                   0064  mov	ax,*$64
21527 616D           50                         push	ax
21528                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21529 616E           E8         A3CD            call	_inb
21530 6171           89EC                       mov	sp,bp
21531                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21532 6173           24                     02  and	al,*2
21533 6175           84C0                       test	al,al
21534 6177           74           11            je  	.4B5
21535                       00006179            .4B6:
21536                                           ! 3369     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
21537                                           ! Debug: list * char = .4B7+0 (used reg = )
21538 6179           BB                   D718  mov	bx,#.4B7
21539 617C           53                         push	bx
21540                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21541 617D           BB                   5F6B  mov	bx,#_panic_msg_keyb_buffer_full
21542 6180           53                         push	bx
21543                                           ! Debug: list int = const 7 (used reg = )
21544 6181           B8                   0007  mov	ax,*7
21545 6184           50                         push	ax
21546                                           ! Debug: func () void = bios_printf+0 (used reg = )
21547 6185           E8         A891            call	_bios_printf
21548 6188           89EC                       mov	sp,bp
21549                                           !BCC_EOS
21550                                           ! 3370   outb(0x64, 0xD4);
21551                       0000618A            .4B5:
21552                                           ! Debug: list int = const $D4 (used reg = )
21553 618A           B8                   00D4  mov	ax,#$D4
21554 618D           50                         push	ax
21555                                           ! Debug: list int = const $64 (used reg = )
21556 618E           B8                   0064  mov	ax,*$64
21557 6191           50                         push	ax
21558                                           ! Debug: func () void = outb+0 (used reg = )
21559 6192           E8         A3BF            call	_outb
21560 6195           89EC                       mov	sp,bp
21561                                           !BCC_EOS
21562                                           ! 3371   outb(0x64, 0x60);
21563                                           ! Debug: list int = const $60 (used reg = )
21564 6197           B8                   0060  mov	ax,*$60
21565 619A           50                         push	ax
21566                                           ! Debug: list int = const $64 (used reg = )
21567 619B           B8                   0064  mov	ax,*$64
21568 619E           50                         push	ax
21569                                           ! Debug: func () void = outb+0 (used reg = )
21570 619F           E8         A3B2            call	_outb
21571 61A2           89EC                       mov	sp,bp
21572                                           !BCC_EOS
21573                                           ! 3372   outb(0x60, command_byte);
21574                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
21575 61A4           8A46         04            mov	al,4[bp]
21576 61A7           30E4                       xor	ah,ah
21577 61A9           50                         push	ax
21578                                           ! Debug: list int = const $60 (used reg = )
21579 61AA           B8                   0060  mov	ax,*$60
21580 61AD           50                         push	ax
21581                                           ! Debug: func () void = outb+0 (used reg = )
21582 61AE           E8         A3A3            call	_outb
21583 61B1           89EC                       mov	sp,bp
21584                                           !BCC_EOS
21585                                           ! 3373 }
21586 61B3           5D                         pop	bp
21587 61B4           C3                         ret
21588                                           ! 3374   void
21589                                           ! Register BX used in function set_kbd_command_byte
21590                                           ! 3375 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
21591                                           ! 3376   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
21592                                           export	_int09_function
21593                       000061B5            _int09_function:
21594                                           !BCC_EOS
21595                                           ! 3377 {
21596                                           ! 3378   Bit8u scancode, asciicode, shift_flags;
21597                                           !BCC_EOS
21598                                           ! 3379   Bit8u mf2_flags, mf2_state;
21599                                           !BCC_EOS
21600                                           ! 3380   scancode = ( AX & 0x00ff );
21601 61B5           55                         push	bp
21602 61B6           89E5                       mov	bp,sp
21603 61B8           83C4                   FA  add	sp,*-6
21604                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
21605 61BB           8A46         12            mov	al,$12[bp]
21606                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
21607 61BE           8846         FF            mov	-1[bp],al
21608                                           !BCC_EOS
21609                                           ! 3381   if (scancode == 0) {
21610                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
21611 61C1           8A46         FF            mov	al,-1[bp]
21612 61C4           84C0                       test	al,al
21613 61C6           75           12            jne 	.4B8
21614                       000061C8            .4B9:
21615                                           ! 3382     bios_printf(4, "KBD: int09 handler: AL=0\n");
21616                                           ! Debug: list * char = .4BA+0 (used reg = )
21617 61C8           BB                   D6FE  mov	bx,#.4BA
21618 61CB           53                         push	bx
21619                                           ! Debug: list int = const 4 (used reg = )
21620 61CC           B8                   0004  mov	ax,*4
21621 61CF           50                         push	ax
21622                                           ! Debug: func () void = bios_printf+0 (used reg = )
21623 61D0           E8         A846            call	_bios_printf
21624 61D3           83C4                   04  add	sp,*4
21625                                           !BCC_EOS
21626                                           ! 3383     return;
21627 61D6           89EC                       mov	sp,bp
21628 61D8           5D                         pop	bp
21629 61D9           C3                         ret
21630                                           !BCC_EOS
21631                                           ! 3384     }
21632                                           ! 3385   shift_flags = read_byte(0x0040, 0x17);
21633                       000061DA            .4B8:
21634                                           ! Debug: list int = const $17 (used reg = )
21635 61DA           B8                   0017  mov	ax,*$17
21636 61DD           50                         push	ax
21637                                           ! Debug: list int = const $40 (used reg = )
21638 61DE           B8                   0040  mov	ax,*$40
21639 61E1           50                         push	ax
21640                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21641 61E2           E8         A40F            call	_read_byte
21642 61E5           83C4                   04  add	sp,*4
21643                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
21644 61E8           8846         FD            mov	-3[bp],al
21645                                           !BCC_EOS
21646                                           ! 3386   mf2_flags = read_byte(0x0040, 0x18);
21647                                           ! Debug: list int = const $18 (used reg = )
21648 61EB           B8                   0018  mov	ax,*$18
21649 61EE           50                         push	ax
21650                                           ! Debug: list int = const $40 (used reg = )
21651 61EF           B8                   0040  mov	ax,*$40
21652 61F2           50                         push	ax
21653                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21654 61F3           E8         A3FE            call	_read_byte
21655 61F6           83C4                   04  add	sp,*4
21656                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
21657 61F9           8846         FC            mov	-4[bp],al
21658                                           !BCC_EOS
21659                                           ! 3387   mf2_state = read_byte(0x0040, 0x96);
21660                                           ! Debug: list int = const $96 (used reg = )
21661 61FC           B8                   0096  mov	ax,#$96
21662 61FF           50                         push	ax
21663                                           ! Debug: list int = const $40 (used reg = )
21664 6200           B8                   0040  mov	ax,*$40
21665 6203           50                         push	ax
21666                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21667 6204           E8         A3ED            call	_read_byte
21668 6207           83C4                   04  add	sp,*4
21669                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
21670 620A           8846         FB            mov	-5[bp],al
21671                                           !BCC_EOS
21672                                           ! 3388   asciicode = 0;
21673                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
21674 620D           30C0                       xor	al,al
21675 620F           8846         FE            mov	-2[bp],al
21676                                           !BCC_EOS
21677                                           ! 3389   switch (scancode) {
21678 6212           8A46         FF            mov	al,-1[bp]
21679 6215           E9         0592            br 	.4BD
21680                                           ! 3390     case 0x3a:
21681                                           ! 3391       shift_flags ^= 0x40;
21682                       00006218            .4BE:
21683                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
21684 6218           8A46         FD            mov	al,-3[bp]
21685 621B           34                     40  xor	al,*$40
21686 621D           8846         FD            mov	-3[bp],al
21687                                           !BCC_EOS
21688                                           ! 3392       write_byte(0x0040, 0x17, shift_flags);
21689                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21690 6220           8A46         FD            mov	al,-3[bp]
21691 6223           30E4                       xor	ah,ah
21692 6225           50                         push	ax
21693                                           ! Debug: list int = const $17 (used reg = )
21694 6226           B8                   0017  mov	ax,*$17
21695 6229           50                         push	ax
21696                                           ! Debug: list int = const $40 (used reg = )
21697 622A           B8                   0040  mov	ax,*$40
21698 622D           50                         push	ax
21699                                           ! Debug: func () void = write_byte+0 (used reg = )
21700 622E           E8         A3E9            call	_write_byte
21701 6231           83C4                   06  add	sp,*6
21702                                           !BCC_EOS
21703                                           ! 3393       mf2_flags |= 0x40;
21704                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
21705 6234           8A46         FC            mov	al,-4[bp]
21706 6237           0C                     40  or	al,*$40
21707 6239           8846         FC            mov	-4[bp],al
21708                                           !BCC_EOS
21709                                           ! 3394       write_byte(0x0040, 0x18, mf2_flags);
21710                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21711 623C           8A46         FC            mov	al,-4[bp]
21712 623F           30E4                       xor	ah,ah
21713 6241           50                         push	ax
21714                                           ! Debug: list int = const $18 (used reg = )
21715 6242           B8                   0018  mov	ax,*$18
21716 6245           50                         push	ax
21717                                           ! Debug: list int = const $40 (used reg = )
21718 6246           B8                   0040  mov	ax,*$40
21719 6249           50                         push	ax
21720                                           ! Debug: func () void = write_byte+0 (used reg = )
21721 624A           E8         A3CD            call	_write_byte
21722 624D           83C4                   06  add	sp,*6
21723                                           !BCC_EOS
21724                                           ! 3395       break;
21725 6250           E9         05B4            br 	.4BB
21726                                           !BCC_EOS
21727                                           ! 3396     case 0xba:
21728                                           ! 3397       mf2_flags &= ~0x40;
21729                       00006253            .4BF:
21730                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
21731 6253           8A46         FC            mov	al,-4[bp]
21732 6256           24                     BF  and	al,#$BF
21733 6258           8846         FC            mov	-4[bp],al
21734                                           !BCC_EOS
21735                                           ! 3398       write_byte(0x0040, 0x18, mf2_flags);
21736                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21737 625B           8A46         FC            mov	al,-4[bp]
21738 625E           30E4                       xor	ah,ah
21739 6260           50                         push	ax
21740                                           ! Debug: list int = const $18 (used reg = )
21741 6261           B8                   0018  mov	ax,*$18
21742 6264           50                         push	ax
21743                                           ! Debug: list int = const $40 (used reg = )
21744 6265           B8                   0040  mov	ax,*$40
21745 6268           50                         push	ax
21746                                           ! Debug: func () void = write_byte+0 (used reg = )
21747 6269           E8         A3AE            call	_write_byte
21748 626C           83C4                   06  add	sp,*6
21749                                           !BCC_EOS
21750                                           ! 3399       break;
21751 626F           E9         0595            br 	.4BB
21752                                           !BCC_EOS
21753                                           ! 3400     case 0x2a:
21754                                           ! 3401       shift_flags |= 0x02;
21755                       00006272            .4C0:
21756                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
21757 6272           8A46         FD            mov	al,-3[bp]
21758 6275           0C                     02  or	al,*2
21759 6277           8846         FD            mov	-3[bp],al
21760                                           !BCC_EOS
21761                                           ! 3402       write_byte(0x0040, 0x17, shift_flags);
21762                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21763 627A           8A46         FD            mov	al,-3[bp]
21764 627D           30E4                       xor	ah,ah
21765 627F           50                         push	ax
21766                                           ! Debug: list int = const $17 (used reg = )
21767 6280           B8                   0017  mov	ax,*$17
21768 6283           50                         push	ax
21769                                           ! Debug: list int = const $40 (used reg = )
21770 6284           B8                   0040  mov	ax,*$40
21771 6287           50                         push	ax
21772                                           ! Debug: func () void = write_byte+0 (used reg = )
21773 6288           E8         A38F            call	_write_byte
21774 628B           83C4                   06  add	sp,*6
21775                                           !BCC_EOS
21776                                           ! 3403       break;
21777 628E           E9         0576            br 	.4BB
21778                                           !BCC_EOS
21779                                           ! 3404     case 0xaa:
21780                                           ! 3405       shift_flags &= ~0x02;
21781                       00006291            .4C1:
21782                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
21783 6291           8A46         FD            mov	al,-3[bp]
21784 6294           24                     FD  and	al,#$FD
21785 6296           8846         FD            mov	-3[bp],al
21786                                           !BCC_EOS
21787                                           ! 3406       write_byte(0x0040, 0x17, shift_flags);
21788                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21789 6299           8A46         FD            mov	al,-3[bp]
21790 629C           30E4                       xor	ah,ah
21791 629E           50                         push	ax
21792                                           ! Debug: list int = const $17 (used reg = )
21793 629F           B8                   0017  mov	ax,*$17
21794 62A2           50                         push	ax
21795                                           ! Debug: list int = const $40 (used reg = )
21796 62A3           B8                   0040  mov	ax,*$40
21797 62A6           50                         push	ax
21798                                           ! Debug: func () void = write_byte+0 (used reg = )
21799 62A7           E8         A370            call	_write_byte
21800 62AA           83C4                   06  add	sp,*6
21801                                           !BCC_EOS
21802                                           ! 3407       break;
21803 62AD           E9         0557            br 	.4BB
21804                                           !BCC_EOS
21805                                           ! 3408     case 0x36:
21806                                           ! 3409       shift_flags |= 0x01;
21807                       000062B0            .4C2:
21808                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
21809 62B0           8A46         FD            mov	al,-3[bp]
21810 62B3           0C                     01  or	al,*1
21811 62B5           8846         FD            mov	-3[bp],al
21812                                           !BCC_EOS
21813                                           ! 3410       write_byte(0x0040, 0x17, shift_flags);
21814                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21815 62B8           8A46         FD            mov	al,-3[bp]
21816 62BB           30E4                       xor	ah,ah
21817 62BD           50                         push	ax
21818                                           ! Debug: list int = const $17 (used reg = )
21819 62BE           B8                   0017  mov	ax,*$17
21820 62C1           50                         push	ax
21821                                           ! Debug: list int = const $40 (used reg = )
21822 62C2           B8                   0040  mov	ax,*$40
21823 62C5           50                         push	ax
21824                                           ! Debug: func () void = write_byte+0 (used reg = )
21825 62C6           E8         A351            call	_write_byte
21826 62C9           83C4                   06  add	sp,*6
21827                                           !BCC_EOS
21828                                           ! 3411       break;
21829 62CC           E9         0538            br 	.4BB
21830                                           !BCC_EOS
21831                                           ! 3412 
21832                                           ! 3412     case 0xb6:
21833                                           ! 3413       shift_flags &= ~0x01;
21834                       000062CF            .4C3:
21835                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
21836 62CF           8A46         FD            mov	al,-3[bp]
21837 62D2           24                     FE  and	al,#$FE
21838 62D4           8846         FD            mov	-3[bp],al
21839                                           !BCC_EOS
21840                                           ! 3414       write_byte(0x0040, 0x17, shift_flags);
21841                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21842 62D7           8A46         FD            mov	al,-3[bp]
21843 62DA           30E4                       xor	ah,ah
21844 62DC           50                         push	ax
21845                                           ! Debug: list int = const $17 (used reg = )
21846 62DD           B8                   0017  mov	ax,*$17
21847 62E0           50                         push	ax
21848                                           ! Debug: list int = const $40 (used reg = )
21849 62E1           B8                   0040  mov	ax,*$40
21850 62E4           50                         push	ax
21851                                           ! Debug: func () void = write_byte+0 (used reg = )
21852 62E5           E8         A332            call	_write_byte
21853 62E8           83C4                   06  add	sp,*6
21854                                           !BCC_EOS
21855                                           ! 3415       break;
21856 62EB           E9         0519            br 	.4BB
21857                                           !BCC_EOS
21858                                           ! 3416     case 0x1d:
21859                                           ! 3417       if ((mf2_state & 0x01) == 0) {
21860                       000062EE            .4C4:
21861                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21862 62EE           8A46         FB            mov	al,-5[bp]
21863 62F1           24                     01  and	al,*1
21864                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21865 62F3           84C0                       test	al,al
21866 62F5           75           5F            jne 	.4C5
21867                       000062F7            .4C6:
21868                                           ! 3418         shift_flags |= 0x04;
21869                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
21870 62F7           8A46         FD            mov	al,-3[bp]
21871 62FA           0C                     04  or	al,*4
21872 62FC           8846         FD            mov	-3[bp],al
21873                                           !BCC_EOS
21874                                           ! 3419         write_byte(0x0040, 0x17, shift_flags);
21875                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21876 62FF           8A46         FD            mov	al,-3[bp]
21877 6302           30E4                       xor	ah,ah
21878 6304           50                         push	ax
21879                                           ! Debug: list int = const $17 (used reg = )
21880 6305           B8                   0017  mov	ax,*$17
21881 6308           50                         push	ax
21882                                           ! Debug: list int = const $40 (used reg = )
21883 6309           B8                   0040  mov	ax,*$40
21884 630C           50                         push	ax
21885                                           ! Debug: func () void = write_byte+0 (used reg = )
21886 630D           E8         A30A            call	_write_byte
21887 6310           83C4                   06  add	sp,*6
21888                                           !BCC_EOS
21889                                           ! 3420         if (mf2_state & 0x02) {
21890                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21891 6313           8A46         FB            mov	al,-5[bp]
21892 6316           24                     02  and	al,*2
21893 6318           84C0                       test	al,al
21894 631A           74           1E            je  	.4C7
21895                       0000631C            .4C8:
21896                                           ! 3421           mf2_state |= 0x04;
21897                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
21898 631C           8A46         FB            mov	al,-5[bp]
21899 631F           0C                     04  or	al,*4
21900 6321           8846         FB            mov	-5[bp],al
21901                                           !BCC_EOS
21902                                           ! 3422           write_byte(0x0040, 0x96, mf2_state);
21903                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21904 6324           8A46         FB            mov	al,-5[bp]
21905 6327           30E4                       xor	ah,ah
21906 6329           50                         push	ax
21907                                           ! Debug: list int = const $96 (used reg = )
21908 632A           B8                   0096  mov	ax,#$96
21909 632D           50                         push	ax
21910                                           ! Debug: list int = const $40 (used reg = )
21911 632E           B8                   0040  mov	ax,*$40
21912 6331           50                         push	ax
21913                                           ! Debug: func () void = write_byte+0 (used reg = )
21914 6332           E8         A2E5            call	_write_byte
21915 6335           83C4                   06  add	sp,*6
21916                                           !BCC_EOS
21917                                           ! 3423         } else {
21918 6338           EB           1C            jmp .4C9
21919                       0000633A            .4C7:
21920                                           ! 3424           mf2_flags |= 0x01;
21921                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
21922 633A           8A46         FC            mov	al,-4[bp]
21923 633D           0C                     01  or	al,*1
21924 633F           8846         FC            mov	-4[bp],al
21925                                           !BCC_EOS
21926                                           ! 3425           write_byte(0x0040, 0x18, mf2_flags);
21927                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21928 6342           8A46         FC            mov	al,-4[bp]
21929 6345           30E4                       xor	ah,ah
21930 6347           50                         push	ax
21931                                           ! Debug: list int = const $18 (used reg = )
21932 6348           B8                   0018  mov	ax,*$18
21933 634B           50                         push	ax
21934                                           ! Debug: list int = const $40 (used reg = )
21935 634C           B8                   0040  mov	ax,*$40
21936 634F           50                         push	ax
21937                                           ! Debug: func () void = write_byte+0 (used reg = )
21938 6350           E8         A2C7            call	_write_byte
21939 6353           83C4                   06  add	sp,*6
21940                                           !BCC_EOS
21941                                           ! 3426         }
21942                                           ! 3427       }
21943                       00006356            .4C9:
21944                                           ! 3428       break;
21945                       00006356            .4C5:
21946 6356           E9         04AE            br 	.4BB
21947                                           !BCC_EOS
21948                                           ! 3429     case 0x9d:
21949                                           ! 3430       if ((mf2_state & 0x01) == 0) {
21950                       00006359            .4CA:
21951                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21952 6359           8A46         FB            mov	al,-5[bp]
21953 635C           24                     01  and	al,*1
21954                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21955 635E           84C0                       test	al,al
21956 6360           75           5F            jne 	.4CB
21957                       00006362            .4CC:
21958                                           ! 3431         shift_flags &= ~0x04;
21959                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
21960 6362           8A46         FD            mov	al,-3[bp]
21961 6365           24                     FB  and	al,#$FB
21962 6367           8846         FD            mov	-3[bp],al
21963                                           !BCC_EOS
21964                                           ! 3432         write_byte(0x0040, 0x17, shift_flags);
21965                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21966 636A           8A46         FD            mov	al,-3[bp]
21967 636D           30E4                       xor	ah,ah
21968 636F           50                         push	ax
21969                                           ! Debug: list int = const $17 (used reg = )
21970 6370           B8                   0017  mov	ax,*$17
21971 6373           50                         push	ax
21972                                           ! Debug: list int = const $40 (used reg = )
21973 6374           B8                   0040  mov	ax,*$40
21974 6377           50                         push	ax
21975                                           ! Debug: func () void = write_byte+0 (used reg = )
21976 6378           E8         A29F            call	_write_byte
21977 637B           83C4                   06  add	sp,*6
21978                                           !BCC_EOS
21979                                           ! 3433         if (mf2_state & 0x02) {
21980                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21981 637E           8A46         FB            mov	al,-5[bp]
21982 6381           24                     02  and	al,*2
21983 6383           84C0                       test	al,al
21984 6385           74           1E            je  	.4CD
21985                       00006387            .4CE:
21986                                           ! 3434           mf2_state &= ~0x04;
21987                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
21988 6387           8A46         FB            mov	al,-5[bp]
21989 638A           24                     FB  and	al,#$FB
21990 638C           8846         FB            mov	-5[bp],al
21991                                           !BCC_EOS
21992                                           ! 3435           write_byte(0x0040, 0x96, mf2_state);
21993                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21994 638F           8A46         FB            mov	al,-5[bp]
21995 6392           30E4                       xor	ah,ah
21996 6394           50                         push	ax
21997                                           ! Debug: list int = const $96 (used reg = )
21998 6395           B8                   0096  mov	ax,#$96
21999 6398           50                         push	ax
22000                                           ! Debug: list int = const $40 (used reg = )
22001 6399           B8                   0040  mov	ax,*$40
22002 639C           50                         push	ax
22003                                           ! Debug: func () void = write_byte+0 (used reg = )
22004 639D           E8         A27A            call	_write_byte
22005 63A0           83C4                   06  add	sp,*6
22006                                           !BCC_EOS
22007                                           ! 3436         } else {
22008 63A3           EB           1C            jmp .4CF
22009                       000063A5            .4CD:
22010                                           ! 3437           mf2_flags &= ~0x01;
22011                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
22012 63A5           8A46         FC            mov	al,-4[bp]
22013 63A8           24                     FE  and	al,#$FE
22014 63AA           8846         FC            mov	-4[bp],al
22015                                           !BCC_EOS
22016                                           ! 3438           write_byte(0x0040, 0x18, mf2_flags);
22017                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22018 63AD           8A46         FC            mov	al,-4[bp]
22019 63B0           30E4                       xor	ah,ah
22020 63B2           50                         push	ax
22021                                           ! Debug: list int = const $18 (used reg = )
22022 63B3           B8                   0018  mov	ax,*$18
22023 63B6           50                         push	ax
22024                                           ! Debug: list int = const $40 (used reg = )
22025 63B7           B8                   0040  mov	ax,*$40
22026 63BA           50                         push	ax
22027                                           ! Debug: func () void = write_byte+0 (used reg = )
22028 63BB           E8         A25C            call	_write_byte
22029 63BE           83C4                   06  add	sp,*6
22030                                           !BCC_EOS
22031                                           ! 3439         }
22032                                           ! 3440       }
22033                       000063C1            .4CF:
22034                                           ! 3441       break;
22035                       000063C1            .4CB:
22036 63C1           E9         0443            br 	.4BB
22037                                           !BCC_EOS
22038                                           ! 3442     case 0x38:
22039                                           ! 3443       shift_flags |= 0x08;
22040                       000063C4            .4D0:
22041                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22042 63C4           8A46         FD            mov	al,-3[bp]
22043 63C7           0C                     08  or	al,*8
22044 63C9           8846         FD            mov	-3[bp],al
22045                                           !BCC_EOS
22046                                           ! 3444       write_byte(0x0040, 0x17, shift_flags);
22047                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22048 63CC           8A46         FD            mov	al,-3[bp]
22049 63CF           30E4                       xor	ah,ah
22050 63D1           50                         push	ax
22051                                           ! Debug: list int = const $17 (used reg = )
22052 63D2           B8                   0017  mov	ax,*$17
22053 63D5           50                         push	ax
22054                                           ! Debug: list int = const $40 (used reg = )
22055 63D6           B8                   0040  mov	ax,*$40
22056 63D9           50                         push	ax
22057                                           ! Debug: func () void = write_byte+0 (used reg = )
22058 63DA           E8         A23D            call	_write_byte
22059 63DD           83C4                   06  add	sp,*6
22060                                           !BCC_EOS
22061                                           ! 3445       if (mf2_state & 0x02) {
22062                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22063 63E0           8A46         FB            mov	al,-5[bp]
22064 63E3           24                     02  and	al,*2
22065 63E5           84C0                       test	al,al
22066 63E7           74           1E            je  	.4D1
22067                       000063E9            .4D2:
22068                                           ! 3446         mf2_state |= 0x08;
22069                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
22070 63E9           8A46         FB            mov	al,-5[bp]
22071 63EC           0C                     08  or	al,*8
22072 63EE           8846         FB            mov	-5[bp],al
22073                                           !BCC_EOS
22074                                           ! 3447         write_byte(0x0040, 0x96, mf2_state);
22075                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22076 63F1           8A46         FB            mov	al,-5[bp]
22077 63F4           30E4                       xor	ah,ah
22078 63F6           50                         push	ax
22079                                           ! Debug: list int = const $96 (used reg = )
22080 63F7           B8                   0096  mov	ax,#$96
22081 63FA           50                         push	ax
22082                                           ! Debug: list int = const $40 (used reg = )
22083 63FB           B8                   0040  mov	ax,*$40
22084 63FE           50                         push	ax
22085                                           ! Debug: func () void = write_byte+0 (used reg = )
22086 63FF           E8         A218            call	_write_byte
22087 6402           83C4                   06  add	sp,*6
22088                                           !BCC_EOS
22089                                           ! 3448       } else {
22090 6405           EB           1C            jmp .4D3
22091                       00006407            .4D1:
22092                                           ! 3449         mf2_flags |= 0x02;
22093                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
22094 6407           8A46         FC            mov	al,-4[bp]
22095 640A           0C                     02  or	al,*2
22096 640C           8846         FC            mov	-4[bp],al
22097                                           !BCC_EOS
22098                                           ! 3450         write_byte(0x0040, 0x18, mf2_flags);
22099                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22100 640F           8A46         FC            mov	al,-4[bp]
22101 6412           30E4                       xor	ah,ah
22102 6414           50                         push	ax
22103                                           ! Debug: list int = const $18 (used reg = )
22104 6415           B8                   0018  mov	ax,*$18
22105 6418           50                         push	ax
22106                                           ! Debug: list int = const $40 (used reg = )
22107 6419           B8                   0040  mov	ax,*$40
22108 641C           50                         push	ax
22109                                           ! Debug: func () void = write_byte+0 (used reg = )
22110 641D           E8         A1FA            call	_write_byte
22111 6420           83C4                   06  add	sp,*6
22112                                           !BCC_EOS
22113                                           ! 3451       }
22114                                           ! 3452       break;
22115                       00006423            .4D3:
22116 6423           E9         03E1            br 	.4BB
22117                                           !BCC_EOS
22118                                           ! 3453     case 0xb8:
22119                                           ! 3454       shift_flags &= ~0x08;
22120                       00006426            .4D4:
22121                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
22122 6426           8A46         FD            mov	al,-3[bp]
22123 6429           24                     F7  and	al,#$F7
22124 642B           8846         FD            mov	-3[bp],al
22125                                           !BCC_EOS
22126                                           ! 3455       write_byte(0x0040, 0x17, shift_flags);
22127                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22128 642E           8A46         FD            mov	al,-3[bp]
22129 6431           30E4                       xor	ah,ah
22130 6433           50                         push	ax
22131                                           ! Debug: list int = const $17 (used reg = )
22132 6434           B8                   0017  mov	ax,*$17
22133 6437           50                         push	ax
22134                                           ! Debug: list int = const $40 (used reg = )
22135 6438           B8                   0040  mov	ax,*$40
22136 643B           50                         push	ax
22137                                           ! Debug: func () void = write_byte+0 (used reg = )
22138 643C           E8         A1DB            call	_write_byte
22139 643F           83C4                   06  add	sp,*6
22140                                           !BCC_EOS
22141                                           ! 3456       if (mf2_state & 0x02) {
22142                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22143 6442           8A46         FB            mov	al,-5[bp]
22144 6445           24                     02  and	al,*2
22145 6447           84C0                       test	al,al
22146 6449           74           1E            je  	.4D5
22147                       0000644B            .4D6:
22148                                           ! 3457         mf2_state &= ~0x08;
22149                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
22150 644B           8A46         FB            mov	al,-5[bp]
22151 644E           24                     F7  and	al,#$F7
22152 6450           8846         FB            mov	-5[bp],al
22153                                           !BCC_EOS
22154                                           ! 3458         write_byte(0x0040, 0x96, mf2_state);
22155                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22156 6453           8A46         FB            mov	al,-5[bp]
22157 6456           30E4                       xor	ah,ah
22158 6458           50                         push	ax
22159                                           ! Debug: list int = const $96 (used reg = )
22160 6459           B8                   0096  mov	ax,#$96
22161 645C           50                         push	ax
22162                                           ! Debug: list int = const $40 (used reg = )
22163 645D           B8                   0040  mov	ax,*$40
22164 6460           50                         push	ax
22165                                           ! Debug: func () void = write_byte+0 (used reg = )
22166 6461           E8         A1B6            call	_write_byte
22167 6464           83C4                   06  add	sp,*6
22168                                           !BCC_EOS
22169                                           ! 3459       } else {
22170 6467           EB           1C            jmp .4D7
22171                       00006469            .4D5:
22172                                           ! 3460         mf2_flags &= ~0x02;
22173                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
22174 6469           8A46         FC            mov	al,-4[bp]
22175 646C           24                     FD  and	al,#$FD
22176 646E           8846         FC            mov	-4[bp],al
22177                                           !BCC_EOS
22178                                           ! 3461         write_byte(0x0040, 0x18, mf2_flags);
22179                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22180 6471           8A46         FC            mov	al,-4[bp]
22181 6474           30E4                       xor	ah,ah
22182 6476           50                         push	ax
22183                                           ! Debug: list int = const $18 (used reg = )
22184 6477           B8                   0018  mov	ax,*$18
22185 647A           50                         push	ax
22186                                           ! Debug: list int = const $40 (used reg = )
22187 647B           B8                   0040  mov	ax,*$40
22188 647E           50                         push	ax
22189                                           ! Debug: func () void = write_byte+0 (used reg = )
22190 647F           E8         A198            call	_write_byte
22191 6482           83C4                   06  add	sp,*6
22192                                           !BCC_EOS
22193                                           ! 3462       }
22194                                           ! 3463       break;
22195                       00006485            .4D7:
22196 6485           E9         037F            br 	.4BB
22197                                           !BCC_EOS
22198                                           ! 3464     case 0x45:
22199                                           ! 3465       if ((mf2_state & 0x03) == 0) {
22200                       00006488            .4D8:
22201                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
22202 6488           8A46         FB            mov	al,-5[bp]
22203 648B           24                     03  and	al,*3
22204                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22205 648D           84C0                       test	al,al
22206 648F           75           38            jne 	.4D9
22207                       00006491            .4DA:
22208                                           ! 3466         mf2_flags |= 0x20;
22209                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
22210 6491           8A46         FC            mov	al,-4[bp]
22211 6494           0C                     20  or	al,*$20
22212 6496           8846         FC            mov	-4[bp],al
22213                                           !BCC_EOS
22214                                           ! 3467         write_byte(0x0040, 0x18, mf2_flags);
22215                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22216 6499           8A46         FC            mov	al,-4[bp]
22217 649C           30E4                       xor	ah,ah
22218 649E           50                         push	ax
22219                                           ! Debug: list int = const $18 (used reg = )
22220 649F           B8                   0018  mov	ax,*$18
22221 64A2           50                         push	ax
22222                                           ! Debug: list int = const $40 (used reg = )
22223 64A3           B8                   0040  mov	ax,*$40
22224 64A6           50                         push	ax
22225                                           ! Debug: func () void = write_byte+0 (used reg = )
22226 64A7           E8         A170            call	_write_byte
22227 64AA           83C4                   06  add	sp,*6
22228                                           !BCC_EOS
22229                                           ! 3468         shift_flags ^= 0x20;
22230                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
22231 64AD           8A46         FD            mov	al,-3[bp]
22232 64B0           34                     20  xor	al,*$20
22233 64B2           8846         FD            mov	-3[bp],al
22234                                           !BCC_EOS
22235                                           ! 3469         write_byte(0x0040, 0x17, shift_flags);
22236                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22237 64B5           8A46         FD            mov	al,-3[bp]
22238 64B8           30E4                       xor	ah,ah
22239 64BA           50                         push	ax
22240                                           ! Debug: list int = const $17 (used reg = )
22241 64BB           B8                   0017  mov	ax,*$17
22242 64BE           50                         push	ax
22243                                           ! Debug: list int = const $40 (used reg = )
22244 64BF           B8                   0040  mov	ax,*$40
22245 64C2           50                         push	ax
22246                                           ! Debug: func () void = write_byte+0 (used reg = )
22247 64C3           E8         A154            call	_write_byte
22248 64C6           83C4                   06  add	sp,*6
22249                                           !BCC_EOS
22250                                           ! 3470       }
22251                                           ! 3471       break;
22252                       000064C9            .4D9:
22253 64C9           E9         033B            br 	.4BB
22254                                           !BCC_EOS
22255                                           ! 3472     case 0xc5:
22256                                           ! 3473       if ((mf2_state & 0x03) == 0) {
22257                       000064CC            .4DB:
22258                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
22259 64CC           8A46         FB            mov	al,-5[bp]
22260 64CF           24                     03  and	al,*3
22261                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
22262 64D1           84C0                       test	al,al
22263 64D3           75           1C            jne 	.4DC
22264                       000064D5            .4DD:
22265                                           ! 3474         mf2_flags &= ~0x20;
22266                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
22267 64D5           8A46         FC            mov	al,-4[bp]
22268 64D8           24                     DF  and	al,#$DF
22269 64DA           8846         FC            mov	-4[bp],al
22270                                           !BCC_EOS
22271                                           ! 3475         write_byte(0x0040, 0x18, mf2_flags);
22272                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22273 64DD           8A46         FC            mov	al,-4[bp]
22274 64E0           30E4                       xor	ah,ah
22275 64E2           50                         push	ax
22276                                           ! Debug: list int = const $18 (used reg = )
22277 64E3           B8                   0018  mov	ax,*$18
22278 64E6           50                         push	ax
22279                                           ! Debug: list int = const $40 (used reg = )
22280 64E7           B8                   0040  mov	ax,*$40
22281 64EA           50                         push	ax
22282                                           ! Debug: func () void = write_byte+0 (used reg = )
22283 64EB           E8         A12C            call	_write_byte
22284 64EE           83C4                   06  add	sp,*6
22285                                           !BCC_EOS
22286                                           ! 3476       }
22287                                           ! 3477       break;
22288                       000064F1            .4DC:
22289 64F1           E9         0313            br 	.4BB
22290                                           !BCC_EOS
22291                                           ! 3478     case 0x46:
22292                                           ! 3479       mf2_flags |= 0x10;
22293                       000064F4            .4DE:
22294                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
22295 64F4           8A46         FC            mov	al,-4[bp]
22296 64F7           0C                     10  or	al,*$10
22297 64F9           8846         FC            mov	-4[bp],al
22298                                           !BCC_EOS
22299                                           ! 3480       write_byte(0x0040, 0x18, mf2_flags);
22300                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22301 64FC           8A46         FC            mov	al,-4[bp]
22302 64FF           30E4                       xor	ah,ah
22303 6501           50                         push	ax
22304                                           ! Debug: list int = const $18 (used reg = )
22305 6502           B8                   0018  mov	ax,*$18
22306 6505           50                         push	ax
22307                                           ! Debug: list int = const $40 (used reg = )
22308 6506           B8                   0040  mov	ax,*$40
22309 6509           50                         push	ax
22310                                           ! Debug: func () void = write_byte+0 (used reg = )
22311 650A           E8         A10D            call	_write_byte
22312 650D           83C4                   06  add	sp,*6
22313                                           !BCC_EOS
22314                                           ! 3481       shift_flags ^= 0x10;
22315                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
22316 6510           8A46         FD            mov	al,-3[bp]
22317 6513           34                     10  xor	al,*$10
22318 6515           8846         FD            mov	-3[bp],al
22319                                           !BCC_EOS
22320                                           ! 3482       write_byte(0x0040, 0x17, shift_flags);
22321                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
22322 6518           8A46         FD            mov	al,-3[bp]
22323 651B           30E4                       xor	ah,ah
22324 651D           50                         push	ax
22325                                           ! Debug: list int = const $17 (used reg = )
22326 651E           B8                   0017  mov	ax,*$17
22327 6521           50                         push	ax
22328                                           ! Debug: list int = const $40 (used reg = )
22329 6522           B8                   0040  mov	ax,*$40
22330 6525           50                         push	ax
22331                                           ! Debug: func () void = write_byte+0 (used reg = )
22332 6526           E8         A0F1            call	_write_byte
22333 6529           83C4                   06  add	sp,*6
22334                                           !BCC_EOS
22335                                           ! 3483       break;
22336 652C           E9         02D8            br 	.4BB
22337                                           !BCC_EOS
22338                                           ! 3484     case 0xc6:
22339                                           ! 3485       mf2_flags &= ~0x10;
22340                       0000652F            .4DF:
22341                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
22342 652F           8A46         FC            mov	al,-4[bp]
22343 6532           24                     EF  and	al,#$EF
22344 6534           8846         FC            mov	-4[bp],al
22345                                           !BCC_EOS
22346                                           ! 3486       write_byte(0x0040, 0x18, mf2_flags);
22347                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22348 6537           8A46         FC            mov	al,-4[bp]
22349 653A           30E4                       xor	ah,ah
22350 653C           50                         push	ax
22351                                           ! Debug: list int = const $18 (used reg = )
22352 653D           B8                   0018  mov	ax,*$18
22353 6540           50                         push	ax
22354                                           ! Debug: list int = const $40 (used reg = )
22355 6541           B8                   0040  mov	ax,*$40
22356 6544           50                         push	ax
22357                                           ! Debug: func () void = write_byte+0 (used reg = )
22358 6545           E8         A0D2            call	_write_byte
22359 6548           83C4                   06  add	sp,*6
22360                                           !BCC_EOS
22361                                           ! 3487       br
22362                                           ! 3487 eak;
22363 654B           E9         02B9            br 	.4BB
22364                                           !BCC_EOS
22365                                           ! 3488     case 0x53:
22366                                           ! 3489         if ((shift_flags & 0x0c) == 0x0c)
22367                       0000654E            .4E0:
22368                                           ! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
22369 654E           8A46         FD            mov	al,-3[bp]
22370 6551           24                     0C  and	al,*$C
22371                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
22372 6553           3C                     0C  cmp	al,*$C
22373 6555           75           03            jne 	.4E1
22374                       00006557            .4E2:
22375                                           ! 3490             machine_reset();
22376                                           ! Debug: func () void = machine_reset+0 (used reg = )
22377 6557           E8         AD6B            call	_machine_reset
22378                                           !BCC_EOS
22379                                           ! 3491     default:
22380                       0000655A            .4E1:
22381                                           ! 3492       if (scancode & 0x80) {
22382                       0000655A            .4E3:
22383                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
22384 655A           8A46         FF            mov	al,-1[bp]
22385 655D           24                     80  and	al,#$80
22386 655F           84C0                       test	al,al
22387 6561           74           03            je  	.4E4
22388                       00006563            .4E5:
22389                                           ! 3493         break;
22390 6563           E9         02A1            br 	.4BB
22391                                           !BCC_EOS
22392                                           ! 3494       }
22393                                           ! 3495       if (scancode > 0x58) {
22394                       00006566            .4E4:
22395                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
22396 6566           8A46         FF            mov	al,-1[bp]
22397 6569           3C                     58  cmp	al,*$58
22398 656B           76           18            jbe 	.4E6
22399                       0000656D            .4E7:
22400                                           ! 3496         bios_printf(4, "KBD: int09h_handler(): unknown scancode read: 0x%02x!\n", scancode);
22401                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
22402 656D           8A46         FF            mov	al,-1[bp]
22403 6570           30E4                       xor	ah,ah
22404 6572           50                         push	ax
22405                                           ! Debug: list * char = .4E8+0 (used reg = )
22406 6573           BB                   D6C7  mov	bx,#.4E8
22407 6576           53                         push	bx
22408                                           ! Debug: list int = const 4 (used reg = )
22409 6577           B8                   0004  mov	ax,*4
22410 657A           50                         push	ax
22411                                           ! Debug: func () void = bios_printf+0 (used reg = )
22412 657B           E8         A49B            call	_bios_printf
22413 657E           83C4                   06  add	sp,*6
22414                                           !BCC_EOS
22415                                           ! 3497         return;
22416 6581           89EC                       mov	sp,bp
22417 6583           5D                         pop	bp
22418 6584           C3                         ret
22419                                           !BCC_EOS
22420                                           ! 3498       }
22421                                           ! 3499       if (shift_flags & 0x08) {
22422                       00006585            .4E6:
22423                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22424 6585           8A46         FD            mov	al,-3[bp]
22425 6588           24                     08  and	al,*8
22426 658A           84C0                       test	al,al
22427 658C           74           3D            je  	.4E9
22428                       0000658E            .4EA:
22429                                           ! 3500         asciicode = scan_to_scanascii[scancode].alt;
22430                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22431 658E           8A46         FF            mov	al,-1[bp]
22432 6591           30E4                       xor	ah,ah
22433 6593           89C2                       mov	dx,ax
22434 6595           D1E0                       shl	ax,*1
22435 6597           D1E0                       shl	ax,*1
22436 6599           01D0                       add	ax,dx
22437 659B           D1E0                       shl	ax,*1
22438 659D           89C3                       mov	bx,ax
22439 659F           81C3                 01C4  add	bx,#_scan_to_scanascii
22440                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
22441 65A3           8A47         06            mov	al,6[bx]
22442 65A6           8846         FE            mov	-2[bp],al
22443                                           !BCC_EOS
22444                                           ! 3501         scancode = scan_to_scanascii[scancode].alt >> 8;
22445                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22446 65A9           8A46         FF            mov	al,-1[bp]
22447 65AC           30E4                       xor	ah,ah
22448 65AE           89C2                       mov	dx,ax
22449 65B0           D1E0                       shl	ax,*1
22450 65B2           D1E0                       shl	ax,*1
22451 65B4           01D0                       add	ax,dx
22452 65B6           D1E0                       shl	ax,*1
22453 65B8           89C3                       mov	bx,ax
22454 65BA           81C3                 01C4  add	bx,#_scan_to_scanascii
22455                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
22456 65BE           8B47         06            mov	ax,6[bx]
22457 65C1           88E0                       mov	al,ah
22458 65C3           30E4                       xor	ah,ah
22459                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22460 65C5           8846         FF            mov	-1[bp],al
22461                                           !BCC_EOS
22462                                           ! 3502       } else if (shift_flags & 0x04) {
22463 65C8           E9         01AD            br 	.4EB
22464                       000065CB            .4E9:
22465                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
22466 65CB           8A46         FD            mov	al,-3[bp]
22467 65CE           24                     04  and	al,*4
22468 65D0           84C0                       test	al,al
22469 65D2           74           3D            je  	.4EC
22470                       000065D4            .4ED:
22471                                           ! 3503         asciicode = scan_to_scanascii[scancode].control;
22472                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22473 65D4           8A46         FF            mov	al,-1[bp]
22474 65D7           30E4                       xor	ah,ah
22475 65D9           89C2                       mov	dx,ax
22476 65DB           D1E0                       shl	ax,*1
22477 65DD           D1E0                       shl	ax,*1
22478 65DF           01D0                       add	ax,dx
22479 65E1           D1E0                       shl	ax,*1
22480 65E3           89C3                       mov	bx,ax
22481 65E5           81C3                 01C4  add	bx,#_scan_to_scanascii
22482                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
22483 65E9           8A47         04            mov	al,4[bx]
22484 65EC           8846         FE            mov	-2[bp],al
22485                                           !BCC_EOS
22486                                           ! 3504         scancode = scan_to_scanascii[scancode].control >> 8;
22487                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22488 65EF           8A46         FF            mov	al,-1[bp]
22489 65F2           30E4                       xor	ah,ah
22490 65F4           89C2                       mov	dx,ax
22491 65F6           D1E0                       shl	ax,*1
22492 65F8           D1E0                       shl	ax,*1
22493 65FA           01D0                       add	ax,dx
22494 65FC           D1E0                       shl	ax,*1
22495 65FE           89C3                       mov	bx,ax
22496 6600           81C3                 01C4  add	bx,#_scan_to_scanascii
22497                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
22498 6604           8B47         04            mov	ax,4[bx]
22499 6607           88E0                       mov	al,ah
22500 6609           30E4                       xor	ah,ah
22501                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22502 660B           8846         FF            mov	-1[bp],al
22503                                           !BCC_EOS
22504                                           ! 3505       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
22505 660E           E9         0167            br 	.4EE
22506                       00006611            .4EC:
22507                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22508 6611           8A46         FB            mov	al,-5[bp]
22509 6614           24                     02  and	al,*2
22510                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
22511 6616           84C0                       test	al,al
22512 6618           74           32            je  	.4EF
22513                       0000661A            .4F1:
22514                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
22515 661A           8A46         FF            mov	al,-1[bp]
22516 661D           3C                     47  cmp	al,*$47
22517 661F           72           2B            jb  	.4EF
22518                       00006621            .4F2:
22519                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
22520 6621           8A46         FF            mov	al,-1[bp]
22521 6624           3C                     53  cmp	al,*$53
22522 6626           77           24            ja  	.4EF
22523                       00006628            .4F0:
22524                                           ! 3506         asciicode = 0xe0;
22525                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
22526 6628           B0                     E0  mov	al,#$E0
22527 662A           8846         FE            mov	-2[bp],al
22528                                           !BCC_EOS
22529                                           ! 3507         scancode = scan_to_scanascii[scancode].normal >> 8;
22530                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22531 662D           8A46         FF            mov	al,-1[bp]
22532 6630           30E4                       xor	ah,ah
22533 6632           89C2                       mov	dx,ax
22534 6634           D1E0                       shl	ax,*1
22535 6636           D1E0                       shl	ax,*1
22536 6638           01D0                       add	ax,dx
22537 663A           D1E0                       shl	ax,*1
22538 663C           89C3                       mov	bx,ax
22539                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22540 663E           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22541 6642           88E0                       mov	al,ah
22542 6644           30E4                       xor	ah,ah
22543                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22544 6646           8846         FF            mov	-1[bp],al
22545                                           !BCC_EOS
22546                                           ! 3508       } else if (shift_flags & 0x03) {
22547 6649           E9         012C            br 	.4F3
22548                       0000664C            .4EF:
22549                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
22550 664C           8A46         FD            mov	al,-3[bp]
22551 664F           24                     03  and	al,*3
22552 6651           84C0                       test	al,al
22553 6653         0F84         0092            beq 	.4F4
22554                       00006657            .4F5:
22555                                           ! 3509         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22556                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22557 6657           8A46         FF            mov	al,-1[bp]
22558 665A           30E4                       xor	ah,ah
22559 665C           89C2                       mov	dx,ax
22560 665E           D1E0                       shl	ax,*1
22561 6660           D1E0                       shl	ax,*1
22562 6662           01D0                       add	ax,dx
22563 6664           D1E0                       shl	ax,*1
22564 6666           89C3                       mov	bx,ax
22565 6668           81C3                 01C4  add	bx,#_scan_to_scanascii
22566                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22567 666C           8A46         FD            mov	al,-3[bp]
22568 666F           2247         08            and	al,8[bx]
22569 6672           84C0                       test	al,al
22570 6674           74           36            je  	.4F6
22571                       00006676            .4F7:
22572                                           ! 3510           asciicode = scan_to_scanascii[scancode].normal;
22573                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22574 6676           8A46         FF            mov	al,-1[bp]
22575 6679           30E4                       xor	ah,ah
22576 667B           89C2                       mov	dx,ax
22577 667D           D1E0                       shl	ax,*1
22578 667F           D1E0                       shl	ax,*1
22579 6681           01D0                       add	ax,dx
22580 6683           D1E0                       shl	ax,*1
22581 6685           89C3                       mov	bx,ax
22582                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22583 6687           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22584 668B           8846         FE            mov	-2[bp],al
22585                                           !BCC_EOS
22586                                           ! 3511           scancode = scan_to_scanascii[scancode].normal >> 8;
22587                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22588 668E           8A46         FF            mov	al,-1[bp]
22589 6691           30E4                       xor	ah,ah
22590 6693           89C2                       mov	dx,ax
22591 6695           D1E0                       shl	ax,*1
22592 6697           D1E0                       shl	ax,*1
22593 6699           01D0                       add	ax,dx
22594 669B           D1E0                       shl	ax,*1
22595 669D           89C3                       mov	bx,ax
22596                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22597 669F           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22598 66A3           88E0                       mov	al,ah
22599 66A5           30E4                       xor	ah,ah
22600                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22601 66A7           8846         FF            mov	-1[bp],al
22602                                           !BCC_EOS
22603                                           ! 3512         } else {
22604 66AA           EB           3A            jmp .4F8
22605                       000066AC            .4F6:
22606                                           ! 3513           asciicode = scan_to_scanascii[scancode].shift;
22607                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22608 66AC           8A46         FF            mov	al,-1[bp]
22609 66AF           30E4                       xor	ah,ah
22610 66B1           89C2                       mov	dx,ax
22611 66B3           D1E0                       shl	ax,*1
22612 66B5           D1E0                       shl	ax,*1
22613 66B7           01D0                       add	ax,dx
22614 66B9           D1E0                       shl	ax,*1
22615 66BB           89C3                       mov	bx,ax
22616 66BD           81C3                 01C4  add	bx,#_scan_to_scanascii
22617                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22618 66C1           8A47         02            mov	al,2[bx]
22619 66C4           8846         FE            mov	-2[bp],al
22620                                           !BCC_EOS
22621                                           ! 3514           scancode = scan_to_scanascii[scancode].shift >> 8;
22622                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22623 66C7           8A46         FF            mov	al,-1[bp]
22624 66CA           30E4                       xor	ah,ah
22625 66CC           89C2                       mov	dx,ax
22626 66CE           D1E0                       shl	ax,*1
22627 66D0           D1E0                       shl	ax,*1
22628 66D2           01D0                       add	ax,dx
22629 66D4           D1E0                       shl	ax,*1
22630 66D6           89C3                       mov	bx,ax
22631 66D8           81C3                 01C4  add	bx,#_scan_to_scanascii
22632                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22633 66DC           8B47         02            mov	ax,2[bx]
22634 66DF           88E0                       mov	al,ah
22635 66E1           30E4                       xor	ah,ah
22636                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22637 66E3           8846         FF            mov	-1[bp],al
22638                                           !BCC_EOS
22639                                           ! 3515         }
22640                                           ! 3516       } else {
22641                       000066E6            .4F8:
22642 66E6           E9         008F            br 	.4F9
22643                       000066E9            .4F4:
22644                                           ! 3517         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22645                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22646 66E9           8A46         FF            mov	al,-1[bp]
22647 66EC           30E4                       xor	ah,ah
22648 66EE           89C2                       mov	dx,ax
22649 66F0           D1E0                       shl	ax,*1
22650 66F2           D1E0                       shl	ax,*1
22651 66F4           01D0                       add	ax,dx
22652 66F6           D1E0                       shl	ax,*1
22653 66F8           89C3                       mov	bx,ax
22654 66FA           81C3                 01C4  add	bx,#_scan_to_scanascii
22655                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22656 66FE           8A46         FD            mov	al,-3[bp]
22657 6701           2247         08            and	al,8[bx]
22658 6704           84C0                       test	al,al
22659 6706           74           3C            je  	.4FA
22660                       00006708            .4FB:
22661                                           ! 3518           asciicode = scan_to_scanascii[scancode].shift;
22662                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22663 6708           8A46         FF            mov	al,-1[bp]
22664 670B           30E4                       xor	ah,ah
22665 670D           89C2                       mov	dx,ax
22666 670F           D1E0                       shl	ax,*1
22667 6711           D1E0                       shl	ax,*1
22668 6713           01D0                       add	ax,dx
22669 6715           D1E0                       shl	ax,*1
22670 6717           89C3                       mov	bx,ax
22671 6719           81C3                 01C4  add	bx,#_scan_to_scanascii
22672                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22673 671D           8A47         02            mov	al,2[bx]
22674 6720           8846         FE            mov	-2[bp],al
22675                                           !BCC_EOS
22676                                           ! 3519           scancode = scan_to_scanascii[scancode].shift >> 8;
22677                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22678 6723           8A46         FF            mov	al,-1[bp]
22679 6726           30E4                       xor	ah,ah
22680 6728           89C2                       mov	dx,ax
22681 672A           D1E0                       shl	ax,*1
22682 672C           D1E0                       shl	ax,*1
22683 672E           01D0                       add	ax,dx
22684 6730           D1E0                       shl	ax,*1
22685 6732           89C3                       mov	bx,ax
22686 6734           81C3                 01C4  add	bx,#_scan_to_scanascii
22687                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22688 6738           8B47         02            mov	ax,2[bx]
22689 673B           88E0                       mov	al,ah
22690 673D           30E4                       xor	ah,ah
22691                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22692 673F           8846         FF            mov	-1[bp],al
22693                                           !BCC_EOS
22694                                           ! 3520         } else {
22695 6742           EB           34            jmp .4FC
22696                       00006744            .4FA:
22697                                           ! 3521           asciicode = scan_to_scanascii[scancode].normal;
22698                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22699 6744           8A46         FF            mov	al,-1[bp]
22700 6747           30E4                       xor	ah,ah
22701 6749           89C2                       mov	dx,ax
22702 674B           D1E0                       shl	ax,*1
22703 674D           D1E0                       shl	ax,*1
22704 674F           01D0                       add	ax,dx
22705 6751           D1E0                       shl	ax,*1
22706 6753           89C3                       mov	bx,ax
22707                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22708 6755           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22709 6759           8846         FE            mov	-2[bp],al
22710                                           !BCC_EOS
22711                                           ! 3522           scancode = scan_to_scanascii[scancode].normal >> 8;
22712                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22713 675C           8A46         FF            mov	al,-1[bp]
22714 675F           30E4                       xor	ah,ah
22715 6761           89C2                       mov	dx,ax
22716 6763           D1E0                       shl	ax,*1
22717 6765           D1E0                       shl	ax,*1
22718 6767           01D0                       add	ax,dx
22719 6769           D1E0                       shl	ax,*1
22720 676B           89C3                       mov	bx,ax
22721                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22722 676D           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22723 6771           88E0                       mov	al,ah
22724 6773           30E4                       xor	ah,ah
22725                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22726 6775           8846         FF            mov	-1[bp],al
22727                                           !BCC_EOS
22728                                           ! 3523         }
22729                                           ! 3524       }
22730                       00006778            .4FC:
22731                                           ! 3525       if (scancode==0 && asciicode==0) {
22732                       00006778            .4F9:
22733                       00006778            .4F3:
22734                       00006778            .4EE:
22735                       00006778            .4EB:
22736                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
22737 6778           8A46         FF            mov	al,-1[bp]
22738 677B           84C0                       test	al,al
22739 677D           75           15            jne 	.4FD
22740                       0000677F            .4FF:
22741                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
22742 677F           8A46         FE            mov	al,-2[bp]
22743 6782           84C0                       test	al,al
22744 6784           75           0E            jne 	.4FD
22745                       00006786            .4FE:
22746                                           ! 3526         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
22747                                           ! Debug: list * char = .500+0 (used reg = )
22748 6786           BB                   D690  mov	bx,#.500
22749 6789           53                         push	bx
22750                                           ! Debug: list int = const 4 (used reg = )
22751 678A           B8                   0004  mov	ax,*4
22752 678D           50                         push	ax
22753                                           ! Debug: func () void = bios_printf+0 (used reg = )
22754 678E           E8         A288            call	_bios_printf
22755 6791           83C4                   04  add	sp,*4
22756                                           !BCC_EOS
22757                                           ! 3527       }
22758                                           ! 3528       enqueue_key(scancode, asciicode);
22759                       00006794            .4FD:
22760                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
22761 6794           8A46         FE            mov	al,-2[bp]
22762 6797           30E4                       xor	ah,ah
22763 6799           50                         push	ax
22764                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
22765 679A           8A46         FF            mov	al,-1[bp]
22766 679D           30E4                       xor	ah,ah
22767 679F           50                         push	ax
22768                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
22769 67A0           E8         0095            call	_enqueue_key
22770 67A3           83C4                   04  add	sp,*4
22771                                           !BCC_EOS
22772                                           ! 3529       break;
22773 67A6           EB           5F            jmp .4BB
22774                                           !BCC_EOS
22775                                           ! 3530   }
22776                                           ! 3531   if ((scancode & 0x7f) != 0x1d) {
22777 67A8           EB           5D            jmp .4BB
22778                       000067AA            .4BD:
22779 67AA           2C                     1D  sub	al,*$1D
22780 67AC         0F84         FB3E            beq 	.4C4
22781 67B0           2C                     0D  sub	al,*$D
22782 67B2         0F84         FABC            beq 	.4C0
22783 67B6           2C                     0C  sub	al,*$C
22784 67B8         0F84         FAF4            beq 	.4C2
22785 67BC           2C                     02  sub	al,*2
22786 67BE         0F84         FC02            beq 	.4D0
22787 67C2           2C                     02  sub	al,*2
22788 67C4         0F84         FA50            beq 	.4BE
22789 67C8           2C                     0B  sub	al,*$B
22790 67CA         0F84         FCBA            beq 	.4D8
22791 67CE           2C                     01  sub	al,*1
22792 67D0         0F84         FD20            beq 	.4DE
22793 67D4           2C                     0D  sub	al,*$D
22794 67D6         0F84         FD74            beq 	.4E0
22795 67DA           2C                     4A  sub	al,*$4A
22796 67DC         0F84         FB79            beq 	.4CA
22797 67E0           2C                     0D  sub	al,*$D
22798 67E2         0F84         FAAB            beq 	.4C1
22799 67E6           2C                     0C  sub	al,*$C
22800 67E8         0F84         FAE3            beq 	.4C3
22801 67EC           2C                     02  sub	al,*2
22802 67EE         0F84         FC34            beq 	.4D4
22803 67F2           2C                     02  sub	al,*2
22804 67F4         0F84         FA5B            beq 	.4BF
22805 67F8           2C                     0B  sub	al,*$B
22806 67FA         0F84         FCCE            beq 	.4DB
22807 67FE           2C                     01  sub	al,*1
22808 6800         0F84         FD2B            beq 	.4DF
22809 6804           E9         FD53            br 	.4E3
22810                       00006807            .4BB:
22811                       FFFFFFF8            ..FFF2	=	-8
22812                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
22813 6807           8A46         FF            mov	al,-1[bp]
22814 680A           24                     7F  and	al,*$7F
22815                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
22816 680C           3C                     1D  cmp	al,*$1D
22817 680E           74           08            je  	.501
22818                       00006810            .502:
22819                                           ! 3532     mf2_state &= ~0x01;
22820                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
22821 6810           8A46         FB            mov	al,-5[bp]
22822 6813           24                     FE  and	al,#$FE
22823 6815           8846         FB            mov	-5[bp],al
22824                                           !BCC_EOS
22825                                           ! 3533   }
22826                                           ! 3534   mf2_state &= ~0x02;
22827                       00006818            .501:
22828                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
22829 6818           8A46         FB            mov	al,-5[bp]
22830 681B           24                     FD  and	al,#$FD
22831 681D           8846         FB            mov	-5[bp],al
22832                                           !BCC_EOS
22833                                           ! 3535   write_byte(0x0040, 0x96, mf2_state);
22834                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22835 6820           8A46         FB            mov	al,-5[bp]
22836 6823           30E4                       xor	ah,ah
22837 6825           50                         push	ax
22838                                           ! Debug: list int = const $96 (used reg = )
22839 6826           B8                   0096  mov	ax,#$96
22840 6829           50                         push	ax
22841                                           ! Debug: list int = const $40 (used reg = )
22842 682A           B8                   0040  mov	ax,*$40
22843 682D           50                         push	ax
22844                                           ! Debug: func () void = write_byte+0 (used reg = )
22845 682E           E8         9DE9            call	_write_byte
22846 6831           83C4                   06  add	sp,*6
22847                                           !BCC_EOS
22848                                           ! 3536 }
22849 6834           89EC                       mov	sp,bp
22850 6836           5D                         pop	bp
22851 6837           C3                         ret
22852                                           ! 3537   unsigned int
22853                                           ! Register BX used in function int09_function
22854                                           ! 3538 enqueue_key(scan_code, ascii_code)
22855                                           ! 3539   Bit8u scan_code, ascii_code;
22856                                           export	_enqueue_key
22857                       00006838            _enqueue_key:
22858                                           !BCC_EOS
22859                                           ! 3540 {
22860                                           ! 3541   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
22861                                           !BCC_EOS
22862                                           ! 3542   buffer_start = read_word(0x0040, 0x0080);
22863 6838           55                         push	bp
22864 6839           89E5                       mov	bp,sp
22865 683B           83C4                   F6  add	sp,*-$A
22866                                           ! Debug: list int = const $80 (used reg = )
22867 683E           B8                   0080  mov	ax,#$80
22868 6841           50                         push	ax
22869                                           ! Debug: list int = const $40 (used reg = )
22870 6842           B8                   0040  mov	ax,*$40
22871 6845           50                         push	ax
22872                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22873 6846           E8         9DBE            call	_read_word
22874 6849           83C4                   04  add	sp,*4
22875                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
22876 684C           8946         FE            mov	-2[bp],ax
22877                                           !BCC_EOS
22878                                           ! 3543   buffer_end = read_word(0x0
22879                                           ! 3543 040, 0x0082);
22880                                           ! Debug: list int = const $82 (used reg = )
22881 684F           B8                   0082  mov	ax,#$82
22882 6852           50                         push	ax
22883                                           ! Debug: list int = const $40 (used reg = )
22884 6853           B8                   0040  mov	ax,*$40
22885 6856           50                         push	ax
22886                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22887 6857           E8         9DAD            call	_read_word
22888 685A           83C4                   04  add	sp,*4
22889                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
22890 685D           8946         FC            mov	-4[bp],ax
22891                                           !BCC_EOS
22892                                           ! 3544   buffer_head = read_word(0x0040, 0x001A);
22893                                           ! Debug: list int = const $1A (used reg = )
22894 6860           B8                   001A  mov	ax,*$1A
22895 6863           50                         push	ax
22896                                           ! Debug: list int = const $40 (used reg = )
22897 6864           B8                   0040  mov	ax,*$40
22898 6867           50                         push	ax
22899                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22900 6868           E8         9D9C            call	_read_word
22901 686B           83C4                   04  add	sp,*4
22902                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
22903 686E           8946         FA            mov	-6[bp],ax
22904                                           !BCC_EOS
22905                                           ! 3545   buffer_tail = read_word(0x0040, 0x001C);
22906                                           ! Debug: list int = const $1C (used reg = )
22907 6871           B8                   001C  mov	ax,*$1C
22908 6874           50                         push	ax
22909                                           ! Debug: list int = const $40 (used reg = )
22910 6875           B8                   0040  mov	ax,*$40
22911 6878           50                         push	ax
22912                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22913 6879           E8         9D8B            call	_read_word
22914 687C           83C4                   04  add	sp,*4
22915                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22916 687F           8946         F8            mov	-8[bp],ax
22917                                           !BCC_EOS
22918                                           ! 3546   temp_tail = buffer_tail;
22919                                           ! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
22920 6882           8B46         F8            mov	ax,-8[bp]
22921 6885           8946         F6            mov	-$A[bp],ax
22922                                           !BCC_EOS
22923                                           ! 3547   buffer_tail += 2;
22924                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22925 6888           8B46         F8            mov	ax,-8[bp]
22926 688B           40                         inc	ax
22927 688C           40                         inc	ax
22928 688D           8946         F8            mov	-8[bp],ax
22929                                           !BCC_EOS
22930                                           ! 3548   if (buffer_tail >= buffer_end)
22931                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22932 6890           8B46         F8            mov	ax,-8[bp]
22933 6893           3B46         FC            cmp	ax,-4[bp]
22934 6896           72           06            jb  	.503
22935                       00006898            .504:
22936                                           ! 3549     buffer_tail = buffer_start;
22937                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22938 6898           8B46         FE            mov	ax,-2[bp]
22939 689B           8946         F8            mov	-8[bp],ax
22940                                           !BCC_EOS
22941                                           ! 3550   if (buffer_tail == buffer_head) {
22942                       0000689E            .503:
22943                                           ! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22944 689E           8B46         F8            mov	ax,-8[bp]
22945 68A1           3B46         FA            cmp	ax,-6[bp]
22946 68A4           75           06            jne 	.505
22947                       000068A6            .506:
22948                                           ! 3551     return(0);
22949 68A6           31C0                       xor	ax,ax
22950 68A8           89EC                       mov	sp,bp
22951 68AA           5D                         pop	bp
22952 68AB           C3                         ret
22953                                           !BCC_EOS
22954                                           ! 3552     }
22955                                           ! 3553    write_byte(0x0040, temp_tail, ascii_code);
22956                       000068AC            .505:
22957                                           ! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
22958 68AC           8A46         06            mov	al,6[bp]
22959 68AF           30E4                       xor	ah,ah
22960 68B1           50                         push	ax
22961                                           ! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
22962 68B2           FF76         F6            push	-$A[bp]
22963                                           ! Debug: list int = const $40 (used reg = )
22964 68B5           B8                   0040  mov	ax,*$40
22965 68B8           50                         push	ax
22966                                           ! Debug: func () void = write_byte+0 (used reg = )
22967 68B9           E8         9D5E            call	_write_byte
22968 68BC           83C4                   06  add	sp,*6
22969                                           !BCC_EOS
22970                                           ! 3554    write_byte(0x0040, temp_tail+1, scan_code);
22971                                           ! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
22972 68BF           8A46         04            mov	al,4[bp]
22973 68C2           30E4                       xor	ah,ah
22974 68C4           50                         push	ax
22975                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
22976 68C5           8B46         F6            mov	ax,-$A[bp]
22977                                           ! Debug: list unsigned int = ax+1 (used reg = )
22978 68C8           40                         inc	ax
22979 68C9           50                         push	ax
22980                                           ! Debug: list int = const $40 (used reg = )
22981 68CA           B8                   0040  mov	ax,*$40
22982 68CD           50                         push	ax
22983                                           ! Debug: func () void = write_byte+0 (used reg = )
22984 68CE           E8         9D49            call	_write_byte
22985 68D1           83C4                   06  add	sp,*6
22986                                           !BCC_EOS
22987                                           ! 3555    write_word(0x0040, 0x001C, buffer_tail);
22988                                           ! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
22989 68D4           FF76         F8            push	-8[bp]
22990                                           ! Debug: list int = const $1C (used reg = )
22991 68D7           B8                   001C  mov	ax,*$1C
22992 68DA           50                         push	ax
22993                                           ! Debug: list int = const $40 (used reg = )
22994 68DB           B8                   0040  mov	ax,*$40
22995 68DE           50                         push	ax
22996                                           ! Debug: func () void = write_word+0 (used reg = )
22997 68DF           E8         9D50            call	_write_word
22998 68E2           83C4                   06  add	sp,*6
22999                                           !BCC_EOS
23000                                           ! 3556    return(1);
23001 68E5           B8                   0001  mov	ax,*1
23002 68E8           89EC                       mov	sp,bp
23003 68EA           5D                         pop	bp
23004 68EB           C3                         ret
23005                                           !BCC_EOS
23006                                           ! 3557 }
23007                                           ! 3558   void
23008                                           ! 3559 int74_function(make_farcall, Z, Y, X, status)
23009                                           ! 3560   Bit16u make_farcall, Z, Y, X, status;
23010                                           export	_int74_function
23011                       000068EC            _int74_function:
23012                                           !BCC_EOS
23013                                           ! 3561 {
23014                                           ! 3562   Bit16u ebda_seg=read_word(0x0040,0x000E);
23015 68EC           55                         push	bp
23016 68ED           89E5                       mov	bp,sp
23017 68EF           4C                         dec	sp
23018 68F0           4C                         dec	sp
23019                                           ! Debug: list int = const $E (used reg = )
23020 68F1           B8                   000E  mov	ax,*$E
23021 68F4           50                         push	ax
23022                                           ! Debug: list int = const $40 (used reg = )
23023 68F5           B8                   0040  mov	ax,*$40
23024 68F8           50                         push	ax
23025                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23026 68F9           E8         9D0B            call	_read_word
23027 68FC           83C4                   04  add	sp,*4
23028                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
23029 68FF           8946         FE            mov	-2[bp],ax
23030                                           !BCC_EOS
23031                                           ! 3563   Bit8u in_byte, index, package_count;
23032                                           !BCC_EOS
23033                                           ! 3564   Bit8u mouse_flags_1, mouse_flags_2;
23034                                           !BCC_EOS
23035                                           ! 3565 ;
23036 6902           83C4                   FA  add	sp,*-6
23037                                           !BCC_EOS
23038                                           ! 3566   make_farcall = 0;
23039                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
23040 6905           31C0                       xor	ax,ax
23041 6907           8946         04            mov	4[bp],ax
23042                                           !BCC_EOS
23043                                           ! 3567   in_byte = inb(0x64);
23044                                           ! Debug: list int = const $64 (used reg = )
23045 690A           B8                   0064  mov	ax,*$64
23046 690D           50                         push	ax
23047                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23048 690E           E8         9C2D            call	_inb
23049 6911           44                         inc	sp
23050 6912           44                         inc	sp
23051                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
23052 6913           8846         FD            mov	-3[bp],al
23053                                           !BCC_EOS
23054                                           ! 3568   if ( (in_byte & 0x21) != 0x21 ) {
23055                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
23056 6916           8A46         FD            mov	al,-3[bp]
23057 6919           24                     21  and	al,*$21
23058                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
23059 691B           3C                     21  cmp	al,*$21
23060 691D           74           04            je  	.507
23061                       0000691F            .508:
23062                                           ! 3569     return;
23063 691F           89EC                       mov	sp,bp
23064 6921           5D                         pop	bp
23065 6922           C3                         ret
23066                                           !BCC_EOS
23067                                           ! 3570     }
23068                                           ! 3571   in_byte = inb(0x60);
23069                       00006923            .507:
23070                                           ! Debug: list int = const $60 (used reg = )
23071 6923           B8                   0060  mov	ax,*$60
23072 6926           50                         push	ax
23073                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23074 6927           E8         9C14            call	_inb
23075 692A           44                         inc	sp
23076 692B           44                         inc	sp
23077                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
23078 692C           8846         FD            mov	-3[bp],al
23079                                           !BCC_EOS
23080                                           ! 3572 ;
23081                                           !BCC_EOS
23082                                           ! 3573   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
23083                                           ! Debug: list int = const $26 (used reg = )
23084 692F           B8                   0026  mov	ax,*$26
23085 6932           50                         push	ax
23086                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23087 6933           FF76         FE            push	-2[bp]
23088                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23089 6936           E8         9CBB            call	_read_byte
23090 6939           83C4                   04  add	sp,*4
23091                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23092 693C           8846         FA            mov	-6[bp],al
23093                                           !BCC_EOS
23094                                           ! 3574   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
23095                                           ! Debug: list int = const $27 (used reg = )
23096 693F           B8                   0027  mov	ax,*$27
23097 6942           50                         push	ax
23098                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23099 6943           FF76         FE            push	-2[bp]
23100                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23101 6946           E8         9CAB            call	_read_byte
23102 6949           83C4                   04  add	sp,*4
23103                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23104 694C           8846         F9            mov	-7[bp],al
23105                                           !BCC_EOS
23106                                           ! 3575   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
23107                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23108 694F           8A46         F9            mov	al,-7[bp]
23109 6952           24                     80  and	al,#$80
23110                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
23111 6954           3C                     80  cmp	al,#$80
23112 6956           74           04            je  	.509
23113                       00006958            .50A:
23114                                           ! 3576       return;
23115 6958           89EC                       mov	sp,bp
23116 695A           5D                         pop	bp
23117 695B           C3                         ret
23118                                           !BCC_EOS
23119                                           ! 3577   }
23120                                           ! 3578   package_count = mouse_flags_2 & 0x07;
23121                       0000695C            .509:
23122                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23123 695C           8A46         F9            mov	al,-7[bp]
23124 695F           24                     07  and	al,*7
23125                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
23126 6961           8846         FB            mov	-5[bp],al
23127                                           !BCC_EOS
23128                                           ! 3579   index = mouse_flags_1 & 0x07;
23129                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23130 6964           8A46         FA            mov	al,-6[bp]
23131 6967           24                     07  and	al,*7
23132                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
23133 6969           8846         FC            mov	-4[bp],al
23134                                           !BCC_EOS
23135                                           ! 3580   write_byte(ebda_seg, 0x28 + index, in_byte);
23136                                           ! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
23137 696C           8A46         FD            mov	al,-3[bp]
23138 696F           30E4                       xor	ah,ah
23139 6971           50                         push	ax
23140                                           ! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
23141                                           ! Debug: expression subtree swapping
23142 6972           8A46         FC            mov	al,-4[bp]
23143 6975           30E4                       xor	ah,ah
23144                                           ! Debug: list unsigned int = ax+$28 (used reg = )
23145 6977           05                   0028  add	ax,*$28
23146 697A           50                         push	ax
23147                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
23148 697B           FF76         FE            push	-2[bp]
23149                                           ! Debug: func () void = write_byte+0 (used reg = )
23150 697E           E8         9C99            call	_write_byte
23151 6981           83C4                   06  add	sp,*6
23152                                           !BCC_EOS
23153                                           ! 3581   if ( (index+1) >= package_count ) {
23154                                           ! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
23155 6984           8A46         FC            mov	al,-4[bp]
23156 6987           30E4                       xor	ah,ah
23157                                           ! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
23158 6989           40                         inc	ax
23159 698A           50                         push	ax
23160 698B           8A46         FB            mov	al,-5[bp]
23161 698E           30E4                       xor	ah,ah
23162 6990           3B46         F6            cmp	ax,-$A[bp]
23163 6993           8D66         F8            lea	sp,-8[bp]
23164 6996           77           51            ja  	.50B
23165                       00006998            .50C:
23166                                           ! 3582 ;
23167                                           !BCC_EOS
23168                                           ! 3583     status = read_byte(ebda_seg, 0x0028 + 0);
23169                                           ! Debug: list int = const $28 (used reg = )
23170 6998           B8                   0028  mov	ax,*$28
23171 699B           50                         push	ax
23172                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23173 699C           FF76         FE            push	-2[bp]
23174                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23175 699F           E8         9C52            call	_read_byte
23176 69A2           83C4                   04  add	sp,*4
23177                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
23178 69A5           30E4                       xor	ah,ah
23179 69A7           8946         0C            mov	$C[bp],ax
23180                                           !BCC_EOS
23181                                           ! 3584     X = read_byte(ebda_seg, 0x0028 + 1);
23182                                           ! Debug: list int = const $29 (used reg = )
23183 69AA           B8                   0029  mov	ax,*$29
23184 69AD           50                         push	ax
23185                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23186 69AE           FF76         FE            push	-2[bp]
23187                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23188 69B1           E8         9C40            call	_read_byte
23189 69B4           83C4                   04  add	sp,*4
23190                                           ! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
23191 69B7           30E4                       xor	ah,ah
23192 69B9           8946         0A            mov	$A[bp],ax
23193                                           !BCC_EOS
23194                                           ! 3585     Y = read_byte(ebda_seg, 0x0028 + 2);
23195                                           ! Debug: list int = const $2A (used reg = )
23196 69BC           B8                   002A  mov	ax,*$2A
23197 69BF           50                         push	ax
23198                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
23199 69C0           FF76         FE            push	-2[bp]
23200                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23201 69C3           E8         9C2E            call	_read_byte
23202 69C6           83C4                   04  add	sp,*4
23203                                           ! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
23204 69C9           30E4                       xor	ah,ah
23205 69CB           8946         08            mov	8[bp],ax
23206                                           !BCC_EOS
23207                                           ! 3586     Z = 0;
23208                                           ! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
23209 69CE           31C0                       xor	ax,ax
23210 69D0           8946         06            mov	6[bp],ax
23211                                           !BCC_EOS
23212                                           ! 3587     mouse_flags_1 = 0;
23213                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23214 69D3           30C0                       xor	al,al
23215 69D5           8846         FA            mov	-6[bp],al
23216                                           !BCC_EOS
23217                                           ! 3588     if (mouse_flags_2 & 0x80)
23218                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
23219 69D8           8A46         F9            mov	al,-7[bp]
23220 69DB           24                     80  and	al,#$80
23221 69DD           84C0                       test	al,al
23222 69DF           74           06            je  	.50D
23223                       000069E1            .50E:
23224                                           ! 3589       make_farcall = 1;
23225                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
23226 69E1           B8                   0001  mov	ax,*1
23227 69E4           8946         04            mov	4[bp],ax
23228                                           !BCC_EOS
23229                                           ! 3590     }
23230                       000069E7            .50D:
23231                                           ! 3591   else {
23232 69E7           EB           07            jmp .50F
23233                       000069E9            .50B:
23234                                           ! 3592     mouse_flags_1++;
23235                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23236 69E9           8A46         FA            mov	al,-6[bp]
23237 69EC           40                         inc	ax
23238 69ED           8846         FA            mov	-6[bp],al
23239                                           !BCC_EOS
23240                                           ! 3593     }
23241                                           ! 3594   write_byte(ebda_seg, 0x0026, mouse_flags_1);
23242                       000069F0            .50F:
23243                                           ! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
23244 69F0           8A46         FA            mov	al,-6[bp]
23245 69F3           30E4                       xor	ah,ah
23246 69F5           50                         push	ax
23247                                           ! Debug: list int = const $26 (used reg = )
23248 69F6           B8                   0026  mov	ax,*$26
23249 69F9           50                         push	ax
23250                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
23251 69FA           FF76         FE            push	-2[bp]
23252                                           ! Debug: func () void = write_byte+0 (used reg = )
23253 69FD           E8         9C1A            call	_write_byte
23254 6A00           83C4                   06  add	sp,*6
23255                                           !BCC_EOS
23256                                           ! 3595 }
23257 6A03           89EC                       mov	sp,bp
23258 6A05           5D                         pop	bp
23259 6A06           C3                         ret
23260                                           ! 3596   void
23261                                           ! 3597 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23262                                           ! 3598   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23263                                           export	_int13_harddisk
23264                       00006A07            _int13_harddisk:
23265                                           !BCC_EOS
23266                                           ! 3599 {
23267                                           ! 3600   Bit32u lba_low, lba_high;
23268                                           !BCC_EOS
23269                                           ! 3601   Bit16u ebda_seg=read_word(0x0040,0x000E);
23270 6A07           55                         push	bp
23271 6A08           89E5                       mov	bp,sp
23272 6A0A           83C4                   F6  add	sp,*-$A
23273                                           ! Debug: list int = const $E (used reg = )
23274 6A0D           B8                   000E  mov	ax,*$E
23275 6A10           50                         push	ax
23276                                           ! Debug: list int = const $40 (used reg = )
23277 6A11           B8                   0040  mov	ax,*$40
23278 6A14           50                         push	ax
23279                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23280 6A15           E8         9BEF            call	_read_word
23281 6A18           83C4                   04  add	sp,*4
23282                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
23283 6A1B           8946         F6            mov	-$A[bp],ax
23284                                           !BCC_EOS
23285                                           ! 3602   Bit16u cylinder, head, sector;
23286                                           !BCC_EOS
23287                                           ! 3603   Bit16u segment, offset;
23288                                           !BCC_EOS
23289                                           ! 3604   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
23290                                           !BCC_EOS
23291                                           ! 3605   Bit16u size, count;
23292                                           !BCC_EOS
23293                                           ! 3606   Bit8u device, status;
23294                                           !BCC_EOS
23295                                           ! 3607   ;
23296 6A1E           83C4                   E4  add	sp,*-$1C
23297                                           !BCC_EOS
23298                                           ! 3608   write_byte(0x0040, 0x008e, 0);
23299                                           ! Debug: list int = const 0 (used reg = )
23300 6A21           31C0                       xor	ax,ax
23301 6A23           50                         push	ax
23302                                           ! Debug: list int = const $8E (used reg = )
23303 6A24           B8                   008E  mov	ax,#$8E
23304 6A27           50                         push	ax
23305                                           ! Debug: list int = const $40 (used reg = )
23306 6A28           B8                   0040  mov	ax,*$40
23307 6A2B           50                         push	ax
23308                                           ! Debug: func () void = write_byte+0 (used reg = )
23309 6A2C           E8         9BEB            call	_write_byte
23310 6A2F           83C4                   06  add	sp,*6
23311                                           !BCC_EOS
23312                                           ! 3609   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
23313                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23314 6A32           8A46         10            mov	al,$10[bp]
23315                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
23316 6A35           3C                     80  cmp	al,#$80
23317 6A37           72           07            jb  	.511
23318                       00006A39            .512:
23319                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23320 6A39           8A46         10            mov	al,$10[bp]
23321                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
23322 6A3C           3C                     88  cmp	al,#$88
23323 6A3E           72           22            jb  	.510
23324                       00006A40            .511:
23325                                           ! 3610     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23326                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23327 6A40           8A46         10            mov	al,$10[bp]
23328                                           ! Debug: list unsigned char = al+0 (used reg = )
23329 6A43           30E4                       xor	ah,ah
23330 6A45           50                         push	ax
23331                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
23332 6A46           8B46         18            mov	ax,$18[bp]
23333 6A49           88E0                       mov	al,ah
23334 6A4B           30E4                       xor	ah,ah
23335                                           ! Debug: list unsigned int = ax+0 (used reg = )
23336 6A4D           50                         push	ax
23337                                           ! Debug: list * char = .513+0 (used reg = )
23338 6A4E           BB                   D659  mov	bx,#.513
23339 6A51           53                         push	bx
23340                                           ! Debug: list int = const 4 (used reg = )
23341 6A52           B8                   0004  mov	ax,*4
23342 6A55           50                         push	ax
23343                                           ! Debug: func () void = bios_printf+0 (used reg = )
23344 6A56           E8         9FC0            call	_bios_printf
23345 6A59           83C4                   08  add	sp,*8
23346                                           !BCC_EOS
23347                                           ! 3611     goto int13_fail;
23348 6A5C           83C4                   00  add	sp,#..FFF1+$28
23349 6A5F           E9         0F40            br 	.FFF1
23350                                           !BCC_EOS
23351                                           ! 3612     }
23352                                           ! 3613   device=read_byte(ebda_seg,&((ebda
23353                       00006A62            .510:
23354                                           ! 3613 _data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
23355                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23356 6A62           8A46         10            mov	al,$10[bp]
23357                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
23358 6A65           30E4                       xor	ah,ah
23359                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
23360 6A67           05                   FF80  add	ax,*-$80
23361 6A6A           89C3                       mov	bx,ax
23362                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
23363                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
23364 6A6C           81C3                 0233  add	bx,#$233
23365 6A70           53                         push	bx
23366                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23367 6A71           FF76         F6            push	-$A[bp]
23368                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23369 6A74           E8         9B7D            call	_read_byte
23370 6A77           83C4                   04  add	sp,*4
23371                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
23372 6A7A           8846         DB            mov	-$25[bp],al
23373                                           !BCC_EOS
23374                                           ! 3614   if (device >= (4*2)) {
23375                                           ! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
23376 6A7D           8A46         DB            mov	al,-$25[bp]
23377 6A80           3C                     08  cmp	al,*8
23378 6A82           72           22            jb  	.514
23379                       00006A84            .515:
23380                                           ! 3615     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23381                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
23382 6A84           8A46         10            mov	al,$10[bp]
23383                                           ! Debug: list unsigned char = al+0 (used reg = )
23384 6A87           30E4                       xor	ah,ah
23385 6A89           50                         push	ax
23386                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
23387 6A8A           8B46         18            mov	ax,$18[bp]
23388 6A8D           88E0                       mov	al,ah
23389 6A8F           30E4                       xor	ah,ah
23390                                           ! Debug: list unsigned int = ax+0 (used reg = )
23391 6A91           50                         push	ax
23392                                           ! Debug: list * char = .516+0 (used reg = )
23393 6A92           BB                   D61B  mov	bx,#.516
23394 6A95           53                         push	bx
23395                                           ! Debug: list int = const 4 (used reg = )
23396 6A96           B8                   0004  mov	ax,*4
23397 6A99           50                         push	ax
23398                                           ! Debug: func () void = bios_printf+0 (used reg = )
23399 6A9A           E8         9F7C            call	_bios_printf
23400 6A9D           83C4                   08  add	sp,*8
23401                                           !BCC_EOS
23402                                           ! 3616     goto int13_fail;
23403 6AA0           83C4                   00  add	sp,#..FFF1+$28
23404 6AA3           E9         0EFC            br 	.FFF1
23405                                           !BCC_EOS
23406                                           ! 3617     }
23407                                           ! 3618   switch (( AX >> 8 )) {
23408                       00006AA6            .514:
23409                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23410 6AA6           8B46         18            mov	ax,$18[bp]
23411 6AA9           88E0                       mov	al,ah
23412 6AAB           30E4                       xor	ah,ah
23413 6AAD           E9         0E71            br 	.519
23414                                           ! 3619     case 0x00:
23415                                           ! 3620       ata_reset (device);
23416                       00006AB0            .51A:
23417                                           ! Debug: list unsigned char device = [S+$28-$27] (used reg = )
23418 6AB0           8A46         DB            mov	al,-$25[bp]
23419 6AB3           30E4                       xor	ah,ah
23420 6AB5           50                         push	ax
23421                                           ! Debug: func () void = ata_reset+0 (used reg = )
23422 6AB6           E8         C305            call	_ata_reset
23423 6AB9           44                         inc	sp
23424 6ABA           44                         inc	sp
23425                                           !BCC_EOS
23426                                           ! 3621       goto int13_success;
23427 6ABB           83C4                   0E  add	sp,#..FFEF-..FFF0
23428 6ABE           E9         0F0E            br 	.FFEF
23429                                           !BCC_EOS
23430                                           ! 3622       break;
23431 6AC1           E9         0EDB            br 	.517
23432                                           !BCC_EOS
23433                                           ! 3623     case 0x01:
23434                                           ! 3624       status = read_byte(0x0040, 0x0074);
23435                       00006AC4            .51B:
23436                                           ! Debug: list int = const $74 (used reg = )
23437 6AC4           B8                   0074  mov	ax,*$74
23438 6AC7           50                         push	ax
23439                                           ! Debug: list int = const $40 (used reg = )
23440 6AC8           B8                   0040  mov	ax,*$40
23441 6ACB           50                         push	ax
23442                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23443 6ACC           E8         9B25            call	_read_byte
23444 6ACF           83C4                   04  add	sp,*4
23445                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23446 6AD2           8846         DA            mov	-$26[bp],al
23447                                           !BCC_EOS
23448                                           ! 3625       AX = ((AX & 0x00ff) | ((status) << 8));
23449                                           ! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
23450 6AD5           8A46         DA            mov	al,-$26[bp]
23451 6AD8           30E4                       xor	ah,ah
23452 6ADA           88C4                       mov	ah,al
23453 6ADC           30C0                       xor	al,al
23454 6ADE           50                         push	ax
23455                                           ! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
23456 6ADF           8A46         18            mov	al,$18[bp]
23457                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23458 6AE2           30E4                       xor	ah,ah
23459 6AE4           0B46         CA            or	ax,0+..FFF0[bp]
23460 6AE7           44                         inc	sp
23461 6AE8           44                         inc	sp
23462                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23463 6AE9           8946         18            mov	$18[bp],ax
23464                                           !BCC_EOS
23465                                           ! 3626       write_byte(0x0040, 0x0074, 0);
23466                                           ! Debug: list int = const 0 (used reg = )
23467 6AEC           31C0                       xor	ax,ax
23468 6AEE           50                         push	ax
23469                                           ! Debug: list int = const $74 (used reg = )
23470 6AEF           B8                   0074  mov	ax,*$74
23471 6AF2           50                         push	ax
23472                                           ! Debug: list int = const $40 (used reg = )
23473 6AF3           B8                   0040  mov	ax,*$40
23474 6AF6           50                         push	ax
23475                                           ! Debug: func () void = write_byte+0 (used reg = )
23476 6AF7           E8         9B20            call	_write_byte
23477 6AFA           83C4                   06  add	sp,*6
23478                                           !BCC_EOS
23479                                           ! 3627       if (status) goto int13_fail_nostatus;
23480 6AFD           8A46         DA            mov	al,-$26[bp]
23481 6B00           84C0                       test	al,al
23482 6B02           74           08            je  	.51C
23483                       00006B04            .51D:
23484 6B04           83C4                   0E  add	sp,#..FFEE-..FFF0
23485 6B07           E9         0EB9            br 	.FFEE
23486                                           !BCC_EOS
23487                                           ! 3628       else goto int13_success_noah;
23488 6B0A           EB           06            jmp .51E
23489                       00006B0C            .51C:
23490 6B0C           83C4                   0E  add	sp,#..FFED-..FFF0
23491 6B0F           E9         0EC7            br 	.FFED
23492                                           !BCC_EOS
23493                                           ! 3629       break;
23494                       00006B12            .51E:
23495 6B12           E9         0E8A            br 	.517
23496                                           !BCC_EOS
23497                                           ! 3630     case 0x02:
23498                                           ! 3631     case 0x03:
23499                       00006B15            .51F:
23500                                           ! 3632     case 0x04:
23501                       00006B15            .520:
23502                                           ! 3633       count = ( AX & 0x00ff );
23503                       00006B15            .521:
23504                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23505 6B15           8A46         18            mov	al,$18[bp]
23506                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23507 6B18           30E4                       xor	ah,ah
23508 6B1A           8946         DC            mov	-$24[bp],ax
23509                                           !BCC_EOS
23510                                           ! 3634       cylinder = ( CX >> 8 );
23511                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
23512 6B1D           8B46         16            mov	ax,$16[bp]
23513 6B20           88E0                       mov	al,ah
23514 6B22           30E4                       xor	ah,ah
23515                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23516 6B24           8946         F4            mov	-$C[bp],ax
23517                                           !BCC_EOS
23518                                           ! 3635       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
23519                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23520 6B27           8A46         16            mov	al,$16[bp]
23521                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
23522 6B2A           30E4                       xor	ah,ah
23523                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
23524 6B2C           D1E0                       shl	ax,*1
23525 6B2E           D1E0                       shl	ax,*1
23526                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
23527 6B30           25                   0300  and	ax,#$300
23528                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23529 6B33           0B46         F4            or	ax,-$C[bp]
23530 6B36           8946         F4            mov	-$C[bp],ax
23531                                           !BCC_EOS
23532                                           ! 3636       sector = (( CX & 0x00ff ) & 0x3f);
23533                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23534 6B39           8A46         16            mov	al,$16[bp]
23535                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
23536 6B3C           24                     3F  and	al,*$3F
23537                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
23538 6B3E           30E4                       xor	ah,ah
23539 6B40           8946         F0            mov	-$10[bp],ax
23540                                           !BCC_EOS
23541                                           ! 3637       head = ( DX >> 8 );
23542                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
23543 6B43           8B46         14            mov	ax,$14[bp]
23544 6B46           88E0                       mov	al,ah
23545 6B48           30E4                       xor	ah,ah
23546                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
23547 6B4A           8946         F2            mov	-$E[bp],ax
23548                                           !BCC_EOS
23549                                           ! 3638       segment = ES;
23550                                           ! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
23551 6B4D           8B46         08            mov	ax,8[bp]
23552 6B50           8946         EE            mov	-$12[bp],ax
23553                                           !BCC_EOS
23554                                           ! 3639       offset = BX;
23555                                           ! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
23556 6B53           8B46         12            mov	ax,$12[bp]
23557 6B56           8946         EC            mov	-$14[bp],ax
23558                                           !BCC_EOS
23559                                           ! 3640       if ((count > 128) || (count == 0) || (sector == 0)) {
23560                                           ! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
23561 6B59           8B46         DC            mov	ax,-$24[bp]
23562 6B5C           3D                   0080  cmp	ax,#$80
23563 6B5F           77           0E            ja  	.523
23564                       00006B61            .525:
23565                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
23566 6B61           8B46         DC            mov	ax,-$24[bp]
23567 6B64           85C0                       test	ax,ax
23568 6B66           74           07            je  	.523
23569                       00006B68            .524:
23570                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23571 6B68           8B46         F0            mov	ax,-$10[bp]
23572 6B6B           85C0                       test	ax,ax
23573 6B6D           75           1C            jne 	.522
23574                       00006B6F            .523:
23575                                           ! 3641         bios_printf(4, "int13_harddisk: function %02x, parameter out of range!\n",( AX >> 8 ));
23576                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23577 6B6F           8B46         18            mov	ax,$18[bp]
23578 6B72           88E0                       mov	al,ah
23579 6B74           30E4                       xor	ah,ah
23580                                           ! Debug: list unsigned int = ax+0 (used reg = )
23581 6B76           50                         push	ax
23582                                           ! Debug: list * char = .526+0 (used reg = )
23583 6B77           BB                   D5E3  mov	bx,#.526
23584 6B7A           53                         push	bx
23585                                           ! Debug: list int = const 4 (used reg = )
23586 6B7B           B8                   0004  mov	ax,*4
23587 6B7E           50                         push	ax
23588                                           ! Debug: func () void = bios_printf+0 (used reg = )
23589 6B7F           E8         9E97            call	_bios_printf
23590 6B82           83C4                   06  add	sp,*6
23591                                           !BCC_EOS
23592                                           ! 3642         goto int13_fail;
23593 6B85           83C4                   0E  add	sp,#..FFF1-..FFF0
23594 6B88           E9         0E17            br 	.FFF1
23595                                           !BCC_EOS
23596                                           ! 3643       }
23597                                           ! 3644       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23598                       00006B8B            .522:
23599                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23600 6B8B           8A46         DB            mov	al,-$25[bp]
23601 6B8E           30E4                       xor	ah,ah
23602 6B90           B9                   001E  mov	cx,*$1E
23603 6B93           F7E9                       imul	cx
23604 6B95           89C3                       mov	bx,ax
23605                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23606                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23607 6B97           81C3                 014E  add	bx,#$14E
23608 6B9B           53                         push	bx
23609                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23610 6B9C           FF76         F6            push	-$A[bp]
23611                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23612 6B9F           E8         9A65            call	_read_word
23613 6BA2           83C4                   04  add	sp,*4
23614                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23615 6BA5           8946         E4            mov	-$1C[bp],ax
23616                                           !BCC_EOS
23617                                           ! 3645       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23618                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23619 6BA8           8A46         DB            mov	al,-$25[bp]
23620 6BAB           30E4                       xor	ah,ah
23621 6BAD           B9                   001E  mov	cx,*$1E
23622 6BB0           F7E9                       imul	cx
23623 6BB2           89C3                       mov	bx,ax
23624                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23625                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23626 6BB4           81C3                 014C  add	bx,#$14C
23627 6BB8           53                         push	bx
23628                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23629 6BB9           FF76         F6            push	-$A[bp]
23630                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23631 6BBC           E8         9A48            call	_read_word
23632 6BBF           83C4                   04  add	sp,*4
23633                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23634 6BC2           8946         E2            mov	-$1E[bp],ax
23635                                           !BCC_EOS
23636                                           ! 3646       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23637                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23638 6BC5           8A46         DB            mov	al,-$25[bp]
23639 6BC8           30E4                       xor	ah,ah
23640 6BCA           B9                   001E  mov	cx,*$1E
23641 6BCD           F7E9                       imul	cx
23642 6BCF           89C3                       mov	bx,ax
23643                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23644                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23645 6BD1           81C3                 0150  add	bx,#$150
23646 6BD5           53                         push	bx
23647                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23648 6BD6           FF76         F6            push	-$A[bp]
23649                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23650 6BD9           E8         9A2B            call	_read_word
23651 6BDC           83C4                   04  add	sp,*4
23652                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23653 6BDF           8946         E0            mov	-$20[bp],ax
23654                                           !BCC_EOS
23655                                           ! 3647       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
23656                                           ! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
23657 6BE2           8B46         F4            mov	ax,-$C[bp]
23658 6BE5           3B46         E4            cmp	ax,-$1C[bp]
23659 6BE8           73           10            jae 	.528
23660                       00006BEA            .52A:
23661                                           ! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
23662 6BEA           8B46         F2            mov	ax,-$E[bp]
23663 6BED           3B46         E2            cmp	ax,-$1E[bp]
23664 6BF0           73           08            jae 	.528
23665                       00006BF2            .529:
23666                                           ! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
23667 6BF2           8B46         F0            mov	ax,-$10[bp]
23668 6BF5           3B46         E0            cmp	ax,-$20[bp]
23669 6BF8           76           25            jbe 	.527
23670                       00006BFA            .528:
23671                                           ! 3648         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", ( AX >> 8 ), cylinder, head, sector);
23672                                           ! Debug: list unsigned short sector = [S+$28-$12] (used reg = )
23673 6BFA           FF76         F0            push	-$10[bp]
23674                                           ! Debug: list unsigned short head = [S+$2A-$10] (used reg = )
23675 6BFD           FF76         F2            push	-$E[bp]
23676                                           ! Debug: list unsigned short cylinder = [S+$2C-$E] (used reg = )
23677 6C00           FF76         F4            push	-$C[bp]
23678                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2E+$16] (used reg = )
23679 6C03           8B46         18            mov	ax,$18[bp]
23680 6C06           88E0                       mov	al,ah
23681 6C08           30E4                       xor	ah,ah
23682                                           ! Debug: list unsigned int = ax+0 (used reg = )
23683 6C0A           50                         push	ax
23684                                           ! Debug: list * char = .52B+0 (used reg = )
23685 6C0B           BB                   D59B  mov	bx,#.52B
23686 6C0E           53                         push	bx
23687                                           ! Debug: list int = const 4 (used reg = )
23688 6C0F           B8                   0004  mov	ax,*4
23689 6C12           50                         push	ax
23690                                           ! Debug: func () void = bios_printf+0 (used reg = )
23691 6C13           E8         9E03            call	_bios_printf
23692 6C16           83C4                   0C  add	sp,*$C
23693                                           !BCC_EOS
23694                                           ! 3649         goto int13_fail;
23695 6C19           83C4                   0E  add	sp,#..FFF1-..FFF0
23696 6C1C           E9         0D83            br 	.FFF1
23697                                           !BCC_EOS
23698                                           ! 3650         }
23699                                           ! 3651       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
23700                       00006C1F            .527:
23701                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23702 6C1F           8B46         18            mov	ax,$18[bp]
23703 6C22           88E0                       mov	al,ah
23704 6C24           30E4                       xor	ah,ah
23705                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
23706 6C26           3D                   0004  cmp	ax,*4
23707 6C29           75           06            jne 	.52C
23708                       00006C2B            .52D:
23709 6C2B           83C4                   0E  add	sp,#..FFEF-..FFF0
23710 6C2E           E9         0D9E            br 	.FFEF
23711                                           !BCC_EOS
23712                                           ! 3652       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
23713                       00006C31            .52C:
23714                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23715 6C31           8A46         DB            mov	al,-$25[bp]
23716 6C34           30E4                       xor	ah,ah
23717 6C36           B9                   001E  mov	cx,*$1E
23718 6C39           F7E9                       imul	cx
23719 6C3B           89C3                       mov	bx,ax
23720                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
23721                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
23722 6C3D           81C3                 0152  add	bx,#$152
23723 6C41           53                         push	bx
23724                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23725 6C42           FF76         F6            push	-$A[bp]
23726                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23727 6C45           E8         99BF            call	_read_word
23728 6C48           83C4                   04  add	sp,*4
23729                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
23730 6C4B           8946         E8            mov	-$18[bp],ax
23731                                           !BCC_EOS
23732                                           ! 3653       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
23733                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23734 6C4E           8A46         DB            mov	al,-$25[bp]
23735 6C51           30E4                       xor	ah,ah
23736 6C53           B9                   001E  mov	cx,*$1E
23737 6C56           F7E9                       imul	cx
23738 6C58           89C3                       mov	bx,ax
23739                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
23740                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
23741 6C5A           81C3                 0156  add	bx,#$156
23742 6C5E           53                         push	bx
23743                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23744 6C5F           FF76         F6            push	-$A[bp]
23745                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23746 6C62           E8         99A2            call	_read_word
23747 6C65           83C4                   04  add	sp,*4
23748                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
23749 6C68           8946         E6            mov	-$1A[bp],ax
23750                                           !BCC_EOS
23751                                           ! 3654       if ( (nph != nlh) || (npspt != nlspt)) {
23752                                           ! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
23753 6C6B           8B46         E8            mov	ax,-$18[bp]
23754 6C6E           3B46         E2            cmp	ax,-$1E[bp]
23755 6C71           75           08            jne 	.52F
23756                       00006C73            .530:
23757                                           ! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
23758 6C73           8B46         E6            mov	ax,-$1A[bp]
23759 6C76           3B46         E0            cmp	ax,-$20[bp]
23760 6C79           74           72            je  	.52E
23761                       00006C7B            .52F:
23762                                           ! 3655         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
23763                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23764 6C7B           8B46         F0            mov	ax,-$10[bp]
23765 6C7E           31DB                       xor	bx,bx
23766 6C80           53                         push	bx
23767 6C81           50                         push	ax
23768                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
23769 6C82           8B46         E0            mov	ax,-$20[bp]
23770 6C85           31DB                       xor	bx,bx
23771 6C87           53                         push	bx
23772 6C88           50                         push	ax
23773                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
23774 6C89           8B46         F2            mov	ax,-$E[bp]
23775 6C8C           31DB                       xor	bx,bx
23776 6C8E           53                         push	bx
23777 6C8F           50                         push	ax
23778                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
23779 6C90           8B46         E2            mov	ax,-$1E[bp]
23780 6C93           31DB                       xor	bx,bx
23781 6C95           53                         push	bx
23782 6C96           50                         push	ax
23783                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
23784 6C97           8B46         F4            mov	ax,-$C[bp]
23785 6C9A           31DB                       xor	bx,bx
23786                                           ! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
23787 6C9C           8D7E         BC            lea	di,-$E+..FFF0[bp]
23788 6C9F           E8         9447            call	lmulul
23789 6CA2           83C4                   04  add	sp,*4
23790                                           ! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
23791 6CA5           8D7E         C0            lea	di,-$A+..FFF0[bp]
23792 6CA8           E8         9418            call	laddul
23793 6CAB           83C4                   04  add	sp,*4
23794                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23795 6CAE           8D7E         C4            lea	di,-6+..FFF0[bp]
23796 6CB1           E8         9435            call	lmulul
23797 6CB4           83C4                   04  add	sp,*4
23798                                           ! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23799 6CB7           8D7E         C8            lea	di,-2+..FFF0[bp]
23800 6CBA           E8         9406            call	laddul
23801 6CBD           83C4                   04  add	sp,*4
23802                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
23803 6CC0           53                         push	bx
23804 6CC1           50                         push	ax
23805 6CC2           B8                   0001  mov	ax,*1
23806 6CC5           31DB                       xor	bx,bx
23807 6CC7           53                         push	bx
23808 6CC8           50                         push	ax
23809 6CC9           8B46         C8            mov	ax,-2+..FFF0[bp]
23810 6CCC           8B5E         CA            mov	bx,0+..FFF0[bp]
23811 6CCF           8D7E         C4            lea	di,-6+..FFF0[bp]
23812 6CD2           E8         940C            call	lsubul
23813 6CD5           83C4                   08  add	sp,*8
23814                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23815 6CD8           8946         FC            mov	-4[bp],ax
23816 6CDB           895E         FE            mov	-2[bp],bx
23817                                           !BCC_EOS
23818                                           ! 3656         lba_high = 0;
23819                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23820 6CDE           31C0                       xor	ax,ax
23821 6CE0           31DB                       xor	bx,bx
23822 6CE2           8946         F8            mov	-8[bp],ax
23823 6CE5           895E         FA            mov	-6[bp],bx
23824                                           !BCC_EOS
23825                                           ! 3657         sector = 0;
23826                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23827 6CE8           31C0                       xor	ax,ax
23828 6CEA           8946         F0            mov	-$10[bp],ax
23829                                           !BCC_EOS
23830                                           ! 3658         }
23831                                           ! 3659       if ( ( AX >> 8 ) == 0x02 )
23832                       00006CED            .52E:
23833                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23834 6CED           8B46         18            mov	ax,$18[bp]
23835 6CF0           88E0                       mov	al,ah
23836 6CF2           30E4                       xor	ah,ah
23837                                           ! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
23838 6CF4           3D                   0002  cmp	ax,*2
23839 6CF7           75           33            jne 	.531
23840                       00006CF9            .532:
23841                                           ! 3660         status=ata_cmd_data_in(device, 0x20, count,
23842                                           ! 3660  cylinder, head, sector, lba_low, lba_high, segment, offset);
23843                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23844 6CF9           FF76         EC            push	-$14[bp]
23845                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23846 6CFC           FF76         EE            push	-$12[bp]
23847                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23848 6CFF           FF76         FA            push	-6[bp]
23849 6D02           FF76         F8            push	-8[bp]
23850                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23851 6D05           FF76         FE            push	-2[bp]
23852 6D08           FF76         FC            push	-4[bp]
23853                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23854 6D0B           FF76         F0            push	-$10[bp]
23855                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23856 6D0E           FF76         F2            push	-$E[bp]
23857                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23858 6D11           FF76         F4            push	-$C[bp]
23859                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23860 6D14           FF76         DC            push	-$24[bp]
23861                                           ! Debug: list int = const $20 (used reg = )
23862 6D17           B8                   0020  mov	ax,*$20
23863 6D1A           50                         push	ax
23864                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23865 6D1B           8A46         DB            mov	al,-$25[bp]
23866 6D1E           30E4                       xor	ah,ah
23867 6D20           50                         push	ax
23868                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
23869 6D21           E8         C1F2            call	_ata_cmd_data_in
23870 6D24           83C4                   18  add	sp,*$18
23871                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23872 6D27           8846         DA            mov	-$26[bp],al
23873                                           !BCC_EOS
23874                                           ! 3661       else
23875                                           ! 3662         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
23876 6D2A           EB           31            jmp .533
23877                       00006D2C            .531:
23878                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23879 6D2C           FF76         EC            push	-$14[bp]
23880                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23881 6D2F           FF76         EE            push	-$12[bp]
23882                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23883 6D32           FF76         FA            push	-6[bp]
23884 6D35           FF76         F8            push	-8[bp]
23885                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23886 6D38           FF76         FE            push	-2[bp]
23887 6D3B           FF76         FC            push	-4[bp]
23888                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23889 6D3E           FF76         F0            push	-$10[bp]
23890                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23891 6D41           FF76         F2            push	-$E[bp]
23892                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23893 6D44           FF76         F4            push	-$C[bp]
23894                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23895 6D47           FF76         DC            push	-$24[bp]
23896                                           ! Debug: list int = const $30 (used reg = )
23897 6D4A           B8                   0030  mov	ax,*$30
23898 6D4D           50                         push	ax
23899                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23900 6D4E           8A46         DB            mov	al,-$25[bp]
23901 6D51           30E4                       xor	ah,ah
23902 6D53           50                         push	ax
23903                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
23904 6D54           E8         C5A8            call	_ata_cmd_data_out
23905 6D57           83C4                   18  add	sp,*$18
23906                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23907 6D5A           8846         DA            mov	-$26[bp],al
23908                                           !BCC_EOS
23909                                           ! 3663       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
23910                       00006D5D            .533:
23911                                           ! Debug: list * unsigned short = const $254 (used reg = )
23912 6D5D           B8                   0254  mov	ax,#$254
23913 6D60           50                         push	ax
23914                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23915 6D61           FF76         F6            push	-$A[bp]
23916                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23917 6D64           E8         98A0            call	_read_word
23918 6D67           83C4                   04  add	sp,*4
23919 6D6A           50                         push	ax
23920                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
23921 6D6B           8B46         18            mov	ax,$18[bp]
23922 6D6E           30C0                       xor	al,al
23923                                           ! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
23924 6D70           0B46         CA            or	ax,0+..FFF0[bp]
23925 6D73           44                         inc	sp
23926 6D74           44                         inc	sp
23927                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23928 6D75           8946         18            mov	$18[bp],ax
23929                                           !BCC_EOS
23930                                           ! 3664       if (status != 0) {
23931                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
23932 6D78           8A46         DA            mov	al,-$26[bp]
23933 6D7B           84C0                       test	al,al
23934 6D7D           74           2D            je  	.534
23935                       00006D7F            .535:
23936                                           ! 3665         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
23937                                           ! Debug: list unsigned char status = [S+$28-$28] (used reg = )
23938 6D7F           8A46         DA            mov	al,-$26[bp]
23939 6D82           30E4                       xor	ah,ah
23940 6D84           50                         push	ax
23941                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
23942 6D85           8B46         18            mov	ax,$18[bp]
23943 6D88           88E0                       mov	al,ah
23944 6D8A           30E4                       xor	ah,ah
23945                                           ! Debug: list unsigned int = ax+0 (used reg = )
23946 6D8C           50                         push	ax
23947                                           ! Debug: list * char = .536+0 (used reg = )
23948 6D8D           BB                   D56E  mov	bx,#.536
23949 6D90           53                         push	bx
23950                                           ! Debug: list int = const 4 (used reg = )
23951 6D91           B8                   0004  mov	ax,*4
23952 6D94           50                         push	ax
23953                                           ! Debug: func () void = bios_printf+0 (used reg = )
23954 6D95           E8         9C81            call	_bios_printf
23955 6D98           83C4                   08  add	sp,*8
23956                                           !BCC_EOS
23957                                           ! 3666         AX = ((AX & 0x00ff) | ((0x0c) << 8));
23958                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23959 6D9B           8A46         18            mov	al,$18[bp]
23960                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
23961 6D9E           30E4                       xor	ah,ah
23962 6DA0           0D                   0C00  or	ax,#$C00
23963                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23964 6DA3           8946         18            mov	$18[bp],ax
23965                                           !BCC_EOS
23966                                           ! 3667         goto int13_fail_noah;
23967 6DA6           83C4                   0E  add	sp,#..FFEC-..FFF0
23968 6DA9           E9         0C01            br 	.FFEC
23969                                           !BCC_EOS
23970                                           ! 3668         }
23971                                           ! 3669       goto int13_success;
23972                       00006DAC            .534:
23973 6DAC           83C4                   0E  add	sp,#..FFEF-..FFF0
23974 6DAF           E9         0C1D            br 	.FFEF
23975                                           !BCC_EOS
23976                                           ! 3670       break;
23977 6DB2           E9         0BEA            br 	.517
23978                                           !BCC_EOS
23979                                           ! 3671     case 0x05:
23980                                           ! 3672       bios_printf(4, "format disk track called\n");
23981                       00006DB5            .537:
23982                                           ! Debug: list * char = .538+0 (used reg = )
23983 6DB5           BB                   D554  mov	bx,#.538
23984 6DB8           53                         push	bx
23985                                           ! Debug: list int = const 4 (used reg = )
23986 6DB9           B8                   0004  mov	ax,*4
23987 6DBC           50                         push	ax
23988                                           ! Debug: func () void = bios_printf+0 (used reg = )
23989 6DBD           E8         9C59            call	_bios_printf
23990 6DC0           83C4                   04  add	sp,*4
23991                                           !BCC_EOS
23992                                           ! 3673       goto int13_success;
23993 6DC3           83C4                   0E  add	sp,#..FFEF-..FFF0
23994 6DC6           E9         0C06            br 	.FFEF
23995                                           !BCC_EOS
23996                                           ! 3674       return;
23997 6DC9           89EC                       mov	sp,bp
23998 6DCB           5D                         pop	bp
23999 6DCC           C3                         ret
24000                                           !BCC_EOS
24001                                           ! 3675       break;
24002 6DCD           E9         0BCF            br 	.517
24003                                           !BCC_EOS
24004                                           ! 3676     case 0x08:
24005                                           ! 3677       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
24006                       00006DD0            .539:
24007                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24008 6DD0           8A46         DB            mov	al,-$25[bp]
24009 6DD3           30E4                       xor	ah,ah
24010 6DD5           B9                   001E  mov	cx,*$1E
24011 6DD8           F7E9                       imul	cx
24012 6DDA           89C3                       mov	bx,ax
24013                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
24014                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
24015 6DDC           81C3                 014E  add	bx,#$14E
24016 6DE0           53                         push	bx
24017                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24018 6DE1           FF76         F6            push	-$A[bp]
24019                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24020 6DE4           E8         9820            call	_read_word
24021 6DE7           83C4                   04  add	sp,*4
24022                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
24023 6DEA           8946         E4            mov	-$1C[bp],ax
24024                                           !BCC_EOS
24025                                           ! 3678       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
24026                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24027 6DED           8A46         DB            mov	al,-$25[bp]
24028 6DF0           30E4                       xor	ah,ah
24029 6DF2           B9                   001E  mov	cx,*$1E
24030 6DF5           F7E9                       imul	cx
24031 6DF7           89C3                       mov	bx,ax
24032                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
24033                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
24034 6DF9           81C3                 014C  add	bx,#$14C
24035 6DFD           53                         push	bx
24036                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24037 6DFE           FF76         F6            push	-$A[bp]
24038                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24039 6E01           E8         9803            call	_read_word
24040 6E04           83C4                   04  add	sp,*4
24041                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
24042 6E07           8946         E2            mov	-$1E[bp],ax
24043                                           !BCC_EOS
24044                                           ! 3679       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
24045                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24046 6E0A           8A46         DB            mov	al,-$25[bp]
24047 6E0D           30E4                       xor	ah,ah
24048 6E0F           B9                   001E  mov	cx,*$1E
24049 6E12           F7E9                       imul	cx
24050 6E14           89C3                       mov	bx,ax
24051                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
24052                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
24053 6E16           81C3                 0150  add	bx,#$150
24054 6E1A           53                         push	bx
24055                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24056 6E1B           FF76         F6            push	-$A[bp]
24057                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24058 6E1E           E8         97E6            call	_read_word
24059 6E21           83C4                   04  add	sp,*4
24060                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24061 6E24           8946         E0            mov	-$20[bp],ax
24062                                           !BCC_EOS
24063                                           ! 3680       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
24064                                           ! Debug: list * unsigned char = const $232 (used reg = )
24065 6E27           B8                   0232  mov	ax,#$232
24066 6E2A           50                         push	ax
24067                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24068 6E2B           FF76         F6            push	-$A[bp]
24069                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24070 6E2E           E8         97C3            call	_read_byte
24071 6E31           83C4                   04  add	sp,*4
24072                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
24073 6E34           30E4                       xor	ah,ah
24074 6E36           8946         DC            mov	-$24[bp],ax
24075                                           !BCC_EOS
24076                                           ! 3681       nlc = nlc - 2;
24077                                           ! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
24078 6E39           8B46         E4            mov	ax,-$1C[bp]
24079                                           ! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
24080 6E3C           48                         dec	ax
24081 6E3D           48                         dec	ax
24082 6E3E           8946         E4            mov	-$1C[bp],ax
24083                                           !BCC_EOS
24084                                           ! 3682       AX = ((AX & 0xff00) | (0));
24085                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
24086 6E41           8B46         18            mov	ax,$18[bp]
24087 6E44           30C0                       xor	al,al
24088                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
24089 6E46           0C                     00  or	al,*0
24090                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24091 6E48           8946         18            mov	$18[bp],ax
24092                                           !BCC_EOS
24093                                           ! 3683       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
24094                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
24095 6E4B           8A46         E4            mov	al,-$1C[bp]
24096                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
24097 6E4E           30E4                       xor	ah,ah
24098 6E50           88C4                       mov	ah,al
24099 6E52           30C0                       xor	al,al
24100 6E54           50                         push	ax
24101                                           ! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
24102 6E55           8A46         16            mov	al,$16[bp]
24103                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24104 6E58           30E4                       xor	ah,ah
24105 6E5A           0B46         CA            or	ax,0+..FFF0[bp]
24106 6E5D           44                         inc	sp
24107 6E5E           44                         inc	sp
24108                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
24109 6E5F           8946         16            mov	$16[bp],ax
24110                                           !BCC_EOS
24111                                           ! 3684       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
24112                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
24113 6E62           8A46         E0            mov	al,-$20[bp]
24114 6E65           24                     3F  and	al,*$3F
24115 6E67           50                         push	ax
24116                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
24117 6E68           8B46         E4            mov	ax,-$1C[bp]
24118 6E6B           D1E8                       shr	ax,*1
24119 6E6D           D1E8                       shr	ax,*1
24120                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
24121 6E6F           24                     C0  and	al,#$C0
24122                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24123 6E71           0A46         CA            or	al,0+..FFF0[bp]
24124 6E74           44                         inc	sp
24125 6E75           44                         inc	sp
24126 6E76           50                         push	ax
24127                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
24128 6E77           8B46         16            mov	ax,$16[bp]
24129 6E7A           30C0                       xor	al,al
24130                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
24131 6E7C           0A46         CA            or	al,0+..FFF0[bp]
24132 6E7F           44                         inc	sp
24133 6E80           44                         inc	sp
24134                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
24135 6E81           8946         16            mov	$16[bp],ax
24136                                           !BCC_EOS
24137                                           ! 3685       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
24138                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
24139 6E84           8B46         E2            mov	ax,-$1E[bp]
24140                                           ! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
24141 6E87           48                         dec	ax
24142 6E88           88C4                       mov	ah,al
24143 6E8A           30C0                       xor	al,al
24144 6E8C           50                         push	ax
24145                                           ! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
24146 6E8D           8A46         14            mov	al,$14[bp]
24147                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
24148 6E90           30E4                       xor	ah,ah
24149 6E92           0B46         CA            or	ax,0+..FFF0[bp]
24150 6E95           44                         inc	sp
24151 6E96           44                         inc	sp
24152                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
24153 6E97           8946         14            mov	$14[bp],ax
24154                                           !BCC_EOS
24155                                           ! 3686       DX = ((DX & 0xff00) | (count));
24156                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
24157 6E9A           8B46         14            mov	ax,$14[bp]
24158 6E9D           30C0                       xor	al,al
24159                                           ! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
24160 6E9F           0B46         DC            or	ax,-$24[bp]
24161                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
24162 6EA2           8946         14            mov	$14[bp],ax
24163                                           !BCC_EOS
24164                                           ! 3687       goto int13_success;
24165 6EA5           83C4                   0E  add	sp,#..FFEF-..FFF0
24166 6EA8           E9         0B24            br 	.FFEF
24167                                           !BCC_EOS
24168                                           ! 3688       break;
24169 6EAB           E9         0AF1            br 	.517
24170                                           !BCC_EOS
24171                                           ! 3689     case 0x10:
24172                                           ! 3690       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
24173                       00006EAE            .53A:
24174                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
24175 6EAE           8A46         DB            mov	al,-$25[bp]
24176 6EB1           30E4                       xor	ah,ah
24177 6EB3           D1E8                       shr	ax,*1
24178                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
24179 6EB5           B1                     03  mov	cl,*3
24180 6EB7           D3E0                       shl	ax,cl
24181 6EB9           89C3                       mov	bx,ax
24182                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
24183                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
24184 6EBB           81C3                 0124  add	bx,#$124
24185 6EBF           53                         push	bx
24186                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24187 6EC0           FF76         F6            push	-$A[bp]
24188                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24189 6EC3           E8         9741            call	_read_word
24190 6EC6           83C4                   04  add	sp,*4
24191                                           ! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
24192                                           ! Debug: list unsigned int = ax+7 (used reg = )
24193 6EC9           05                   0007  add	ax,*7
24194 6ECC           50                         push	ax
24195                                           ! Debug: func () unsigned char = inb+0 (used reg = )
24196 6ECD           E8         966E            call	_inb
24197 6ED0           44                         inc	sp
24198 6ED1           44                         inc	sp
24199                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
24200 6ED2           8846         DA            mov	-$26[bp],al
24201                                           !BCC_EOS
24202                                           ! 3691       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
24203                                           ! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
24204 6ED5           8A46         DA            mov	al,-$26[bp]
24205 6ED8           24                     C0  and	al,#$C0
24206                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
24207 6EDA           3C                     40  cmp	al,*$40
24208 6EDC           75           08            jne 	.53B
24209                       00006EDE            .53C:
24210                                           ! 3692         goto int13_success;
24211 6EDE           83C4                   0E  add	sp,#..FFEF-..FFF0
24212 6EE1           E9         0AEB            br 	.FFEF
24213                                           !BCC_EOS
24214                                           ! 3693         }
24215                                           ! 3694       else {
24216 6EE4           EB           11            jmp .53D
24217                       00006EE6            .53B:
24218                                           ! 3695         AX = ((AX & 0x00ff) | ((0xAA) << 8));
24219                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24220 6EE6           8A46         18            mov	al,$18[bp]
24221                                           ! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
24222 6EE9           30E4                       xor	ah,ah
24223 6EEB           0D                   AA00  or	ax,#-$5600
24224                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24225 6EEE           8946         18            mov	$18[bp],ax
24226                                           !BCC_EOS
24227                                           ! 3696         goto int13_fail_noah;
24228 6EF1           83C4                   0E  add	sp,#..FFEC-..FFF0
24229 6EF4           E9         0AB6            br 	.FFEC
24230                                           !BCC_EOS
24231                                           ! 3697         }
24232                                           ! 3698       break;
24233                       00006EF7            .53D:
24234 6EF7           E9         0AA5            br 	.517
24235                                           !BCC_EOS
24236                                           ! 3699     case 0x15:
24237                                           ! 3700       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
24238                       00006EFA            .53E:
24239                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24240 6EFA           8A46         DB            mov	al,-$25[bp]
24241 6EFD           30E4                       xor	ah,ah
24242 6EFF           B9                   001E  mov	cx,*$1E
24243 6F02           F7E9                       imul	cx
24244 6F04           89C3                       mov	bx,ax
24245                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
24246                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
24247 6F06           81C3                 014E  add	bx,#$14E
24248 6F0A           53                         push	bx
24249                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24250 6F0B           FF76         F6            push	-$A[bp]
24251                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24252 6F0E           E8         96F6            call	_read_word
24253 6F11           83C4                   04  add	sp,*4
24254                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
24255 6F14           8946         E4            mov	-$1C[bp],ax
24256                                           !BCC_EOS
24257                                           ! 3701       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
24258                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24259 6F17           8A46         DB            mov	al,-$25[bp]
24260 6F1A           30E4                       xor	ah,ah
24261 6F1C           B9                   001E  mov	cx,*$1E
24262 6F1F           F7E9                       imul	cx
24263 6F21           89C3                       mov	bx,ax
24264                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
24265                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
24266 6F23           81C3                 014C  add	bx,#$14C
24267 6F27           53                         push	bx
24268                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24269 6F28           FF76         F6            push	-$A[bp]
24270                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24271 6F2B           E8         96D9            call	_read_word
24272 6F2E           83C4                   04  add	sp,*4
24273                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
24274 6F31           8946         E2            mov	-$1E[bp],ax
24275                                           !BCC_EOS
24276                                           ! 3702       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
24277                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24278 6F34           8A46         DB            mov	al,-$25[bp]
24279 6F37           30E4                       xor	ah,ah
24280 6F39           B9                   001E  mov	cx,*$1E
24281 6F3C           F7E9                       imul	cx
24282 6F3E           89C3                       mov	bx,ax
24283                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
24284                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
24285 6F40           81C3                 0150  add	bx,#$150
24286 6F44           53                         push	bx
24287                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24288 6F45           FF76         F6            push	-$A[bp]
24289                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24290 6F48           E8         96BC            call	_read_word
24291 6F4B           83C4                   04  add	sp,*4
24292                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24293 6F4E           8946         E0            mov	-$20[bp],ax
24294                                           !BCC_EOS
24295                                           ! 3703       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
24296                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
24297 6F51           8B46         E0            mov	ax,-$20[bp]
24298 6F54           31DB                       xor	bx,bx
24299 6F56           53                         push	bx
24300 6F57           50                         push	ax
24301                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
24302 6F58           8B46         E2            mov	ax,-$1E[bp]
24303 6F5B           31DB                       xor	bx,bx
24304 6F5D           53                         push	bx
24305 6F5E           50                         push	ax
24306                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
24307 6F5F           8B46         E4            mov	ax,-$1C[bp]
24308                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
24309 6F62           48                         dec	ax
24310 6F63           31DB                       xor	bx,bx
24311                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
24312 6F65           8D7E         C4            lea	di,-6+..FFF0[bp]
24313 6F68           E8         917E            call	lmulul
24314 6F6B           83C4                   04  add	sp,*4
24315                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
24316 6F6E           8D7E         C8            lea	di,-2+..FFF0[bp]
24317 6F71           E8         9175            call	lmulul
24318 6F74           83C4                   04  add	sp,*4
24319                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24320 6F77           8946         FC            mov	-4[bp],ax
24321 6F7A           895E         FE            mov	-2[bp],bx
24322                                           !BCC_EOS
24323                                           ! 3704       CX = lba_low >> 16;
24324                                           ! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
24325 6F7D           8B46         FC            mov	ax,-4[bp]
24326 6F80           8B5E         FE            mov	bx,-2[bp]
24327 6F83           93                         xchg	bx,ax
24328 6F84           31DB                       xor	bx,bx
24329                                           ! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
24330 6F86           8946         16            mov	$16[bp],ax
24331                                           !BCC_EOS
24332                                           ! 3705       DX = lba_low & 0xffff;
24333                                           ! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
24334                                           ! Debug: expression subtree swapping
24335 6F89           B8                   FFFF  mov	ax,#$FFFF
24336 6F8C           31DB                       xor	bx,bx
24337 6F8E           8D7E         FC            lea	di,-4[bp]
24338 6F91           E8         9127            call	landul
24339                                           ! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
24340 6F94           8946         14            mov	$14[bp],ax
24341                                           !BCC_EOS
24342                                           ! 3706       AX = ((AX & 0x00ff) | ((3) << 8));
24343                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24344 6F97           8A46         18            mov	al,$18[bp]
24345                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
24346 6F9A           30E4                       xor	ah,ah
24347 6F9C           0D                   0300  or	ax,#$300
24348                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24349 6F9F           8946         18            mov	$18[bp],ax
24350                                           !BCC_EOS
24351                                           ! 3707      
24352                                           ! 3707  goto int13_success_noah;
24353 6FA2           83C4                   0E  add	sp,#..FFED-..FFF0
24354 6FA5           E9         0A31            br 	.FFED
24355                                           !BCC_EOS
24356                                           ! 3708       break;
24357 6FA8           E9         09F4            br 	.517
24358                                           !BCC_EOS
24359                                           ! 3709     case 0x41:
24360                                           ! 3710       BX=0xaa55;
24361                       00006FAB            .53F:
24362                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
24363 6FAB           B8                   AA55  mov	ax,#$AA55
24364 6FAE           8946         12            mov	$12[bp],ax
24365                                           !BCC_EOS
24366                                           ! 3711       AX = ((AX & 0x00ff) | ((0x30) << 8));
24367                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24368 6FB1           8A46         18            mov	al,$18[bp]
24369                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
24370 6FB4           30E4                       xor	ah,ah
24371 6FB6           0D                   3000  or	ax,#$3000
24372                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24373 6FB9           8946         18            mov	$18[bp],ax
24374                                           !BCC_EOS
24375                                           ! 3712       CX=0x0007;
24376                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
24377 6FBC           B8                   0007  mov	ax,*7
24378 6FBF           8946         16            mov	$16[bp],ax
24379                                           !BCC_EOS
24380                                           ! 3713       goto int13_success_noah;
24381 6FC2           83C4                   0E  add	sp,#..FFED-..FFF0
24382 6FC5           E9         0A11            br 	.FFED
24383                                           !BCC_EOS
24384                                           ! 3714       break;
24385 6FC8           E9         09D4            br 	.517
24386                                           !BCC_EOS
24387                                           ! 3715     case 0x42:
24388                                           ! 3716     case 0x43:
24389                       00006FCB            .540:
24390                                           ! 3717     case 0x44:
24391                       00006FCB            .541:
24392                                           ! 3718     case 0x47:
24393                       00006FCB            .542:
24394                                           ! 3719       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
24395                       00006FCB            .543:
24396                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
24397 6FCB           8B46         0C            mov	ax,$C[bp]
24398                                           ! Debug: list unsigned int = ax+2 (used reg = )
24399 6FCE           40                         inc	ax
24400 6FCF           40                         inc	ax
24401 6FD0           50                         push	ax
24402                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24403 6FD1           FF76         06            push	6[bp]
24404                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24405 6FD4           E8         9630            call	_read_word
24406 6FD7           83C4                   04  add	sp,*4
24407                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24408 6FDA           8946         DC            mov	-$24[bp],ax
24409                                           !BCC_EOS
24410                                           ! 3720       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
24411                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
24412 6FDD           8B46         0C            mov	ax,$C[bp]
24413                                           ! Debug: list unsigned int = ax+6 (used reg = )
24414 6FE0           05                   0006  add	ax,*6
24415 6FE3           50                         push	ax
24416                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24417 6FE4           FF76         06            push	6[bp]
24418                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24419 6FE7           E8         961D            call	_read_word
24420 6FEA           83C4                   04  add	sp,*4
24421                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
24422 6FED           8946         EE            mov	-$12[bp],ax
24423                                           !BCC_EOS
24424                                           ! 3721       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
24425                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
24426 6FF0           8B46         0C            mov	ax,$C[bp]
24427                                           ! Debug: list unsigned int = ax+4 (used reg = )
24428 6FF3           05                   0004  add	ax,*4
24429 6FF6           50                         push	ax
24430                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24431 6FF7           FF76         06            push	6[bp]
24432                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24433 6FFA           E8         960A            call	_read_word
24434 6FFD           83C4                   04  add	sp,*4
24435                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
24436 7000           8946         EC            mov	-$14[bp],ax
24437                                           !BCC_EOS
24438                                           ! 3722       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
24439                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
24440 7003           8B46         0C            mov	ax,$C[bp]
24441                                           ! Debug: list unsigned int = ax+$C (used reg = )
24442 7006           05                   000C  add	ax,*$C
24443 7009           50                         push	ax
24444                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24445 700A           FF76         06            push	6[bp]
24446                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24447 700D           E8         9073            call	_read_dword
24448 7010           89D3                       mov	bx,dx
24449 7012           83C4                   04  add	sp,*4
24450                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24451 7015           8946         F8            mov	-8[bp],ax
24452 7018           895E         FA            mov	-6[bp],bx
24453                                           !BCC_EOS
24454                                           ! 3723       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
24455                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24456 701B           8A46         DB            mov	al,-$25[bp]
24457 701E           30E4                       xor	ah,ah
24458 7020           B9                   001E  mov	cx,*$1E
24459 7023           F7E9                       imul	cx
24460 7025           89C3                       mov	bx,ax
24461                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24462                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24463 7027           81C3                 015C  add	bx,#$15C
24464 702B           53                         push	bx
24465                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24466 702C           FF76         F6            push	-$A[bp]
24467                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24468 702F           E8         9051            call	_read_dword
24469 7032           89D3                       mov	bx,dx
24470 7034           83C4                   04  add	sp,*4
24471                                           ! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24472 7037           8D7E         F8            lea	di,-8[bp]
24473 703A           E8         908E            call	lcmpul
24474 703D           73           1C            jae 	.544
24475                       0000703F            .545:
24476                                           ! 3724         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
24477                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24478 703F           8B46         18            mov	ax,$18[bp]
24479 7042           88E0                       mov	al,ah
24480 7044           30E4                       xor	ah,ah
24481                                           ! Debug: list unsigned int = ax+0 (used reg = )
24482 7046           50                         push	ax
24483                                           ! Debug: list * char = .546+0 (used reg = )
24484 7047           BB                   D523  mov	bx,#.546
24485 704A           53                         push	bx
24486                                           ! Debug: list int = const 4 (used reg = )
24487 704B           B8                   0004  mov	ax,*4
24488 704E           50                         push	ax
24489                                           ! Debug: func () void = bios_printf+0 (used reg = )
24490 704F           E8         99C7            call	_bios_printf
24491 7052           83C4                   06  add	sp,*6
24492                                           !BCC_EOS
24493                                           ! 3725         goto int13_fail;
24494 7055           83C4                   0E  add	sp,#..FFF1-..FFF0
24495 7058           E9         0947            br 	.FFF1
24496                                           !BCC_EOS
24497                                           ! 3726         }
24498                                           ! 3727       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
24499                       0000705B            .544:
24500                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
24501 705B           8B46         0C            mov	ax,$C[bp]
24502                                           ! Debug: list unsigned int = ax+8 (used reg = )
24503 705E           05                   0008  add	ax,*8
24504 7061           50                         push	ax
24505                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24506 7062           FF76         06            push	6[bp]
24507                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24508 7065           E8         901B            call	_read_dword
24509 7068           89D3                       mov	bx,dx
24510 706A           83C4                   04  add	sp,*4
24511                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24512 706D           8946         FC            mov	-4[bp],ax
24513 7070           895E         FE            mov	-2[bp],bx
24514                                           !BCC_EOS
24515                                           ! 3728       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
24516                                           ! 3729           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
24517                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24518 7073           8A46         DB            mov	al,-$25[bp]
24519 7076           30E4                       xor	ah,ah
24520 7078           B9                   001E  mov	cx,*$1E
24521 707B           F7E9                       imul	cx
24522 707D           89C3                       mov	bx,ax
24523                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24524                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24525 707F           81C3                 015C  add	bx,#$15C
24526 7083           53                         push	bx
24527                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24528 7084           FF76         F6            push	-$A[bp]
24529                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24530 7087           E8         8FF9            call	_read_dword
24531 708A           89D3                       mov	bx,dx
24532 708C           83C4                   04  add	sp,*4
24533                                           ! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24534                                           ! Debug: expression subtree swapping
24535 708F           8D7E         F8            lea	di,-8[bp]
24536 7092           E8         9036            call	lcmpul
24537 7095           75           40            jne 	.547
24538                       00007097            .549:
24539                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24540 7097           8A46         DB            mov	al,-$25[bp]
24541 709A           30E4                       xor	ah,ah
24542 709C           B9                   001E  mov	cx,*$1E
24543 709F           F7E9                       imul	cx
24544 70A1           89C3                       mov	bx,ax
24545                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24546                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24547 70A3           81C3                 0158  add	bx,#$158
24548 70A7           53                         push	bx
24549                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24550 70A8           FF76         F6            push	-$A[bp]
24551                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24552 70AB           E8         8FD5            call	_read_dword
24553 70AE           89D3                       mov	bx,dx
24554 70B0           83C4                   04  add	sp,*4
24555                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24556 70B3           8D7E         FC            lea	di,-4[bp]
24557 70B6           E8         9012            call	lcmpul
24558 70B9           77           1C            ja  	.547
24559                       000070BB            .548:
24560                                           ! 3730         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
24561                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24562 70BB           8B46         18            mov	ax,$18[bp]
24563 70BE           88E0                       mov	al,ah
24564 70C0           30E4                       xor	ah,ah
24565                                           ! Debug: list unsigned int = ax+0 (used reg = )
24566 70C2           50                         push	ax
24567                                           ! Debug: list * char = .54A+0 (used reg = )
24568 70C3           BB                   D4F2  mov	bx,#.54A
24569 70C6           53                         push	bx
24570                                           ! Debug: list int = const 4 (used reg = )
24571 70C7           B8                   0004  mov	ax,*4
24572 70CA           50                         push	ax
24573                                           ! Debug: func () void = bios_printf+0 (used reg = )
24574 70CB           E8         994B            call	_bios_printf
24575 70CE           83C4                   06  add	sp,*6
24576                                           !BCC_EOS
24577                                           ! 3731         goto int13_fail;
24578 70D1           83C4                   0E  add	sp,#..FFF1-..FFF0
24579 70D4           E9         08CB            br 	.FFF1
24580                                           !BCC_EOS
24581                                           ! 3732         }
24582                                           ! 3733       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
24583                       000070D7            .547:
24584                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24585 70D7           8B46         18            mov	ax,$18[bp]
24586 70DA           88E0                       mov	al,ah
24587 70DC           30E4                       xor	ah,ah
24588                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
24589 70DE           3D                   0044  cmp	ax,*$44
24590 70E1           74           0C            je  	.54C
24591                       000070E3            .54D:
24592                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24593 70E3           8B46         18            mov	ax,$18[bp]
24594 70E6           88E0                       mov	al,ah
24595 70E8           30E4                       xor	ah,ah
24596                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
24597 70EA           3D                   0047  cmp	ax,*$47
24598 70ED           75           06            jne 	.54B
24599                       000070EF            .54C:
24600                                           ! 3734         goto int13_success;
24601 70EF           83C4                   0E  add	sp,#..FFEF-..FFF0
24602 70F2           E9         08DA            br 	.FFEF
24603                                           !BCC_EOS
24604                                           ! 3735       if ( ( AX >> 8 ) == 0x42 )
24605                       000070F5            .54B:
24606                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24607 70F5           8B46         18            mov	ax,$18[bp]
24608 70F8           88E0                       mov	al,ah
24609 70FA           30E4                       xor	ah,ah
24610                                           ! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
24611 70FC           3D                   0042  cmp	ax,*$42
24612 70FF           75           33            jne 	.54E
24613                       00007101            .54F:
24614                                           ! 3736         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24615                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24616 7101           FF76         EC            push	-$14[bp]
24617                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24618 7104           FF76         EE            push	-$12[bp]
24619                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24620 7107           FF76         FA            push	-6[bp]
24621 710A           FF76         F8            push	-8[bp]
24622                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24623 710D           FF76         FE            push	-2[bp]
24624 7110           FF76         FC            push	-4[bp]
24625                                           ! Debug: list int = const 0 (used reg = )
24626 7113           31C0                       xor	ax,ax
24627 7115           50                         push	ax
24628                                           ! Debug: list int = const 0 (used reg = )
24629 7116           31C0                       xor	ax,ax
24630 7118           50                         push	ax
24631                                           ! Debug: list int = const 0 (used reg = )
24632 7119           31C0                       xor	ax,ax
24633 711B           50                         push	ax
24634                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24635 711C           FF76         DC            push	-$24[bp]
24636                                           ! Debug: list int = const $20 (used reg = )
24637 711F           B8                   0020  mov	ax,*$20
24638 7122           50                         push	ax
24639                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24640 7123           8A46         DB            mov	al,-$25[bp]
24641 7126           30E4                       xor	ah,ah
24642 7128           50                         push	ax
24643                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
24644 7129           E8         BDEA            call	_ata_cmd_data_in
24645 712C           83C4                   18  add	sp,*$18
24646                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24647 712F           8846         DA            mov	-$26[bp],al
24648                                           !BCC_EOS
24649                                           ! 3737       else
24650                                           ! 3738         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24651 7132           EB           31            jmp .550
24652                       00007134            .54E:
24653                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24654 7134           FF76         EC            push	-$14[bp]
24655                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24656 7137           FF76         EE            push	-$12[bp]
24657                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24658 713A           FF76         FA            push	-6[bp]
24659 713D           FF76         F8            push	-8[bp]
24660                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24661 7140           FF76         FE            push	-2[bp]
24662 7143           FF76         FC            push	-4[bp]
24663                                           ! Debug: list int = const 0 (used reg = )
24664 7146           31C0                       xor	ax,ax
24665 7148           50                         push	ax
24666                                           ! Debug: list int = const 0 (used reg = )
24667 7149           31C0                       xor	ax,ax
24668 714B           50                         push	ax
24669                                           ! Debug: list int = const 0 (used reg = )
24670 714C           31C0                       xor	ax,ax
24671 714E           50                         push	ax
24672                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24673 714F           FF76         DC            push	-$24[bp]
24674                                           ! Debug: list int = const $30 (used reg = )
24675 7152           B8                   0030  mov	ax,*$30
24676 7155           50                         push	ax
24677                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24678 7156           8A46         DB            mov	al,-$25[bp]
24679 7159           30E4                       xor	ah,ah
24680 715B           50                         push	ax
24681                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24682 715C           E8         C1A0            call	_ata_cmd_data_out
24683 715F           83C4                   18  add	sp,*$18
24684                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24685 7162           8846         DA            mov	-$26[bp],al
24686                                           !BCC_EOS
24687                                           ! 3739       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
24688                       00007165            .550:
24689                                           ! Debug: list * unsigned short = const $254 (used reg = )
24690 7165           B8                   0254  mov	ax,#$254
24691 7168           50                         push	ax
24692                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24693 7169           FF76         F6            push	-$A[bp]
24694                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24695 716C           E8         9498            call	_read_word
24696 716F           83C4                   04  add	sp,*4
24697                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24698 7172           8946         DC            mov	-$24[bp],ax
24699                                           !BCC_EOS
24700                                           ! 3740       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
24701                                           ! Debug: list unsigned short count = [S+$28-$26] (used reg = )
24702 7175           FF76         DC            push	-$24[bp]
24703                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
24704 7178           8B46         0C            mov	ax,$C[bp]
24705                                           ! Debug: list unsigned int = ax+2 (used reg = )
24706 717B           40                         inc	ax
24707 717C           40                         inc	ax
24708 717D           50                         push	ax
24709                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
24710 717E           FF76         06            push	6[bp]
24711                                           ! Debug: func () void = write_word+0 (used reg = )
24712 7181           E8         94AE            call	_write_word
24713 7184           83C4                   06  add	sp,*6
24714                                           !BCC_EOS
24715                                           ! 3741       if (status != 0) {
24716                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24717 7187           8A46         DA            mov	al,-$26[bp]
24718 718A           84C0                       test	al,al
24719 718C           74           2D            je  	.551
24720                       0000718E            .552:
24721                                           ! 3742         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
24722                                           ! Debug: list unsigned char status = [S+$28-$28] (used reg = )
24723 718E           8A46         DA            mov	al,-$26[bp]
24724 7191           30E4                       xor	ah,ah
24725 7193           50                         push	ax
24726                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$16] (used reg = )
24727 7194           8B46         18            mov	ax,$18[bp]
24728 7197           88E0                       mov	al,ah
24729 7199           30E4                       xor	ah,ah
24730                                           ! Debug: list unsigned int = ax+0 (used reg = )
24731 719B           50                         push	ax
24732                                           ! Debug: list * char = .553+0 (used reg = )
24733 719C           BB                   D4C5  mov	bx,#.553
24734 719F           53                         push	bx
24735                                           ! Debug: list int = const 4 (used reg = )
24736 71A0           B8                   0004  mov	ax,*4
24737 71A3           50                         push	ax
24738                                           ! Debug: func () void = bios_printf+0 (used reg = )
24739 71A4           E8         9872            call	_bios_printf
24740 71A7           83C4                   08  add	sp,*8
24741                                           !BCC_EOS
24742                                           ! 3743         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24743                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24744 71AA           8A46         18            mov	al,$18[bp]
24745                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24746 71AD           30E4                       xor	ah,ah
24747 71AF           0D                   0C00  or	ax,#$C00
24748                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24749 71B2           8946         18            mov	$18[bp],ax
24750                                           !BCC_EOS
24751                                           ! 3744         goto int13_fail_noah;
24752 71B5           83C4                   0E  add	sp,#..FFEC-..FFF0
24753 71B8           E9         07F2            br 	.FFEC
24754                                           !BCC_EOS
24755                                           ! 3745         }
24756                                           ! 3746       goto int13_success;
24757                       000071BB            .551:
24758 71BB           83C4                   0E  add	sp,#..FFEF-..FFF0
24759 71BE           E9         080E            br 	.FFEF
24760                                           !BCC_EOS
24761                                           ! 3747       break;
24762 71C1           E9         07DB            br 	.517
24763                                           !BCC_EOS
24764                                           ! 3748     case 0x45:
24765                                           ! 3749     case 0x49:
24766                       000071C4            .554:
24767                                           ! 3750       goto int13_success;
24768                       000071C4            .555:
24769 71C4           83C4                   0E  add	sp,#..FFEF-..FFF0
24770 71C7           E9         0805            br 	.FFEF
24771                                           !BCC_EOS
24772                                           ! 3751       break;
24773 71CA           E9         07D2            br 	.517
24774                                           !BCC_EOS
24775                                           ! 3752     case 0x46:
24776                                           ! 3753       AX = ((AX & 0x00ff) | ((0xb2) << 8));
24777                       000071CD            .556:
24778                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24779 71CD           8A46         18            mov	al,$18[bp]
24780                                           ! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
24781 71D0           30E4                       xor	ah,ah
24782 71D2           0D                   B200  or	ax,#-$4E00
24783                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24784 71D5           8946         18            mov	$18[bp],ax
24785                                           !BCC_EOS
24786                                           ! 3754       goto int13_fail_noah;
24787 71D8           83C4                   0E  add	sp,#..FFEC-..FFF0
24788 71DB           E9         07CF            br 	.FFEC
24789                                           !BCC_EOS
24790                                           ! 3755       break;
24791 71DE           E9         07BE            br 	.517
24792                                           !BCC_EOS
24793                                           ! 3756     case 0x48:
24794                                           ! 3757       size=read_word(
24795                       000071E1            .557:
24796                                           ! 3757 DS,SI+(Bit16u)&((dpt_t *) 0)->size);
24797                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
24798 71E1           8B46         0C            mov	ax,$C[bp]
24799                                           ! Debug: list unsigned int = ax+0 (used reg = )
24800 71E4           50                         push	ax
24801                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24802 71E5           FF76         06            push	6[bp]
24803                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24804 71E8           E8         941C            call	_read_word
24805 71EB           83C4                   04  add	sp,*4
24806                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
24807 71EE           8946         DE            mov	-$22[bp],ax
24808                                           !BCC_EOS
24809                                           ! 3758       if(size < 0x1a)
24810                                           ! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24811 71F1           8B46         DE            mov	ax,-$22[bp]
24812 71F4           3D                   001A  cmp	ax,*$1A
24813 71F7           73           06            jae 	.558
24814                       000071F9            .559:
24815                                           ! 3759         goto int13_fail;
24816 71F9           83C4                   0E  add	sp,#..FFF1-..FFF0
24817 71FC           E9         07A3            br 	.FFF1
24818                                           !BCC_EOS
24819                                           ! 3760       if(size >= 0x1a) {
24820                       000071FF            .558:
24821                                           ! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24822 71FF           8B46         DE            mov	ax,-$22[bp]
24823 7202           3D                   001A  cmp	ax,*$1A
24824 7205         0F82         01E3            blo 	.55A
24825                       00007209            .55B:
24826                                           ! 3761         Bit16u blksize;
24827                                           !BCC_EOS
24828                                           ! 3762         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
24829                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24830 7209           8A46         DB            mov	al,-$25[bp]
24831 720C           30E4                       xor	ah,ah
24832 720E           B9                   001E  mov	cx,*$1E
24833 7211           F7E9                       imul	cx
24834 7213           89C3                       mov	bx,ax
24835                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
24836                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
24837 7215           81C3                 0154  add	bx,#$154
24838 7219           53                         push	bx
24839                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24840 721A           FF76         F6            push	-$A[bp]
24841                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24842 721D           E8         93E7            call	_read_word
24843 7220           83C4                   04  add	sp,*4
24844                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
24845 7223           8946         EA            mov	-$16[bp],ax
24846                                           !BCC_EOS
24847                                           ! 3763         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
24848                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24849 7226           8A46         DB            mov	al,-$25[bp]
24850 7229           30E4                       xor	ah,ah
24851 722B           B9                   001E  mov	cx,*$1E
24852 722E           F7E9                       imul	cx
24853 7230           89C3                       mov	bx,ax
24854                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
24855                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
24856 7232           81C3                 0152  add	bx,#$152
24857 7236           53                         push	bx
24858                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24859 7237           FF76         F6            push	-$A[bp]
24860                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24861 723A           E8         93CA            call	_read_word
24862 723D           83C4                   04  add	sp,*4
24863                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24864 7240           8946         E8            mov	-$18[bp],ax
24865                                           !BCC_EOS
24866                                           ! 3764         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
24867                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24868 7243           8A46         DB            mov	al,-$25[bp]
24869 7246           30E4                       xor	ah,ah
24870 7248           B9                   001E  mov	cx,*$1E
24871 724B           F7E9                       imul	cx
24872 724D           89C3                       mov	bx,ax
24873                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
24874                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
24875 724F           81C3                 0156  add	bx,#$156
24876 7253           53                         push	bx
24877                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24878 7254           FF76         F6            push	-$A[bp]
24879                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24880 7257           E8         93AD            call	_read_word
24881 725A           83C4                   04  add	sp,*4
24882                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
24883 725D           8946         E6            mov	-$1A[bp],ax
24884                                           !BCC_EOS
24885                                           ! 3765         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
24886                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24887 7260           8A46         DB            mov	al,-$25[bp]
24888 7263           30E4                       xor	ah,ah
24889 7265           B9                   001E  mov	cx,*$1E
24890 7268           F7E9                       imul	cx
24891 726A           89C3                       mov	bx,ax
24892                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24893                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24894 726C           81C3                 0158  add	bx,#$158
24895 7270           53                         push	bx
24896                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24897 7271           FF76         F6            push	-$A[bp]
24898                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24899 7274           E8         8E0C            call	_read_dword
24900 7277           89D3                       mov	bx,dx
24901 7279           83C4                   04  add	sp,*4
24902                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
24903 727C           8946         FC            mov	-4[bp],ax
24904 727F           895E         FE            mov	-2[bp],bx
24905                                           !BCC_EOS
24906                                           ! 3766         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
24907                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24908 7282           8A46         DB            mov	al,-$25[bp]
24909 7285           30E4                       xor	ah,ah
24910 7287           B9                   001E  mov	cx,*$1E
24911 728A           F7E9                       imul	cx
24912 728C           89C3                       mov	bx,ax
24913                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24914                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24915 728E           81C3                 015C  add	bx,#$15C
24916 7292           53                         push	bx
24917                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24918 7293           FF76         F6            push	-$A[bp]
24919                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24920 7296           E8         8DEA            call	_read_dword
24921 7299           89D3                       mov	bx,dx
24922 729B           83C4                   04  add	sp,*4
24923                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
24924 729E           8946         F8            mov	-8[bp],ax
24925 72A1           895E         FA            mov	-6[bp],bx
24926                                           !BCC_EOS
24927                                           ! 3767         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
24928                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24929 72A4           8A46         DB            mov	al,-$25[bp]
24930 72A7           30E4                       xor	ah,ah
24931 72A9           B9                   001E  mov	cx,*$1E
24932 72AC           F7E9                       imul	cx
24933 72AE           89C3                       mov	bx,ax
24934                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
24935                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
24936 72B0           81C3                 0148  add	bx,#$148
24937 72B4           53                         push	bx
24938                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24939 72B5           FF76         F6            push	-$A[bp]
24940                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24941 72B8           E8         934C            call	_read_word
24942 72BB           83C4                   04  add	sp,*4
24943                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
24944 72BE           8946         D8            mov	-$28[bp],ax
24945                                           !BCC_EOS
24946                                           ! 3768         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
24947                                           ! Debug: list int = const $1A (used reg = )
24948 72C1           B8                   001A  mov	ax,*$1A
24949 72C4           50                         push	ax
24950                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
24951 72C5           8B46         0C            mov	ax,$C[bp]
24952                                           ! Debug: list unsigned int = ax+0 (used reg = )
24953 72C8           50                         push	ax
24954                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24955 72C9           FF76         06            push	6[bp]
24956                                           ! Debug: func () void = write_word+0 (used reg = )
24957 72CC           E8         9363            call	_write_word
24958 72CF           83C4                   06  add	sp,*6
24959                                           !BCC_EOS
24960                                           ! 3769         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
24961 72D2           8B46         F8            mov	ax,-8[bp]
24962 72D5           8B5E         FA            mov	bx,-6[bp]
24963 72D8           E8         8E39            call	ltstl
24964 72DB           75           50            jne 	.55D
24965                       000072DD            .55E:
24966                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24967 72DD           8B46         E8            mov	ax,-$18[bp]
24968 72E0           31DB                       xor	bx,bx
24969 72E2           53                         push	bx
24970 72E3           50                         push	ax
24971                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
24972 72E4           8B46         E6            mov	ax,-$1A[bp]
24973 72E7           31DB                       xor	bx,bx
24974                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
24975 72E9           53                         push	bx
24976 72EA           50                         push	ax
24977 72EB           8B46         FC            mov	ax,-4[bp]
24978 72EE           8B5E         FE            mov	bx,-2[bp]
24979 72F1           8D7E         C4            lea	di,-6+..FFF0[bp]
24980 72F4           E8         8E77            call	ldivul
24981 72F7           83C4                   04  add	sp,*4
24982                                           ! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
24983 72FA           8D7E         C8            lea	di,-2+..FFF0[bp]
24984 72FD           E8         8E6E            call	ldivul
24985 7300           83C4                   04  add	sp,*4
24986                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
24987 7303           53                         push	bx
24988 7304           50                         push	ax
24989 7305           B8                   3FFF  mov	ax,#$3FFF
24990 7308           31DB                       xor	bx,bx
24991 730A           53                         push	bx
24992 730B           50                         push	ax
24993 730C           8B46         C8            mov	ax,-2+..FFF0[bp]
24994 730F           8B5E         CA            mov	bx,0+..FFF0[bp]
24995 7312           8D7E         C4            lea	di,-6+..FFF0[bp]
24996 7315           E8         8DB3            call	lcmpul
24997 7318           76           04            jbe	.55F
24998 731A           B0                     01  mov	al,*1
24999 731C           EB           02            jmp	.560
25000                       0000731E            .55F:
25001 731E           30C0                       xor	al,al
25002                       00007320            .560:
25003 7320           83C4                   08  add	sp,*8
25004                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
25005 7323           30E4                       xor	ah,ah
25006 7325           99                         cwd
25007 7326           89D3                       mov	bx,dx
25008 7328           E8         8DE9            call	ltstl
25009 732B           74           28            je  	.55C
25010                       0000732D            .55D:
25011                                           ! 3770         {
25012                                           ! 3771           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
25013                                           ! Debug: list int = const 0 (used reg = )
25014 732D           31C0                       xor	ax,ax
25015 732F           50                         push	ax
25016                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
25017 7330           8B46         0C            mov	ax,$C[bp]
25018                                           ! Debug: list unsigned int = ax+2 (used reg = )
25019 7333           40                         inc	ax
25020 7334           40                         inc	ax
25021 7335           50                         push	ax
25022                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25023 7336           FF76         06            push	6[bp]
25024                                           ! Debug: func () void = write_word+0 (used reg = )
25025 7339           E8         92F6            call	_write_word
25026 733C           83C4                   06  add	sp,*6
25027                                           !BCC_EOS
25028                                           ! 3772           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
25029                                           ! Debug: list int = const $3FFF (used reg = )
25030 733F           B8                   3FFF  mov	ax,#$3FFF
25031 7342           50                         push	ax
25032                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
25033 7343           8B46         0C            mov	ax,$C[bp]
25034                                           ! Debug: list unsigned int = ax+4 (used reg = )
25035 7346           05                   0004  add	ax,*4
25036 7349           50                         push	ax
25037                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25038 734A           FF76         06            push	6[bp]
25039                                           ! Debug: func () void = write_dword+0 (used reg = )
25040 734D           E8         8D4B            call	_write_dword
25041 7350           83C4                   06  add	sp,*6
25042                                           !BCC_EOS
25043                                           ! 3773         }
25044                                           ! 3774         else
25045                                           ! 3775         {
25046 7353           EB           2A            jmp .562
25047                       00007355            .55C:
25048                                           ! 3776           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
25049                                           ! Debug: list int = const 2 (used reg = )
25050 7355           B8                   0002  mov	ax,*2
25051 7358           50                         push	ax
25052                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
25053 7359           8B46         0C            mov	ax,$C[bp]
25054                                           ! Debug: list unsigned int = ax+2 (used reg = )
25055 735C           40                         inc	ax
25056 735D           40                         inc	ax
25057 735E           50                         push	ax
25058                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25059 735F           FF76         06            push	6[bp]
25060                                           ! Debug: func () void = write_word+0 (used reg = )
25061 7362           E8         92CD            call	_write_word
25062 7365           83C4                   06  add	sp,*6
25063                                           !BCC_EOS
25064                                           ! 3777           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
25065                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
25066 7368           8B46         EA            mov	ax,-$16[bp]
25067 736B           31DB                       xor	bx,bx
25068                                           ! Debug: list unsigned long = bx+0 (used reg = )
25069 736D           53                         push	bx
25070 736E           50                         push	ax
25071                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
25072 736F           8B46         0C            mov	ax,$C[bp]
25073                                           ! Debug: list unsigned int = ax+4 (used reg = )
25074 7372           05                   0004  add	ax,*4
25075 7375           50                         push	ax
25076                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25077 7376           FF76         06            push	6[bp]
25078                                           ! Debug: func () void = write_dword+0 (used reg = )
25079 7379           E8         8D1F            call	_write_dword
25080 737C           83C4                   08  add	sp,*8
25081                                           !BCC_EOS
25082                                           ! 3778         }
25083                                           ! 3779         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
25084                       0000737F            .562:
25085                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
25086 737F           8B46         E8            mov	ax,-$18[bp]
25087 7382           31DB                       xor	bx,bx
25088                                           ! Debug: list unsigned long = bx+0 (used reg = )
25089 7384           53                         push	bx
25090 7385           50                         push	ax
25091                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
25092 7386           8B46         0C            mov	ax,$C[bp]
25093                                           ! Debug: list unsigned int = ax+8 (used reg = )
25094 7389           05                   0008  add	ax,*8
25095 738C           50                         push	ax
25096                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25097 738D           FF76         06            push	6[bp]
25098                                           ! Debug: func () void = write_dword+0 (used reg = )
25099 7390           E8         8D08            call	_write_dword
25100 7393           83C4                   08  add	sp,*8
25101                                           !BCC_EOS
25102                                           ! 3780         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
25103                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
25104 7396           8B46         E6            mov	ax,-$1A[bp]
25105 7399           31DB                       xor	bx,bx
25106                                           ! Debug: list unsigned long = bx+0 (used reg = )
25107 739B           53                         push	bx
25108 739C           50                         push	ax
25109                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
25110 739D           8B46         0C            mov	ax,$C[bp]
25111                                           ! Debug: list unsigned int = ax+$C (used reg = )
25112 73A0           05                   000C  add	ax,*$C
25113 73A3           50                         push	ax
25114                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25115 73A4           FF76         06            push	6[bp]
25116                                           ! Debug: func () void = write_dword+0 (used reg = )
25117 73A7           E8         8CF1            call	_write_dword
25118 73AA           83C4                   08  add	sp,*8
25119                                           !BCC_EOS
25120                                           ! 3781         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
25121                                           ! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
25122 73AD           FF76         FE            push	-2[bp]
25123 73B0           FF76         FC            push	-4[bp]
25124                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
25125 73B3           8B46         0C            mov	ax,$C[bp]
25126                                           ! Debug: list unsigned int = ax+$10 (used reg = )
25127 73B6           05                   0010  add	ax,*$10
25128 73B9           50                         push	ax
25129                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25130 73BA           FF76         06            push	6[bp]
25131                                           ! Debug: func () void = write_dword+0 (used reg = )
25132 73BD           E8         8CDB            call	_write_dword
25133 73C0           83C4                   08  add	sp,*8
25134                                           !BCC_EOS
25135                                           ! 3782         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
25136                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
25137 73C3           FF76         FA            push	-6[bp]
25138 73C6           FF76         F8            push	-8[bp]
25139                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
25140 73C9           8B46         0C            mov	ax,$C[bp]
25141                                           ! Debug: list unsigned int = ax+$14 (used reg = )
25142 73CC           05                   0014  add	ax,*$14
25143 73CF           50                         push	ax
25144                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25145 73D0           FF76         06            push	6[bp]
25146                                           ! Debug: func () void = write_dword+0 (used reg = )
25147 73D3           E8         8CC5            call	_write_dword
25148 73D6           83C4                   08  add	sp,*8
25149                                           !BCC_EOS
25150                                           ! 3783         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
25151                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
25152 73D9           FF76         D8            push	-$28[bp]
25153                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
25154 73DC           8B46         0C            mov	ax,$C[bp]
25155                                           ! Debug: list unsigned int = ax+$18 (used reg = )
25156 73DF           05                   0018  add	ax,*$18
25157 73E2           50                         push	ax
25158                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25159 73E3           FF76         06            push	6[bp]
25160                                           ! Debug: func () void = write_word+0 (used reg = )
25161 73E6           E8         9249            call	_write_word
25162 73E9           83C4                   06  add	sp,*6
25163                                           !BCC_EOS
25164                                           ! 3784         }
25165                                           ! 3785       if(size >= 0x1e) {
25166                       000073EC            .55A:
25167                                           ! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
25168 73EC           8B46         DE            mov	ax,-$22[bp]
25169 73EF           3D                   001E  cmp	ax,*$1E
25170 73F2         0F82         0273            blo 	.563
25171                       000073F6            .564:
25172                                           ! 3786         Bit8u channel, dev, irq, mode, checksum, i, translation;
25173                                           !BCC_EOS
25174                                           ! 3787         Bit16u iobase1, iobase2, options;
25175                                           !BCC_EOS
25176                                           ! 3788         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
25177                                           ! Debug: list int = const $1E (used reg = )
25178 73F6           B8                   001E  mov	ax,*$1E
25179 73F9           50                         push	ax
25180                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
25181 73FA           8B46         0C            mov	ax,$C[bp]
25182                                           ! Debug: list unsigned int = ax+0 (used reg = )
25183 73FD           50                         push	ax
25184                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25185 73FE           FF76         06            push	6[bp]
25186                                           ! Debug: func () void = write_word+0 (used reg = )
25187 7401           E8         922E            call	_write_word
25188 7404           83C4                   06  add	sp,*6
25189                                           !BCC_EOS
25190                                           ! 3789         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
25191                                           ! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
25192 7407           FF76         F6            push	-$A[bp]
25193                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
25194 740A           8B46         0C            mov	ax,$C[bp]
25195                                           ! Debug: list unsigned int = ax+$1C (used reg = )
25196 740D           05                   001C  add	ax,*$1C
25197 7410           50                         push	ax
25198                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25199 7411           FF76         06            push	6[bp]
25200                                           ! Debug: func () void = write_word+0 (used reg = )
25201 7414           E8         921B            call	_write_word
25202 7417           83C4                   06  add	sp,*6
25203                                           !BCC_EOS
25204                                           ! 3790         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
25205                                           ! Debug: list * struct  = const $244 (used reg = )
25206 741A           B8                   0244  mov	ax,#$244
25207 741D           50                         push	ax
25208                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
25209 741E           8B46         0C            mov	ax,$C[bp]
25210                                           ! Debug: list unsigned int = ax+$1A (used reg = )
25211 7421           05                   001A  add	ax,*$1A
25212 7424           50                         push	ax
25213                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
25214 7425           FF76         06            push	6[bp]
25215                                           ! Debug: func () void = write_word+0 (used reg = )
25216 7428           E8         9207            call	_write_word
25217 742B           83C4                   06  add	sp,*6
25218                                           !BCC_EOS
25219                                           ! 3791         channel = device / 2;
25220                                           ! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
25221 742E           8A46         DB            mov	al,-$25[bp]
25222 7431           30E4                       xor	ah,ah
25223 7433           D1E8                       shr	ax,*1
25224                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
25225 7435           8846         D9            mov	-$27[bp],al
25226                                           !BCC_EOS
25227                                           ! 3792         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25228                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25229 7438           8A46         D9            mov	al,-$27[bp]
25230 743B           30E4                       xor	ah,ah
25231 743D           B1                     03  mov	cl,*3
25232 743F           D3E0                       shl	ax,cl
25233 7441           89C3                       mov	bx,ax
25234                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25235                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25236 7443           81C3                 0124  add	bx,#$124
25237 7447           53                         push	bx
25238                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25239 7448           FF76         F6            push	-$A[bp]
25240                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25241 744B           E8         91B9            call	_read_word
25242 744E           83C4                   04  add	sp,*4
25243                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
25244 7451           8946         D0            mov	-$30[bp],ax
25245                                           !BCC_EOS
25246                                           ! 3793         iobase2 = read_word(ebda_seg, &((ebda
25247                                           ! 3793 _data_t *) 0)->ata.channels[channel].iobase2);
25248                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25249 7454           8A46         D9            mov	al,-$27[bp]
25250 7457           30E4                       xor	ah,ah
25251 7459           B1                     03  mov	cl,*3
25252 745B           D3E0                       shl	ax,cl
25253 745D           89C3                       mov	bx,ax
25254                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
25255                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
25256 745F           81C3                 0126  add	bx,#$126
25257 7463           53                         push	bx
25258                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25259 7464           FF76         F6            push	-$A[bp]
25260                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25261 7467           E8         919D            call	_read_word
25262 746A           83C4                   04  add	sp,*4
25263                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
25264 746D           8946         CE            mov	-$32[bp],ax
25265                                           !BCC_EOS
25266                                           ! 3794         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
25267                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
25268 7470           8A46         D9            mov	al,-$27[bp]
25269 7473           30E4                       xor	ah,ah
25270 7475           B1                     03  mov	cl,*3
25271 7477           D3E0                       shl	ax,cl
25272 7479           89C3                       mov	bx,ax
25273                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
25274                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
25275 747B           81C3                 0128  add	bx,#$128
25276 747F           53                         push	bx
25277                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25278 7480           FF76         F6            push	-$A[bp]
25279                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25280 7483           E8         916E            call	_read_byte
25281 7486           83C4                   04  add	sp,*4
25282                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
25283 7489           8846         D7            mov	-$29[bp],al
25284                                           !BCC_EOS
25285                                           ! 3795         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
25286                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
25287 748C           8A46         DB            mov	al,-$25[bp]
25288 748F           30E4                       xor	ah,ah
25289 7491           B9                   001E  mov	cx,*$1E
25290 7494           F7E9                       imul	cx
25291 7496           89C3                       mov	bx,ax
25292                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
25293                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
25294 7498           81C3                 0146  add	bx,#$146
25295 749C           53                         push	bx
25296                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25297 749D           FF76         F6            push	-$A[bp]
25298                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25299 74A0           E8         9151            call	_read_byte
25300 74A3           83C4                   04  add	sp,*4
25301                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
25302 74A6           8846         D6            mov	-$2A[bp],al
25303                                           !BCC_EOS
25304                                           ! 3796         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
25305                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
25306 74A9           8A46         DB            mov	al,-$25[bp]
25307 74AC           30E4                       xor	ah,ah
25308 74AE           B9                   001E  mov	cx,*$1E
25309 74B1           F7E9                       imul	cx
25310 74B3           89C3                       mov	bx,ax
25311                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
25312                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
25313 74B5           81C3                 014A  add	bx,#$14A
25314 74B9           53                         push	bx
25315                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25316 74BA           FF76         F6            push	-$A[bp]
25317                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25318 74BD           E8         9134            call	_read_byte
25319 74C0           83C4                   04  add	sp,*4
25320                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
25321 74C3           8846         D3            mov	-$2D[bp],al
25322                                           !BCC_EOS
25323                                           ! 3797         options = (translation==0?0:1)<<3;
25324                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
25325 74C6           8A46         D3            mov	al,-$2D[bp]
25326 74C9           84C0                       test	al,al
25327 74CB           75           04            jne 	.565
25328                       000074CD            .566:
25329 74CD           30C0                       xor	al,al
25330 74CF           EB           02            jmp .567
25331                       000074D1            .565:
25332 74D1           B0                     01  mov	al,*1
25333                       000074D3            .567:
25334                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
25335 74D3           30E4                       xor	ah,ah
25336 74D5           B1                     03  mov	cl,*3
25337 74D7           D3E0                       shl	ax,cl
25338                                           ! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25339 74D9           8946         CC            mov	-$34[bp],ax
25340                                           !BCC_EOS
25341                                           ! 3798         options |= (1<<4);
25342                                           ! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
25343 74DC           8B46         CC            mov	ax,-$34[bp]
25344 74DF           0C                     10  or	al,*$10
25345 74E1           8946         CC            mov	-$34[bp],ax
25346                                           !BCC_EOS
25347                                           ! 3799         options |= (mode==0x01?1:0)<<7;
25348                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
25349 74E4           8A46         D6            mov	al,-$2A[bp]
25350 74E7           3C                     01  cmp	al,*1
25351 74E9           75           04            jne 	.568
25352                       000074EB            .569:
25353 74EB           B0                     01  mov	al,*1
25354 74ED           EB           02            jmp .56A
25355                       000074EF            .568:
25356 74EF           30C0                       xor	al,al
25357                       000074F1            .56A:
25358                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
25359 74F1           30E4                       xor	ah,ah
25360 74F3           B1                     07  mov	cl,*7
25361 74F5           D3E0                       shl	ax,cl
25362                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25363 74F7           0B46         CC            or	ax,-$34[bp]
25364 74FA           8946         CC            mov	-$34[bp],ax
25365                                           !BCC_EOS
25366                                           ! 3800         options |= (translation==1?1:0)<<9;
25367                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
25368 74FD           8A46         D3            mov	al,-$2D[bp]
25369 7500           3C                     01  cmp	al,*1
25370 7502           75           04            jne 	.56B
25371                       00007504            .56C:
25372 7504           B0                     01  mov	al,*1
25373 7506           EB           02            jmp .56D
25374                       00007508            .56B:
25375 7508           30C0                       xor	al,al
25376                       0000750A            .56D:
25377                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
25378 750A           30E4                       xor	ah,ah
25379 750C           88C4                       mov	ah,al
25380 750E           30C0                       xor	al,al
25381 7510           D1E0                       shl	ax,*1
25382                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25383 7512           0B46         CC            or	ax,-$34[bp]
25384 7515           8946         CC            mov	-$34[bp],ax
25385                                           !BCC_EOS
25386                                           ! 3801         options |= (translation==3?3:0)<<9;
25387                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
25388 7518           8A46         D3            mov	al,-$2D[bp]
25389 751B           3C                     03  cmp	al,*3
25390 751D           75           04            jne 	.56E
25391                       0000751F            .56F:
25392 751F           B0                     03  mov	al,*3
25393 7521           EB           02            jmp .570
25394                       00007523            .56E:
25395 7523           30C0                       xor	al,al
25396                       00007525            .570:
25397                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
25398 7525           30E4                       xor	ah,ah
25399 7527           88C4                       mov	ah,al
25400 7529           30C0                       xor	al,al
25401 752B           D1E0                       shl	ax,*1
25402                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
25403 752D           0B46         CC            or	ax,-$34[bp]
25404 7530           8946         CC            mov	-$34[bp],ax
25405                                           !BCC_EOS
25406                                           ! 3802         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
25407                                           ! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
25408 7533           FF76         D0            push	-$30[bp]
25409                                           ! Debug: list * unsigned short = const $244 (used reg = )
25410 7536           B8                   0244  mov	ax,#$244
25411 7539           50                         push	ax
25412                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25413 753A           FF76         F6            push	-$A[bp]
25414                                           ! Debug: func () void = write_word+0 (used reg = )
25415 753D           E8         90F2            call	_write_word
25416 7540           83C4                   06  add	sp,*6
25417                                           !BCC_EOS
25418                                           ! 3803         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
25419                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
25420 7543           8B46         CE            mov	ax,-$32[bp]
25421                                           ! Debug: list unsigned int = ax+6 (used reg = )
25422 7546           05                   0006  add	ax,*6
25423 7549           50                         push	ax
25424                                           ! Debug: list * unsigned short = const $246 (used reg = )
25425 754A           B8                   0246  mov	ax,#$246
25426 754D           50                         push	ax
25427                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25428 754E           FF76         F6            push	-$A[bp]
25429                                           ! Debug: func () void = write_word+0 (used reg = )
25430 7551           E8         90DE            call	_write_word
25431 7554           83C4                   06  add	sp,*6
25432                                           !BCC_EOS
25433                                           ! 3804         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
25434                                           ! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
25435 7557           8A46         DB            mov	al,-$25[bp]
25436 755A           30E4                       xor	ah,ah
25437 755C           24                     01  and	al,*1
25438                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
25439                                           ! Debug: expression subtree swapping
25440 755E           0C                     0E  or	al,*$E
25441                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
25442 7560           30E4                       xor	ah,ah
25443 7562           B1                     04  mov	cl,*4
25444 7564           D3E0                       shl	ax,cl
25445                                           ! Debug: list unsigned int = ax+0 (used reg = )
25446 7566           50                         push	ax
25447                                           ! Debug: list * unsigned char = const $248 (used reg = )
25448 7567           B8                   0248  mov	ax,#$248
25449 756A           50                         push	ax
25450                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25451 756B           FF76         F6            push	-$A[bp]
25452                                           ! Debug: func () void = write_byte+0 (used reg = )
25453 756E           E8         90A9            call	_write_byte
25454 7571           83C4                   06  add	sp,*6
25455                                           !BCC_EOS
25456                                           ! 3805         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
25457                                           ! Debug: list int = const $CB (used reg = )
25458 7574           B8                   00CB  mov	ax,#$CB
25459 7577           50                         push	ax
25460                                           ! Debug: list * unsigned char = const $249 (used reg = )
25461 7578           B8                   0249  mov	ax,#$249
25462 757B           50                         push	ax
25463                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25464 757C           FF76         F6            push	-$A[bp]
25465                                           ! Debug: func () void = write_byte+0 (used reg = )
25466 757F           E8         9098            call	_write_byte
25467 7582           83C4                   06  add	sp,*6
25468                                           !BCC_EOS
25469                                           ! 3806         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
25470                                           ! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
25471 7585           8A46         D7            mov	al,-$29[bp]
25472 7588           30E4                       xor	ah,ah
25473 758A           50                         push	ax
25474                                           ! Debug: list * unsigned char = const $24A (used reg = )
25475 758B           B8                   024A  mov	ax,#$24A
25476 758E           50                         push	ax
25477                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25478 758F           FF76         F6            push	-$A[bp]
25479                                           ! Debug: func () void = write_byte+0 (used reg = )
25480 7592           E8         9085            call	_write_byte
25481 7595           83C4                   06  add	sp,*6
25482                                           !BCC_EOS
25483                                           ! 3807         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
25484                                           ! Debug: list int = const 1 (used reg = )
25485 7598           B8                   0001  mov	ax,*1
25486 759B           50                         push	ax
25487                                           ! Debug: list * unsigned char = const $24B (used reg = )
25488 759C           B8                   024B  mov	ax,#$24B
25489 759F           50                         push	ax
25490                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25491 75A0           FF76         F6            push	-$A[bp]
25492                                           ! Debug: func () void = write_byte+0 (used reg = )
25493 75A3           E8         9074            call	_write_byte
25494 75A6           83C4                   06  add	sp,*6
25495                                           !BCC_EOS
25496                                           ! 3808         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
25497                                           ! Debug: list int = const 0 (used reg = )
25498 75A9           31C0                       xor	ax,ax
25499 75AB           50                         push	ax
25500                                           ! Debug: list * unsigned char = const $24C (used reg = )
25501 75AC           B8                   024C  mov	ax,#$24C
25502 75AF           50                         push	ax
25503                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25504 75B0           FF76         F6            push	-$A[bp]
25505                                           ! Debug: func () void = write_byte+0 (used reg = )
25506 75B3           E8         9064            call	_write_byte
25507 75B6           83C4                   06  add	sp,*6
25508                                           !BCC_EOS
25509                                           ! 3809         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
25510                                           ! Debug: list int = const 0 (used reg = )
25511 75B9           31C0                       xor	ax,ax
25512 75BB           50                         push	ax
25513                                           ! Debug: list * unsigned char = const $24D (used reg = )
25514 75BC           B8                   024D  mov	ax,#$24D
25515 75BF           50                         push	ax
25516                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25517 75C0           FF76         F6            push	-$A[bp]
25518                                           ! Debug: func () void = write_byte+0 (used reg = )
25519 75C3           E8         9054            call	_write_byte
25520 75C6           83C4                   06  add	sp,*6
25521                                           !BCC_EOS
25522                                           ! 3810         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
25523                                           ! Debug: list unsigned short options = [S+$36-$36] (used reg = )
25524 75C9           FF76         CC            push	-$34[bp]
25525                                           ! Debug: list * unsigned short = const $24E (used reg = )
25526 75CC           B8                   024E  mov	ax,#$24E
25527 75CF           50                         push	ax
25528                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25529 75D0           FF76         F6            push	-$A[bp]
25530                                           ! Debug: func () void = write_word+0 (used reg = )
25531 75D3           E8         905C            call	_write_word
25532 75D6           83C4                   06  add	sp,*6
25533                                           !BCC_EOS
25534                                           ! 3811         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
25535                                           ! Debug: list int = const 0 (used reg = )
25536 75D9           31C0                       xor	ax,ax
25537 75DB           50                         push	ax
25538                                           ! Debug: list * unsigned short = const $250 (used reg = )
25539 75DC           B8                   0250  mov	ax,#$250
25540 75DF           50                         push	ax
25541                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25542 75E0           FF76         F6            push	-$A[bp]
25543                                           ! Debug: func () void = write_word+0 (used reg = )
25544 75E3           E8         904C            call	_write_word
25545 75E6           83C4                   06  add	sp,*6
25546                                           !BCC_EOS
25547                                           ! 3812         if (size >=0x42)
25548                                           ! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
25549 75E9           8B46         DE            mov	ax,-$22[bp]
25550 75EC           3D                   0042  cmp	ax,*$42
25551 75EF           72           13            jb  	.571
25552                       000075F1            .572:
25553                                           ! 3813           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
25554                                           ! Debug: list int = const $11 (used reg = )
25555 75F1           B8                   0011  mov	ax,*$11
25556 75F4           50                         push	ax
25557                                           ! Debug: list * unsigned char = const $252 (used reg = )
25558 75F5           B8                   0252  mov	ax,#$252
25559 75F8           50                         push	ax
25560                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25561 75F9           FF76         F6            push	-$A[bp]
25562                                           ! Debug: func () void = write_byte+0 (used reg = )
25563 75FC           E8         901B            call	_write_byte
25564 75FF           83C4                   06  add	sp,*6
25565                                           !BCC_EOS
25566                                           ! 3814         else
25567                                           ! 3815           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
25568 7602           EB           11            jmp .573
25569                       00007604            .571:
25570                                           ! Debug: list int = const $10 (used reg = )
25571 7604           B8                   0010  mov	ax,*$10
25572 7607           50                         push	ax
25573                                           ! Debug: list * unsigned char = const $252 (used reg = )
25574 7608           B8                   0252  mov	ax,#$252
25575 760B           50                         push	ax
25576                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25577 760C           FF76         F6            push	-$A[bp]
25578                                           ! Debug: func () void = write_byte+0 (used reg = )
25579 760F           E8         9008            call	_write_byte
25580 7612           83C4                   06  add	sp,*6
25581                                           !BCC_EOS
25582                                           ! 3816         checksum=0;
25583                       00007615            .573:
25584                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25585 7615           30C0                       xor	al,al
25586 7617           8846         D5            mov	-$2B[bp],al
25587                                           !BCC_EOS
25588                                           ! 3817         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
25589                                           ! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
25590 761A           30C0                       xor	al,al
25591 761C           8846         D4            mov	-$2C[bp],al
25592                                           !BCC_EOS
25593                                           !BCC_EOS
25594 761F           EB           24            jmp .576
25595                       00007621            .577:
25596                                           ! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
25597 7621           8A46         D4            mov	al,-$2C[bp]
25598 7624           30E4                       xor	ah,ah
25599                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
25600 7626           05                   0244  add	ax,#$244
25601 7629           50                         push	ax
25602                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25603 762A           FF76         F6            push	-$A[bp]
25604                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25605 762D           E8         8FC4            call	_read_byte
25606 7630           83C4                   04  add	sp,*4
25607                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25608 7633           30E4                       xor	ah,ah
25609 7635           0246         D5            add	al,-$2B[bp]
25610 7638           80D4                   00  adc	ah,*0
25611 763B           8846         D5            mov	-$2B[bp],al
25612                                           !BCC_EOS
25613                                           ! 3818         checksum = ~checksum;
25614                       0000763E            .575:
25615                                           ! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
25616 763E           8A46         D4            mov	al,-$2C[bp]
25617 7641           40                         inc	ax
25618 7642           8846         D4            mov	-$2C[bp],al
25619                       00007645            .576:
25620                                           ! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
25621 7645           8A46         D4            mov	al,-$2C[bp]
25622 7648           3C                     0F  cmp	al,*$F
25623 764A           72           D5            jb 	.577
25624                       0000764C            .578:
25625                       0000764C            .574:
25626                                           ! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
25627 764C           8A46         D5            mov	al,-$2B[bp]
25628 764F           30E4                       xor	ah,ah
25629 7651           F7D0                       not	ax
25630                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25631 7653           8846         D5            mov	-$2B[bp],al
25632                                           !BCC_EOS
25633                                           ! 3819         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
25634                                           ! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
25635 7656           8A46         D5            mov	al,-$2B[bp]
25636 7659           30E4                       xor	ah,ah
25637 765B           50                         push	ax
25638                                           ! Debug: list * unsigned char = const $253 (used reg = )
25639 765C           B8                   0253  mov	ax,#$253
25640 765F           50                         push	ax
25641                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25642 7660           FF76         F6            push	-$A[bp]
25643                                           ! Debug: func () void = write_byte+0 (used reg = )
25644 7663           E8         8FB4            call	_write_byte
25645 7666           83C4                   06  add	sp,*6
25646                                           !BCC_EOS
25647                                           ! 3820         }
25648                                           ! 3821       if(size >= 0x42) {
25649                       00007669            .563:
25650                                           ! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
25651 7669           8B46         DE            mov	ax,-$22[bp]
25652 766C           3D                   0042  cmp	ax,*$42
25653 766F         0F82         023B            blo 	.579
25654                       00007673            .57A:
25655                                           ! 3822         Bit8u channel, iface, checksum, i;
25656                                           !BCC_EOS
25657                                           ! 3823         Bit16u iobase1;
25658                                           !BCC_EOS
25659                                           ! 3824         channel = device / 2;
25660                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25661 7673           8A46         DB            mov	al,-$25[bp]
25662 7676           30E4                       xor	ah,ah
25663 7678           D1E8                       shr	ax,*1
25664                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
25665 767A           8846         D9            mov	-$27[bp],al
25666                                           !BCC_EOS
25667                                           ! 3825         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
25668                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25669 767D           8A46         D9            mov	al,-$27[bp]
25670 7680           30E4                       xor	ah,ah
25671 7682           B1                     03  mov	cl,*3
25672 7684           D3E0                       shl	ax,cl
25673 7686           89C3                       mov	bx,ax
25674                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
25675                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
25676 7688           81C3                 0122  add	bx,#$122
25677 768C           53                         push	bx
25678                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25679 768D           FF76         F6            push	-$A[bp]
25680                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25681 7690           E8         8F61            call	_read_byte
25682 7693           83C4                   04  add	sp,*4
25683                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25684 7696           8846         D8            mov	-$28[bp],al
25685                                           !BCC_EOS
25686                                           ! 3826         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25687                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25688 7699           8A46         D9            mov	al,-$27[bp]
25689 769C           30E4                       xor	ah,ah
25690 769E           B1                     03  mov	cl,*3
25691 76A0           D3E0                       shl	ax,cl
25692 76A2           89C3                       mov	bx,ax
25693                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25694                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25695 76A4           81C3                 0124  add	bx,#$124
25696 76A8           53                         push	bx
25697                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25698 76A9           FF76         F6            push	-$A[bp]
25699                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25700 76AC           E8         8F58            call	_read_word
25701 76AF           83C4                   04  add	sp,*4
25702                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25703 76B2           8946         D4            mov	-$2C[bp],ax
25704                                           !BCC_EOS
25705                                           ! 3827         write_wor
25706                                           ! 3827 d(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
25707                                           ! Debug: list int = const $42 (used reg = )
25708 76B5           B8                   0042  mov	ax,*$42
25709 76B8           50                         push	ax
25710                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
25711 76B9           8B46         0C            mov	ax,$C[bp]
25712                                           ! Debug: list unsigned int = ax+0 (used reg = )
25713 76BC           50                         push	ax
25714                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25715 76BD           FF76         06            push	6[bp]
25716                                           ! Debug: func () void = write_word+0 (used reg = )
25717 76C0           E8         8F6F            call	_write_word
25718 76C3           83C4                   06  add	sp,*6
25719                                           !BCC_EOS
25720                                           ! 3828         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
25721                                           ! Debug: list unsigned int = const $BEDD (used reg = )
25722 76C6           B8                   BEDD  mov	ax,#$BEDD
25723 76C9           50                         push	ax
25724                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
25725 76CA           8B46         0C            mov	ax,$C[bp]
25726                                           ! Debug: list unsigned int = ax+$1E (used reg = )
25727 76CD           05                   001E  add	ax,*$1E
25728 76D0           50                         push	ax
25729                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25730 76D1           FF76         06            push	6[bp]
25731                                           ! Debug: func () void = write_word+0 (used reg = )
25732 76D4           E8         8F5B            call	_write_word
25733 76D7           83C4                   06  add	sp,*6
25734                                           !BCC_EOS
25735                                           ! 3829         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
25736                                           ! Debug: list int = const $24 (used reg = )
25737 76DA           B8                   0024  mov	ax,*$24
25738 76DD           50                         push	ax
25739                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
25740 76DE           8B46         0C            mov	ax,$C[bp]
25741                                           ! Debug: list unsigned int = ax+$20 (used reg = )
25742 76E1           05                   0020  add	ax,*$20
25743 76E4           50                         push	ax
25744                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25745 76E5           FF76         06            push	6[bp]
25746                                           ! Debug: func () void = write_byte+0 (used reg = )
25747 76E8           E8         8F2F            call	_write_byte
25748 76EB           83C4                   06  add	sp,*6
25749                                           !BCC_EOS
25750                                           ! 3830         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
25751                                           ! Debug: list int = const 0 (used reg = )
25752 76EE           31C0                       xor	ax,ax
25753 76F0           50                         push	ax
25754                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
25755 76F1           8B46         0C            mov	ax,$C[bp]
25756                                           ! Debug: list unsigned int = ax+$21 (used reg = )
25757 76F4           05                   0021  add	ax,*$21
25758 76F7           50                         push	ax
25759                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25760 76F8           FF76         06            push	6[bp]
25761                                           ! Debug: func () void = write_byte+0 (used reg = )
25762 76FB           E8         8F1C            call	_write_byte
25763 76FE           83C4                   06  add	sp,*6
25764                                           !BCC_EOS
25765                                           ! 3831         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
25766                                           ! Debug: list int = const 0 (used reg = )
25767 7701           31C0                       xor	ax,ax
25768 7703           50                         push	ax
25769                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
25770 7704           8B46         0C            mov	ax,$C[bp]
25771                                           ! Debug: list unsigned int = ax+$22 (used reg = )
25772 7707           05                   0022  add	ax,*$22
25773 770A           50                         push	ax
25774                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25775 770B           FF76         06            push	6[bp]
25776                                           ! Debug: func () void = write_word+0 (used reg = )
25777 770E           E8         8F21            call	_write_word
25778 7711           83C4                   06  add	sp,*6
25779                                           !BCC_EOS
25780                                           ! 3832         if (iface==0x00) {
25781                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25782 7714           8A46         D8            mov	al,-$28[bp]
25783 7717           84C0                       test	al,al
25784 7719           75           51            jne 	.57B
25785                       0000771B            .57C:
25786                                           ! 3833           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
25787                                           ! Debug: list int = const $49 (used reg = )
25788 771B           B8                   0049  mov	ax,*$49
25789 771E           50                         push	ax
25790                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
25791 771F           8B46         0C            mov	ax,$C[bp]
25792                                           ! Debug: list unsigned int = ax+$24 (used reg = )
25793 7722           05                   0024  add	ax,*$24
25794 7725           50                         push	ax
25795                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25796 7726           FF76         06            push	6[bp]
25797                                           ! Debug: func () void = write_byte+0 (used reg = )
25798 7729           E8         8EEE            call	_write_byte
25799 772C           83C4                   06  add	sp,*6
25800                                           !BCC_EOS
25801                                           ! 3834           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
25802                                           ! Debug: list int = const $53 (used reg = )
25803 772F           B8                   0053  mov	ax,*$53
25804 7732           50                         push	ax
25805                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
25806 7733           8B46         0C            mov	ax,$C[bp]
25807                                           ! Debug: list unsigned int = ax+$25 (used reg = )
25808 7736           05                   0025  add	ax,*$25
25809 7739           50                         push	ax
25810                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25811 773A           FF76         06            push	6[bp]
25812                                           ! Debug: func () void = write_byte+0 (used reg = )
25813 773D           E8         8EDA            call	_write_byte
25814 7740           83C4                   06  add	sp,*6
25815                                           !BCC_EOS
25816                                           ! 3835           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
25817                                           ! Debug: list int = const $41 (used reg = )
25818 7743           B8                   0041  mov	ax,*$41
25819 7746           50                         push	ax
25820                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
25821 7747           8B46         0C            mov	ax,$C[bp]
25822                                           ! Debug: list unsigned int = ax+$26 (used reg = )
25823 774A           05                   0026  add	ax,*$26
25824 774D           50                         push	ax
25825                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25826 774E           FF76         06            push	6[bp]
25827                                           ! Debug: func () void = write_byte+0 (used reg = )
25828 7751           E8         8EC6            call	_write_byte
25829 7754           83C4                   06  add	sp,*6
25830                                           !BCC_EOS
25831                                           ! 3836           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
25832                                           ! Debug: list int = const 0 (used reg = )
25833 7757           31C0                       xor	ax,ax
25834 7759           50                         push	ax
25835                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
25836 775A           8B46         0C            mov	ax,$C[bp]
25837                                           ! Debug: list unsigned int = ax+$27 (used reg = )
25838 775D           05                   0027  add	ax,*$27
25839 7760           50                         push	ax
25840                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25841 7761           FF76         06            push	6[bp]
25842                                           ! Debug: func () void = write_byte+0 (used reg = )
25843 7764           E8         8EB3            call	_write_byte
25844 7767           83C4                   06  add	sp,*6
25845                                           !BCC_EOS
25846                                           ! 3837           }
25847                                           ! 3838         else {
25848 776A           EB           00            jmp .57D
25849                       0000776C            .57B:
25850                                           ! 3839           }
25851                                           ! 3840         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
25852                       0000776C            .57D:
25853                                           ! Debug: list int = const $41 (used reg = )
25854 776C           B8                   0041  mov	ax,*$41
25855 776F           50                         push	ax
25856                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
25857 7770           8B46         0C            mov	ax,$C[bp]
25858                                           ! Debug: list unsigned int = ax+$28 (used reg = )
25859 7773           05                   0028  add	ax,*$28
25860 7776           50                         push	ax
25861                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25862 7777           FF76         06            push	6[bp]
25863                                           ! Debug: func () void = write_byte+0 (used reg = )
25864 777A           E8         8E9D            call	_write_byte
25865 777D           83C4                   06  add	sp,*6
25866                                           !BCC_EOS
25867                                           ! 3841         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
25868                                           ! Debug: list int = const $54 (used reg = )
25869 7780           B8                   0054  mov	ax,*$54
25870 7783           50                         push	ax
25871                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
25872 7784           8B46         0C            mov	ax,$C[bp]
25873                                           ! Debug: list unsigned int = ax+$29 (used reg = )
25874 7787           05                   0029  add	ax,*$29
25875 778A           50                         push	ax
25876                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25877 778B           FF76         06            push	6[bp]
25878                                           ! Debug: func () void = write_byte+0 (used reg = )
25879 778E           E8         8E89            call	_write_byte
25880 7791           83C4                   06  add	sp,*6
25881                                           !BCC_EOS
25882                                           ! 3842         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
25883                                           ! Debug: list int = const $41 (used reg = )
25884 7794           B8                   0041  mov	ax,*$41
25885 7797           50                         push	ax
25886                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
25887 7798           8B46         0C            mov	ax,$C[bp]
25888                                           ! Debug: list unsigned int = ax+$2A (used reg = )
25889 779B           05                   002A  add	ax,*$2A
25890 779E           50                         push	ax
25891                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25892 779F           FF76         06            push	6[bp]
25893                                           ! Debug: func () void = write_byte+0 (used reg = )
25894 77A2           E8         8E75            call	_write_byte
25895 77A5           83C4                   06  add	sp,*6
25896                                           !BCC_EOS
25897                                           ! 3843         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
25898                                           ! Debug: list int = const 0 (used reg = )
25899 77A8           31C0                       xor	ax,ax
25900 77AA           50                         push	ax
25901                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
25902 77AB           8B46         0C            mov	ax,$C[bp]
25903                                           ! Debug: list unsigned int = ax+$2B (used reg = )
25904 77AE           05                   002B  add	ax,*$2B
25905 77B1           50                         push	ax
25906                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25907 77B2           FF76         06            push	6[bp]
25908                                           ! Debug: func () void = write_byte+0 (used reg = )
25909 77B5           E8         8E62            call	_write_byte
25910 77B8           83C4                   06  add	sp,*6
25911                                           !BCC_EOS
25912                                           ! 3844         if (iface==0x00) {
25913                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25914 77BB           8A46         D8            mov	al,-$28[bp]
25915 77BE           84C0                       test	al,al
25916 77C0           75           3E            jne 	.57E
25917                       000077C2            .57F:
25918                                           ! 3845           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
25919                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25920 77C2           FF76         D4            push	-$2C[bp]
25921                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
25922 77C5           8B46         0C            mov	ax,$C[bp]
25923                                           ! Debug: list unsigned int = ax+$30 (used reg = )
25924 77C8           05                   0030  add	ax,*$30
25925 77CB           50                         push	ax
25926                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25927 77CC           FF76         06            push	6[bp]
25928                                           ! Debug: func () void = write_word+0 (used reg = )
25929 77CF           E8         8E60            call	_write_word
25930 77D2           83C4                   06  add	sp,*6
25931                                           !BCC_EOS
25932                                           ! 3846           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
25933                                           ! Debug: list int = const 0 (used reg = )
25934 77D5           31C0                       xor	ax,ax
25935 77D7           50                         push	ax
25936                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
25937 77D8           8B46         0C            mov	ax,$C[bp]
25938                                           ! Debug: list unsigned int = ax+$32 (used reg = )
25939 77DB           05                   0032  add	ax,*$32
25940 77DE           50                         push	ax
25941                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25942 77DF           FF76         06            push	6[bp]
25943                                           ! Debug: func () void = write_word+0 (used reg = )
25944 77E2           E8         8E4D            call	_write_word
25945 77E5           83C4                   06  add	sp,*6
25946                                           !BCC_EOS
25947                                           ! 3847           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
25948                                           ! Debug: list long = const 0 (used reg = )
25949 77E8           31C0                       xor	ax,ax
25950 77EA           31DB                       xor	bx,bx
25951 77EC           53                         push	bx
25952 77ED           50                         push	ax
25953                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
25954 77EE           8B46         0C            mov	ax,$C[bp]
25955                                           ! Debug: list unsigned int = ax+$34 (used reg = )
25956 77F1           05                   0034  add	ax,*$34
25957 77F4           50                         push	ax
25958                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
25959 77F5           FF76         06            push	6[bp]
25960                                           ! Debug: func () void = write_dword+0 (used reg = )
25961 77F8           E8         88A0            call	_write_dword
25962 77FB           83C4                   08  add	sp,*8
25963                                           !BCC_EOS
25964                                           ! 3848           }
25965                                           ! 3849         else {
25966 77FE           EB           00            jmp .580
25967                       00007800            .57E:
25968                                           ! 3850           }
25969                                           ! 3851         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
25970                       00007800            .580:
25971                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25972 7800           8A46         DB            mov	al,-$25[bp]
25973 7803           30E4                       xor	ah,ah
25974 7805           24                     01  and	al,*1
25975                                           ! Debug: list unsigned char = al+0 (used reg = )
25976 7807           30E4                       xor	ah,ah
25977 7809           50                         push	ax
25978                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
25979 780A           8B46         0C            mov	ax,$C[bp]
25980                                           ! Debug: list unsigned int = ax+$38 (used reg = )
25981 780D           05                   0038  add	ax,*$38
25982 7810           50                         push	ax
25983                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25984 7811           FF76         06            push	6[bp]
25985                                           ! Debug: func () void = write_byte+0 (used reg = )
25986 7814           E8         8E03            call	_write_byte
25987 7817           83C4                   06  add	sp,*6
25988                                           !BCC_EOS
25989                                           ! 3852         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
25990                                           ! Debug: list int = const 0 (used reg = )
25991 781A           31C0                       xor	ax,ax
25992 781C           50                         push	ax
25993                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
25994 781D           8B46         0C            mov	ax,$C[bp]
25995                                           ! Debug: list unsigned int = ax+$39 (used reg = )
25996 7820           05                   0039  add	ax,*$39
25997 7823           50                         push	ax
25998                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25999 7824           FF76         06            push	6[bp]
26000                                           ! Debug: func () void = write_byte+0 (used reg = )
26001 7827           E8         8DF0            call	_write_byte
26002 782A           83C4                   06  add	sp,*6
26003                                           !BCC_EOS
26004                                           ! 3853         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
26005                                           ! Debug: list int = const 0 (used reg = )
26006 782D           31C0                       xor	ax,ax
26007 782F           50                         push	ax
26008                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
26009 7830           8B46         0C            mov	ax,$C[bp]
26010                                           ! Debug: list unsigned int = ax+$3A (used reg = )
26011 7833           05                   003A  add	ax,*$3A
26012 7836           50                         push	ax
26013                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26014 7837           FF76         06            push	6[bp]
26015                                           ! Debug: func () void = write_word+0 (used reg = )
26016 783A           E8         8DF5            call	_write_word
26017 783D           83C4                   06  add	sp,*6
26018                                           !BCC_EOS
26019                                           ! 3854         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
26020                                           ! Debug: list long = const 0 (used reg = )
26021 7840           31C0                       xor	ax,ax
26022 7842           31DB                       xor	bx,bx
26023 7844           53                         push	bx
26024 7845           50                         push	ax
26025                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
26026 7846           8B46         0C            mov	ax,$C[bp]
26027                                           ! Debug: list unsigned int = ax+$3C (used reg = )
26028 7849           05                   003C  add	ax,*$3C
26029 784C           50                         push	ax
26030                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
26031 784D           FF76         06            push	6[bp]
26032                                           ! Debug: func () void = write_dword+0 (used reg = )
26033 7850           E8         8848            call	_write_dword
26034 7853           83C4                   08  add	sp,*8
26035                                           !BCC_EOS
26036                                           ! 3855         checksum=0;
26037                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26038 7856           30C0                       xor	al,al
26039 7858           8846         D7            mov	-$29[bp],al
26040                                           !BCC_EOS
26041                                           ! 3856         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
26042                                           ! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
26043 785B           B0                     1E  mov	al,*$1E
26044 785D           8846         D6            mov	-$2A[bp],al
26045                                           !BCC_EOS
26046                                           !BCC_EOS
26047 7860           EB           25            jmp .583
26048                       00007862            .584:
26049                                           ! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
26050 7862           8B46         0C            mov	ax,$C[bp]
26051 7865           0246         D6            add	al,-$2A[bp]
26052 7868           80D4                   00  adc	ah,*0
26053                                           ! Debug: list unsigned int = ax+0 (used reg = )
26054 786B           50                         push	ax
26055                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26056 786C           FF76         06            push	6[bp]
26057                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26058 786F           E8         8D82            call	_read_byte
26059 7872           83C4                   04  add	sp,*4
26060                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26061 7875           30E4                       xor	ah,ah
26062 7877           0246         D7            add	al,-$29[bp]
26063 787A           80D4                   00  adc	ah,*0
26064 787D           8846         D7            mov	-$29[bp],al
26065                                           !BCC_EOS
26066                                           ! 3857         checksum = ~checksum;
26067                       00007880            .582:
26068                                           ! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
26069 7880           8A46         D6            mov	al,-$2A[bp]
26070 7883           40                         inc	ax
26071 7884           8846         D6            mov	-$2A[bp],al
26072                       00007887            .583:
26073                                           ! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
26074 7887           8A46         D6            mov	al,-$2A[bp]
26075 788A           3C                     40  cmp	al,*$40
26076 788C           72           D4            jb 	.584
26077                       0000788E            .585:
26078                       0000788E            .581:
26079                                           ! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
26080 788E           8A46         D7            mov	al,-$29[bp]
26081 7891           30E4                       xor	ah,ah
26082 7893           F7D0                       not	ax
26083                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
26084 7895           8846         D7            mov	-$29[bp],al
26085                                           !BCC_EOS
26086                                           ! 3858         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
26087                                           ! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
26088 7898           8A46         D7            mov	al,-$29[bp]
26089 789B           30E4                       xor	ah,ah
26090 789D           50                         push	ax
26091                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
26092 789E           8B46         0C            mov	ax,$C[bp]
26093                                           ! Debug: list unsigned int = ax+$41 (used reg = )
26094 78A1           05                   0041  add	ax,*$41
26095 78A4           50                         push	ax
26096                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
26097 78A5           FF76         06            push	6[bp]
26098                                           ! Debug: func () void = write_byte+0 (used reg = )
26099 78A8           E8         8D6F            call	_write_byte
26100 78AB           83C4                   06  add	sp,*6
26101                                           !BCC_EOS
26102                                           ! 3859         }
26103                                           ! 3860       goto int13_success;
26104                       000078AE            .579:
26105 78AE           83C4                   0E  add	sp,#..FFEF-..FFF0
26106 78B1           E9         011B            br 	.FFEF
26107                                           !BCC_EOS
26108                                           ! 3861       break;
26109 78B4           E9         00E8            br 	.517
26110                                           !BCC_EOS
26111                                           ! 3862     case 0x4e:
26112                                           ! 3863       switch (( AX & 0x00ff )) {
26113                       000078B7            .586:
26114                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26115 78B7           8A46         18            mov	al,$18[bp]
26116 78BA           EB           10            jmp .589
26117                                           ! 3864         case 0x01:
26118                                           ! 3865         case 0x03:
26119                       000078BC            .58A:
26120                                           ! 3866         case 0x04:
26121                       000078BC            .58B:
26122                                           ! 3867         case 0x06:
26123                       000078BC            .58C:
26124                                           ! 3868           goto int13_success;
26125                       000078BC            .58D:
26126 78BC           83C4                   0E  add	sp,#..FFEF-..FFF0
26127 78BF           E9         010D            br 	.FFEF
26128                                           !BCC_EOS
26129                                           ! 3869           break;
26130 78C2           EB           1A            jmp .587
26131                                           !BCC_EOS
26132                                           ! 3870         default :
26133                                           ! 3871           goto int13_fail;
26134                       000078C4            .58E:
26135 78C4           83C4                   0E  add	sp,#..FFF1-..FFF0
26136 78C7           E9         00D8            br 	.FFF1
26137                                           !BCC_EOS
26138                                           ! 3872         }
26139                                           ! 3873       break;
26140 78CA           EB           12            jmp .587
26141                       000078CC            .589:
26142 78CC           2C                     01  sub	al,*1
26143 78CE           74           EC            je 	.58A
26144 78D0           2C                     02  sub	al,*2
26145 78D2           74           E8            je 	.58B
26146 78D4           2C                     01  sub	al,*1
26147 78D6           74           E4            je 	.58C
26148 78D8           2C                     02  sub	al,*2
26149 78DA           74           E0            je 	.58D
26150 78DC           EB           E6            jmp	.58E
26151                       000078DE            .587:
26152 78DE           E9         00BE            br 	.517
26153                                           !BCC_EOS
26154                                           ! 3874     case 0x09:
26155                                           ! 3875     case 0x0c:
26156                       000078E1            .58F:
26157                                           ! 3876     case 0x0d:
26158                       000078E1            .590:
26159                                           ! 3877     case 0x11:
26160                       000078E1            .591:
26161                                           ! 3878  
26162                                           ! 3878    case 0x14:
26163                       000078E1            .592:
26164                                           ! 3879       bios_printf(4, "int13_harddisk: function %02xh unimplemented, returns success\n", ( AX >> 8 ));
26165                       000078E1            .593:
26166                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26167 78E1           8B46         18            mov	ax,$18[bp]
26168 78E4           88E0                       mov	al,ah
26169 78E6           30E4                       xor	ah,ah
26170                                           ! Debug: list unsigned int = ax+0 (used reg = )
26171 78E8           50                         push	ax
26172                                           ! Debug: list * char = .594+0 (used reg = )
26173 78E9           BB                   D486  mov	bx,#.594
26174 78EC           53                         push	bx
26175                                           ! Debug: list int = const 4 (used reg = )
26176 78ED           B8                   0004  mov	ax,*4
26177 78F0           50                         push	ax
26178                                           ! Debug: func () void = bios_printf+0 (used reg = )
26179 78F1           E8         9125            call	_bios_printf
26180 78F4           83C4                   06  add	sp,*6
26181                                           !BCC_EOS
26182                                           ! 3880       goto int13_success;
26183 78F7           83C4                   0E  add	sp,#..FFEF-..FFF0
26184 78FA           E9         00D2            br 	.FFEF
26185                                           !BCC_EOS
26186                                           ! 3881       break;
26187 78FD           E9         009F            br 	.517
26188                                           !BCC_EOS
26189                                           ! 3882     case 0x0a:
26190                                           ! 3883     case 0x0b:
26191                       00007900            .595:
26192                                           ! 3884     case 0x18:
26193                       00007900            .596:
26194                                           ! 3885     case 0x50:
26195                       00007900            .597:
26196                                           ! 3886     default:
26197                       00007900            .598:
26198                                           ! 3887       bios_printf(4, "int13_harddisk: function %02xh unsupported, returns fail\n", ( AX >> 8 ));
26199                       00007900            .599:
26200                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26201 7900           8B46         18            mov	ax,$18[bp]
26202 7903           88E0                       mov	al,ah
26203 7905           30E4                       xor	ah,ah
26204                                           ! Debug: list unsigned int = ax+0 (used reg = )
26205 7907           50                         push	ax
26206                                           ! Debug: list * char = .59A+0 (used reg = )
26207 7908           BB                   D44C  mov	bx,#.59A
26208 790B           53                         push	bx
26209                                           ! Debug: list int = const 4 (used reg = )
26210 790C           B8                   0004  mov	ax,*4
26211 790F           50                         push	ax
26212                                           ! Debug: func () void = bios_printf+0 (used reg = )
26213 7910           E8         9106            call	_bios_printf
26214 7913           83C4                   06  add	sp,*6
26215                                           !BCC_EOS
26216                                           ! 3888       goto int13_fail;
26217 7916           83C4                   0E  add	sp,#..FFF1-..FFF0
26218 7919           E9         0086            br 	.FFF1
26219                                           !BCC_EOS
26220                                           ! 3889       break;
26221 791C           E9         0080            br 	.517
26222                                           !BCC_EOS
26223                                           ! 3890     }
26224                                           ! 3891 int13_fail:
26225 791F           EB           7E            jmp .517
26226                       00007921            .519:
26227 7921           83C4                   F2  add	sp,*-$E
26228 7924           2D                   0000  sub	ax,*0
26229 7927           7C           D7            jl 	.599
26230 7929           3D                   0018  cmp	ax,*$18
26231 792C           77           3B            ja  	.59B
26232 792E           D1E0                       shl	ax,*1
26233 7930           89C3                       mov	bx,ax
26234 7932           2E                         seg	cs
26235 7933           FFA7       7937            br	.59C[bx]
26236                       00007937            .59C:
26237 7937                      6AB0            .word	.51A
26238 7939                      6AC4            .word	.51B
26239 793B                      6B15            .word	.51F
26240 793D                      6B15            .word	.520
26241 793F                      6B15            .word	.521
26242 7941                      6DB5            .word	.537
26243 7943                      7900            .word	.599
26244 7945                      7900            .word	.599
26245 7947                      6DD0            .word	.539
26246 7949                      78E1            .word	.58F
26247 794B                      7900            .word	.595
26248 794D                      7900            .word	.596
26249 794F                      78E1            .word	.590
26250 7951                      78E1            .word	.591
26251 7953                      7900            .word	.599
26252 7955                      7900            .word	.599
26253 7957                      6EAE            .word	.53A
26254 7959                      78E1            .word	.592
26255 795B                      7900            .word	.599
26256 795D                      7900            .word	.599
26257 795F                      78E1            .word	.593
26258 7961                      6EFA            .word	.53E
26259 7963                      7900            .word	.599
26260 7965                      7900            .word	.599
26261 7967                      7900            .word	.597
26262                       00007969            .59B:
26263 7969           2D                   0041  sub	ax,*$41
26264 796C           72           92            jb 	.599
26265 796E           3D                   000F  cmp	ax,*$F
26266 7971           77           29            ja  	.59D
26267 7973           D1E0                       shl	ax,*1
26268 7975           89C3                       mov	bx,ax
26269 7977           2E                         seg	cs
26270 7978           FFA7       797C            br	.59E[bx]
26271                       0000797C            .59E:
26272 797C                      6FAB            .word	.53F
26273 797E                      6FCB            .word	.540
26274 7980                      6FCB            .word	.541
26275 7982                      6FCB            .word	.542
26276 7984                      71C4            .word	.554
26277 7986                      71CD            .word	.556
26278 7988                      6FCB            .word	.543
26279 798A                      71E1            .word	.557
26280 798C                      71C4            .word	.555
26281 798E                      7900            .word	.599
26282 7990                      7900            .word	.599
26283 7992                      7900            .word	.599
26284 7994                      7900            .word	.599
26285 7996                      78B7            .word	.586
26286 7998                      7900            .word	.599
26287 799A                      7900            .word	.598
26288                       0000799C            .59D:
26289 799C           E9         FF61            br 	.599
26290                       0000799F            .517:
26291                       FFFFFFCA            ..FFF0	=	-$36
26292 799F           83C4                   0E  add	sp,*$E
26293                       000079A2            .FFF1:
26294                       FFFFFFD8            ..FFF1	=	-$28
26295                                           ! 3892     AX = ((AX & 0x00ff) | ((0x01) << 8));
26296                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26297 79A2           8A46         18            mov	al,$18[bp]
26298                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
26299 79A5           30E4                       xor	ah,ah
26300 79A7           0D                   0100  or	ax,#$100
26301                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
26302 79AA           8946         18            mov	$18[bp],ax
26303                                           !BCC_EOS
26304                                           ! 3893 int13_fail_noah:
26305                       000079AD            .FFEC:
26306                       FFFFFFD8            ..FFEC	=	-$28
26307                                           ! 3894     write_byte(0x0040, 0x0074, ( AX >> 8 ));
26308                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
26309 79AD           8B46         18            mov	ax,$18[bp]
26310 79B0           88E0                       mov	al,ah
26311 79B2           30E4                       xor	ah,ah
26312                                           ! Debug: list unsigned int = ax+0 (used reg = )
26313 79B4           50                         push	ax
26314                                           ! Debug: list int = const $74 (used reg = )
26315 79B5           B8                   0074  mov	ax,*$74
26316 79B8           50                         push	ax
26317                                           ! Debug: list int = const $40 (used reg = )
26318 79B9           B8                   0040  mov	ax,*$40
26319 79BC           50                         push	ax
26320                                           ! Debug: func () void = write_byte+0 (used reg = )
26321 79BD           E8         8C5A            call	_write_byte
26322 79C0           83C4                   06  add	sp,*6
26323                                           !BCC_EOS
26324                                           ! 3895 int13_fail_nostatus:
26325                       000079C3            .FFEE:
26326                       FFFFFFD8            ..FFEE	=	-$28
26327                                           ! 3896     FLAGS |= 0x0001;
26328                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
26329 79C3           8B46         1E            mov	ax,$1E[bp]
26330 79C6           0C                     01  or	al,*1
26331 79C8           8946         1E            mov	$1E[bp],ax
26332                                           !BCC_EOS
26333                                           ! 3897     return;
26334 79CB           89EC                       mov	sp,bp
26335 79CD           5D                         pop	bp
26336 79CE           C3                         ret
26337                                           !BCC_EOS
26338                                           ! 3898 int13_success:
26339                       000079CF            .FFEF:
26340                       FFFFFFD8            ..FFEF	=	-$28
26341                                           ! 3899     AX = ((AX & 0x00ff) | ((0x00) << 8));
26342                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
26343 79CF           8A46         18            mov	al,$18[bp]
26344                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
26345 79D2           0C                     00  or	al,*0
26346                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
26347 79D4           30E4                       xor	ah,ah
26348 79D6           8946         18            mov	$18[bp],ax
26349                                           !BCC_EOS
26350                                           ! 3900 int13_success_noah:
26351                       000079D9            .FFED:
26352                       FFFFFFD8            ..FFED	=	-$28
26353                                           ! 3901     write_byte(0x0040, 0x0074, 0x00);
26354                                           ! Debug: list int = const 0 (used reg = )
26355 79D9           31C0                       xor	ax,ax
26356 79DB           50                         push	ax
26357                                           ! Debug: list int = const $74 (used reg = )
26358 79DC           B8                   0074  mov	ax,*$74
26359 79DF           50                         push	ax
26360                                           ! Debug: list int = const $40 (used reg = )
26361 79E0           B8                   0040  mov	ax,*$40
26362 79E3           50                         push	ax
26363                                           ! Debug: func () void = write_byte+0 (used reg = )
26364 79E4           E8         8C33            call	_write_byte
26365 79E7           83C4                   06  add	sp,*6
26366                                           !BCC_EOS
26367                                           ! 3902     FLAGS &= 0xfffe;
26368                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
26369 79EA           8B46         1E            mov	ax,$1E[bp]
26370 79ED           24                     FE  and	al,#$FE
26371 79EF           8946         1E            mov	$1E[bp],ax
26372                                           !BCC_EOS
26373                                           ! 3903     return;
26374 79F2           89EC                       mov	sp,bp
26375 79F4           5D                         pop	bp
26376 79F5           C3                         ret
26377                                           !BCC_EOS
26378                                           ! 3904 }
26379                                           ! 3905   void
26380                                           ! Register BX used in function int13_harddisk
26381                                           ! 3906 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
26382                                           ! 3907   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
26383                                           export	_int13_cdrom
26384                       000079F6            _int13_cdrom:
26385                                           !BCC_EOS
26386                                           ! 3908 {
26387                                           ! 3909   Bit16u ebda_seg=read_word(0x0040,0x000E);
26388 79F6           55                         push	bp
26389 79F7           89E5                       mov	bp,sp
26390 79F9           4C                         dec	sp
26391 79FA           4C                         dec	sp
26392                                           ! Debug: list int = const $E (used reg = )
26393 79FB           B8                   000E  mov	ax,*$E
26394 79FE           50                         push	ax
26395                                           ! Debug: list int = const $40 (used reg = )
26396 79FF           B8                   0040  mov	ax,*$40
26397 7A02           50                         push	ax
26398                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26399 7A03           E8         8C01            call	_read_word
26400 7A06           83C4                   04  add	sp,*4
26401                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
26402 7A09           8946         FE            mov	-2[bp],ax
26403                                           !BCC_EOS
26404                                           ! 3910   Bit8u device, status, locks;
26405                                           !BCC_EOS
26406                                           ! 3911   Bit8u atacmd[12];
26407                                           !BCC_EOS
26408                                           ! 3912   Bit32u lba;
26409                                           !BCC_EOS
26410                                           ! 3913   Bit16u count, segment, offset, i, size;
26411                                           !BCC_EOS
26412                                           ! 3914   ;
26413 7A0C           83C4                   E2  add	sp,*-$1E
26414                                           !BCC_EOS
26415                                           ! 3915   write_byte(0x0040, 0x0074, 0x00);
26416                                           ! Debug: list int = const 0 (used reg = )
26417 7A0F           31C0                       xor	ax,ax
26418 7A11           50                         push	ax
26419                                           ! Debug: list int = const $74 (used reg = )
26420 7A12           B8                   0074  mov	ax,*$74
26421 7A15           50                         push	ax
26422                                           ! Debug: list int = const $40 (used reg = )
26423 7A16           B8                   0040  mov	ax,*$40
26424 7A19           50                         push	ax
26425                                           ! Debug: func () void = write_byte+0 (used reg = )
26426 7A1A           E8         8BFD            call	_write_byte
26427 7A1D           83C4                   06  add	sp,*6
26428                                           !BCC_EOS
26429                                           ! 3916   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
26430                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26431 7A20           8A46         10            mov	al,$10[bp]
26432                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
26433 7A23           3C                     E0  cmp	al,#$E0
26434 7A25           72           07            jb  	.5A0
26435                       00007A27            .5A1:
26436                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26437 7A27           8A46         10            mov	al,$10[bp]
26438                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
26439 7A2A           3C                     E8  cmp	al,#$E8
26440 7A2C           72           22            jb  	.59F
26441                       00007A2E            .5A0:
26442                                           ! 3917     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
26443                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26444 7A2E           8A46         10            mov	al,$10[bp]
26445                                           ! Debug: list unsigned char = al+0 (used reg = )
26446 7A31           30E4                       xor	ah,ah
26447 7A33           50                         push	ax
26448                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
26449 7A34           8B46         18            mov	ax,$18[bp]
26450 7A37           88E0                       mov	al,ah
26451 7A39           30E4                       xor	ah,ah
26452                                           ! Debug: list unsigned int = ax+0 (used reg = )
26453 7A3B           50                         push	ax
26454                                           ! Debug: list * char = .5A2+0 (used reg = )
26455 7A3C           BB                   D418  mov	bx,#.5A2
26456 7A3F           53                         push	bx
26457                                           ! Debug: list int = const 4 (used reg = )
26458 7A40           B8                   0004  mov	ax,*4
26459 7A43           50                         push	ax
26460                                           ! Debug: func () void = bios_printf+0 (used reg = )
26461 7A44           E8         8FD2            call	_bios_printf
26462 7A47           83C4                   08  add	sp,*8
26463                                           !BCC_EOS
26464                                           ! 3918     goto int13_fail;
26465 7A4A           83C4                   00  add	sp,#..FFEB+$22
26466 7A4D           E9         0A81            br 	.FFEB
26467                                           !BCC_EOS
26468                                           ! 3919     }
26469                                           ! 3920   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
26470                       00007A50            .59F:
26471                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26472 7A50           8A46         10            mov	al,$10[bp]
26473                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
26474 7A53           30E4                       xor	ah,ah
26475                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
26476 7A55           05                   FF20  add	ax,#-$E0
26477 7A58           89C3                       mov	bx,ax
26478                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
26479                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
26480 7A5A           81C3                 023C  add	bx,#$23C
26481 7A5E           53                         push	bx
26482                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26483 7A5F           FF76         FE            push	-2[bp]
26484                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26485 7A62           E8         8B8F            call	_read_byte
26486 7A65           83C4                   04  add	sp,*4
26487                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
26488 7A68           8846         FD            mov	-3[bp],al
26489                                           !BCC_EOS
26490                                           ! 3921   if (device >= (4*2)) {
26491                                           ! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
26492 7A6B           8A46         FD            mov	al,-3[bp]
26493 7A6E           3C                     08  cmp	al,*8
26494 7A70           72           22            jb  	.5A3
26495                       00007A72            .5A4:
26496                                           ! 3922     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
26497                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
26498 7A72           8A46         10            mov	al,$10[bp]
26499                                           ! Debug: list unsigned char = al+0 (used reg = )
26500 7A75           30E4                       xor	ah,ah
26501 7A77           50                         push	ax
26502                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
26503 7A78           8B46         18            mov	ax,$18[bp]
26504 7A7B           88E0                       mov	al,ah
26505 7A7D           30E4                       xor	ah,ah
26506                                           ! Debug: list unsigned int = ax+0 (used reg = )
26507 7A7F           50                         push	ax
26508                                           ! Debug: list * char = .5A5+0 (used reg = )
26509 7A80           BB                   D3DD  mov	bx,#.5A5
26510 7A83           53                         push	bx
26511                                           ! Debug: list int = const 4 (used reg = )
26512 7A84           B8                   0004  mov	ax,*4
26513 7A87           50                         push	ax
26514                                           ! Debug: func () void = bios_printf+0 (used reg = )
26515 7A88           E8         8F8E            call	_bios_printf
26516 7A8B           83C4                   08  add	sp,*8
26517                                           !BCC_EOS
26518                                           ! 3923     goto int13_fail;
26519 7A8E           83C4                   00  add	sp,#..FFEB+$22
26520 7A91           E9         0A3D            br 	.FFEB
26521                                           !BCC_EOS
26522                                           ! 3924     }
26523                                           ! 3925   switch (( AX >> 8 )) {
26524                       00007A94            .5A3:
26525                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26526 7A94           8B46         18            mov	ax,$18[bp]
26527 7A97           88E0                       mov	al,ah
26528 7A99           30E4                       xor	ah,ah
26529 7A9B           E9         09B2            br 	.5A8
26530                                           ! 3926     case 0x00:
26531                                           ! 3927     case 0x09:
26532                       00007A9E            .5A9:
26533                                           ! 3928     case 0x0c:
26534                       00007A9E            .5AA:
26535                                           ! 3929     case 0x0d:
26536                       00007A9E            .5AB:
26537                                           ! 3930     case 0x10:
26538                       00007A9E            .5AC:
26539                                           ! 3931     case 0x11:
26540                       00007A9E            .5AD:
26541                                           ! 3932     case 0x14:
26542                       00007A9E            .5AE:
26543                                           ! 3933     case 0x16:
26544                       00007A9E            .5AF:
26545                                           ! 3934       goto int13_success;
26546                       00007A9E            .5B0:
26547 7A9E           83C4                   0C  add	sp,#..FFE9-..FFEA
26548 7AA1           E9         0A5A            br 	.FFE9
26549                                           !BCC_EOS
26550                                           ! 3935       break;
26551 7AA4           E9         0A27            br 	.5A6
26552                                           !BCC_EOS
26553                                           ! 3936     case 0x03:
26554                                           ! 3937     case 0x05:
26555                       00007AA7            .5B1:
26556                                           ! 3938     case 0x43:
26557                       00007AA7            .5B2:
26558                                           ! 3939       AX = ((AX & 0x00ff) | ((0x03) << 8));
26559                       00007AA7            .5B3:
26560                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26561 7AA7           8A46         18            mov	al,$18[bp]
26562                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
26563 7AAA           30E4                       xor	ah,ah
26564 7AAC           0D                   0300  or	ax,#$300
26565                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26566 7AAF           8946         18            mov	$18[bp],ax
26567                                           !BCC_EOS
26568                                           ! 3940       goto int13_fail_noah;
26569 7AB2           83C4                   0C  add	sp,#..FFE8-..FFEA
26570 7AB5           E9         0A24            br 	.FFE8
26571                                           !BCC_EOS
26572                                           ! 3941       break;
26573 7AB8           E9         0A13            br 	.5A6
26574                                           !BCC_EOS
26575                                           ! 3942     case 0x01:
26576                                           ! 3943       status = read_byte(0x0040, 0x0074);
26577                       00007ABB            .5B4:
26578                                           ! Debug: list int = const $74 (used reg = )
26579 7ABB           B8                   0074  mov	ax,*$74
26580 7ABE           50                         push	ax
26581                                           ! Debug: list int = const $40 (used reg = )
26582 7ABF           B8                   0040  mov	ax,*$40
26583 7AC2           50                         push	ax
26584                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26585 7AC3           E8         8B2E            call	_read_byte
26586 7AC6           83C4                   04  add	sp,*4
26587                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
26588 7AC9           8846         FC            mov	-4[bp],al
26589                                           !BCC_EOS
26590                                           ! 3944       AX = ((AX & 0x00ff) | ((status) << 8));
26591                                           ! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
26592 7ACC           8A46         FC            mov	al,-4[bp]
26593 7ACF           30E4                       xor	ah,ah
26594 7AD1           88C4                       mov	ah,al
26595 7AD3           30C0                       xor	al,al
26596 7AD5           50                         push	ax
26597                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
26598 7AD6           8A46         18            mov	al,$18[bp]
26599                                           ! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
26600 7AD9           30E4                       xor	ah,ah
26601 7ADB           0B46         D2            or	ax,0+..FFEA[bp]
26602 7ADE           44                         inc	sp
26603 7ADF           44                         inc	sp
26604                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26605 7AE0           8946         18            mov	$18[bp],ax
26606                                           !BCC_EOS
26607                                           ! 3945       write_byte(0x0040, 0x0074, 0);
26608                                           ! Debug: list int = const 0 (used reg = )
26609 7AE3           31C0                       xor	ax,ax
26610 7AE5           50                         push	ax
26611                                           ! Debug: list int = const $74 (used reg = )
26612 7AE6           B8                   0074  mov	ax,*$74
26613 7AE9           50                         push	ax
26614                                           ! Debug: list int = const $40 (used reg = )
26615 7AEA           B8                   0040  mov	ax,*$40
26616 7AED           50                         push	ax
26617                                           ! Debug: func () void = write_byte+0 (used reg = )
26618 7AEE           E8         8B29            call	_write_byte
26619 7AF1           83C4                   06  add	sp,*6
26620                                           !BCC_EOS
26621                                           ! 3946       if (status) goto int13_fail_nostatus;
26622 7AF4           8A46         FC            mov	al,-4[bp]
26623 7AF7           84C0                       test	al,al
26624 7AF9           74           08            je  	.5B5
26625                       00007AFB            .5B6:
26626 7AFB           83C4                   0C  add	sp,#..FFE7-..FFEA
26627 7AFE           E9         09F1            br 	.FFE7
26628                                           !BCC_EOS
26629                                           ! 3947       else goto int13_success_noah;
26630 7B01           EB           06            jmp .5B7
26631                       00007B03            .5B5:
26632 7B03           83C4                   0C  add	sp,#..FFE6-..FFEA
26633 7B06           E9         09FF            br 	.FFE6
26634                                           !BCC_EOS
26635                                           ! 3948       break;
26636                       00007B09            .5B7:
26637 7B09           E9         09C2            br 	.5A6
26638                                           !BCC_EOS
26639                                           ! 3949    
26640                                           ! 3949  case 0x15:
26641                                           ! 3950       AX = ((AX & 0x00ff) | ((0x02) << 8));
26642                       00007B0C            .5B8:
26643                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26644 7B0C           8A46         18            mov	al,$18[bp]
26645                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
26646 7B0F           30E4                       xor	ah,ah
26647 7B11           0D                   0200  or	ax,#$200
26648                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26649 7B14           8946         18            mov	$18[bp],ax
26650                                           !BCC_EOS
26651                                           ! 3951       goto int13_fail_noah;
26652 7B17           83C4                   0C  add	sp,#..FFE8-..FFEA
26653 7B1A           E9         09BF            br 	.FFE8
26654                                           !BCC_EOS
26655                                           ! 3952       break;
26656 7B1D           E9         09AE            br 	.5A6
26657                                           !BCC_EOS
26658                                           ! 3953     case 0x41:
26659                                           ! 3954       BX=0xaa55;
26660                       00007B20            .5B9:
26661                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
26662 7B20           B8                   AA55  mov	ax,#$AA55
26663 7B23           8946         12            mov	$12[bp],ax
26664                                           !BCC_EOS
26665                                           ! 3955       AX = ((AX & 0x00ff) | ((0x30) << 8));
26666                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26667 7B26           8A46         18            mov	al,$18[bp]
26668                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
26669 7B29           30E4                       xor	ah,ah
26670 7B2B           0D                   3000  or	ax,#$3000
26671                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26672 7B2E           8946         18            mov	$18[bp],ax
26673                                           !BCC_EOS
26674                                           ! 3956       CX=0x0007;
26675                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
26676 7B31           B8                   0007  mov	ax,*7
26677 7B34           8946         16            mov	$16[bp],ax
26678                                           !BCC_EOS
26679                                           ! 3957       goto int13_success_noah;
26680 7B37           83C4                   0C  add	sp,#..FFE6-..FFEA
26681 7B3A           E9         09CB            br 	.FFE6
26682                                           !BCC_EOS
26683                                           ! 3958       break;
26684 7B3D           E9         098E            br 	.5A6
26685                                           !BCC_EOS
26686                                           ! 3959     case 0x42:
26687                                           ! 3960     case 0x44:
26688                       00007B40            .5BA:
26689                                           ! 3961     case 0x47:
26690                       00007B40            .5BB:
26691                                           ! 3962       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
26692                       00007B40            .5BC:
26693                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
26694 7B40           8B46         0C            mov	ax,$C[bp]
26695                                           ! Debug: list unsigned int = ax+2 (used reg = )
26696 7B43           40                         inc	ax
26697 7B44           40                         inc	ax
26698 7B45           50                         push	ax
26699                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26700 7B46           FF76         06            push	6[bp]
26701                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26702 7B49           E8         8ABB            call	_read_word
26703 7B4C           83C4                   04  add	sp,*4
26704                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26705 7B4F           8946         E8            mov	-$18[bp],ax
26706                                           !BCC_EOS
26707                                           ! 3963       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
26708                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
26709 7B52           8B46         0C            mov	ax,$C[bp]
26710                                           ! Debug: list unsigned int = ax+6 (used reg = )
26711 7B55           05                   0006  add	ax,*6
26712 7B58           50                         push	ax
26713                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26714 7B59           FF76         06            push	6[bp]
26715                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26716 7B5C           E8         8AA8            call	_read_word
26717 7B5F           83C4                   04  add	sp,*4
26718                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
26719 7B62           8946         E6            mov	-$1A[bp],ax
26720                                           !BCC_EOS
26721                                           ! 3964       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
26722                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
26723 7B65           8B46         0C            mov	ax,$C[bp]
26724                                           ! Debug: list unsigned int = ax+4 (used reg = )
26725 7B68           05                   0004  add	ax,*4
26726 7B6B           50                         push	ax
26727                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26728 7B6C           FF76         06            push	6[bp]
26729                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26730 7B6F           E8         8A95            call	_read_word
26731 7B72           83C4                   04  add	sp,*4
26732                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
26733 7B75           8946         E4            mov	-$1C[bp],ax
26734                                           !BCC_EOS
26735                                           ! 3965       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
26736                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
26737 7B78           8B46         0C            mov	ax,$C[bp]
26738                                           ! Debug: list unsigned int = ax+$C (used reg = )
26739 7B7B           05                   000C  add	ax,*$C
26740 7B7E           50                         push	ax
26741                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26742 7B7F           FF76         06            push	6[bp]
26743                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26744 7B82           E8         84FE            call	_read_dword
26745 7B85           89D3                       mov	bx,dx
26746 7B87           83C4                   04  add	sp,*4
26747                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26748 7B8A           8946         EA            mov	-$16[bp],ax
26749 7B8D           895E         EC            mov	-$14[bp],bx
26750                                           !BCC_EOS
26751                                           ! 3966       if (lba != 0L) {
26752                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
26753                                           ! Debug: expression subtree swapping
26754 7B90           31C0                       xor	ax,ax
26755 7B92           31DB                       xor	bx,bx
26756 7B94           53                         push	bx
26757 7B95           50                         push	ax
26758 7B96           8B46         EA            mov	ax,-$16[bp]
26759 7B99           8B5E         EC            mov	bx,-$14[bp]
26760 7B9C           8D7E         D0            lea	di,-2+..FFEA[bp]
26761 7B9F           E8         8529            call	lcmpul
26762 7BA2           8D66         D4            lea	sp,2+..FFEA[bp]
26763 7BA5           74           1C            je  	.5BD
26764                       00007BA7            .5BE:
26765                                           ! 3967         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
26766                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26767 7BA7           8B46         18            mov	ax,$18[bp]
26768 7BAA           88E0                       mov	al,ah
26769 7BAC           30E4                       xor	ah,ah
26770                                           ! Debug: list unsigned int = ax+0 (used reg = )
26771 7BAE           50                         push	ax
26772                                           ! Debug: list * char = .5BF+0 (used reg = )
26773 7BAF           BB                   D3AB  mov	bx,#.5BF
26774 7BB2           53                         push	bx
26775                                           ! Debug: list int = const 7 (used reg = )
26776 7BB3           B8                   0007  mov	ax,*7
26777 7BB6           50                         push	ax
26778                                           ! Debug: func () void = bios_printf+0 (used reg = )
26779 7BB7           E8         8E5F            call	_bios_printf
26780 7BBA           83C4                   06  add	sp,*6
26781                                           !BCC_EOS
26782                                           ! 3968         goto int13_fail;
26783 7BBD           83C4                   0C  add	sp,#..FFEB-..FFEA
26784 7BC0           E9         090E            br 	.FFEB
26785                                           !BCC_EOS
26786                                           ! 3969         }
26787                                           ! 3970       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
26788                       00007BC3            .5BD:
26789                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
26790 7BC3           8B46         0C            mov	ax,$C[bp]
26791                                           ! Debug: list unsigned int = ax+8 (used reg = )
26792 7BC6           05                   0008  add	ax,*8
26793 7BC9           50                         push	ax
26794                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26795 7BCA           FF76         06            push	6[bp]
26796                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26797 7BCD           E8         84B3            call	_read_dword
26798 7BD0           89D3                       mov	bx,dx
26799 7BD2           83C4                   04  add	sp,*4
26800                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26801 7BD5           8946         EA            mov	-$16[bp],ax
26802 7BD8           895E         EC            mov	-$14[bp],bx
26803                                           !BCC_EOS
26804                                           ! 3971       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
26805                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26806 7BDB           8B46         18            mov	ax,$18[bp]
26807 7BDE           88E0                       mov	al,ah
26808 7BE0           30E4                       xor	ah,ah
26809                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
26810 7BE2           3D                   0044  cmp	ax,*$44
26811 7BE5           74           0C            je  	.5C1
26812                       00007BE7            .5C2:
26813                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26814 7BE7           8B46         18            mov	ax,$18[bp]
26815 7BEA           88E0                       mov	al,ah
26816 7BEC           30E4                       xor	ah,ah
26817                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
26818 7BEE           3D                   0047  cmp	ax,*$47
26819 7BF1           75           06            jne 	.5C0
26820                       00007BF3            .5C1:
26821                                           ! 3972         goto int13_success;
26822 7BF3           83C4                   0C  add	sp,#..FFE9-..FFEA
26823 7BF6           E9         0905            br 	.FFE9
26824                                           !BCC_EOS
26825                                           ! 3973       memsetb(get_SS(),atacmd,0,12);
26826                       00007BF9            .5C0:
26827                                           ! Debug: list int = const $C (used reg = )
26828 7BF9           B8                   000C  mov	ax,*$C
26829 7BFC           50                         push	ax
26830                                           ! Debug: list int = const 0 (used reg = )
26831 7BFD           31C0                       xor	ax,ax
26832 7BFF           50                         push	ax
26833                                           ! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
26834 7C00           8D5E         EF            lea	bx,-$11[bp]
26835 7C03           53                         push	bx
26836                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26837 7C04           E8         8A46            call	_get_SS
26838                                           ! Debug: list unsigned short = ax+0 (used reg = )
26839 7C07           50                         push	ax
26840                                           ! Debug: func () void = memsetb+0 (used reg = )
26841 7C08           E8         83F5            call	_memsetb
26842 7C0B           83C4                   08  add	sp,*8
26843                                           !BCC_EOS
26844                                           ! 3974       atacmd[0]=0x28;
26845                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
26846 7C0E           B0                     28  mov	al,*$28
26847 7C10           8846         EF            mov	-$11[bp],al
26848                                           !BCC_EOS
26849                                           ! 3975       atacmd[7]=(count & 0xff00) >> 8;
26850                                           ! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
26851 7C13           8B46         E8            mov	ax,-$18[bp]
26852 7C16           30C0                       xor	al,al
26853                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
26854 7C18           88E0                       mov	al,ah
26855 7C1A           30E4                       xor	ah,ah
26856                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
26857 7C1C           8846         F6            mov	-$A[bp],al
26858                                           !BCC_EOS
26859                                           ! 3976       atacmd[8]=(count & 0x00ff);
26860                                           ! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
26861 7C1F           8A46         E8            mov	al,-$18[bp]
26862                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
26863 7C22           8846         F7            mov	-9[bp],al
26864                                           !BCC_EOS
26865                                           ! 3977       atacmd[2]=(lba & 0xff000000) >> 24;
26866                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
26867                                           ! Debug: expression subtree swapping
26868 7C25           31C0                       xor	ax,ax
26869 7C27           BB                   FF00  mov	bx,#$FF00
26870 7C2A           8D7E         EA            lea	di,-$16[bp]
26871 7C2D           E8         848B            call	landul
26872                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
26873 7C30           93                         xchg	bx,ax
26874 7C31           88E0                       mov	al,ah
26875 7C33           30E4                       xor	ah,ah
26876 7C35           31DB                       xor	bx,bx
26877                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
26878 7C37           8846         F1            mov	-$F[bp],al
26879                                           !BCC_EOS
26880                                           ! 3978       atacmd[3]=(lba & 0x00ff0000) >> 16;
26881                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
26882                                           ! Debug: expression subtree swapping
26883 7C3A           31C0                       xor	ax,ax
26884 7C3C           BB                   00FF  mov	bx,#$FF
26885 7C3F           8D7E         EA            lea	di,-$16[bp]
26886 7C42           E8         8476            call	landul
26887                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
26888 7C45           93                         xchg	bx,ax
26889 7C46           31DB                       xor	bx,bx
26890                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
26891 7C48           8846         F2            mov	-$E[bp],al
26892                                           !BCC_EOS
26893                                           ! 3979       atacmd[4]=(lba & 0x0000ff00) >> 8;
26894                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
26895                                           ! Debug: expression subtree swapping
26896 7C4B           B8                   FF00  mov	ax,#$FF00
26897 7C4E           31DB                       xor	bx,bx
26898 7C50           8D7E         EA            lea	di,-$16[bp]
26899 7C53           E8         8465            call	landul
26900                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
26901 7C56           88E0                       mov	al,ah
26902 7C58           88DC                       mov	ah,bl
26903 7C5A           88FB                       mov	bl,bh
26904 7C5C           28FF                       sub	bh,bh
26905                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
26906 7C5E           8846         F3            mov	-$D[bp],al
26907                                           !BCC_EOS
26908                                           ! 3980       atacmd[5]=(lba & 0x000000ff);
26909                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
26910                                           ! Debug: expression subtree swapping
26911 7C61           B8                   00FF  mov	ax,#$FF
26912 7C64           31DB                       xor	bx,bx
26913 7C66           8D7E         EA            lea	di,-$16[bp]
26914 7C69           E8         844F            call	landul
26915                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
26916 7C6C           8846         F4            mov	-$C[bp],al
26917                                           !BCC_EOS
26918                                           ! 3981       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
26919                                           ! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
26920 7C6F           FF76         E4            push	-$1C[bp]
26921                                           ! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
26922 7C72           FF76         E6            push	-$1A[bp]
26923                                           ! Debug: list int = const 1 (used reg = )
26924 7C75           B8                   0001  mov	ax,*1
26925 7C78           50                         push	ax
26926                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
26927 7C79           8B46         E8            mov	ax,-$18[bp]
26928 7C7C           31DB                       xor	bx,bx
26929                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
26930 7C7E           53                         push	bx
26931 7C7F           50                         push	ax
26932 7C80           B8                   0800  mov	ax,#$800
26933 7C83           31DB                       xor	bx,bx
26934 7C85           53                         push	bx
26935 7C86           50                         push	ax
26936 7C87           8B46         CA            mov	ax,-8+..FFEA[bp]
26937 7C8A           8B5E         CC            mov	bx,-6+..FFEA[bp]
26938 7C8D           8D7E         C6            lea	di,-$C+..FFEA[bp]
26939 7C90           E8         8456            call	lmulul
26940 7C93           83C4                   08  add	sp,*8
26941                                           ! Debug: list unsigned long = bx+0 (used reg = )
26942 7C96           53                         push	bx
26943 7C97           50                         push	ax
26944                                           ! Debug: list int = const 0 (used reg = )
26945 7C98           31C0                       xor	ax,ax
26946 7C9A           50                         push	ax
26947                                           ! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
26948 7C9B           8D5E         EF            lea	bx,-$11[bp]
26949 7C9E           53                         push	bx
26950                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26951 7C9F           E8         89AB            call	_get_SS
26952                                           ! Debug: list unsigned short = ax+0 (used reg = )
26953 7CA2           50                         push	ax
26954                                           ! Debug: list int = const $C (used reg = )
26955 7CA3           B8                   000C  mov	ax,*$C
26956 7CA6           50                         push	ax
26957                                           ! Debug: list unsigned char device = [S+$34-5] (used reg = )
26958 7CA7           8A46         FD            mov	al,-3[bp]
26959 7CAA           30E4                       xor	ah,ah
26960 7CAC           50                         push	ax
26961                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
26962 7CAD           E8         BA29            call	_ata_cmd_packet
26963 7CB0           83C4                   14  add	sp,*$14
26964                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
26965 7CB3           8846         FC            mov	-4[bp],al
26966                                           !BCC_EOS
26967                                           ! 3982       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
26968                                           ! Debug: list * unsigned long = const $256 (used reg = )
26969 7CB6           B8                   0256  mov	ax,#$256
26970 7CB9           50                         push	ax
26971                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26972 7CBA           FF76         FE            push	-2[bp]
26973                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26974 7CBD           E8         83C3            call	_read_dword
26975 7CC0           89D3                       mov	bx,dx
26976 7CC2           83C4                   04  add	sp,*4
26977                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
26978 7CC5           88E0                       mov	al,ah
26979 7CC7           88DC                       mov	ah,bl
26980 7CC9           88FB                       mov	bl,bh
26981 7CCB           28FF                       sub	bh,bh
26982 7CCD           BF                   0003  mov	di,*3
26983 7CD0           E8         8456            call	lsrul
26984                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
26985                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26986 7CD3           8946         E8            mov	-$18[bp],ax
26987                                           !BCC_EOS
26988                                           ! 3983       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
26989                                           ! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
26990 7CD6           FF76         E8            push	-$18[bp]
26991                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
26992 7CD9           8B46         0C            mov	ax,$C[bp]
26993                                           ! Debug: list unsigned int = ax+2 (used reg = )
26994 7CDC           40                         inc	ax
26995 7CDD           40                         inc	ax
26996 7CDE           50                         push	ax
26997                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
26998 7CDF           FF76         06            push	6[bp]
26999                                           ! Debug: func () void = write_word+0 (used reg = )
27000 7CE2           E8         894D            call	_write_word
27001 7CE5           83C4                   06  add	sp,*6
27002                                           !BCC_EOS
27003                                           ! 3984       if (status != 0) {
27004                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
27005 7CE8           8A46         FC            mov	al,-4[bp]
27006 7CEB           84C0                       test	al,al
27007 7CED           74           2D            je  	.5C3
27008                       00007CEF            .5C4:
27009                                           ! 3985         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",( AX >> 8 ),status);
27010                                           ! Debug: list unsigned char status = [S+$22-6] (used reg = )
27011 7CEF           8A46         FC            mov	al,-4[bp]
27012 7CF2           30E4                       xor	ah,ah
27013 7CF4           50                         push	ax
27014                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
27015 7CF5           8B46         18            mov	ax,$18[bp]
27016 7CF8           88E0                       mov	al,ah
27017 7CFA           30E4                       xor	ah,ah
27018                                           ! Debug: list unsigned int = ax+0 (used reg = )
27019 7CFC           50                         push	ax
27020                                           ! Debug: list * char = .5C5+0 (used reg = )
27021 7CFD           BB                   D380  mov	bx,#.5C5
27022 7D00           53                         push	bx
27023                                           ! Debug: list int = const 4 (used reg = )
27024 7D01           B8                   0004  mov	ax,*4
27025 7D04           50                         push	ax
27026                                           ! Debug: func () void = bios_printf+0 (used reg = )
27027 7D05           E8         8D11            call	_bios_printf
27028 7D08           83C4                   08  add	sp,*8
27029                                           !BCC_EOS
27030                                           ! 3986         AX = ((AX & 0x00ff) | ((0x0c) << 8));
27031                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27032 7D0B           8A46         18            mov	al,$18[bp]
27033                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
27034 7D0E           30E4                       xor	ah,ah
27035 7D10           0D                   0C00  or	ax,#$C00
27036                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27037 7D13           8946         18            mov	$18[bp],ax
27038                                           !BCC_EOS
27039                                           ! 3987         goto int13_fail_noah;
27040 7D16           83C4                   0C  add	sp,#..FFE8-..FFEA
27041 7D19           E9         07C0            br 	.FFE8
27042                                           !BCC_EOS
27043                                           ! 3988         }
27044                                           ! 3989       goto int13_success;
27045                       00007D1C            .5C3:
27046 7D1C           83C4                   0C  add	sp,#..FFE9-..FFEA
27047 7D1F           E9         07DC            br 	.FFE9
27048                                           !BCC_EOS
27049                                           ! 3990       break;
27050 7D22           E9         07A9            br 	.5A6
27051                                           !BCC_EOS
27052                                           ! 3991     case 0x45:
27053                                           ! 3992       if (( AX & 0x00ff ) > 2) goto int13_fail;
27054                       00007D25            .5C6:
27055                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27056 7D25           8A46         18            mov	al,$18[bp]
27057                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
27058 7D28           3C                     02  cmp	al,*2
27059 7D2A           76           06            jbe 	.5C7
27060                       00007D2C            .5C8:
27061 7D2C           83C4                   0C  add	sp,#..FFEB-..FFEA
27062 7D2F           E9         079F            br 	.FFEB
27063                                           !BCC_EOS
27064                                           ! 3993       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
27065                       00007D32            .5C7:
27066                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
27067 7D32           8A46         FD            mov	al,-3[bp]
27068 7D35           30E4                       xor	ah,ah
27069 7D37           B9                   001E  mov	cx,*$1E
27070 7D3A           F7E9                       imul	cx
27071 7D3C           89C3                       mov	bx,ax
27072                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27073                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27074 7D3E           81C3                 0145  add	bx,#$145
27075 7D42           53                         push	bx
27076                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27077 7D43           FF76         FE            push	-2[bp]
27078                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27079 7D46           E8         88AB            call	_read_byte
27080 7D49           83C4                   04  add	sp,*4
27081                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
27082 7D4C           8846         FB            mov	-5[bp],al
27083                                           !BCC_EOS
27084                                           ! 3994       switch (( AX & 0x00ff )) {
27085                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27086 7D4F           8A46         18            mov	al,$18[bp]
27087 7D52           E9         00D5            br 	.5CB
27088                                           ! 3995         case 0 :
27089                                           ! 3996           if (locks == 0xff) {
27090                       00007D55            .5CC:
27091                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
27092 7D55           8A46         FB            mov	al,-5[bp]
27093 7D58           3C                     FF  cmp	al,#$FF
27094 7D5A           75           1B            jne 	.5CD
27095                       00007D5C            .5CE:
27096                                           ! 3997             AX = ((AX & 0x00ff) | ((0xb4) << 8));
27097                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27098 7D5C           8A46         18            mov	al,$18[bp]
27099                                           ! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
27100 7D5F           30E4                       xor	ah,ah
27101 7D61           0D                   B400  or	ax,#-$4C00
27102                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27103 7D64           8946         18            mov	$18[bp],ax
27104                                           !BCC_EOS
27105                                           ! 3998             AX = ((AX & 0xff00) | (1));
27106                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27107 7D67           8B46         18            mov	ax,$18[bp]
27108 7D6A           30C0                       xor	al,al
27109                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
27110 7D6C           0C                     01  or	al,*1
27111                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27112 7D6E           8946         18            mov	$18[bp],ax
27113                                           !BCC_EOS
27114                                           ! 3999             goto int13_fail_noah;
27115 7D71           83C4                   0C  add	sp,#..FFE8-..FFEA
27116 7D74           E9         0765            br 	.FFE8
27117                                           !BCC_EOS
27118                                           ! 4000             }
27119                                           ! 4001           write_byte(ebda_seg, &((e
27120                       00007D77            .5CD:
27121                                           ! 4001 bda_data_t *) 0)->ata.devices[device].lock, ++locks);
27122                                           ! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
27123 7D77           8A46         FB            mov	al,-5[bp]
27124 7D7A           40                         inc	ax
27125 7D7B           8846         FB            mov	-5[bp],al
27126                                           ! Debug: list unsigned char = al+0 (used reg = )
27127 7D7E           30E4                       xor	ah,ah
27128 7D80           50                         push	ax
27129                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
27130 7D81           8A46         FD            mov	al,-3[bp]
27131 7D84           30E4                       xor	ah,ah
27132 7D86           B9                   001E  mov	cx,*$1E
27133 7D89           F7E9                       imul	cx
27134 7D8B           89C3                       mov	bx,ax
27135                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27136                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27137 7D8D           81C3                 0145  add	bx,#$145
27138 7D91           53                         push	bx
27139                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
27140 7D92           FF76         FE            push	-2[bp]
27141                                           ! Debug: func () void = write_byte+0 (used reg = )
27142 7D95           E8         8882            call	_write_byte
27143 7D98           83C4                   06  add	sp,*6
27144                                           !BCC_EOS
27145                                           ! 4002           AX = ((AX & 0xff00) | (1));
27146                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27147 7D9B           8B46         18            mov	ax,$18[bp]
27148 7D9E           30C0                       xor	al,al
27149                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
27150 7DA0           0C                     01  or	al,*1
27151                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27152 7DA2           8946         18            mov	$18[bp],ax
27153                                           !BCC_EOS
27154                                           ! 4003           break;
27155 7DA5           E9         0092            br 	.5C9
27156                                           !BCC_EOS
27157                                           ! 4004         case 1 :
27158                                           ! 4005           if (locks == 0x00) {
27159                       00007DA8            .5CF:
27160                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27161 7DA8           8A46         FB            mov	al,-5[bp]
27162 7DAB           84C0                       test	al,al
27163 7DAD           75           1B            jne 	.5D0
27164                       00007DAF            .5D1:
27165                                           ! 4006             AX = ((AX & 0x00ff) | ((0xb0) << 8));
27166                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27167 7DAF           8A46         18            mov	al,$18[bp]
27168                                           ! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
27169 7DB2           30E4                       xor	ah,ah
27170 7DB4           0D                   B000  or	ax,#-$5000
27171                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27172 7DB7           8946         18            mov	$18[bp],ax
27173                                           !BCC_EOS
27174                                           ! 4007             AX = ((AX & 0xff00) | (0));
27175                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
27176 7DBA           8B46         18            mov	ax,$18[bp]
27177 7DBD           30C0                       xor	al,al
27178                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
27179 7DBF           0C                     00  or	al,*0
27180                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27181 7DC1           8946         18            mov	$18[bp],ax
27182                                           !BCC_EOS
27183                                           ! 4008             goto int13_fail_noah;
27184 7DC4           83C4                   0C  add	sp,#..FFE8-..FFEA
27185 7DC7           E9         0712            br 	.FFE8
27186                                           !BCC_EOS
27187                                           ! 4009             }
27188                                           ! 4010           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
27189                       00007DCA            .5D0:
27190                                           ! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
27191 7DCA           8A46         FB            mov	al,-5[bp]
27192 7DCD           48                         dec	ax
27193 7DCE           8846         FB            mov	-5[bp],al
27194                                           ! Debug: list unsigned char = al+0 (used reg = )
27195 7DD1           30E4                       xor	ah,ah
27196 7DD3           50                         push	ax
27197                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
27198 7DD4           8A46         FD            mov	al,-3[bp]
27199 7DD7           30E4                       xor	ah,ah
27200 7DD9           B9                   001E  mov	cx,*$1E
27201 7DDC           F7E9                       imul	cx
27202 7DDE           89C3                       mov	bx,ax
27203                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27204                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27205 7DE0           81C3                 0145  add	bx,#$145
27206 7DE4           53                         push	bx
27207                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
27208 7DE5           FF76         FE            push	-2[bp]
27209                                           ! Debug: func () void = write_byte+0 (used reg = )
27210 7DE8           E8         882F            call	_write_byte
27211 7DEB           83C4                   06  add	sp,*6
27212                                           !BCC_EOS
27213                                           ! 4011           AX = ((AX & 0xff00) | (locks==0?0:1));
27214                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27215 7DEE           8A46         FB            mov	al,-5[bp]
27216 7DF1           84C0                       test	al,al
27217 7DF3           75           04            jne 	.5D2
27218                       00007DF5            .5D3:
27219 7DF5           30C0                       xor	al,al
27220 7DF7           EB           02            jmp .5D4
27221                       00007DF9            .5D2:
27222 7DF9           B0                     01  mov	al,*1
27223                       00007DFB            .5D4:
27224 7DFB           50                         push	ax
27225                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
27226 7DFC           8B46         18            mov	ax,$18[bp]
27227 7DFF           30C0                       xor	al,al
27228                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
27229 7E01           0A46         D2            or	al,0+..FFEA[bp]
27230 7E04           44                         inc	sp
27231 7E05           44                         inc	sp
27232                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27233 7E06           8946         18            mov	$18[bp],ax
27234                                           !BCC_EOS
27235                                           ! 4012           break;
27236 7E09           EB           2F            jmp .5C9
27237                                           !BCC_EOS
27238                                           ! 4013         case 2 :
27239                                           ! 4014           AX = ((AX & 0xff00) | (locks==0?0:1));
27240                       00007E0B            .5D5:
27241                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27242 7E0B           8A46         FB            mov	al,-5[bp]
27243 7E0E           84C0                       test	al,al
27244 7E10           75           04            jne 	.5D6
27245                       00007E12            .5D7:
27246 7E12           30C0                       xor	al,al
27247 7E14           EB           02            jmp .5D8
27248                       00007E16            .5D6:
27249 7E16           B0                     01  mov	al,*1
27250                       00007E18            .5D8:
27251 7E18           50                         push	ax
27252                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
27253 7E19           8B46         18            mov	ax,$18[bp]
27254 7E1C           30C0                       xor	al,al
27255                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
27256 7E1E           0A46         D2            or	al,0+..FFEA[bp]
27257 7E21           44                         inc	sp
27258 7E22           44                         inc	sp
27259                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27260 7E23           8946         18            mov	$18[bp],ax
27261                                           !BCC_EOS
27262                                           ! 4015           break;
27263 7E26           EB           12            jmp .5C9
27264                                           !BCC_EOS
27265                                           ! 4016         }
27266                                           ! 4017       goto int13_success;
27267 7E28           EB           10            jmp .5C9
27268                       00007E2A            .5CB:
27269 7E2A           2C                     00  sub	al,*0
27270 7E2C         0F84         FF25            beq 	.5CC
27271 7E30           2C                     01  sub	al,*1
27272 7E32         0F84         FF72            beq 	.5CF
27273 7E36           2C                     01  sub	al,*1
27274 7E38           74           D1            je 	.5D5
27275                       00007E3A            .5C9:
27276 7E3A           83C4                   0C  add	sp,#..FFE9-..FFEA
27277 7E3D           E9         06BE            br 	.FFE9
27278                                           !BCC_EOS
27279                                           ! 4018       break;
27280 7E40           E9         068B            br 	.5A6
27281                                           !BCC_EOS
27282                                           ! 4019     case 0x46:
27283                                           ! 4020       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
27284                       00007E43            .5D9:
27285                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
27286 7E43           8A46         FD            mov	al,-3[bp]
27287 7E46           30E4                       xor	ah,ah
27288 7E48           B9                   001E  mov	cx,*$1E
27289 7E4B           F7E9                       imul	cx
27290 7E4D           89C3                       mov	bx,ax
27291                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
27292                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
27293 7E4F           81C3                 0145  add	bx,#$145
27294 7E53           53                         push	bx
27295                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
27296 7E54           FF76         FE            push	-2[bp]
27297                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27298 7E57           E8         879A            call	_read_byte
27299 7E5A           83C4                   04  add	sp,*4
27300                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
27301 7E5D           8846         FB            mov	-5[bp],al
27302                                           !BCC_EOS
27303                                           ! 4021       if (locks != 0) {
27304                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
27305 7E60           8A46         FB            mov	al,-5[bp]
27306 7E63           84C0                       test	al,al
27307 7E65           74           11            je  	.5DA
27308                       00007E67            .5DB:
27309                                           ! 4022         AX = ((AX & 0x00ff) | ((0xb1) << 8));
27310                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27311 7E67           8A46         18            mov	al,$18[bp]
27312                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
27313 7E6A           30E4                       xor	ah,ah
27314 7E6C           0D                   B100  or	ax,#-$4F00
27315                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27316 7E6F           8946         18            mov	$18[bp],ax
27317                                           !BCC_EOS
27318                                           ! 4023         goto int13_fail_noah;
27319 7E72           83C4                   0C  add	sp,#..FFE8-..FFEA
27320 7E75           E9         0664            br 	.FFE8
27321                                           !BCC_EOS
27322                                           ! 4024         }
27323                                           ! 4025 #asm
27324                       00007E78            .5DA:
27325                                           !BCC_EOS
27326                                           !BCC_ASM
27327                       0000002E            _int13_cdrom.BP	set	$2E
27328                       0000000E            .int13_cdrom.BP	set	$E
27329                       00000024            _int13_cdrom.EHBX	set	$24
27330                       00000004            .int13_cdrom.EHBX	set	4
27331                       0000003C            _int13_cdrom.CS	set	$3C
27332                       0000001C            .int13_cdrom.CS	set	$1C
27333                       00000008            _int13_cdrom.count	set	8
27334                       FFFFFFE8            .int13_cdrom.count	set	-$18
27335                       00000036            _int13_cdrom.CX	set	$36
27336                       00000016            .int13_cdrom.CX	set	$16
27337                       00000006            _int13_cdrom.segment	set	6
27338                       FFFFFFE6            .int13_cdrom.segment	set	-$1A
27339                       0000002A            _int13_cdrom.DI	set	$2A
27340                       0000000A            .int13_cdrom.DI	set	$A
27341                       0000003E            _int13_cdrom.FLAGS	set	$3E
27342                       0000001E            .int13_cdrom.FLAGS	set	$1E
27343                       00000026            _int13_cdrom.DS	set	$26
27344                       00000006            .int13_cdrom.DS	set	6
27345                       00000030            _int13_cdrom.ELDX	set	$30
27346                       00000010            .int13_cdrom.ELDX	set	$10
27347                       00000034            _int13_cdrom.DX	set	$34
27348                       00000014            .int13_cdrom.DX	set	$14
27349                       00000000            _int13_cdrom.size	set	0
27350                       FFFFFFE0            .int13_cdrom.size	set	-$20
27351                       00000002            _int13_cdrom.i	set	2
27352                       FFFFFFE2            .int13_cdrom.i	set	-$1E
27353                       0000001D            _int13_cdrom.device	set	$1D
27354                       FFFFFFFD            .int13_cdrom.device	set	-3
27355                       00000028            _int13_cdrom.ES	set	$28
27356                       00000008            .int13_cdrom.ES	set	8
27357                       0000001E            _int13_cdrom.ebda_seg	set	$1E
27358                       FFFFFFFE            .int13_cdrom.ebda_seg	set	-2
27359                       0000002C            _int13_cdrom.SI	set	$2C
27360                       0000000C            .int13_cdrom.SI	set	$C
27361                       0000003A            _int13_cdrom.IP	set	$3A
27362                       0000001A            .int13_cdrom.IP	set	$1A
27363                       0000000A            _int13_cdrom.lba	set	$A
27364                       FFFFFFEA            .int13_cdrom.lba	set	-$16
27365                       0000001C            _int13_cdrom.status	set	$1C
27366                       FFFFFFFC            .int13_cdrom.status	set	-4
27367                       0000000F            _int13_cdrom.atacmd	set	$F
27368                       FFFFFFEF            .int13_cdrom.atacmd	set	-$11
27369                       00000038            _int13_cdrom.AX	set	$38
27370                       00000018            .int13_cdrom.AX	set	$18
27371                       00000004            _int13_cdrom.offset	set	4
27372                       FFFFFFE4            .int13_cdrom.offset	set	-$1C
27373                       00000032            _int13_cdrom.BX	set	$32
27374                       00000012            .int13_cdrom.BX	set	$12
27375                       0000001B            _int13_cdrom.locks	set	$1B
27376                       FFFFFFFB            .int13_cdrom.locks	set	-5
27377 7E78           55                                 push bp
27378 7E79           89E5                               mov bp, sp
27379 7E7B           B4                     52          mov ah, #0x52
27380 7E7D           CD                     15          int #0x15
27381 7E7F           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
27382 7E82           73           06                    jnc int13_cdrom_rme_end
27383 7E84           C706       001C      0001          mov _int13_cdrom.status, #1
27384                       00007E8A            int13_cdrom_rme_end:
27385 7E8A           5D                                 pop bp
27386                                           ! 4035 endasm
27387                                           !BCC_ENDASM
27388                                           !BCC_EOS
27389                                           ! 4036       if (status != 0) {
27390                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
27391 7E8B           8A46         FC            mov	al,-4[bp]
27392 7E8E           84C0                       test	al,al
27393 7E90           74           11            je  	.5DC
27394                       00007E92            .5DD:
27395                                           ! 4037         AX = ((AX & 0x00ff) | ((0xb1) << 8));
27396                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27397 7E92           8A46         18            mov	al,$18[bp]
27398                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
27399 7E95           30E4                       xor	ah,ah
27400 7E97           0D                   B100  or	ax,#-$4F00
27401                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27402 7E9A           8946         18            mov	$18[bp],ax
27403                                           !BCC_EOS
27404                                           ! 4038         goto int13_fail_noah;
27405 7E9D           83C4                   0C  add	sp,#..FFE8-..FFEA
27406 7EA0           E9         0639            br 	.FFE8
27407                                           !BCC_EOS
27408                                           ! 4039       }
27409                                           ! 4040       goto int13_success;
27410                       00007EA3            .5DC:
27411 7EA3           83C4                   0C  add	sp,#..FFE9-..FFEA
27412 7EA6           E9         0655            br 	.FFE9
27413                                           !BCC_EOS
27414                                           ! 4041       break;
27415 7EA9           E9         0622            br 	.5A6
27416                                           !BCC_EOS
27417                                           ! 4042     case 0x48:
27418                                           ! 4043       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
27419                       00007EAC            .5DE:
27420                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
27421 7EAC           8B46         0C            mov	ax,$C[bp]
27422                                           ! Debug: list unsigned int = ax+0 (used reg = )
27423 7EAF           50                         push	ax
27424                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
27425 7EB0           FF76         06            push	6[bp]
27426                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27427 7EB3           E8         8751            call	_read_word
27428 7EB6           83C4                   04  add	sp,*4
27429                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
27430 7EB9           8946         E0            mov	-$20[bp],ax
27431                                           !BCC_EOS
27432                                           ! 4044       if(size < 0x1a)
27433                                           ! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
27434 7EBC           8B46         E0            mov	ax,-$20[bp]
27435 7EBF           3D                   001A  cmp	ax,*$1A
27436 7EC2           73           06            jae 	.5DF
27437                       00007EC4            .5E0:
27438                                           ! 4045         goto int13_fail;
27439 7EC4           83C4                   0C  add	sp,#..FFEB-..FFEA
27440 7EC7           E9         0607            br 	.FFEB
27441                                           !BCC_EOS
27442                                           ! 4046       if(size >= 0x1a) {
27443                       00007ECA            .5DF:
27444                                           ! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
27445 7ECA           8B46         E0            mov	ax,-$20[bp]
27446 7ECD           3D                   001A  cmp	ax,*$1A
27447 7ED0         0F82         00CC            blo 	.5E1
27448                       00007ED4            .5E2:
27449                                           ! 4047         Bit16u cylinders, heads, spt, blksize;
27450                                           !BCC_EOS
27451                                           ! 4048         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
27452                                           ! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
27453 7ED4           8A46         FD            mov	al,-3[bp]
27454 7ED7           30E4                       xor	ah,ah
27455 7ED9           B9                   001E  mov	cx,*$1E
27456 7EDC           F7E9                       imul	cx
27457 7EDE           89C3                       mov	bx,ax
27458                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
27459                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
27460 7EE0           81C3                 0148  add	bx,#$148
27461 7EE4           53                         push	bx
27462                                           ! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
27463 7EE5           FF76         FE            push	-2[bp]
27464                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27465 7EE8           E8         871C            call	_read_word
27466 7EEB           83C4                   04  add	sp,*4
27467                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
27468 7EEE           8946         D8            mov	-$28[bp],ax
27469                                           !BCC_EOS
27470                                           ! 4049         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
27471                                           ! Debug: list int = const $1A (used reg = )
27472 7EF1           B8                   001A  mov	ax,*$1A
27473 7EF4           50                         push	ax
27474                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
27475 7EF5           8B46         0C            mov	ax,$C[bp]
27476                                           ! Debug: list unsigned int = ax+0 (used reg = )
27477 7EF8           50                         push	ax
27478                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27479 7EF9           FF76         06            push	6[bp]
27480                                           ! Debug: func () void = write_word+0 (used reg = )
27481 7EFC           E8         8733            call	_write_word
27482 7EFF           83C4                   06  add	sp,*6
27483                                           !BCC_EOS
27484                                           ! 4050         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
27485                                           ! Debug: list int = const $74 (used reg = )
27486 7F02           B8                   0074  mov	ax,*$74
27487 7F05           50                         push	ax
27488                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
27489 7F06           8B46         0C            mov	ax,$C[bp]
27490                                           ! Debug: list unsigned int = ax+2 (used reg = )
27491 7F09           40                         inc	ax
27492 7F0A           40                         inc	ax
27493 7F0B           50                         push	ax
27494                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27495 7F0C           FF76         06            push	6[bp]
27496                                           ! Debug: func () void = write_word+0 (used reg = )
27497 7F0F           E8         8720            call	_write_word
27498 7F12           83C4                   06  add	sp,*6
27499                                           !BCC_EOS
27500                                           ! 4051         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
27501                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27502 7F15           B8                   FFFF  mov	ax,#$FFFF
27503 7F18           BB                   FFFF  mov	bx,#$FFFF
27504 7F1B           53                         push	bx
27505 7F1C           50                         push	ax
27506                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
27507 7F1D           8B46         0C            mov	ax,$C[bp]
27508                                           ! Debug: list unsigned int = ax+4 (used reg = )
27509 7F20           05                   0004  add	ax,*4
27510 7F23           50                         push	ax
27511                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27512 7F24           FF76         06            push	6[bp]
27513                                           ! Debug: func () void = write_dword+0 (used reg = )
27514 7F27           E8         8171            call	_write_dword
27515 7F2A           83C4                   08  add	sp,*8
27516                                           !BCC_EOS
27517                                           ! 4052         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
27518                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27519 7F2D           B8                   FFFF  mov	ax,#$FFFF
27520 7F30           BB                   FFFF  mov	bx,#$FFFF
27521 7F33           53                         push	bx
27522 7F34           50                         push	ax
27523                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
27524 7F35           8B46         0C            mov	ax,$C[bp]
27525                                           ! Debug: list unsigned int = ax+8 (used reg = )
27526 7F38           05                   0008  add	ax,*8
27527 7F3B           50                         push	ax
27528                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27529 7F3C           FF76         06            push	6[bp]
27530                                           ! Debug: func () void = write_dword+0 (used reg = )
27531 7F3F           E8         8159            call	_write_dword
27532 7F42           83C4                   08  add	sp,*8
27533                                           !BCC_EOS
27534                                           ! 4053         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
27535                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27536 7F45           B8                   FFFF  mov	ax,#$FFFF
27537 7F48           BB                   FFFF  mov	bx,#$FFFF
27538 7F4B           53                         push	bx
27539 7F4C           50                         push	ax
27540                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
27541 7F4D           8B46         0C            mov	ax,$C[bp]
27542                                           ! Debug: list unsigned int = ax+$C (used reg = )
27543 7F50           05                   000C  add	ax,*$C
27544 7F53           50                         push	ax
27545                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27546 7F54           FF76         06            push	6[bp]
27547                                           ! Debug: func () void = write_dword+0 (used reg = )
27548 7F57           E8         8141            call	_write_dword
27549 7F5A           83C4                   08  add	sp,*8
27550                                           !BCC_EOS
27551                                           ! 4054         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
27552                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27553 7F5D           B8                   FFFF  mov	ax,#$FFFF
27554 7F60           BB                   FFFF  mov	bx,#$FFFF
27555 7F63           53                         push	bx
27556 7F64           50                         push	ax
27557                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
27558 7F65           8B46         0C            mov	ax,$C[bp]
27559                                           ! Debug: list unsigned int = ax+$10 (used reg = )
27560 7F68           05                   0010  add	ax,*$10
27561 7F6B           50                         push	ax
27562                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27563 7F6C           FF76         06            push	6[bp]
27564                                           ! Debug: func () void = write_dword+0 (used reg = )
27565 7F6F           E8         8129            call	_write_dword
27566 7F72           83C4                   08  add	sp,*8
27567                                           !BCC_EOS
27568                                           ! 4055         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
27569                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
27570 7F75           B8                   FFFF  mov	ax,#$FFFF
27571 7F78           BB                   FFFF  mov	bx,#$FFFF
27572 7F7B           53                         push	bx
27573 7F7C           50                         push	ax
27574                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
27575 7F7D           8B46         0C            mov	ax,$C[bp]
27576                                           ! Debug: list unsigned int = ax+$14 (used reg = )
27577 7F80           05                   0014  add	ax,*$14
27578 7F83           50                         push	ax
27579                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
27580 7F84           FF76         06            push	6[bp]
27581                                           ! Debug: func () void = write_dword+0 (used reg = )
27582 7F87           E8         8111            call	_write_dword
27583 7F8A           83C4                   08  add	sp,*8
27584                                           !BCC_EOS
27585                                           ! 4056         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
27586                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
27587 7F8D           FF76         D8            push	-$28[bp]
27588                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
27589 7F90           8B46         0C            mov	ax,$C[bp]
27590                                           ! Debug: list unsigned int = ax+$18 (used reg = )
27591 7F93           05                   0018  add	ax,*$18
27592 7F96           50                         push	ax
27593                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27594 7F97           FF76         06            push	6[bp]
27595                                           ! Debug: func () void = write_word+0 (used reg = )
27596 7F9A           E8         8695            call	_write_word
27597 7F9D           83C4                   06  add	sp,*6
27598                                           !BCC_EOS
27599                                           ! 4057         }
27600                                           ! 4058       
27601                                           ! 4058 if(size >= 0x1e) {
27602                       00007FA0            .5E1:
27603                                           ! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
27604 7FA0           8B46         E0            mov	ax,-$20[bp]
27605 7FA3           3D                   001E  cmp	ax,*$1E
27606 7FA6         0F82         01F9            blo 	.5E3
27607                       00007FAA            .5E4:
27608                                           ! 4059         Bit8u channel, dev, irq, mode, checksum, i;
27609                                           !BCC_EOS
27610                                           ! 4060         Bit16u iobase1, iobase2, options;
27611                                           !BCC_EOS
27612                                           ! 4061         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
27613                                           ! Debug: list int = const $1E (used reg = )
27614 7FAA           B8                   001E  mov	ax,*$1E
27615 7FAD           50                         push	ax
27616                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
27617 7FAE           8B46         0C            mov	ax,$C[bp]
27618                                           ! Debug: list unsigned int = ax+0 (used reg = )
27619 7FB1           50                         push	ax
27620                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27621 7FB2           FF76         06            push	6[bp]
27622                                           ! Debug: func () void = write_word+0 (used reg = )
27623 7FB5           E8         867A            call	_write_word
27624 7FB8           83C4                   06  add	sp,*6
27625                                           !BCC_EOS
27626                                           ! 4062         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
27627                                           ! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
27628 7FBB           FF76         FE            push	-2[bp]
27629                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
27630 7FBE           8B46         0C            mov	ax,$C[bp]
27631                                           ! Debug: list unsigned int = ax+$1C (used reg = )
27632 7FC1           05                   001C  add	ax,*$1C
27633 7FC4           50                         push	ax
27634                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27635 7FC5           FF76         06            push	6[bp]
27636                                           ! Debug: func () void = write_word+0 (used reg = )
27637 7FC8           E8         8667            call	_write_word
27638 7FCB           83C4                   06  add	sp,*6
27639                                           !BCC_EOS
27640                                           ! 4063         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
27641                                           ! Debug: list * struct  = const $244 (used reg = )
27642 7FCE           B8                   0244  mov	ax,#$244
27643 7FD1           50                         push	ax
27644                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
27645 7FD2           8B46         0C            mov	ax,$C[bp]
27646                                           ! Debug: list unsigned int = ax+$1A (used reg = )
27647 7FD5           05                   001A  add	ax,*$1A
27648 7FD8           50                         push	ax
27649                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27650 7FD9           FF76         06            push	6[bp]
27651                                           ! Debug: func () void = write_word+0 (used reg = )
27652 7FDC           E8         8653            call	_write_word
27653 7FDF           83C4                   06  add	sp,*6
27654                                           !BCC_EOS
27655                                           ! 4064         channel = device / 2;
27656                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27657 7FE2           8A46         FD            mov	al,-3[bp]
27658 7FE5           30E4                       xor	ah,ah
27659 7FE7           D1E8                       shr	ax,*1
27660                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
27661 7FE9           8846         DF            mov	-$21[bp],al
27662                                           !BCC_EOS
27663                                           ! 4065         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27664                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27665 7FEC           8A46         DF            mov	al,-$21[bp]
27666 7FEF           30E4                       xor	ah,ah
27667 7FF1           B1                     03  mov	cl,*3
27668 7FF3           D3E0                       shl	ax,cl
27669 7FF5           89C3                       mov	bx,ax
27670                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27671                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27672 7FF7           81C3                 0124  add	bx,#$124
27673 7FFB           53                         push	bx
27674                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27675 7FFC           FF76         FE            push	-2[bp]
27676                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27677 7FFF           E8         8605            call	_read_word
27678 8002           83C4                   04  add	sp,*4
27679                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27680 8005           8946         D8            mov	-$28[bp],ax
27681                                           !BCC_EOS
27682                                           ! 4066         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
27683                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27684 8008           8A46         DF            mov	al,-$21[bp]
27685 800B           30E4                       xor	ah,ah
27686 800D           B1                     03  mov	cl,*3
27687 800F           D3E0                       shl	ax,cl
27688 8011           89C3                       mov	bx,ax
27689                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
27690                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
27691 8013           81C3                 0126  add	bx,#$126
27692 8017           53                         push	bx
27693                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27694 8018           FF76         FE            push	-2[bp]
27695                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27696 801B           E8         85E9            call	_read_word
27697 801E           83C4                   04  add	sp,*4
27698                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27699 8021           8946         D6            mov	-$2A[bp],ax
27700                                           !BCC_EOS
27701                                           ! 4067         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
27702                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27703 8024           8A46         DF            mov	al,-$21[bp]
27704 8027           30E4                       xor	ah,ah
27705 8029           B1                     03  mov	cl,*3
27706 802B           D3E0                       shl	ax,cl
27707 802D           89C3                       mov	bx,ax
27708                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
27709                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
27710 802F           81C3                 0128  add	bx,#$128
27711 8033           53                         push	bx
27712                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27713 8034           FF76         FE            push	-2[bp]
27714                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27715 8037           E8         85BA            call	_read_byte
27716 803A           83C4                   04  add	sp,*4
27717                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
27718 803D           8846         DD            mov	-$23[bp],al
27719                                           !BCC_EOS
27720                                           ! 4068         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
27721                                           ! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
27722 8040           8A46         FD            mov	al,-3[bp]
27723 8043           30E4                       xor	ah,ah
27724 8045           B9                   001E  mov	cx,*$1E
27725 8048           F7E9                       imul	cx
27726 804A           89C3                       mov	bx,ax
27727                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
27728                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
27729 804C           81C3                 0146  add	bx,#$146
27730 8050           53                         push	bx
27731                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27732 8051           FF76         FE            push	-2[bp]
27733                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27734 8054           E8         859D            call	_read_byte
27735 8057           83C4                   04  add	sp,*4
27736                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
27737 805A           8846         DC            mov	-$24[bp],al
27738                                           !BCC_EOS
27739                                           ! 4069         options = (1<<4);
27740                                           ! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
27741 805D           B8                   0010  mov	ax,*$10
27742 8060           8946         D4            mov	-$2C[bp],ax
27743                                           !BCC_EOS
27744                                           ! 4070         options |= (1<<5);
27745                                           ! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
27746 8063           8B46         D4            mov	ax,-$2C[bp]
27747 8066           0C                     20  or	al,*$20
27748 8068           8946         D4            mov	-$2C[bp],ax
27749                                           !BCC_EOS
27750                                           ! 4071         options |= (1<<6);
27751                                           ! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
27752 806B           8B46         D4            mov	ax,-$2C[bp]
27753 806E           0C                     40  or	al,*$40
27754 8070           8946         D4            mov	-$2C[bp],ax
27755                                           !BCC_EOS
27756                                           ! 4072         options |= (mode==0x01?1:0<<7);
27757                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
27758 8073           8A46         DC            mov	al,-$24[bp]
27759 8076           3C                     01  cmp	al,*1
27760 8078           75           04            jne 	.5E5
27761                       0000807A            .5E6:
27762 807A           B0                     01  mov	al,*1
27763 807C           EB           02            jmp .5E7
27764                       0000807E            .5E5:
27765 807E           30C0                       xor	al,al
27766                       00008080            .5E7:
27767                                           ! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
27768 8080           30E4                       xor	ah,ah
27769 8082           0B46         D4            or	ax,-$2C[bp]
27770 8085           8946         D4            mov	-$2C[bp],ax
27771                                           !BCC_EOS
27772                                           ! 4073         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
27773                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27774 8088           FF76         D8            push	-$28[bp]
27775                                           ! Debug: list * unsigned short = const $244 (used reg = )
27776 808B           B8                   0244  mov	ax,#$244
27777 808E           50                         push	ax
27778                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27779 808F           FF76         FE            push	-2[bp]
27780                                           ! Debug: func () void = write_word+0 (used reg = )
27781 8092           E8         859D            call	_write_word
27782 8095           83C4                   06  add	sp,*6
27783                                           !BCC_EOS
27784                                           ! 4074         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
27785                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27786 8098           8B46         D6            mov	ax,-$2A[bp]
27787                                           ! Debug: list unsigned int = ax+6 (used reg = )
27788 809B           05                   0006  add	ax,*6
27789 809E           50                         push	ax
27790                                           ! Debug: list * unsigned short = const $246 (used reg = )
27791 809F           B8                   0246  mov	ax,#$246
27792 80A2           50                         push	ax
27793                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27794 80A3           FF76         FE            push	-2[bp]
27795                                           ! Debug: func () void = write_word+0 (used reg = )
27796 80A6           E8         8589            call	_write_word
27797 80A9           83C4                   06  add	sp,*6
27798                                           !BCC_EOS
27799                                           ! 4075         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
27800                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27801 80AC           8A46         FD            mov	al,-3[bp]
27802 80AF           30E4                       xor	ah,ah
27803 80B1           24                     01  and	al,*1
27804                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
27805                                           ! Debug: expression subtree swapping
27806 80B3           0C                     0E  or	al,*$E
27807                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
27808 80B5           30E4                       xor	ah,ah
27809 80B7           B1                     04  mov	cl,*4
27810 80B9           D3E0                       shl	ax,cl
27811                                           ! Debug: list unsigned int = ax+0 (used reg = )
27812 80BB           50                         push	ax
27813                                           ! Debug: list * unsigned char = const $248 (used reg = )
27814 80BC           B8                   0248  mov	ax,#$248
27815 80BF           50                         push	ax
27816                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27817 80C0           FF76         FE            push	-2[bp]
27818                                           ! Debug: func () void = write_byte+0 (used reg = )
27819 80C3           E8         8554            call	_write_byte
27820 80C6           83C4                   06  add	sp,*6
27821                                           !BCC_EOS
27822                                           ! 4076         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
27823                                           ! Debug: list int = const $CB (used reg = )
27824 80C9           B8                   00CB  mov	ax,#$CB
27825 80CC           50                         push	ax
27826                                           ! Debug: list * unsigned char = const $249 (used reg = )
27827 80CD           B8                   0249  mov	ax,#$249
27828 80D0           50                         push	ax
27829                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27830 80D1           FF76         FE            push	-2[bp]
27831                                           ! Debug: func () void = write_byte+0 (used reg = )
27832 80D4           E8         8543            call	_write_byte
27833 80D7           83C4                   06  add	sp,*6
27834                                           !BCC_EOS
27835                                           ! 4077         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
27836                                           ! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
27837 80DA           8A46         DD            mov	al,-$23[bp]
27838 80DD           30E4                       xor	ah,ah
27839 80DF           50                         push	ax
27840                                           ! Debug: list * unsigned char = const $24A (used reg = )
27841 80E0           B8                   024A  mov	ax,#$24A
27842 80E3           50                         push	ax
27843                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27844 80E4           FF76         FE            push	-2[bp]
27845                                           ! Debug: func () void = write_byte+0 (used reg = )
27846 80E7           E8         8530            call	_write_byte
27847 80EA           83C4                   06  add	sp,*6
27848                                           !BCC_EOS
27849                                           ! 4078         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
27850                                           ! Debug: list int = const 1 (used reg = )
27851 80ED           B8                   0001  mov	ax,*1
27852 80F0           50                         push	ax
27853                                           ! Debug: list * unsigned char = const $24B (used reg = )
27854 80F1           B8                   024B  mov	ax,#$24B
27855 80F4           50                         push	ax
27856                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27857 80F5           FF76         FE            push	-2[bp]
27858                                           ! Debug: func () void = write_byte+0 (used reg = )
27859 80F8           E8         851F            call	_write_byte
27860 80FB           83C4                   06  add	sp,*6
27861                                           !BCC_EOS
27862                                           ! 4079         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
27863                                           ! Debug: list int = const 0 (used reg = )
27864 80FE           31C0                       xor	ax,ax
27865 8100           50                         push	ax
27866                                           ! Debug: list * unsigned char = const $24C (used reg = )
27867 8101           B8                   024C  mov	ax,#$24C
27868 8104           50                         push	ax
27869                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27870 8105           FF76         FE            push	-2[bp]
27871                                           ! Debug: func () void = write_byte+0 (used reg = )
27872 8108           E8         850F            call	_write_byte
27873 810B           83C4                   06  add	sp,*6
27874                                           !BCC_EOS
27875                                           ! 4080         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
27876                                           ! Debug: list int = const 0 (used reg = )
27877 810E           31C0                       xor	ax,ax
27878 8110           50                         push	ax
27879                                           ! Debug: list * unsigned char = const $24D (used reg = )
27880 8111           B8                   024D  mov	ax,#$24D
27881 8114           50                         push	ax
27882                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27883 8115           FF76         FE            push	-2[bp]
27884                                           ! Debug: func () void = write_byte+0 (used reg = )
27885 8118           E8         84FF            call	_write_byte
27886 811B           83C4                   06  add	sp,*6
27887                                           !BCC_EOS
27888                                           ! 4081         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
27889                                           ! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
27890 811E           FF76         D4            push	-$2C[bp]
27891                                           ! Debug: list * unsigned short = const $24E (used reg = )
27892 8121           B8                   024E  mov	ax,#$24E
27893 8124           50                         push	ax
27894                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27895 8125           FF76         FE            push	-2[bp]
27896                                           ! Debug: func () void = write_word+0 (used reg = )
27897 8128           E8         8507            call	_write_word
27898 812B           83C4                   06  add	sp,*6
27899                                           !BCC_EOS
27900                                           ! 4082         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
27901                                           ! Debug: list int = const 0 (used reg = )
27902 812E           31C0                       xor	ax,ax
27903 8130           50                         push	ax
27904                                           ! Debug: list * unsigned short = const $250 (used reg = )
27905 8131           B8                   0250  mov	ax,#$250
27906 8134           50                         push	ax
27907                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27908 8135           FF76         FE            push	-2[bp]
27909                                           ! Debug: func () void = write_word+0 (used reg = )
27910 8138           E8         84F7            call	_write_word
27911 813B           83C4                   06  add	sp,*6
27912                                           !BCC_EOS
27913                                           ! 4083         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
27914                                           ! Debug: list int = const $11 (used reg = )
27915 813E           B8                   0011  mov	ax,*$11
27916 8141           50                         push	ax
27917                                           ! Debug: list * unsigned char = const $252 (used reg = )
27918 8142           B8                   0252  mov	ax,#$252
27919 8145           50                         push	ax
27920                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27921 8146           FF76         FE            push	-2[bp]
27922                                           ! Debug: func () void = write_byte+0 (used reg = )
27923 8149           E8         84CE            call	_write_byte
27924 814C           83C4                   06  add	sp,*6
27925                                           !BCC_EOS
27926                                           ! 4084         checksum=0;
27927                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27928 814F           30C0                       xor	al,al
27929 8151           8846         DB            mov	-$25[bp],al
27930                                           !BCC_EOS
27931                                           ! 4085         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
27932                                           ! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
27933 8154           30C0                       xor	al,al
27934 8156           8846         DA            mov	-$26[bp],al
27935                                           !BCC_EOS
27936                                           !BCC_EOS
27937 8159           EB           24            jmp .5EA
27938                       0000815B            .5EB:
27939                                           ! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
27940 815B           8A46         DA            mov	al,-$26[bp]
27941 815E           30E4                       xor	ah,ah
27942                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
27943 8160           05                   0244  add	ax,#$244
27944 8163           50                         push	ax
27945                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27946 8164           FF76         FE            push	-2[bp]
27947                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27948 8167           E8         848A            call	_read_byte
27949 816A           83C4                   04  add	sp,*4
27950                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27951 816D           30E4                       xor	ah,ah
27952 816F           0246         DB            add	al,-$25[bp]
27953 8172           80D4                   00  adc	ah,*0
27954 8175           8846         DB            mov	-$25[bp],al
27955                                           !BCC_EOS
27956                                           ! 4086         checksum = ~checksum;
27957                       00008178            .5E9:
27958                                           ! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
27959 8178           8A46         DA            mov	al,-$26[bp]
27960 817B           40                         inc	ax
27961 817C           8846         DA            mov	-$26[bp],al
27962                       0000817F            .5EA:
27963                                           ! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
27964 817F           8A46         DA            mov	al,-$26[bp]
27965 8182           3C                     0F  cmp	al,*$F
27966 8184           72           D5            jb 	.5EB
27967                       00008186            .5EC:
27968                       00008186            .5E8:
27969                                           ! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
27970 8186           8A46         DB            mov	al,-$25[bp]
27971 8189           30E4                       xor	ah,ah
27972 818B           F7D0                       not	ax
27973                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27974 818D           8846         DB            mov	-$25[bp],al
27975                                           !BCC_EOS
27976                                           ! 4087         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
27977                                           ! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
27978 8190           8A46         DB            mov	al,-$25[bp]
27979 8193           30E4                       xor	ah,ah
27980 8195           50                         push	ax
27981                                           ! Debug: list * unsigned char = const $253 (used reg = )
27982 8196           B8                   0253  mov	ax,#$253
27983 8199           50                         push	ax
27984                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27985 819A           FF76         FE            push	-2[bp]
27986                                           ! Debug: func () void = write_byte+0 (used reg = )
27987 819D           E8         847A            call	_write_byte
27988 81A0           83C4                   06  add	sp,*6
27989                                           !BCC_EOS
27990                                           ! 4088         }
27991                                           ! 4089       if(size >= 0x42) {
27992                       000081A3            .5E3:
27993                                           ! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
27994 81A3           8B46         E0            mov	ax,-$20[bp]
27995 81A6           3D                   0042  cmp	ax,*$42
27996 81A9         0F82         023B            blo 	.5ED
27997                       000081AD            .5EE:
27998                                           ! 4090         Bit8u channel, iface, checksum, i;
27999                                           !BCC_EOS
28000                                           ! 4091         Bit16u iobase1;
28001                                           !BCC_EOS
28002                                           ! 4092         
28003                                           ! 4092 channel = device / 2;
28004                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
28005 81AD           8A46         FD            mov	al,-3[bp]
28006 81B0           30E4                       xor	ah,ah
28007 81B2           D1E8                       shr	ax,*1
28008                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
28009 81B4           8846         DF            mov	-$21[bp],al
28010                                           !BCC_EOS
28011                                           ! 4093         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
28012                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
28013 81B7           8A46         DF            mov	al,-$21[bp]
28014 81BA           30E4                       xor	ah,ah
28015 81BC           B1                     03  mov	cl,*3
28016 81BE           D3E0                       shl	ax,cl
28017 81C0           89C3                       mov	bx,ax
28018                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
28019                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
28020 81C2           81C3                 0122  add	bx,#$122
28021 81C6           53                         push	bx
28022                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
28023 81C7           FF76         FE            push	-2[bp]
28024                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28025 81CA           E8         8427            call	_read_byte
28026 81CD           83C4                   04  add	sp,*4
28027                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
28028 81D0           8846         DE            mov	-$22[bp],al
28029                                           !BCC_EOS
28030                                           ! 4094         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
28031                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
28032 81D3           8A46         DF            mov	al,-$21[bp]
28033 81D6           30E4                       xor	ah,ah
28034 81D8           B1                     03  mov	cl,*3
28035 81DA           D3E0                       shl	ax,cl
28036 81DC           89C3                       mov	bx,ax
28037                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
28038                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
28039 81DE           81C3                 0124  add	bx,#$124
28040 81E2           53                         push	bx
28041                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
28042 81E3           FF76         FE            push	-2[bp]
28043                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28044 81E6           E8         841E            call	_read_word
28045 81E9           83C4                   04  add	sp,*4
28046                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
28047 81EC           8946         DA            mov	-$26[bp],ax
28048                                           !BCC_EOS
28049                                           ! 4095         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
28050                                           ! Debug: list int = const $42 (used reg = )
28051 81EF           B8                   0042  mov	ax,*$42
28052 81F2           50                         push	ax
28053                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
28054 81F3           8B46         0C            mov	ax,$C[bp]
28055                                           ! Debug: list unsigned int = ax+0 (used reg = )
28056 81F6           50                         push	ax
28057                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28058 81F7           FF76         06            push	6[bp]
28059                                           ! Debug: func () void = write_word+0 (used reg = )
28060 81FA           E8         8435            call	_write_word
28061 81FD           83C4                   06  add	sp,*6
28062                                           !BCC_EOS
28063                                           ! 4096         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
28064                                           ! Debug: list unsigned int = const $BEDD (used reg = )
28065 8200           B8                   BEDD  mov	ax,#$BEDD
28066 8203           50                         push	ax
28067                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
28068 8204           8B46         0C            mov	ax,$C[bp]
28069                                           ! Debug: list unsigned int = ax+$1E (used reg = )
28070 8207           05                   001E  add	ax,*$1E
28071 820A           50                         push	ax
28072                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28073 820B           FF76         06            push	6[bp]
28074                                           ! Debug: func () void = write_word+0 (used reg = )
28075 820E           E8         8421            call	_write_word
28076 8211           83C4                   06  add	sp,*6
28077                                           !BCC_EOS
28078                                           ! 4097         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
28079                                           ! Debug: list int = const $24 (used reg = )
28080 8214           B8                   0024  mov	ax,*$24
28081 8217           50                         push	ax
28082                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
28083 8218           8B46         0C            mov	ax,$C[bp]
28084                                           ! Debug: list unsigned int = ax+$20 (used reg = )
28085 821B           05                   0020  add	ax,*$20
28086 821E           50                         push	ax
28087                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28088 821F           FF76         06            push	6[bp]
28089                                           ! Debug: func () void = write_byte+0 (used reg = )
28090 8222           E8         83F5            call	_write_byte
28091 8225           83C4                   06  add	sp,*6
28092                                           !BCC_EOS
28093                                           ! 4098         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
28094                                           ! Debug: list int = const 0 (used reg = )
28095 8228           31C0                       xor	ax,ax
28096 822A           50                         push	ax
28097                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
28098 822B           8B46         0C            mov	ax,$C[bp]
28099                                           ! Debug: list unsigned int = ax+$21 (used reg = )
28100 822E           05                   0021  add	ax,*$21
28101 8231           50                         push	ax
28102                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28103 8232           FF76         06            push	6[bp]
28104                                           ! Debug: func () void = write_byte+0 (used reg = )
28105 8235           E8         83E2            call	_write_byte
28106 8238           83C4                   06  add	sp,*6
28107                                           !BCC_EOS
28108                                           ! 4099         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
28109                                           ! Debug: list int = const 0 (used reg = )
28110 823B           31C0                       xor	ax,ax
28111 823D           50                         push	ax
28112                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
28113 823E           8B46         0C            mov	ax,$C[bp]
28114                                           ! Debug: list unsigned int = ax+$22 (used reg = )
28115 8241           05                   0022  add	ax,*$22
28116 8244           50                         push	ax
28117                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28118 8245           FF76         06            push	6[bp]
28119                                           ! Debug: func () void = write_word+0 (used reg = )
28120 8248           E8         83E7            call	_write_word
28121 824B           83C4                   06  add	sp,*6
28122                                           !BCC_EOS
28123                                           ! 4100         if (iface==0x00) {
28124                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
28125 824E           8A46         DE            mov	al,-$22[bp]
28126 8251           84C0                       test	al,al
28127 8253           75           51            jne 	.5EF
28128                       00008255            .5F0:
28129                                           ! 4101           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
28130                                           ! Debug: list int = const $49 (used reg = )
28131 8255           B8                   0049  mov	ax,*$49
28132 8258           50                         push	ax
28133                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
28134 8259           8B46         0C            mov	ax,$C[bp]
28135                                           ! Debug: list unsigned int = ax+$24 (used reg = )
28136 825C           05                   0024  add	ax,*$24
28137 825F           50                         push	ax
28138                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28139 8260           FF76         06            push	6[bp]
28140                                           ! Debug: func () void = write_byte+0 (used reg = )
28141 8263           E8         83B4            call	_write_byte
28142 8266           83C4                   06  add	sp,*6
28143                                           !BCC_EOS
28144                                           ! 4102           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
28145                                           ! Debug: list int = const $53 (used reg = )
28146 8269           B8                   0053  mov	ax,*$53
28147 826C           50                         push	ax
28148                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
28149 826D           8B46         0C            mov	ax,$C[bp]
28150                                           ! Debug: list unsigned int = ax+$25 (used reg = )
28151 8270           05                   0025  add	ax,*$25
28152 8273           50                         push	ax
28153                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28154 8274           FF76         06            push	6[bp]
28155                                           ! Debug: func () void = write_byte+0 (used reg = )
28156 8277           E8         83A0            call	_write_byte
28157 827A           83C4                   06  add	sp,*6
28158                                           !BCC_EOS
28159                                           ! 4103           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
28160                                           ! Debug: list int = const $41 (used reg = )
28161 827D           B8                   0041  mov	ax,*$41
28162 8280           50                         push	ax
28163                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
28164 8281           8B46         0C            mov	ax,$C[bp]
28165                                           ! Debug: list unsigned int = ax+$26 (used reg = )
28166 8284           05                   0026  add	ax,*$26
28167 8287           50                         push	ax
28168                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28169 8288           FF76         06            push	6[bp]
28170                                           ! Debug: func () void = write_byte+0 (used reg = )
28171 828B           E8         838C            call	_write_byte
28172 828E           83C4                   06  add	sp,*6
28173                                           !BCC_EOS
28174                                           ! 4104           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
28175                                           ! Debug: list int = const 0 (used reg = )
28176 8291           31C0                       xor	ax,ax
28177 8293           50                         push	ax
28178                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
28179 8294           8B46         0C            mov	ax,$C[bp]
28180                                           ! Debug: list unsigned int = ax+$27 (used reg = )
28181 8297           05                   0027  add	ax,*$27
28182 829A           50                         push	ax
28183                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28184 829B           FF76         06            push	6[bp]
28185                                           ! Debug: func () void = write_byte+0 (used reg = )
28186 829E           E8         8379            call	_write_byte
28187 82A1           83C4                   06  add	sp,*6
28188                                           !BCC_EOS
28189                                           ! 4105           }
28190                                           ! 4106         else {
28191 82A4           EB           00            jmp .5F1
28192                       000082A6            .5EF:
28193                                           ! 4107           }
28194                                           ! 4108         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
28195                       000082A6            .5F1:
28196                                           ! Debug: list int = const $41 (used reg = )
28197 82A6           B8                   0041  mov	ax,*$41
28198 82A9           50                         push	ax
28199                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
28200 82AA           8B46         0C            mov	ax,$C[bp]
28201                                           ! Debug: list unsigned int = ax+$28 (used reg = )
28202 82AD           05                   0028  add	ax,*$28
28203 82B0           50                         push	ax
28204                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28205 82B1           FF76         06            push	6[bp]
28206                                           ! Debug: func () void = write_byte+0 (used reg = )
28207 82B4           E8         8363            call	_write_byte
28208 82B7           83C4                   06  add	sp,*6
28209                                           !BCC_EOS
28210                                           ! 4109         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
28211                                           ! Debug: list int = const $54 (used reg = )
28212 82BA           B8                   0054  mov	ax,*$54
28213 82BD           50                         push	ax
28214                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
28215 82BE           8B46         0C            mov	ax,$C[bp]
28216                                           ! Debug: list unsigned int = ax+$29 (used reg = )
28217 82C1           05                   0029  add	ax,*$29
28218 82C4           50                         push	ax
28219                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28220 82C5           FF76         06            push	6[bp]
28221                                           ! Debug: func () void = write_byte+0 (used reg = )
28222 82C8           E8         834F            call	_write_byte
28223 82CB           83C4                   06  add	sp,*6
28224                                           !BCC_EOS
28225                                           ! 4110         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
28226                                           ! Debug: list int = const $41 (used reg = )
28227 82CE           B8                   0041  mov	ax,*$41
28228 82D1           50                         push	ax
28229                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
28230 82D2           8B46         0C            mov	ax,$C[bp]
28231                                           ! Debug: list unsigned int = ax+$2A (used reg = )
28232 82D5           05                   002A  add	ax,*$2A
28233 82D8           50                         push	ax
28234                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28235 82D9           FF76         06            push	6[bp]
28236                                           ! Debug: func () void = write_byte+0 (used reg = )
28237 82DC           E8         833B            call	_write_byte
28238 82DF           83C4                   06  add	sp,*6
28239                                           !BCC_EOS
28240                                           ! 4111         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
28241                                           ! Debug: list int = const 0 (used reg = )
28242 82E2           31C0                       xor	ax,ax
28243 82E4           50                         push	ax
28244                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
28245 82E5           8B46         0C            mov	ax,$C[bp]
28246                                           ! Debug: list unsigned int = ax+$2B (used reg = )
28247 82E8           05                   002B  add	ax,*$2B
28248 82EB           50                         push	ax
28249                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28250 82EC           FF76         06            push	6[bp]
28251                                           ! Debug: func () void = write_byte+0 (used reg = )
28252 82EF           E8         8328            call	_write_byte
28253 82F2           83C4                   06  add	sp,*6
28254                                           !BCC_EOS
28255                                           ! 4112         if (iface==0x00) {
28256                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
28257 82F5           8A46         DE            mov	al,-$22[bp]
28258 82F8           84C0                       test	al,al
28259 82FA           75           3E            jne 	.5F2
28260                       000082FC            .5F3:
28261                                           ! 4113           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
28262                                           ! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
28263 82FC           FF76         DA            push	-$26[bp]
28264                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
28265 82FF           8B46         0C            mov	ax,$C[bp]
28266                                           ! Debug: list unsigned int = ax+$30 (used reg = )
28267 8302           05                   0030  add	ax,*$30
28268 8305           50                         push	ax
28269                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28270 8306           FF76         06            push	6[bp]
28271                                           ! Debug: func () void = write_word+0 (used reg = )
28272 8309           E8         8326            call	_write_word
28273 830C           83C4                   06  add	sp,*6
28274                                           !BCC_EOS
28275                                           ! 4114           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
28276                                           ! Debug: list int = const 0 (used reg = )
28277 830F           31C0                       xor	ax,ax
28278 8311           50                         push	ax
28279                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
28280 8312           8B46         0C            mov	ax,$C[bp]
28281                                           ! Debug: list unsigned int = ax+$32 (used reg = )
28282 8315           05                   0032  add	ax,*$32
28283 8318           50                         push	ax
28284                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28285 8319           FF76         06            push	6[bp]
28286                                           ! Debug: func () void = write_word+0 (used reg = )
28287 831C           E8         8313            call	_write_word
28288 831F           83C4                   06  add	sp,*6
28289                                           !BCC_EOS
28290                                           ! 4115           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
28291                                           ! Debug: list long = const 0 (used reg = )
28292 8322           31C0                       xor	ax,ax
28293 8324           31DB                       xor	bx,bx
28294 8326           53                         push	bx
28295 8327           50                         push	ax
28296                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
28297 8328           8B46         0C            mov	ax,$C[bp]
28298                                           ! Debug: list unsigned int = ax+$34 (used reg = )
28299 832B           05                   0034  add	ax,*$34
28300 832E           50                         push	ax
28301                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
28302 832F           FF76         06            push	6[bp]
28303                                           ! Debug: func () void = write_dword+0 (used reg = )
28304 8332           E8         7D66            call	_write_dword
28305 8335           83C4                   08  add	sp,*8
28306                                           !BCC_EOS
28307                                           ! 4116           }
28308                                           ! 4117         else {
28309 8338           EB           00            jmp .5F4
28310                       0000833A            .5F2:
28311                                           ! 4118           }
28312                                           ! 4119         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
28313                       0000833A            .5F4:
28314                                           ! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
28315 833A           8A46         FD            mov	al,-3[bp]
28316 833D           30E4                       xor	ah,ah
28317 833F           24                     01  and	al,*1
28318                                           ! Debug: list unsigned char = al+0 (used reg = )
28319 8341           30E4                       xor	ah,ah
28320 8343           50                         push	ax
28321                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
28322 8344           8B46         0C            mov	ax,$C[bp]
28323                                           ! Debug: list unsigned int = ax+$38 (used reg = )
28324 8347           05                   0038  add	ax,*$38
28325 834A           50                         push	ax
28326                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28327 834B           FF76         06            push	6[bp]
28328                                           ! Debug: func () void = write_byte+0 (used reg = )
28329 834E           E8         82C9            call	_write_byte
28330 8351           83C4                   06  add	sp,*6
28331                                           !BCC_EOS
28332                                           ! 4120         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
28333                                           ! Debug: list int = const 0 (used reg = )
28334 8354           31C0                       xor	ax,ax
28335 8356           50                         push	ax
28336                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
28337 8357           8B46         0C            mov	ax,$C[bp]
28338                                           ! Debug: list unsigned int = ax+$39 (used reg = )
28339 835A           05                   0039  add	ax,*$39
28340 835D           50                         push	ax
28341                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28342 835E           FF76         06            push	6[bp]
28343                                           ! Debug: func () void = write_byte+0 (used reg = )
28344 8361           E8         82B6            call	_write_byte
28345 8364           83C4                   06  add	sp,*6
28346                                           !BCC_EOS
28347                                           ! 4121         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
28348                                           ! Debug: list int = const 0 (used reg = )
28349 8367           31C0                       xor	ax,ax
28350 8369           50                         push	ax
28351                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
28352 836A           8B46         0C            mov	ax,$C[bp]
28353                                           ! Debug: list unsigned int = ax+$3A (used reg = )
28354 836D           05                   003A  add	ax,*$3A
28355 8370           50                         push	ax
28356                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28357 8371           FF76         06            push	6[bp]
28358                                           ! Debug: func () void = write_word+0 (used reg = )
28359 8374           E8         82BB            call	_write_word
28360 8377           83C4                   06  add	sp,*6
28361                                           !BCC_EOS
28362                                           ! 4122         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
28363                                           ! Debug: list long = const 0 (used reg = )
28364 837A           31C0                       xor	ax,ax
28365 837C           31DB                       xor	bx,bx
28366 837E           53                         push	bx
28367 837F           50                         push	ax
28368                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
28369 8380           8B46         0C            mov	ax,$C[bp]
28370                                           ! Debug: list unsigned int = ax+$3C (used reg = )
28371 8383           05                   003C  add	ax,*$3C
28372 8386           50                         push	ax
28373                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
28374 8387           FF76         06            push	6[bp]
28375                                           ! Debug: func () void = write_dword+0 (used reg = )
28376 838A           E8         7D0E            call	_write_dword
28377 838D           83C4                   08  add	sp,*8
28378                                           !BCC_EOS
28379                                           ! 4123         checksum=0;
28380                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
28381 8390           30C0                       xor	al,al
28382 8392           8846         DD            mov	-$23[bp],al
28383                                           !BCC_EOS
28384                                           ! 4124         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
28385                                           ! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
28386 8395           B0                     1E  mov	al,*$1E
28387 8397           8846         DC            mov	-$24[bp],al
28388                                           !BCC_EOS
28389                                           !BCC_EOS
28390 839A           EB           25            jmp .5F7
28391                       0000839C            .5F8:
28392                                           ! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
28393 839C           8B46         0C            mov	ax,$C[bp]
28394 839F           0246         DC            add	al,-$24[bp]
28395 83A2           80D4                   00  adc	ah,*0
28396                                           ! Debug: list unsigned int = ax+0 (used reg = )
28397 83A5           50                         push	ax
28398                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
28399 83A6           FF76         06            push	6[bp]
28400                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28401 83A9           E8         8248            call	_read_byte
28402 83AC           83C4                   04  add	sp,*4
28403                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
28404 83AF           30E4                       xor	ah,ah
28405 83B1           0246         DD            add	al,-$23[bp]
28406 83B4           80D4                   00  adc	ah,*0
28407 83B7           8846         DD            mov	-$23[bp],al
28408                                           !BCC_EOS
28409                                           ! 4125         checksum = ~checksum;
28410                       000083BA            .5F6:
28411                                           ! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
28412 83BA           8A46         DC            mov	al,-$24[bp]
28413 83BD           40                         inc	ax
28414 83BE           8846         DC            mov	-$24[bp],al
28415                       000083C1            .5F7:
28416                                           ! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
28417 83C1           8A46         DC            mov	al,-$24[bp]
28418 83C4           3C                     40  cmp	al,*$40
28419 83C6           72           D4            jb 	.5F8
28420                       000083C8            .5F9:
28421                       000083C8            .5F5:
28422                                           ! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
28423 83C8           8A46         DD            mov	al,-$23[bp]
28424 83CB           30E4                       xor	ah,ah
28425 83CD           F7D0                       not	ax
28426                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
28427 83CF           8846         DD            mov	-$23[bp],al
28428                                           !BCC_EOS
28429                                           ! 4126         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
28430                                           ! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
28431 83D2           8A46         DD            mov	al,-$23[bp]
28432 83D5           30E4                       xor	ah,ah
28433 83D7           50                         push	ax
28434                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
28435 83D8           8B46         0C            mov	ax,$C[bp]
28436                                           ! Debug: list unsigned int = ax+$41 (used reg = )
28437 83DB           05                   0041  add	ax,*$41
28438 83DE           50                         push	ax
28439                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
28440 83DF           FF76         06            push	6[bp]
28441                                           ! Debug: func () void = write_byte+0 (used reg = )
28442 83E2           E8         8235            call	_write_byte
28443 83E5           83C4                   06  add	sp,*6
28444                                           !BCC_EOS
28445                                           ! 4127         }
28446                                           ! 4128       goto int13_success;
28447                       000083E8            .5ED:
28448 83E8           83C4                   0C  add	sp,#..FFE9-..FFEA
28449 83EB           E9         0110            br 	.FFE9
28450                                           !BCC_EOS
28451                                           ! 4129       break;
28452 83EE           E9         00DD            br 	.5A6
28453                                           !BCC_EOS
28454                                           ! 4130     case 0x49:
28455                                           ! 4131       AX = ((AX & 0x00ff) | ((06) << 8));
28456                       000083F1            .5FA:
28457                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28458 83F1           8A46         18            mov	al,$18[bp]
28459                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
28460 83F4           30E4                       xor	ah,ah
28461 83F6           0D                   0600  or	ax,#$600
28462                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28463 83F9           8946         18            mov	$18[bp],ax
28464                                           !BCC_EOS
28465                                           ! 4132       goto int13_fail_no
28466                                           ! 4132 status;
28467 83FC           83C4                   0C  add	sp,#..FFE7-..FFEA
28468 83FF           E9         00F0            br 	.FFE7
28469                                           !BCC_EOS
28470                                           ! 4133       break;
28471 8402           E9         00C9            br 	.5A6
28472                                           !BCC_EOS
28473                                           ! 4134     case 0x4e:
28474                                           ! 4135       switch (( AX & 0x00ff )) {
28475                       00008405            .5FB:
28476                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28477 8405           8A46         18            mov	al,$18[bp]
28478 8408           EB           10            jmp .5FE
28479                                           ! 4136         case 0x01:
28480                                           ! 4137         case 0x03:
28481                       0000840A            .5FF:
28482                                           ! 4138         case 0x04:
28483                       0000840A            .600:
28484                                           ! 4139         case 0x06:
28485                       0000840A            .601:
28486                                           ! 4140           goto int13_success;
28487                       0000840A            .602:
28488 840A           83C4                   0C  add	sp,#..FFE9-..FFEA
28489 840D           E9         00EE            br 	.FFE9
28490                                           !BCC_EOS
28491                                           ! 4141           break;
28492 8410           EB           1A            jmp .5FC
28493                                           !BCC_EOS
28494                                           ! 4142         default :
28495                                           ! 4143           goto int13_fail;
28496                       00008412            .603:
28497 8412           83C4                   0C  add	sp,#..FFEB-..FFEA
28498 8415           E9         00B9            br 	.FFEB
28499                                           !BCC_EOS
28500                                           ! 4144         }
28501                                           ! 4145       break;
28502 8418           EB           12            jmp .5FC
28503                       0000841A            .5FE:
28504 841A           2C                     01  sub	al,*1
28505 841C           74           EC            je 	.5FF
28506 841E           2C                     02  sub	al,*2
28507 8420           74           E8            je 	.600
28508 8422           2C                     01  sub	al,*1
28509 8424           74           E4            je 	.601
28510 8426           2C                     02  sub	al,*2
28511 8428           74           E0            je 	.602
28512 842A           EB           E6            jmp	.603
28513                       0000842C            .5FC:
28514 842C           E9         009F            br 	.5A6
28515                                           !BCC_EOS
28516                                           ! 4146     case 0x02:
28517                                           ! 4147     case 0x04:
28518                       0000842F            .604:
28519                                           ! 4148     case 0x08:
28520                       0000842F            .605:
28521                                           ! 4149     case 0x0a:
28522                       0000842F            .606:
28523                                           ! 4150     case 0x0b:
28524                       0000842F            .607:
28525                                           ! 4151     case 0x18:
28526                       0000842F            .608:
28527                                           ! 4152     case 0x50:
28528                       0000842F            .609:
28529                                           ! 4153     default:
28530                       0000842F            .60A:
28531                                           ! 4154       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", ( AX >> 8 ));
28532                       0000842F            .60B:
28533                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28534 842F           8B46         18            mov	ax,$18[bp]
28535 8432           88E0                       mov	al,ah
28536 8434           30E4                       xor	ah,ah
28537                                           ! Debug: list unsigned int = ax+0 (used reg = )
28538 8436           50                         push	ax
28539                                           ! Debug: list * char = .60C+0 (used reg = )
28540 8437           BB                   D35E  mov	bx,#.60C
28541 843A           53                         push	bx
28542                                           ! Debug: list int = const 4 (used reg = )
28543 843B           B8                   0004  mov	ax,*4
28544 843E           50                         push	ax
28545                                           ! Debug: func () void = bios_printf+0 (used reg = )
28546 843F           E8         85D7            call	_bios_printf
28547 8442           83C4                   06  add	sp,*6
28548                                           !BCC_EOS
28549                                           ! 4155       goto int13_fail;
28550 8445           83C4                   0C  add	sp,#..FFEB-..FFEA
28551 8448           E9         0086            br 	.FFEB
28552                                           !BCC_EOS
28553                                           ! 4156       break;
28554 844B           E9         0080            br 	.5A6
28555                                           !BCC_EOS
28556                                           ! 4157     }
28557                                           ! 4158 int13_fail:
28558 844E           EB           7E            jmp .5A6
28559                       00008450            .5A8:
28560 8450           83C4                   F4  add	sp,*-$C
28561 8453           2D                   0000  sub	ax,*0
28562 8456           7C           D7            jl 	.60B
28563 8458           3D                   0018  cmp	ax,*$18
28564 845B           77           3B            ja  	.60D
28565 845D           D1E0                       shl	ax,*1
28566 845F           89C3                       mov	bx,ax
28567 8461           2E                         seg	cs
28568 8462           FFA7       8466            br	.60E[bx]
28569                       00008466            .60E:
28570 8466                      7A9E            .word	.5A9
28571 8468                      7ABB            .word	.5B4
28572 846A                      842F            .word	.604
28573 846C                      7AA7            .word	.5B1
28574 846E                      842F            .word	.605
28575 8470                      7AA7            .word	.5B2
28576 8472                      842F            .word	.60B
28577 8474                      842F            .word	.60B
28578 8476                      842F            .word	.606
28579 8478                      7A9E            .word	.5AA
28580 847A                      842F            .word	.607
28581 847C                      842F            .word	.608
28582 847E                      7A9E            .word	.5AB
28583 8480                      7A9E            .word	.5AC
28584 8482                      842F            .word	.60B
28585 8484                      842F            .word	.60B
28586 8486                      7A9E            .word	.5AD
28587 8488                      7A9E            .word	.5AE
28588 848A                      842F            .word	.60B
28589 848C                      842F            .word	.60B
28590 848E                      7A9E            .word	.5AF
28591 8490                      7B0C            .word	.5B8
28592 8492                      7A9E            .word	.5B0
28593 8494                      842F            .word	.60B
28594 8496                      842F            .word	.609
28595                       00008498            .60D:
28596 8498           2D                   0041  sub	ax,*$41
28597 849B           72           92            jb 	.60B
28598 849D           3D                   000F  cmp	ax,*$F
28599 84A0           77           29            ja  	.60F
28600 84A2           D1E0                       shl	ax,*1
28601 84A4           89C3                       mov	bx,ax
28602 84A6           2E                         seg	cs
28603 84A7           FFA7       84AB            br	.610[bx]
28604                       000084AB            .610:
28605 84AB                      7B20            .word	.5B9
28606 84AD                      7B40            .word	.5BA
28607 84AF                      7AA7            .word	.5B3
28608 84B1                      7B40            .word	.5BB
28609 84B3                      7D25            .word	.5C6
28610 84B5                      7E43            .word	.5D9
28611 84B7                      7B40            .word	.5BC
28612 84B9                      7EAC            .word	.5DE
28613 84BB                      83F1            .word	.5FA
28614 84BD                      842F            .word	.60B
28615 84BF                      842F            .word	.60B
28616 84C1                      842F            .word	.60B
28617 84C3                      842F            .word	.60B
28618 84C5                      8405            .word	.5FB
28619 84C7                      842F            .word	.60B
28620 84C9                      842F            .word	.60A
28621                       000084CB            .60F:
28622 84CB           E9         FF61            br 	.60B
28623                       000084CE            .5A6:
28624                       FFFFFFD2            ..FFEA	=	-$2E
28625 84CE           83C4                   0C  add	sp,*$C
28626                       000084D1            .FFEB:
28627                       FFFFFFDE            ..FFEB	=	-$22
28628                                           ! 4159     AX = ((AX & 0x00ff) | ((0x01) << 8));
28629                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28630 84D1           8A46         18            mov	al,$18[bp]
28631                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28632 84D4           30E4                       xor	ah,ah
28633 84D6           0D                   0100  or	ax,#$100
28634                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28635 84D9           8946         18            mov	$18[bp],ax
28636                                           !BCC_EOS
28637                                           ! 4160 int13_fail_noah:
28638                       000084DC            .FFE8:
28639                       FFFFFFDE            ..FFE8	=	-$22
28640                                           ! 4161     write_byte(0x0040, 0x0074, ( AX >> 8 ));
28641                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28642 84DC           8B46         18            mov	ax,$18[bp]
28643 84DF           88E0                       mov	al,ah
28644 84E1           30E4                       xor	ah,ah
28645                                           ! Debug: list unsigned int = ax+0 (used reg = )
28646 84E3           50                         push	ax
28647                                           ! Debug: list int = const $74 (used reg = )
28648 84E4           B8                   0074  mov	ax,*$74
28649 84E7           50                         push	ax
28650                                           ! Debug: list int = const $40 (used reg = )
28651 84E8           B8                   0040  mov	ax,*$40
28652 84EB           50                         push	ax
28653                                           ! Debug: func () void = write_byte+0 (used reg = )
28654 84EC           E8         812B            call	_write_byte
28655 84EF           83C4                   06  add	sp,*6
28656                                           !BCC_EOS
28657                                           ! 4162 int13_fail_nostatus:
28658                       000084F2            .FFE7:
28659                       FFFFFFDE            ..FFE7	=	-$22
28660                                           ! 4163     FLAGS |= 0x0001;
28661                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28662 84F2           8B46         1E            mov	ax,$1E[bp]
28663 84F5           0C                     01  or	al,*1
28664 84F7           8946         1E            mov	$1E[bp],ax
28665                                           !BCC_EOS
28666                                           ! 4164     return;
28667 84FA           89EC                       mov	sp,bp
28668 84FC           5D                         pop	bp
28669 84FD           C3                         ret
28670                                           !BCC_EOS
28671                                           ! 4165 int13_success:
28672                       000084FE            .FFE9:
28673                       FFFFFFDE            ..FFE9	=	-$22
28674                                           ! 4166     AX = ((AX & 0x00ff) | ((0x00) << 8));
28675                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28676 84FE           8A46         18            mov	al,$18[bp]
28677                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28678 8501           0C                     00  or	al,*0
28679                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
28680 8503           30E4                       xor	ah,ah
28681 8505           8946         18            mov	$18[bp],ax
28682                                           !BCC_EOS
28683                                           ! 4167 int13_success_noah:
28684                       00008508            .FFE6:
28685                       FFFFFFDE            ..FFE6	=	-$22
28686                                           ! 4168     write_byte(0x0040, 0x0074, 0x00);
28687                                           ! Debug: list int = const 0 (used reg = )
28688 8508           31C0                       xor	ax,ax
28689 850A           50                         push	ax
28690                                           ! Debug: list int = const $74 (used reg = )
28691 850B           B8                   0074  mov	ax,*$74
28692 850E           50                         push	ax
28693                                           ! Debug: list int = const $40 (used reg = )
28694 850F           B8                   0040  mov	ax,*$40
28695 8512           50                         push	ax
28696                                           ! Debug: func () void = write_byte+0 (used reg = )
28697 8513           E8         8104            call	_write_byte
28698 8516           83C4                   06  add	sp,*6
28699                                           !BCC_EOS
28700                                           ! 4169     FLAGS &= 0xfffe;
28701                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28702 8519           8B46         1E            mov	ax,$1E[bp]
28703 851C           24                     FE  and	al,#$FE
28704 851E           8946         1E            mov	$1E[bp],ax
28705                                           !BCC_EOS
28706                                           ! 4170     return;
28707 8521           89EC                       mov	sp,bp
28708 8523           5D                         pop	bp
28709 8524           C3                         ret
28710                                           !BCC_EOS
28711                                           ! 4171 }
28712                                           ! 4172   void
28713                                           ! Register BX used in function int13_cdrom
28714                                           ! 4173 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28715                                           ! 4174   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28716                                           export	_int13_eltorito
28717                       00008525            _int13_eltorito:
28718                                           !BCC_EOS
28719                                           ! 4175 {
28720                                           ! 4176   Bit16u ebda_seg=read_word(0x0040,0x000E);
28721 8525           55                         push	bp
28722 8526           89E5                       mov	bp,sp
28723 8528           4C                         dec	sp
28724 8529           4C                         dec	sp
28725                                           ! Debug: list int = const $E (used reg = )
28726 852A           B8                   000E  mov	ax,*$E
28727 852D           50                         push	ax
28728                                           ! Debug: list int = const $40 (used reg = )
28729 852E           B8                   0040  mov	ax,*$40
28730 8531           50                         push	ax
28731                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28732 8532           E8         80D2            call	_read_word
28733 8535           83C4                   04  add	sp,*4
28734                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28735 8538           8946         FE            mov	-2[bp],ax
28736                                           !BCC_EOS
28737                                           ! 4177   ;
28738                                           !BCC_EOS
28739                                           ! 4178   switch (( AX >> 8 )) {
28740                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28741 853B           8B46         16            mov	ax,$16[bp]
28742 853E           88E0                       mov	al,ah
28743 8540           30E4                       xor	ah,ah
28744 8542           E9         01BE            br 	.613
28745                                           ! 4179     case 0x4a:
28746                                           ! 4180     case 0x4c:
28747                       00008545            .614:
28748                                           ! 4181     case 0x4d:
28749                       00008545            .615:
28750                                           ! 4182       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
28751                       00008545            .616:
28752                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
28753 8545           FF76         16            push	$16[bp]
28754                                           ! Debug: list * char = .617+0 (used reg = )
28755 8548           BB                   D32D  mov	bx,#.617
28756 854B           53                         push	bx
28757                                           ! Debug: list int = const 7 (used reg = )
28758 854C           B8                   0007  mov	ax,*7
28759 854F           50                         push	ax
28760                                           ! Debug: func () void = bios_printf+0 (used reg = )
28761 8550           E8         84C6            call	_bios_printf
28762 8553           83C4                   06  add	sp,*6
28763                                           !BCC_EOS
28764                                           ! 4183       goto int13_fail;
28765 8556           83C4                   00  add	sp,#..FFE4-..FFE5
28766 8559           E9         01C5            br 	.FFE4
28767                                           !BCC_EOS
28768                                           ! 4184       break;
28769 855C           E9         01C2            br 	.611
28770                                           !BCC_EOS
28771                                           ! 4185     case 0x4b:
28772                                           ! 4186       write_byte(DS,SI+0x00,0x13);
28773                       0000855F            .618:
28774                                           ! Debug: list int = const $13 (used reg = )
28775 855F           B8                   0013  mov	ax,*$13
28776 8562           50                         push	ax
28777                                           ! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
28778 8563           8B46         0A            mov	ax,$A[bp]
28779                                           ! Debug: list unsigned int = ax+0 (used reg = )
28780 8566           50                         push	ax
28781                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28782 8567           FF76         04            push	4[bp]
28783                                           ! Debug: func () void = write_byte+0 (used reg = )
28784 856A           E8         80AD            call	_write_byte
28785 856D           83C4                   06  add	sp,*6
28786                                           !BCC_EOS
28787                                           ! 4187       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
28788                                           ! Debug: list * unsigned char = const $25B (used reg = )
28789 8570           B8                   025B  mov	ax,#$25B
28790 8573           50                         push	ax
28791                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28792 8574           FF76         FE            push	-2[bp]
28793                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28794 8577           E8         807A            call	_read_byte
28795 857A           83C4                   04  add	sp,*4
28796                                           ! Debug: list unsigned char = al+0 (used reg = )
28797 857D           30E4                       xor	ah,ah
28798 857F           50                         push	ax
28799                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
28800 8580           8B46         0A            mov	ax,$A[bp]
28801                                           ! Debug: list unsigned int = ax+1 (used reg = )
28802 8583           40                         inc	ax
28803 8584           50                         push	ax
28804                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28805 8585           FF76         04            push	4[bp]
28806                                           ! Debug: func () void = write_byte+0 (used reg = )
28807 8588           E8         808F            call	_write_byte
28808 858B           83C4                   06  add	sp,*6
28809                                           !BCC_EOS
28810                                           ! 4188       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
28811                                           ! Debug: list * unsigned char = const $25C (used reg = )
28812 858E           B8                   025C  mov	ax,#$25C
28813 8591           50                         push	ax
28814                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28815 8592           FF76         FE            push	-2[bp]
28816                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28817 8595           E8         805C            call	_read_byte
28818 8598           83C4                   04  add	sp,*4
28819                                           ! Debug: list unsigned char = al+0 (used reg = )
28820 859B           30E4                       xor	ah,ah
28821 859D           50                         push	ax
28822                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
28823 859E           8B46         0A            mov	ax,$A[bp]
28824                                           ! Debug: list unsigned int = ax+2 (used reg = )
28825 85A1           40                         inc	ax
28826 85A2           40                         inc	ax
28827 85A3           50                         push	ax
28828                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28829 85A4           FF76         04            push	4[bp]
28830                                           ! Debug: func () void = write_byte+0 (used reg = )
28831 85A7           E8         8070            call	_write_byte
28832 85AA           83C4                   06  add	sp,*6
28833                                           !BCC_EOS
28834                                           ! 4189       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
28835                                           ! Debug: list * unsigned char = const $25D (used reg = )
28836 85AD           B8                   025D  mov	ax,#$25D
28837 85B0           50                         push	ax
28838                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28839 85B1           FF76         FE            push	-2[bp]
28840                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28841 85B4           E8         803D            call	_read_byte
28842 85B7           83C4                   04  add	sp,*4
28843                                           ! Debug: list unsigned char = al+0 (used reg = )
28844 85BA           30E4                       xor	ah,ah
28845 85BC           50                         push	ax
28846                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
28847 85BD           8B46         0A            mov	ax,$A[bp]
28848                                           ! Debug: list unsigned int = ax+3 (used reg = )
28849 85C0           05                   0003  add	ax,*3
28850 85C3           50                         push	ax
28851                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28852 85C4           FF76         04            push	4[bp]
28853                                           ! Debug: func () void = write_byte+0 (used reg = )
28854 85C7           E8         8050            call	_write_byte
28855 85CA           83C4                   06  add	sp,*6
28856                                           !BCC_EOS
28857                                           ! 4190       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
28858                                           ! Debug: list * unsigned long = const $260 (used reg = )
28859 85CD           B8                   0260  mov	ax,#$260
28860 85D0           50                         push	ax
28861                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28862 85D1           FF76         FE            push	-2[bp]
28863                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
28864 85D4           E8         7AAC            call	_read_dword
28865 85D7           89D3                       mov	bx,dx
28866 85D9           83C4                   04  add	sp,*4
28867                                           ! Debug: list unsigned long = bx+0 (used reg = )
28868 85DC           53                         push	bx
28869 85DD           50                         push	ax
28870                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
28871 85DE           8B46         0A            mov	ax,$A[bp]
28872                                           ! Debug: list unsigned int = ax+4 (used reg = )
28873 85E1           05                   0004  add	ax,*4
28874 85E4           50                         push	ax
28875                                           ! Debug: list unsigned short DS = [S+$A+2] (used reg = )
28876 85E5           FF76         04            push	4[bp]
28877                                           ! Debug: func () void = write_dword+0 (used reg = )
28878 85E8           E8         7AB0            call	_write_dword
28879 85EB           83C4                   08  add	sp,*8
28880                                           !BCC_EOS
28881                                           ! 4191       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
28882                                           ! Debug: list * unsigned short = const $25E (used reg = )
28883 85EE           B8                   025E  mov	ax,#$25E
28884 85F1           50                         push	ax
28885                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28886 85F2           FF76         FE            push	-2[bp]
28887                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28888 85F5           E8         800F            call	_read_word
28889 85F8           83C4                   04  add	sp,*4
28890                                           ! Debug: list unsigned short = ax+0 (used reg = )
28891 85FB           50                         push	ax
28892                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
28893 85FC           8B46         0A            mov	ax,$A[bp]
28894                                           ! Debug: list unsigned int = ax+8 (used reg = )
28895 85FF           05                   0008  add	ax,*8
28896 8602           50                         push	ax
28897                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28898 8603           FF76         04            push	4[bp]
28899                                           ! Debug: func () void = write_word+0 (used reg = )
28900 8606           E8         8029            call	_write_word
28901 8609           83C4                   06  add	sp,*6
28902                                           !BCC_EOS
28903                                           ! 4192       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
28904                                           ! Debug: list * unsigned short = const $264 (used reg = )
28905 860C           B8                   0264  mov	ax,#$264
28906 860F           50                         push	ax
28907                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28908 8610           FF76         FE            push	-2[bp]
28909                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28910 8613           E8         7FF1            call	_read_word
28911 8616           83C4                   04  add	sp,*4
28912                                           ! Debug: list unsigned short = ax+0 (used reg = )
28913 8619           50                         push	ax
28914                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
28915 861A           8B46         0A            mov	ax,$A[bp]
28916                                           ! Debug: list unsigned int = ax+$A (used reg = )
28917 861D           05                   000A  add	ax,*$A
28918 8620           50                         push	ax
28919                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28920 8621           FF76         04            push	4[bp]
28921                                           ! Debug: func () void = write_word+0 (used reg = )
28922 8624           E8         800B            call	_write_word
28923 8627           83C4                   06  add	sp,*6
28924                                           !BCC_EOS
28925                                           ! 4193       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
28926                                           ! Debug: list * unsigned short = const $266 (used reg = )
28927 862A           B8                   0266  mov	ax,#$266
28928 862D           50                         push	ax
28929                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28930 862E           FF76         FE            push	-2[bp]
28931                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28932 8631           E8         7FD3            call	_read_word
28933 8634           83C4                   04  add	sp,*4
28934                                           ! Debug: list unsigned short = ax+0 (used reg = )
28935 8637           50                         push	ax
28936                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
28937 8638           8B46         0A            mov	ax,$A[bp]
28938                                           ! Debug: list unsigned int = ax+$C (used reg = )
28939 863B           05                   000C  add	ax,*$C
28940 863E           50                         push	ax
28941                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28942 863F           FF76         04            push	4[bp]
28943                                           ! Debug: func () void = write_word+0 (used reg = )
28944 8642           E8         7FED            call	_write_word
28945 8645           83C4                   06  add	sp,*6
28946                                           !BCC_EOS
28947                                           ! 4194       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
28948                                           ! Debug: list * unsigned short = const $268 (used reg = )
28949 8648           B8                   0268  mov	ax,#$268
28950 864B           50                         push	ax
28951                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28952 864C           FF76         FE            push	-2[bp]
28953                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28954 864F           E8         7FB5            call	_read_word
28955 8652           83C4                   04  add	sp,*4
28956                                           ! Debug: list unsigned short = ax+0 (used reg = )
28957 8655           50                         push	ax
28958                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
28959 8656           8B46         0A            mov	ax,$A[bp]
28960                                           ! Debug: list unsigned int = ax+$E (used reg = )
28961 8659           05                   000E  add	ax,*$E
28962 865C           50                         push	ax
28963                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28964 865D           FF76         04            push	4[bp]
28965                                           ! Debug: func () void = write_word+0 (used reg = )
28966 8660           E8         7FCF            call	_write_word
28967 8663           83C4                   06  add	sp,*6
28968                                           !BCC_EOS
28969                                           ! 4195       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vde
28970                                           ! 4195 vice.cylinders));
28971                                           ! Debug: list * unsigned short = const $26C (used reg = )
28972 8666           B8                   026C  mov	ax,#$26C
28973 8669           50                         push	ax
28974                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28975 866A           FF76         FE            push	-2[bp]
28976                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28977 866D           E8         7F84            call	_read_byte
28978 8670           83C4                   04  add	sp,*4
28979                                           ! Debug: list unsigned char = al+0 (used reg = )
28980 8673           30E4                       xor	ah,ah
28981 8675           50                         push	ax
28982                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
28983 8676           8B46         0A            mov	ax,$A[bp]
28984                                           ! Debug: list unsigned int = ax+$10 (used reg = )
28985 8679           05                   0010  add	ax,*$10
28986 867C           50                         push	ax
28987                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28988 867D           FF76         04            push	4[bp]
28989                                           ! Debug: func () void = write_byte+0 (used reg = )
28990 8680           E8         7F97            call	_write_byte
28991 8683           83C4                   06  add	sp,*6
28992                                           !BCC_EOS
28993                                           ! 4196       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
28994                                           ! Debug: list * unsigned short = const $26E (used reg = )
28995 8686           B8                   026E  mov	ax,#$26E
28996 8689           50                         push	ax
28997                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28998 868A           FF76         FE            push	-2[bp]
28999                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29000 868D           E8         7F64            call	_read_byte
29001 8690           83C4                   04  add	sp,*4
29002                                           ! Debug: list unsigned char = al+0 (used reg = )
29003 8693           30E4                       xor	ah,ah
29004 8695           50                         push	ax
29005                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
29006 8696           8B46         0A            mov	ax,$A[bp]
29007                                           ! Debug: list unsigned int = ax+$11 (used reg = )
29008 8699           05                   0011  add	ax,*$11
29009 869C           50                         push	ax
29010                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29011 869D           FF76         04            push	4[bp]
29012                                           ! Debug: func () void = write_byte+0 (used reg = )
29013 86A0           E8         7F77            call	_write_byte
29014 86A3           83C4                   06  add	sp,*6
29015                                           !BCC_EOS
29016                                           ! 4197       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
29017                                           ! Debug: list * unsigned short = const $26A (used reg = )
29018 86A6           B8                   026A  mov	ax,#$26A
29019 86A9           50                         push	ax
29020                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
29021 86AA           FF76         FE            push	-2[bp]
29022                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29023 86AD           E8         7F44            call	_read_byte
29024 86B0           83C4                   04  add	sp,*4
29025                                           ! Debug: list unsigned char = al+0 (used reg = )
29026 86B3           30E4                       xor	ah,ah
29027 86B5           50                         push	ax
29028                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
29029 86B6           8B46         0A            mov	ax,$A[bp]
29030                                           ! Debug: list unsigned int = ax+$12 (used reg = )
29031 86B9           05                   0012  add	ax,*$12
29032 86BC           50                         push	ax
29033                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
29034 86BD           FF76         04            push	4[bp]
29035                                           ! Debug: func () void = write_byte+0 (used reg = )
29036 86C0           E8         7F57            call	_write_byte
29037 86C3           83C4                   06  add	sp,*6
29038                                           !BCC_EOS
29039                                           ! 4198       if(( AX & 0x00ff ) == 0x00) {
29040                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29041 86C6           8A46         16            mov	al,$16[bp]
29042                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
29043 86C9           84C0                       test	al,al
29044 86CB           75           10            jne 	.619
29045                       000086CD            .61A:
29046                                           ! 4199         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
29047                                           ! Debug: list int = const 0 (used reg = )
29048 86CD           31C0                       xor	ax,ax
29049 86CF           50                         push	ax
29050                                           ! Debug: list * unsigned char = const $25A (used reg = )
29051 86D0           B8                   025A  mov	ax,#$25A
29052 86D3           50                         push	ax
29053                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
29054 86D4           FF76         FE            push	-2[bp]
29055                                           ! Debug: func () void = write_byte+0 (used reg = )
29056 86D7           E8         7F40            call	_write_byte
29057 86DA           83C4                   06  add	sp,*6
29058                                           !BCC_EOS
29059                                           ! 4200         }
29060                                           ! 4201       goto int13_success;
29061                       000086DD            .619:
29062 86DD           83C4                   00  add	sp,#..FFE3-..FFE5
29063 86E0           EB           6C            jmp .FFE3
29064                                           !BCC_EOS
29065                                           ! 4202       break;
29066 86E2           EB           3D            jmp .611
29067                                           !BCC_EOS
29068                                           ! 4203     default:
29069                                           ! 4204       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", ( AX >> 8 ));
29070                       000086E4            .61B:
29071                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
29072 86E4           8B46         16            mov	ax,$16[bp]
29073 86E7           88E0                       mov	al,ah
29074 86E9           30E4                       xor	ah,ah
29075                                           ! Debug: list unsigned int = ax+0 (used reg = )
29076 86EB           50                         push	ax
29077                                           ! Debug: list * char = .61C+0 (used reg = )
29078 86EC           BB                   D308  mov	bx,#.61C
29079 86EF           53                         push	bx
29080                                           ! Debug: list int = const 4 (used reg = )
29081 86F0           B8                   0004  mov	ax,*4
29082 86F3           50                         push	ax
29083                                           ! Debug: func () void = bios_printf+0 (used reg = )
29084 86F4           E8         8322            call	_bios_printf
29085 86F7           83C4                   06  add	sp,*6
29086                                           !BCC_EOS
29087                                           ! 4205       goto int13_fail;
29088 86FA           83C4                   00  add	sp,#..FFE4-..FFE5
29089 86FD           EB           22            jmp .FFE4
29090                                           !BCC_EOS
29091                                           ! 4206       break;
29092 86FF           EB           20            jmp .611
29093                                           !BCC_EOS
29094                                           ! 4207     }
29095                                           ! 4208 int13_fail:
29096 8701           EB           1E            jmp .611
29097                       00008703            .613:
29098 8703           2D                   004A  sub	ax,*$4A
29099 8706         0F84         FE3B            beq 	.614
29100 870A           2D                   0001  sub	ax,*1
29101 870D         0F84         FE4E            beq 	.618
29102 8711           2D                   0001  sub	ax,*1
29103 8714         0F84         FE2D            beq 	.615
29104 8718           2D                   0001  sub	ax,*1
29105 871B         0F84         FE26            beq 	.616
29106 871F           EB           C3            jmp	.61B
29107                       00008721            .611:
29108                       FFFFFFFC            ..FFE5	=	-4
29109                       00008721            .FFE4:
29110                       FFFFFFFC            ..FFE4	=	-4
29111                                           ! 4209     AX = ((AX & 0x00ff) | ((0x01) << 8));
29112                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29113 8721           8A46         16            mov	al,$16[bp]
29114                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
29115 8724           30E4                       xor	ah,ah
29116 8726           0D                   0100  or	ax,#$100
29117                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
29118 8729           8946         16            mov	$16[bp],ax
29119                                           !BCC_EOS
29120                                           ! 4210     write_byte(0x0040, 0x0074, ( AX >> 8 ));
29121                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
29122 872C           8B46         16            mov	ax,$16[bp]
29123 872F           88E0                       mov	al,ah
29124 8731           30E4                       xor	ah,ah
29125                                           ! Debug: list unsigned int = ax+0 (used reg = )
29126 8733           50                         push	ax
29127                                           ! Debug: list int = const $74 (used reg = )
29128 8734           B8                   0074  mov	ax,*$74
29129 8737           50                         push	ax
29130                                           ! Debug: list int = const $40 (used reg = )
29131 8738           B8                   0040  mov	ax,*$40
29132 873B           50                         push	ax
29133                                           ! Debug: func () void = write_byte+0 (used reg = )
29134 873C           E8         7EDB            call	_write_byte
29135 873F           83C4                   06  add	sp,*6
29136                                           !BCC_EOS
29137                                           ! 4211     FLAGS |= 0x0001;
29138                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
29139 8742           8B46         1C            mov	ax,$1C[bp]
29140 8745           0C                     01  or	al,*1
29141 8747           8946         1C            mov	$1C[bp],ax
29142                                           !BCC_EOS
29143                                           ! 4212     return;
29144 874A           89EC                       mov	sp,bp
29145 874C           5D                         pop	bp
29146 874D           C3                         ret
29147                                           !BCC_EOS
29148                                           ! 4213 int13_success:
29149                       0000874E            .FFE3:
29150                       FFFFFFFC            ..FFE3	=	-4
29151                                           ! 4214     AX = ((AX & 0x00ff) | ((0x00) << 8));
29152                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
29153 874E           8A46         16            mov	al,$16[bp]
29154                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
29155 8751           0C                     00  or	al,*0
29156                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
29157 8753           30E4                       xor	ah,ah
29158 8755           8946         16            mov	$16[bp],ax
29159                                           !BCC_EOS
29160                                           ! 4215     write_byte(0x0040, 0x0074, 0x00);
29161                                           ! Debug: list int = const 0 (used reg = )
29162 8758           31C0                       xor	ax,ax
29163 875A           50                         push	ax
29164                                           ! Debug: list int = const $74 (used reg = )
29165 875B           B8                   0074  mov	ax,*$74
29166 875E           50                         push	ax
29167                                           ! Debug: list int = const $40 (used reg = )
29168 875F           B8                   0040  mov	ax,*$40
29169 8762           50                         push	ax
29170                                           ! Debug: func () void = write_byte+0 (used reg = )
29171 8763           E8         7EB4            call	_write_byte
29172 8766           83C4                   06  add	sp,*6
29173                                           !BCC_EOS
29174                                           ! 4216     FLAGS &= 0xfffe;
29175                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
29176 8769           8B46         1C            mov	ax,$1C[bp]
29177 876C           24                     FE  and	al,#$FE
29178 876E           8946         1C            mov	$1C[bp],ax
29179                                           !BCC_EOS
29180                                           ! 4217     return;
29181 8771           89EC                       mov	sp,bp
29182 8773           5D                         pop	bp
29183 8774           C3                         ret
29184                                           !BCC_EOS
29185                                           ! 4218 }
29186                                           ! 4219   void
29187                                           ! Register BX used in function int13_eltorito
29188                                           ! 4220 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
29189                                           ! 4221   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
29190                                           export	_int13_cdemu
29191                       00008775            _int13_cdemu:
29192                                           !BCC_EOS
29193                                           ! 4222 {
29194                                           ! 4223   Bit16u ebda_seg=read_word(0x0040,0x000E);
29195 8775           55                         push	bp
29196 8776           89E5                       mov	bp,sp
29197 8778           4C                         dec	sp
29198 8779           4C                         dec	sp
29199                                           ! Debug: list int = const $E (used reg = )
29200 877A           B8                   000E  mov	ax,*$E
29201 877D           50                         push	ax
29202                                           ! Debug: list int = const $40 (used reg = )
29203 877E           B8                   0040  mov	ax,*$40
29204 8781           50                         push	ax
29205                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29206 8782           E8         7E82            call	_read_word
29207 8785           83C4                   04  add	sp,*4
29208                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
29209 8788           8946         FE            mov	-2[bp],ax
29210                                           !BCC_EOS
29211                                           ! 4224   Bit8u device, status;
29212                                           !BCC_EOS
29213                                           ! 4225   Bit16u vheads, vspt, vcylinders;
29214                                           !BCC_EOS
29215                                           ! 4226   Bit16u head, sector, cylinder, nbsectors;
29216                                           !BCC_EOS
29217                                           ! 4227   Bit32u vlba, ilba, slba, elba;
29218                                           !BCC_EOS
29219                                           ! 4228   Bit16u before, segment, offset;
29220                                           !BCC_EOS
29221                                           ! 4229   Bit8u atacmd[12];
29222                                           !BCC_EOS
29223                                           ! 4230   ;
29224 878B           83C4                   CE  add	sp,*-$32
29225                                           !BCC_EOS
29226                                           ! 4231   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
29227                                           ! Debug: list * unsigned char = const $25D (used reg = )
29228 878E           B8                   025D  mov	ax,#$25D
29229 8791           50                         push	ax
29230                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29231 8792           FF76         FE            push	-2[bp]
29232                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29233 8795           E8         7E5C            call	_read_byte
29234 8798           83C4                   04  add	sp,*4
29235                                           ! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
29236 879B           30E4                       xor	ah,ah
29237 879D           D1E0                       shl	ax,*1
29238                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
29239 879F           8846         FD            mov	-3[bp],al
29240                                           !BCC_EOS
29241                                           ! 4232   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
29242                                           ! Debug: list * unsigned short = const $25E (used reg = )
29243 87A2           B8                   025E  mov	ax,#$25E
29244 87A5           50                         push	ax
29245                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29246 87A6           FF76         FE            push	-2[bp]
29247                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29248 87A9           E8         7E48            call	_read_byte
29249 87AC           83C4                   04  add	sp,*4
29250                                           ! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
29251 87AF           30E4                       xor	ah,ah
29252 87B1           0246         FD            add	al,-3[bp]
29253 87B4           80D4                   00  adc	ah,*0
29254 87B7           8846         FD            mov	-3[bp],al
29255                                           !BCC_EOS
29256                                           ! 4233   write_byte(0x0040, 0x0074, 0x00);
29257                                           ! Debug: list int = const 0 (used reg = )
29258 87BA           31C0                       xor	ax,ax
29259 87BC           50                         push	ax
29260                                           ! Debug: list int = const $74 (used reg = )
29261 87BD           B8                   0074  mov	ax,*$74
29262 87C0           50                         push	ax
29263                                           ! Debug: list int = const $40 (used reg = )
29264 87C1           B8                   0040  mov	ax,*$40
29265 87C4           50                         push	ax
29266                                           ! Debug: func () void = write_byte+0 (used reg = )
29267 87C5           E8         7E52            call	_write_byte
29268 87C8           83C4                   06  add	sp,*6
29269                                           !BCC_EOS
29270                                           ! 4234   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
29271                                           ! 4235    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
29272                                           ! Debug: list * unsigned char = const $25A (used reg = )
29273 87CB           B8                   025A  mov	ax,#$25A
29274 87CE           50                         push	ax
29275                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29276 87CF           FF76         FE            push	-2[bp]
29277                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29278 87D2           E8         7E1F            call	_read_byte
29279 87D5           83C4                   04  add	sp,*4
29280                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
29281 87D8           84C0                       test	al,al
29282 87DA           74           19            je  	.61E
29283                       000087DC            .61F:
29284                                           ! Debug: expression subtree swapping
29285                                           ! Debug: list * unsigned char = const $25C (used reg = )
29286 87DC           B8                   025C  mov	ax,#$25C
29287 87DF           50                         push	ax
29288                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29289 87E0           FF76         FE            push	-2[bp]
29290                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29291 87E3           E8         7E0E            call	_read_byte
29292 87E6           83C4                   04  add	sp,*4
29293 87E9           50                         push	ax
29294                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
29295 87EA           8A46         12            mov	al,$12[bp]
29296                                           ! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29297 87ED           3A46         CA            cmp	al,-$36[bp]
29298 87F0           8D66         CC            lea	sp,-$34[bp]
29299 87F3           74           22            je  	.61D
29300                       000087F5            .61E:
29301                                           ! 4236     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", ( AX >> 8 ), ( DX & 0x00ff ));
29302                                           ! Debug: and int = const $FF to unsigned short DX = [S+$36+$10] (used reg = )
29303 87F5           8A46         12            mov	al,$12[bp]
29304                                           ! Debug: list unsigned char = al+0 (used reg = )
29305 87F8           30E4                       xor	ah,ah
29306 87FA           50                         push	ax
29307                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
29308 87FB           8B46         16            mov	ax,$16[bp]
29309 87FE           88E0                       mov	al,ah
29310 8800           30E4                       xor	ah,ah
29311                                           ! Debug: list unsigned int = ax+0 (used reg = )
29312 8802           50                         push	ax
29313                                           ! Debug: list * char = .620+0 (used reg = )
29314 8803           BB                   D2C9  mov	bx,#.620
29315 8806           53                         push	bx
29316                                           ! Debug: list int = const 4 (used reg = )
29317 8807           B8                   0004  mov	ax,*4
29318 880A           50                         push	ax
29319                                           ! Debug: func () void = bios_printf+0 (used reg = )
29320 880B           E8         820B            call	_bios_printf
29321 880E           83C4                   08  add	sp,*8
29322                                           !BCC_EOS
29323                                           ! 4237     goto int13_fail;
29324 8811           83C4                   00  add	sp,#..FFE2+$36
29325 8814           E9         0563            br 	.FFE2
29326                                           !BCC_EOS
29327                                           ! 4238     }
29328                                           ! 4239   switch (( AX >> 8 )) {
29329                       00008817            .61D:
29330                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29331 8817           8B46         16            mov	ax,$16[bp]
29332 881A           88E0                       mov	al,ah
29333 881C           30E4                       xor	ah,ah
29334 881E           E9         04DE            br 	.623
29335                                           ! 4240     case 0x00:
29336                                           ! 4241     case 0x09:
29337                       00008821            .624:
29338                                           ! 4242     case 0x0c:
29339                       00008821            .625:
29340                                           ! 4243     case 0x0d:
29341                       00008821            .626:
29342                                           ! 4244     case 0x10:
29343                       00008821            .627:
29344                                           ! 4245     case 0x11:
29345                       00008821            .628:
29346                                           ! 4246     case 0x14:
29347                       00008821            .629:
29348                                           ! 4247     case 0x16:
29349                       00008821            .62A:
29350                                           ! 4248       goto int13_success;
29351                       00008821            .62B:
29352 8821           83C4                   00  add	sp,#..FFE0-..FFE1
29353 8824           E9         0580            br 	.FFE0
29354                                           !BCC_EOS
29355                                           ! 4249       break;
29356 8827           E9         0550            br 	.621
29357                                           !BCC_EOS
29358                                           ! 4250     case 0x03:
29359                                           ! 4251     case 0x05:
29360                       0000882A            .62C:
29361                                           ! 4252       AX = ((AX & 0x00ff) | ((0x03) << 8));
29362                       0000882A            .62D:
29363                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29364 882A           8A46         16            mov	al,$16[bp]
29365                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
29366 882D           30E4                       xor	ah,ah
29367 882F           0D                   0300  or	ax,#$300
29368                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29369 8832           8946         16            mov	$16[bp],ax
29370                                           !BCC_EOS
29371                                           ! 4253       goto int13_fail_noah;
29372 8835           83C4                   00  add	sp,#..FFDF-..FFE1
29373 8838           E9         054A            br 	.FFDF
29374                                           !BCC_EOS
29375                                           ! 4254       break;
29376 883B           E9         053C            br 	.621
29377                                           !BCC_EOS
29378                                           ! 4255     case 0x01:
29379                                           ! 4256       status=read_byte(0x0040, 0x0074);
29380                       0000883E            .62E:
29381                                           ! Debug: list int = const $74 (used reg = )
29382 883E           B8                   0074  mov	ax,*$74
29383 8841           50                         push	ax
29384                                           ! Debug: list int = const $40 (used reg = )
29385 8842           B8                   0040  mov	ax,*$40
29386 8845           50                         push	ax
29387                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29388 8846           E8         7DAB            call	_read_byte
29389 8849           83C4                   04  add	sp,*4
29390                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
29391 884C           8846         FC            mov	-4[bp],al
29392                                           !BCC_EOS
29393                                           ! 4257       AX = ((AX & 0x00ff) | ((status) << 8));
29394                                           ! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
29395 884F           8A46         FC            mov	al,-4[bp]
29396 8852           30E4                       xor	ah,ah
29397 8854           88C4                       mov	ah,al
29398 8856           30C0                       xor	al,al
29399 8858           50                         push	ax
29400                                           ! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
29401 8859           8A46         16            mov	al,$16[bp]
29402                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29403 885C           30E4                       xor	ah,ah
29404 885E           0B46         CA            or	ax,0+..FFE1[bp]
29405 8861           44                         inc	sp
29406 8862           44                         inc	sp
29407                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29408 8863           8946         16            mov	$16[bp],ax
29409                                           !BCC_EOS
29410                                           ! 4258       write_byte(0x0040, 
29411                                           ! 4258 0x0074, 0);
29412                                           ! Debug: list int = const 0 (used reg = )
29413 8866           31C0                       xor	ax,ax
29414 8868           50                         push	ax
29415                                           ! Debug: list int = const $74 (used reg = )
29416 8869           B8                   0074  mov	ax,*$74
29417 886C           50                         push	ax
29418                                           ! Debug: list int = const $40 (used reg = )
29419 886D           B8                   0040  mov	ax,*$40
29420 8870           50                         push	ax
29421                                           ! Debug: func () void = write_byte+0 (used reg = )
29422 8871           E8         7DA6            call	_write_byte
29423 8874           83C4                   06  add	sp,*6
29424                                           !BCC_EOS
29425                                           ! 4259       if (status) goto int13_fail_nostatus;
29426 8877           8A46         FC            mov	al,-4[bp]
29427 887A           84C0                       test	al,al
29428 887C           74           08            je  	.62F
29429                       0000887E            .630:
29430 887E           83C4                   00  add	sp,#..FFDE-..FFE1
29431 8881           E9         0517            br 	.FFDE
29432                                           !BCC_EOS
29433                                           ! 4260       else goto int13_success_noah;
29434 8884           EB           06            jmp .631
29435                       00008886            .62F:
29436 8886           83C4                   00  add	sp,#..FFDD-..FFE1
29437 8889           E9         0525            br 	.FFDD
29438                                           !BCC_EOS
29439                                           ! 4261       break;
29440                       0000888C            .631:
29441 888C           E9         04EB            br 	.621
29442                                           !BCC_EOS
29443                                           ! 4262     case 0x02:
29444                                           ! 4263     case 0x04:
29445                       0000888F            .632:
29446                                           ! 4264       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
29447                       0000888F            .633:
29448                                           ! Debug: list * unsigned short = const $26E (used reg = )
29449 888F           B8                   026E  mov	ax,#$26E
29450 8892           50                         push	ax
29451                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29452 8893           FF76         FE            push	-2[bp]
29453                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29454 8896           E8         7D6E            call	_read_word
29455 8899           83C4                   04  add	sp,*4
29456                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
29457 889C           8946         F8            mov	-8[bp],ax
29458                                           !BCC_EOS
29459                                           ! 4265       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
29460                                           ! Debug: list * unsigned short = const $26C (used reg = )
29461 889F           B8                   026C  mov	ax,#$26C
29462 88A2           50                         push	ax
29463                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29464 88A3           FF76         FE            push	-2[bp]
29465                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29466 88A6           E8         7D5E            call	_read_word
29467 88A9           83C4                   04  add	sp,*4
29468                                           ! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
29469 88AC           8946         F6            mov	-$A[bp],ax
29470                                           !BCC_EOS
29471                                           ! 4266       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
29472                                           ! Debug: list * unsigned short = const $26A (used reg = )
29473 88AF           B8                   026A  mov	ax,#$26A
29474 88B2           50                         push	ax
29475                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29476 88B3           FF76         FE            push	-2[bp]
29477                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29478 88B6           E8         7D4E            call	_read_word
29479 88B9           83C4                   04  add	sp,*4
29480                                           ! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
29481 88BC           8946         FA            mov	-6[bp],ax
29482                                           !BCC_EOS
29483                                           ! 4267       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
29484                                           ! Debug: list * unsigned long = const $260 (used reg = )
29485 88BF           B8                   0260  mov	ax,#$260
29486 88C2           50                         push	ax
29487                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29488 88C3           FF76         FE            push	-2[bp]
29489                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
29490 88C6           E8         77BA            call	_read_dword
29491 88C9           89D3                       mov	bx,dx
29492 88CB           83C4                   04  add	sp,*4
29493                                           ! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
29494 88CE           8946         E6            mov	-$1A[bp],ax
29495 88D1           895E         E8            mov	-$18[bp],bx
29496                                           !BCC_EOS
29497                                           ! 4268       sector = ( CX & 0x00ff ) & 0x003f;
29498                                           ! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
29499 88D4           8A46         14            mov	al,$14[bp]
29500                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
29501 88D7           24                     3F  and	al,*$3F
29502                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
29503 88D9           30E4                       xor	ah,ah
29504 88DB           8946         F2            mov	-$E[bp],ax
29505                                           !BCC_EOS
29506                                           ! 4269       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
29507                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
29508 88DE           8B46         14            mov	ax,$14[bp]
29509 88E1           88E0                       mov	al,ah
29510 88E3           30E4                       xor	ah,ah
29511 88E5           50                         push	ax
29512                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
29513 88E6           8A46         14            mov	al,$14[bp]
29514                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
29515 88E9           24                     C0  and	al,#$C0
29516                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
29517 88EB           30E4                       xor	ah,ah
29518 88ED           D1E0                       shl	ax,*1
29519 88EF           D1E0                       shl	ax,*1
29520                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
29521 88F1           0B46         CA            or	ax,0+..FFE1[bp]
29522 88F4           44                         inc	sp
29523 88F5           44                         inc	sp
29524                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
29525 88F6           8946         F0            mov	-$10[bp],ax
29526                                           !BCC_EOS
29527                                           ! 4270       head = ( DX >> 8 );
29528                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
29529 88F9           8B46         12            mov	ax,$12[bp]
29530 88FC           88E0                       mov	al,ah
29531 88FE           30E4                       xor	ah,ah
29532                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
29533 8900           8946         F4            mov	-$C[bp],ax
29534                                           !BCC_EOS
29535                                           ! 4271       nbsectors = ( AX & 0x00ff );
29536                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29537 8903           8A46         16            mov	al,$16[bp]
29538                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29539 8906           30E4                       xor	ah,ah
29540 8908           8946         EE            mov	-$12[bp],ax
29541                                           !BCC_EOS
29542                                           ! 4272       segment = ES;
29543                                           ! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
29544 890B           8B46         06            mov	ax,6[bp]
29545 890E           8946         DA            mov	-$26[bp],ax
29546                                           !BCC_EOS
29547                                           ! 4273       offset = BX;
29548                                           ! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
29549 8911           8B46         10            mov	ax,$10[bp]
29550 8914           8946         D8            mov	-$28[bp],ax
29551                                           !BCC_EOS
29552                                           ! 4274       if(nbsectors==0) goto int13_success;
29553                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29554 8917           8B46         EE            mov	ax,-$12[bp]
29555 891A           85C0                       test	ax,ax
29556 891C           75           06            jne 	.634
29557                       0000891E            .635:
29558 891E           83C4                   00  add	sp,#..FFE0-..FFE1
29559 8921           E9         0483            br 	.FFE0
29560                                           !BCC_EOS
29561                                           ! 4275       if ((sector > vspt)
29562                       00008924            .634:
29563                                           ! 4276        || (cylinder >= vcylinders)
29564                                           ! 4277        || (head >= vheads)) {
29565                                           ! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
29566 8924           8B46         F2            mov	ax,-$E[bp]
29567 8927           3B46         F8            cmp	ax,-8[bp]
29568 892A           77           10            ja  	.637
29569                       0000892C            .639:
29570                                           ! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
29571 892C           8B46         F0            mov	ax,-$10[bp]
29572 892F           3B46         F6            cmp	ax,-$A[bp]
29573 8932           73           08            jae 	.637
29574                       00008934            .638:
29575                                           ! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
29576 8934           8B46         F4            mov	ax,-$C[bp]
29577 8937           3B46         FA            cmp	ax,-6[bp]
29578 893A           72           06            jb  	.636
29579                       0000893C            .637:
29580                                           ! 4278         goto int13_fail;
29581 893C           83C4                   00  add	sp,#..FFE2-..FFE1
29582 893F           E9         0438            br 	.FFE2
29583                                           !BCC_EOS
29584                                           ! 4279         }
29585                                           ! 4280       if (( AX >> 8 ) == 0x04) goto int13_success;
29586                       00008942            .636:
29587                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29588 8942           8B46         16            mov	ax,$16[bp]
29589 8945           88E0                       mov	al,ah
29590 8947           30E4                       xor	ah,ah
29591                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
29592 8949           3D                   0004  cmp	ax,*4
29593 894C           75           06            jne 	.63A
29594                       0000894E            .63B:
29595 894E           83C4                   00  add	sp,#..FFE0-..FFE1
29596 8951           E9         0453            br 	.FFE0
29597                                           !BCC_EOS
29598                                           ! 4281       segment = ES+(BX / 16);
29599                       00008954            .63A:
29600                                           ! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
29601 8954           8B46         10            mov	ax,$10[bp]
29602 8957           B1                     04  mov	cl,*4
29603 8959           D3E8                       shr	ax,cl
29604                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
29605                                           ! Debug: expression subtree swapping
29606 895B           0346         06            add	ax,6[bp]
29607                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
29608 895E           8946         DA            mov	-$26[bp],ax
29609                                           !BCC_EOS
29610                                           ! 4282       offset = BX % 16;
29611                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
29612 8961           8B46         10            mov	ax,$10[bp]
29613 8964           24                     0F  and	al,*$F
29614                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
29615 8966           30E4                       xor	ah,ah
29616 8968           8946         D8            mov	-$28[bp],ax
29617                                           !BCC_EOS
29618                                           ! 4283       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
29619                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
29620 896B           8B46         F2            mov	ax,-$E[bp]
29621                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
29622 896E           48                         dec	ax
29623 896F           31DB                       xor	bx,bx
29624 8971           53                         push	bx
29625 8972           50                         push	ax
29626                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
29627 8973           8B46         F8            mov	ax,-8[bp]
29628 8976           31DB                       xor	bx,bx
29629 8978           53                         push	bx
29630 8979           50                         push	ax
29631                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
29632 897A           8B46         F4            mov	ax,-$C[bp]
29633 897D           31DB                       xor	bx,bx
29634 897F           53                         push	bx
29635 8980           50                         push	ax
29636                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
29637 8981           8B46         FA            mov	ax,-6[bp]
29638 8984           31DB                       xor	bx,bx
29639 8986           53                         push	bx
29640 8987           50                         push	ax
29641                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
29642 8988           8B46         F0            mov	ax,-$10[bp]
29643 898B           31DB                       xor	bx,bx
29644                                           ! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
29645 898D           8D7E         BC            lea	di,-$E+..FFE1[bp]
29646 8990           E8         7756            call	lmulul
29647 8993           83C4                   04  add	sp,*4
29648                                           ! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
29649 8996           8D7E         C0            lea	di,-$A+..FFE1[bp]
29650 8999           E8         7727            call	laddul
29651 899C           83C4                   04  add	sp,*4
29652                                           ! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
29653 899F           8D7E         C4            lea	di,-6+..FFE1[bp]
29654 89A2           E8         7744            call	lmulul
29655 89A5           83C4                   04  add	sp,*4
29656                                           ! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
29657 89A8           8D7E         C8            lea	di,-2+..FFE1[bp]
29658 89AB           E8         7715            call	laddul
29659 89AE           83C4                   04  add	sp,*4
29660                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29661 89B1           8946         EA            mov	-$16[bp],ax
29662 89B4           895E         EC            mov	-$14[bp],bx
29663                                           !BCC_EOS
29664                                           ! 4284       AX = ((AX & 0xff00) | (nbsectors));
29665                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29666 89B7           8B46         16            mov	ax,$16[bp]
29667 89BA           30C0                       xor	al,al
29668                                           ! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
29669 89BC           0B46         EE            or	ax,-$12[bp]
29670                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29671 89BF           8946         16            mov	$16[bp],ax
29672                                           !BCC_EOS
29673                                           ! 4285       slba = (Bit32u)vlba/4;
29674                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
29675 89C2           B8                   0004  mov	ax,*4
29676 89C5           31DB                       xor	bx,bx
29677 89C7           53                         push	bx
29678 89C8           50                         push	ax
29679 89C9           8B46         EA            mov	ax,-$16[bp]
29680 89CC           8B5E         EC            mov	bx,-$14[bp]
29681 89CF           8D7E         C8            lea	di,-2+..FFE1[bp]
29682 89D2           E8         7799            call	ldivul
29683 89D5           83C4                   04  add	sp,*4
29684                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
29685 89D8           8946         E2            mov	-$1E[bp],ax
29686 89DB           895E         E4            mov	-$1C[bp],bx
29687                                           !BCC_EOS
29688                                           ! 4286       before= (Bit16u)vlba%4;
29689                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
29690 89DE           8B46         EA            mov	ax,-$16[bp]
29691 89E1           24                     03  and	al,*3
29692                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
29693 89E3           30E4                       xor	ah,ah
29694 89E5           8946         DC            mov	-$24[bp],ax
29695                                           !BCC_EOS
29696                                           ! 4287       elba = (Bit32u)(vlba+nbsectors-1)/4;
29697                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29698 89E8           8B46         EE            mov	ax,-$12[bp]
29699 89EB           31DB                       xor	bx,bx
29700                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29701                                           ! Debug: expression subtree swapping
29702 89ED           8D7E         EA            lea	di,-$16[bp]
29703 89F0           E8         76D0            call	laddul
29704                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29705 89F3           53                         push	bx
29706 89F4           50                         push	ax
29707 89F5           B8                   0001  mov	ax,*1
29708 89F8           31DB                       xor	bx,bx
29709 89FA           53                         push	bx
29710 89FB           50                         push	ax
29711 89FC           8B46         C8            mov	ax,-2+..FFE1[bp]
29712 89FF           8B5E         CA            mov	bx,0+..FFE1[bp]
29713 8A02           8D7E         C4            lea	di,-6+..FFE1[bp]
29714 8A05           E8         76D9            call	lsubul
29715 8A08           83C4                   08  add	sp,*8
29716                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
29717                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
29718 8A0B           53                         push	bx
29719 8A0C           50                         push	ax
29720 8A0D           B8                   0004  mov	ax,*4
29721 8A10           31DB                       xor	bx,bx
29722 8A12           53                         push	bx
29723 8A13           50                         push	ax
29724 8A14           8B46         C8            mov	ax,-2+..FFE1[bp]
29725 8A17           8B5E         CA            mov	bx,0+..FFE1[bp]
29726 8A1A           8D7E         C4            lea	di,-6+..FFE1[bp]
29727 8A1D           E8         774E            call	ldivul
29728 8A20           83C4                   08  add	sp,*8
29729                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
29730 8A23           8946         DE            mov	-$22[bp],ax
29731 8A26           895E         E0            mov	-$20[bp],bx
29732                                           !BCC_EOS
29733                                           ! 4288       memsetb(get_SS(),atacmd,0,12);
29734                                           ! Debug: list int = const $C (used reg = )
29735 8A29           B8                   000C  mov	ax,*$C
29736 8A2C           50                         push	ax
29737                                           ! Debug: list int = const 0 (used reg = )
29738 8A2D           31C0                       xor	ax,ax
29739 8A2F           50                         push	ax
29740                                           ! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
29741 8A30           8D5E         CC            lea	bx,-$34[bp]
29742 8A33           53                         push	bx
29743                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29744 8A34           E8         7C16            call	_get_SS
29745                                           ! Debug: list unsigned short = ax+0 (used reg = )
29746 8A37           50                         push	ax
29747                                           ! Debug: func () void = memsetb+0 (used reg = )
29748 8A38           E8         75C5            call	_memsetb
29749 8A3B           83C4                   08  add	sp,*8
29750                                           !BCC_EOS
29751                                           ! 4289       atacmd[0]=0x28;
29752                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
29753 8A3E           B0                     28  mov	al,*$28
29754 8A40           8846         CC            mov	-$34[bp],al
29755                                           !BCC_EOS
29756                                           ! 4290       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
29757                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29758 8A43           8B46         DE            mov	ax,-$22[bp]
29759 8A46           8B5E         E0            mov	bx,-$20[bp]
29760 8A49           8D7E         E2            lea	di,-$1E[bp]
29761 8A4C           E8         7692            call	lsubul
29762                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29763 8A4F           53                         push	bx
29764 8A50           50                         push	ax
29765 8A51           B8                   0001  mov	ax,*1
29766 8A54           31DB                       xor	bx,bx
29767 8A56           53                         push	bx
29768 8A57           50                         push	ax
29769 8A58           8B46         C8            mov	ax,-2+..FFE1[bp]
29770 8A5B           8B5E         CA            mov	bx,0+..FFE1[bp]
29771 8A5E           8D7E         C4            lea	di,-6+..FFE1[bp]
29772 8A61           E8         765F            call	laddul
29773 8A64           83C4                   08  add	sp,*8
29774                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29775                                           ! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
29776 8A67           30C0                       xor	al,al
29777                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
29778 8A69           88E0                       mov	al,ah
29779 8A6B           30E4                       xor	ah,ah
29780                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
29781 8A6D           8846         D3            mov	-$2D[bp],al
29782                                           !BCC_EOS
29783                                           ! 4291       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
29784                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29785 8A70           8B46         DE            mov	ax,-$22[bp]
29786 8A73           8B5E         E0            mov	bx,-$20[bp]
29787 8A76           8D7E         E2            lea	di,-$1E[bp]
29788 8A79           E8         7665            call	lsubul
29789                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29790 8A7C           53                         push	bx
29791 8A7D           50                         push	ax
29792 8A7E           B8                   0001  mov	ax,*1
29793 8A81           31DB                       xor	bx,bx
29794 8A83           53                         push	bx
29795 8A84           50                         push	ax
29796 8A85           8B46         C8            mov	ax,-2+..FFE1[bp]
29797 8A88           8B5E         CA            mov	bx,0+..FFE1[bp]
29798 8A8B           8D7E         C4            lea	di,-6+..FFE1[bp]
29799 8A8E           E8         7632            call	laddul
29800 8A91           83C4                   08  add	sp,*8
29801                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29802                                           ! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
29803                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
29804 8A94           8846         D4            mov	-$2C[bp],al
29805                                           !BCC_EOS
29806                                           ! 4292       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
29807                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29808 8A97           8B46         E6            mov	ax,-$1A[bp]
29809 8A9A           8B5E         E8            mov	bx,-$18[bp]
29810 8A9D           8D7E         E2            lea	di,-$1E[bp]
29811 8AA0           E8         7620            call	laddul
29812                                           ! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
29813 8AA3           53                         push	bx
29814 8AA4           50                         push	ax
29815 8AA5           31C0                       xor	ax,ax
29816 8AA7           BB                   FF00  mov	bx,#$FF00
29817 8AAA           53                         push	bx
29818 8AAB           50                         push	ax
29819 8AAC           8B46         C8            mov	ax,-2+..FFE1[bp]
29820 8AAF           8B5E         CA            mov	bx,0+..FFE1[bp]
29821 8AB2           8D7E         C4            lea	di,-6+..FFE1[bp]
29822 8AB5           E8         7603            call	landul
29823 8AB8           83C4                   08  add	sp,*8
29824                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
29825 8ABB           93                         xchg	bx,ax
29826 8ABC           88E0                       mov	al,ah
29827 8ABE           30E4                       xor	ah,ah
29828 8AC0           31DB                       xor	bx,bx
29829                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
29830 8AC2           8846         CE            mov	-$32[bp],al
29831                                           !BCC_EOS
29832                                           ! 4293       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
29833                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29834 8AC5           8B46         E6            mov	ax,-$1A[bp]
29835 8AC8           8B5E         E8            mov	bx,-$18[bp]
29836 8ACB           8D7E         E2            lea	di,-$1E[bp]
29837 8ACE           E8         75F2            call	laddul
29838                                           ! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
29839 8AD1           53                         push	bx
29840 8AD2           50                         push	ax
29841 8AD3           31C0                       xor	ax,ax
29842 8AD5           BB                   00FF  mov	bx,#$FF
29843 8AD8           53                         push	bx
29844 8AD9           50                         push	ax
29845 8ADA           8B46         C8            mov	ax,-2+..FFE1[bp]
29846 8ADD           8B5E         CA            mov	bx,0+..FFE1[bp]
29847 8AE0           8D7E         C4            lea	di,-6+..FFE1[bp]
29848 8AE3           E8         75D5            call	landul
29849 8AE6           83C4                   08  add	sp,*8
29850                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
29851 8AE9           93                         xchg	bx,ax
29852 8AEA           31DB                       xor	bx,bx
29853                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
29854 8AEC           8846         CF            mov	-$31[bp],al
29855                                           !BCC_EOS
29856                                           ! 4294       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
29857                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29858 8AEF           8B46         E6            mov	ax,-$1A[bp]
29859 8AF2           8B5E         E8            mov	bx,-$18[bp]
29860 8AF5           8D7E         E2            lea	di,-$1E[bp]
29861 8AF8           E8         75C8            call	laddul
29862                                           ! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
29863 8AFB           53                         push	bx
29864 8AFC           50                         push	ax
29865 8AFD           B8                   FF00  mov	ax,#$FF00
29866 8B00           31DB                       xor	bx,bx
29867 8B02           53                         push	bx
29868 8B03           50                         push	ax
29869 8B04           8B46         C8            mov	ax,-2+..FFE1[bp]
29870 8B07           8B5E         CA            mov	bx,0+..FFE1[bp]
29871 8B0A           8D7E         C4            lea	di,-6+..FFE1[bp]
29872 8B0D           E8         75AB            call	landul
29873 8B10           83C4                   08  add	sp,*8
29874                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
29875 8B13           88E0                       mov	al,ah
29876 8B15           88DC                       mov	ah,bl
29877 8B17           88FB                       mov	bl,bh
29878 8B19           28FF                       sub	bh,bh
29879                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
29880 8B1B           8846         D0            mov	-$30[bp],al
29881                                           !BCC_EOS
29882                                           ! 4295       atacmd[5]=(ilba+slba & 0x000000ff);
29883                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29884 8B1E           8B46         E6            mov	ax,-$1A[bp]
29885 8B21           8B5E         E8            mov	bx,-$18[bp]
29886 8B24           8D7E         E2            lea	di,-$1E[bp]
29887 8B27           E8         7599            call	laddul
29888                                           ! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
29889 8B2A           53                         push	bx
29890 8B2B           50                         push	ax
29891 8B2C           B8                   00FF  mov	ax,#$FF
29892 8B2F           31DB                       xor	bx,bx
29893 8B31           53                         push	bx
29894 8B32           50                         push	ax
29895 8B33           8B46         C8            mov	ax,-2+..FFE1[bp]
29896 8B36           8B5E         CA            mov	bx,0+..FFE1[bp]
29897 8B39           8D7E         C4            lea	di,-6+..FFE1[bp]
29898 8B3C           E8         757C            call	landul
29899 8B3F           83C4                   08  add	sp,*8
29900                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
29901 8B42           8846         D1            mov	-$2F[bp],al
29902                                           !BCC_EOS
29903                                           ! 4296       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
29904                                           ! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
29905 8B45           FF76         D8            push	-$28[bp]
29906                                           ! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
29907 8B48           FF76         DA            push	-$26[bp]
29908                                           ! Debug: list int = const 1 (used reg = )
29909 8B4B           B8                   0001  mov	ax,*1
29910 8B4E           50                         push	ax
29911                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
29912 8B4F           8B46         EE            mov	ax,-$12[bp]
29913 8B52           31DB                       xor	bx,bx
29914                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
29915 8B54           53                         push	bx
29916 8B55           50                         push	ax
29917 8B56           B8                   0200  mov	ax,#$200
29918 8B59           31DB                       xor	bx,bx
29919 8B5B           53                         push	bx
29920 8B5C           50                         push	ax
29921 8B5D           8B46         C2            mov	ax,-8+..FFE1[bp]
29922 8B60           8B5E         C4            mov	bx,-6+..FFE1[bp]
29923 8B63           8D7E         BE            lea	di,-$C+..FFE1[bp]
29924 8B66           E8         7580            call	lmulul
29925 8B69           83C4                   08  add	sp,*8
29926                                           ! Debug: list unsigned long = bx+0 (used reg = )
29927 8B6C           53                         push	bx
29928 8B6D           50                         push	ax
29929                                           ! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
29930 8B6E           8B46         DC            mov	ax,-$24[bp]
29931 8B71           B9                   0200  mov	cx,#$200
29932 8B74           F7E9                       imul	cx
29933                                           ! Debug: list unsigned int = ax+0 (used reg = )
29934 8B76           50                         push	ax
29935                                           ! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
29936 8B77           8D5E         CC            lea	bx,-$34[bp]
29937 8B7A           53                         push	bx
29938                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29939 8B7B           E8         7ACF            call	_get_SS
29940                                           ! Debug: list unsigned short = ax+0 (used reg = )
29941 8B7E           50                         push	ax
29942                                           ! Debug: list int = const $C (used reg = )
29943 8B7F           B8                   000C  mov	ax,*$C
29944 8B82           50                         push	ax
29945                                           ! Debug: list unsigned char device = [S+$48-5] (used reg = )
29946 8B83           8A46         FD            mov	al,-3[bp]
29947 8B86           30E4                       xor	ah,ah
29948 8B88           50                         push	ax
29949                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
29950 8B89           E8         AB4D            call	_ata_cmd_packet
29951 8B8C           83C4                   14  add	sp,*$14
29952                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
29953 8B8F           8846         FC            mov	-4[bp],al
29954                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29955 8B92           84C0                       test	al,al
29956 8B94           74           37            je  	.63C
29957                       00008B96            .63D:
29958                                           ! 4297         bios_printf(4, "int13_cdemu: function %02x, error %02x !\n",( AX >> 8 ),status);
29959                                           ! Debug: list unsigned char status = [S+$36-6] (used reg = )
29960 8B96           8A46         FC            mov	al,-4[bp]
29961 8B99           30E4                       xor	ah,ah
29962 8B9B           50                         push	ax
29963                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
29964 8B9C           8B46         16            mov	ax,$16[bp]
29965 8B9F           88E0                       mov	al,ah
29966 8BA1           30E4                       xor	ah,ah
29967                                           ! Debug: list unsigned int = ax+0 (used reg = )
29968 8BA3           50                         push	ax
29969                                           ! Debug: list * char = .63E+0 (used reg = )
29970 8BA4           BB                   D29F  mov	bx,#.63E
29971 8BA7           53                         push	bx
29972                                           ! Debug: list int = const 4 (used reg = )
29973 8BA8           B8                   0004  mov	ax,*4
29974 8BAB           50                         push	ax
29975                                           ! Debug: func () void = bios_printf+0 (used reg = )
29976 8BAC           E8         7E6A            call	_bios_printf
29977 8BAF           83C4                   08  add	sp,*8
29978                                           !BCC_EOS
29979                                           ! 4298         AX = ((AX & 0x00ff) | ((0x02) << 8));
29980                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29981 8BB2           8A46         16            mov	al,$16[bp]
29982                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
29983 8BB5           30E4                       xor	ah,ah
29984 8BB7           0D                   0200  or	ax,#$200
29985                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29986 8BBA           8946         16            mov	$16[bp],ax
29987                                           !BCC_EOS
29988                                           ! 4299         AX = ((AX & 0xff00) | (0));
29989                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29990 8BBD           8B46         16            mov	ax,$16[bp]
29991 8BC0           30C0                       xor	al,al
29992                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29993 8BC2           0C                     00  or	al,*0
29994                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29995 8BC4           8946         16            mov	$16[bp],ax
29996                                           !BCC_EOS
29997                                           ! 4300         goto int13_fail_noah;
29998 8BC7           83C4                   00  add	sp,#..FFDF-..FFE1
29999 8BCA           E9         01B8            br 	.FFDF
30000                                           !BCC_EOS
30001                                           ! 4301         }
30002                                           ! 4302       goto int13_success;
30003                       00008BCD            .63C:
30004 8BCD           83C4                   00  add	sp,#..FFE0-..FFE1
30005 8BD0           E9         01D4            br 	.FFE0
30006                                           !BCC_EOS
30007                                           ! 4303       break;
30008 8BD3           E9         01A4            br 	.621
30009                                           !BCC_EOS
30010                                           ! 4304     case 0x08:
30011                                           ! 4305       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
30012                       00008BD6            .63F:
30013                                           ! Debug: list * unsigned short = const $26E (used reg = )
30014 8BD6           B8                   026E  mov	ax,#$26E
30015 8BD9           50                         push	ax
30016                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30017 8BDA           FF76         FE            push	-2[bp]
30018                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30019 8BDD           E8         7A27            call	_read_word
30020 8BE0           83C4                   04  add	sp,*4
30021                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
30022 8BE3           8946         F8            mov	-8[bp],ax
30023                                           !BCC_EOS
30024                                           ! 4306       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylind
30025                                           ! 4306 ers) - 1;
30026                                           ! Debug: list * unsigned short = const $26C (used reg = )
30027 8BE6           B8                   026C  mov	ax,#$26C
30028 8BE9           50                         push	ax
30029                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30030 8BEA           FF76         FE            push	-2[bp]
30031                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30032 8BED           E8         7A17            call	_read_word
30033 8BF0           83C4                   04  add	sp,*4
30034                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
30035                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
30036 8BF3           48                         dec	ax
30037 8BF4           8946         F6            mov	-$A[bp],ax
30038                                           !BCC_EOS
30039                                           ! 4307       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
30040                                           ! Debug: list * unsigned short = const $26A (used reg = )
30041 8BF7           B8                   026A  mov	ax,#$26A
30042 8BFA           50                         push	ax
30043                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30044 8BFB           FF76         FE            push	-2[bp]
30045                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
30046 8BFE           E8         7A06            call	_read_word
30047 8C01           83C4                   04  add	sp,*4
30048                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
30049                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
30050 8C04           48                         dec	ax
30051 8C05           8946         FA            mov	-6[bp],ax
30052                                           !BCC_EOS
30053                                           ! 4308       AX = ((AX & 0xff00) | (0x00));
30054                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
30055 8C08           8B46         16            mov	ax,$16[bp]
30056 8C0B           30C0                       xor	al,al
30057                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30058 8C0D           0C                     00  or	al,*0
30059                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30060 8C0F           8946         16            mov	$16[bp],ax
30061                                           !BCC_EOS
30062                                           ! 4309       BX = ((BX & 0xff00) | (0x00));
30063                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30064 8C12           8B46         10            mov	ax,$10[bp]
30065 8C15           30C0                       xor	al,al
30066                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30067 8C17           0C                     00  or	al,*0
30068                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30069 8C19           8946         10            mov	$10[bp],ax
30070                                           !BCC_EOS
30071                                           ! 4310       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
30072                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
30073 8C1C           8A46         F6            mov	al,-$A[bp]
30074                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
30075 8C1F           30E4                       xor	ah,ah
30076 8C21           88C4                       mov	ah,al
30077 8C23           30C0                       xor	al,al
30078 8C25           50                         push	ax
30079                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
30080 8C26           8A46         14            mov	al,$14[bp]
30081                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30082 8C29           30E4                       xor	ah,ah
30083 8C2B           0B46         CA            or	ax,0+..FFE1[bp]
30084 8C2E           44                         inc	sp
30085 8C2F           44                         inc	sp
30086                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
30087 8C30           8946         14            mov	$14[bp],ax
30088                                           !BCC_EOS
30089                                           ! 4311       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
30090                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
30091 8C33           8A46         F8            mov	al,-8[bp]
30092 8C36           24                     3F  and	al,*$3F
30093 8C38           50                         push	ax
30094                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
30095 8C39           8B46         F6            mov	ax,-$A[bp]
30096 8C3C           D1E8                       shr	ax,*1
30097 8C3E           D1E8                       shr	ax,*1
30098                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
30099 8C40           24                     C0  and	al,#$C0
30100                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30101 8C42           0A46         CA            or	al,0+..FFE1[bp]
30102 8C45           44                         inc	sp
30103 8C46           44                         inc	sp
30104 8C47           50                         push	ax
30105                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
30106 8C48           8B46         14            mov	ax,$14[bp]
30107 8C4B           30C0                       xor	al,al
30108                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
30109 8C4D           0A46         CA            or	al,0+..FFE1[bp]
30110 8C50           44                         inc	sp
30111 8C51           44                         inc	sp
30112                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
30113 8C52           8946         14            mov	$14[bp],ax
30114                                           !BCC_EOS
30115                                           ! 4312       DX = ((DX & 0x00ff) | ((vheads) << 8));
30116                                           ! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
30117 8C55           8B46         FA            mov	ax,-6[bp]
30118 8C58           88C4                       mov	ah,al
30119 8C5A           30C0                       xor	al,al
30120 8C5C           50                         push	ax
30121                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
30122 8C5D           8A46         12            mov	al,$12[bp]
30123                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
30124 8C60           30E4                       xor	ah,ah
30125 8C62           0B46         CA            or	ax,0+..FFE1[bp]
30126 8C65           44                         inc	sp
30127 8C66           44                         inc	sp
30128                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
30129 8C67           8946         12            mov	$12[bp],ax
30130                                           !BCC_EOS
30131                                           ! 4313       DX = ((DX & 0xff00) | (0x02));
30132                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
30133 8C6A           8B46         12            mov	ax,$12[bp]
30134 8C6D           30C0                       xor	al,al
30135                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
30136 8C6F           0C                     02  or	al,*2
30137                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
30138 8C71           8946         12            mov	$12[bp],ax
30139                                           !BCC_EOS
30140                                           ! 4314       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
30141                                           ! Debug: list * unsigned char = const $25B (used reg = )
30142 8C74           B8                   025B  mov	ax,#$25B
30143 8C77           50                         push	ax
30144                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
30145 8C78           FF76         FE            push	-2[bp]
30146                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30147 8C7B           E8         7976            call	_read_byte
30148 8C7E           83C4                   04  add	sp,*4
30149 8C81           EB           26            jmp .642
30150                                           ! 4315         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
30151                       00008C83            .643:
30152                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30153 8C83           8B46         10            mov	ax,$10[bp]
30154 8C86           30C0                       xor	al,al
30155                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
30156 8C88           0C                     02  or	al,*2
30157                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30158 8C8A           8946         10            mov	$10[bp],ax
30159                                           !BCC_EOS
30160 8C8D           EB           26            jmp .640
30161                                           !BCC_EOS
30162                                           ! 4316         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
30163                       00008C8F            .644:
30164                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30165 8C8F           8B46         10            mov	ax,$10[bp]
30166 8C92           30C0                       xor	al,al
30167                                           ! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
30168 8C94           0C                     04  or	al,*4
30169                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30170 8C96           8946         10            mov	$10[bp],ax
30171                                           !BCC_EOS
30172 8C99           EB           1A            jmp .640
30173                                           !BCC_EOS
30174                                           ! 4317         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
30175                       00008C9B            .645:
30176                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
30177 8C9B           8B46         10            mov	ax,$10[bp]
30178 8C9E           30C0                       xor	al,al
30179                                           ! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
30180 8CA0           0C                     06  or	al,*6
30181                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
30182 8CA2           8946         10            mov	$10[bp],ax
30183                                           !BCC_EOS
30184 8CA5           EB           0E            jmp .640
30185                                           !BCC_EOS
30186                                           ! 4318         }
30187                                           ! 4319 #asm
30188 8CA7           EB           0C            jmp .640
30189                       00008CA9            .642:
30190 8CA9           2C                     01  sub	al,*1
30191 8CAB           74           D6            je 	.643
30192 8CAD           2C                     01  sub	al,*1
30193 8CAF           74           DE            je 	.644
30194 8CB1           2C                     01  sub	al,*1
30195 8CB3           74           E6            je 	.645
30196                       00008CB5            .640:
30197                                           !BCC_EOS
30198                                           !BCC_ASM
30199                       00000040            _int13_cdemu.BP	set	$40
30200                       0000000C            .int13_cdemu.BP	set	$C
30201                       0000004E            _int13_cdemu.CS	set	$4E
30202                       0000001A            .int13_cdemu.CS	set	$1A
30203                       00000022            _int13_cdemu.nbsectors	set	$22
30204                       FFFFFFEE            .int13_cdemu.nbsectors	set	-$12
30205                       00000048            _int13_cdemu.CX	set	$48
30206                       00000014            .int13_cdemu.CX	set	$14
30207                       00000012            _int13_cdemu.elba	set	$12
30208                       FFFFFFDE            .int13_cdemu.elba	set	-$22
30209                       0000000E            _int13_cdemu.segment	set	$E
30210                       FFFFFFDA            .int13_cdemu.segment	set	-$26
30211                       0000003C            _int13_cdemu.DI	set	$3C
30212                       00000008            .int13_cdemu.DI	set	8
30213                       00000050            _int13_cdemu.FLAGS	set	$50
30214                       0000001C            .int13_cdemu.FLAGS	set	$1C
30215                       0000002A            _int13_cdemu.vcylinders	set	$2A
30216                       FFFFFFF6            .int13_cdemu.vcylinders	set	-$A
30217                       00000026            _int13_cdemu.sector	set	$26
30218                       FFFFFFF2            .int13_cdemu.sector	set	-$E
30219                       00000038            _int13_cdemu.DS	set	$38
30220                       00000004            .int13_cdemu.DS	set	4
30221                       00000028            _int13_cdemu.head	set	$28
30222                       FFFFFFF4            .int13_cdemu.head	set	-$C
30223                       00000024            _int13_cdemu.cylinder	set	$24
30224                       FFFFFFF0            .int13_cdemu.cylinder	set	-$10
30225                       00000046            _int13_cdemu.DX	set	$46
30226                       00000012            .int13_cdemu.DX	set	$12
30227                       00000031            _int13_cdemu.device	set	$31
30228                       FFFFFFFD            .int13_cdemu.device	set	-3
30229                       0000003A            _int13_cdemu.ES	set	$3A
30230                       00000006            .int13_cdemu.ES	set	6
30231                       0000002C            _int13_cdemu.vspt	set	$2C
30232                       FFFFFFF8            .int13_cdemu.vspt	set	-8
30233                       0000001E            _int13_cdemu.vlba	set	$1E
30234                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
30235                       00000032            _int13_cdemu.ebda_seg	set	$32
30236                       FFFFFFFE            .int13_cdemu.ebda_seg	set	-2
30237                       0000003E            _int13_cdemu.SI	set	$3E
30238                       0000000A            .int13_cdemu.SI	set	$A
30239                       0000004C            _int13_cdemu.IP	set	$4C
30240                       00000018            .int13_cdemu.IP	set	$18
30241                       00000030            _int13_cdemu.status	set	$30
30242                       FFFFFFFC            .int13_cdemu.status	set	-4
30243                       00000000            _int13_cdemu.atacmd	set	0
30244                       FFFFFFCC            .int13_cdemu.atacmd	set	-$34
30245                       0000004A            _int13_cdemu.AX	set	$4A
30246                       00000016            .int13_cdemu.AX	set	$16
30247                       0000001A            _int13_cdemu.ilba	set	$1A
30248                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
30249                       00000010            _int13_cdemu.before	set	$10
30250                       FFFFFFDC            .int13_cdemu.before	set	-$24
30251                       0000000C            _int13_cdemu.offset	set	$C
30252                       FFFFFFD8            .int13_cdemu.offset	set	-$28
30253                       00000016            _int13_cdemu.slba	set	$16
30254                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
30255                       00000042            _int13_cdemu.SP	set	$42
30256                       0000000E            .int13_cdemu.SP	set	$E
30257                       0000002E            _int13_cdemu.vheads	set	$2E
30258                       FFFFFFFA            .int13_cdemu.vheads	set	-6
30259                       00000044            _int13_cdemu.BX	set	$44
30260                       00000010            .int13_cdemu.BX	set	$10
30261 8CB5           55                               push bp
30262 8CB6           89E5                             mov bp, sp
30263 8CB8           B8                   EFDE        mov ax, #diskette_param_table2
30264 8CBB           8946         3E                  mov _int13_cdemu.DI+2[bp], ax
30265 8CBE           8C4E         3C                  mov _int13_cdemu.ES+2[bp], cs
30266 8CC1           5D                               pop bp
30267                                           ! 4326 endasm
30268                                           !BCC_ENDASM
30269                                           !BCC_EOS
30270                                           ! 4327       goto int13_success;
30271 8CC2           83C4                   00  add	sp,#..FFE0-..FFE1
30272 8CC5           E9         00DF            br 	.FFE0
30273                                           !BCC_EOS
30274                                           ! 4328       break;
30275 8CC8           E9         00AF            br 	.621
30276                                           !BCC_EOS
30277                                           ! 4329     case 0x15:
30278                                           ! 4330       AX = ((AX & 0x00ff) | ((0x03) << 8));
30279                       00008CCB            .646:
30280                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30281 8CCB           8A46         16            mov	al,$16[bp]
30282                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
30283 8CCE           30E4                       xor	ah,ah
30284 8CD0           0D                   0300  or	ax,#$300
30285                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30286 8CD3           8946         16            mov	$16[bp],ax
30287                                           !BCC_EOS
30288                                           ! 4331       goto int13_success_noah;
30289 8CD6           83C4                   00  add	sp,#..FFDD-..FFE1
30290 8CD9           E9         00D5            br 	.FFDD
30291                                           !BCC_EOS
30292                                           ! 4332       break;
30293 8CDC           E9         009B            br 	.621
30294                                           !BCC_EOS
30295                                           ! 4333     case 0x0a:
30296                                           ! 4334     case 0x0b:
30297                       00008CDF            .647:
30298                                           ! 4335     case 0x18:
30299                       00008CDF            .648:
30300                                           ! 4336     case 0x41:
30301                       00008CDF            .649:
30302                                           ! 4337     case 0x42:
30303                       00008CDF            .64A:
30304                                           ! 4338     case 0x43:
30305                       00008CDF            .64B:
30306                                           ! 4339     case 0x44:
30307                       00008CDF            .64C:
30308                                           ! 4340     case 0x45:
30309                       00008CDF            .64D:
30310                                           ! 4341     case 0x46:
30311                       00008CDF            .64E:
30312                                           ! 4342     case 0x47:
30313                       00008CDF            .64F:
30314                                           ! 4343     case 0x48:
30315                       00008CDF            .650:
30316                                           ! 4344     case 0x49:
30317                       00008CDF            .651:
30318                                           ! 4345     case 0x4e:
30319                       00008CDF            .652:
30320                                           ! 4346     case 0x50:
30321                       00008CDF            .653:
30322                                           ! 4347     default:
30323                       00008CDF            .654:
30324                                           ! 4348       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", ( AX >> 8 ));
30325                       00008CDF            .655:
30326                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
30327 8CDF           8B46         16            mov	ax,$16[bp]
30328 8CE2           88E0                       mov	al,ah
30329 8CE4           30E4                       xor	ah,ah
30330                                           ! Debug: list unsigned int = ax+0 (used reg = )
30331 8CE6           50                         push	ax
30332                                           ! Debug: list * char = .656+0 (used reg = )
30333 8CE7           BB                   D267  mov	bx,#.656
30334 8CEA           53                         push	bx
30335                                           ! Debug: list int = const 4 (used reg = )
30336 8CEB           B8                   0004  mov	ax,*4
30337 8CEE           50                         push	ax
30338                                           ! Debug: func () void = bios_printf+0 (used reg = )
30339 8CEF           E8         7D27            call	_bios_printf
30340 8CF2           83C4                   06  add	sp,*6
30341                                           !BCC_EOS
30342                                           ! 4349       goto int13_fail;
30343 8CF5           83C4                   00  add	sp,#..FFE2-..FFE1
30344 8CF8           E9         007F            jmp .FFE2
30345                                           !BCC_EOS
30346                                           ! 4350       break;
30347 8CFB           EB           7D            jmp .621
30348                                           !BCC_EOS
30349                                           ! 4351     }
30350                                           ! 4352 int13_fail:
30351 8CFD           EB           7B            jmp .621
30352                       00008CFF            .623:
30353 8CFF           2D                   0000  sub	ax,*0
30354 8D02           7C           DB            jl 	.655
30355 8D04           3D                   0018  cmp	ax,*$18
30356 8D07           77           3B            ja  	.657
30357 8D09           D1E0                       shl	ax,*1
30358 8D0B           89C3                       mov	bx,ax
30359 8D0D           2E                         seg	cs
30360 8D0E           FFA7       8D12            br	.658[bx]
30361                       00008D12            .658:
30362 8D12                      8821            .word	.624
30363 8D14                      883E            .word	.62E
30364 8D16                      888F            .word	.632
30365 8D18                      882A            .word	.62C
30366 8D1A                      888F            .word	.633
30367 8D1C                      882A            .word	.62D
30368 8D1E                      8CDF            .word	.655
30369 8D20                      8CDF            .word	.655
30370 8D22                      8BD6            .word	.63F
30371 8D24                      8821            .word	.625
30372 8D26                      8CDF            .word	.647
30373 8D28                      8CDF            .word	.648
30374 8D2A                      8821            .word	.626
30375 8D2C                      8821            .word	.627
30376 8D2E                      8CDF            .word	.655
30377 8D30                      8CDF            .word	.655
30378 8D32                      8821            .word	.628
30379 8D34                      8821            .word	.629
30380 8D36                      8CDF            .word	.655
30381 8D38                      8CDF            .word	.655
30382 8D3A                      8821            .word	.62A
30383 8D3C                      8CCB            .word	.646
30384 8D3E                      8821            .word	.62B
30385 8D40                      8CDF            .word	.655
30386 8D42                      8CDF            .word	.649
30387                       00008D44            .657:
30388 8D44           2D                   0041  sub	ax,*$41
30389 8D47           72           96            jb 	.655
30390 8D49           3D                   000F  cmp	ax,*$F
30391 8D4C           77           29            ja  	.659
30392 8D4E           D1E0                       shl	ax,*1
30393 8D50           89C3                       mov	bx,ax
30394 8D52           2E                         seg	cs
30395 8D53           FFA7       8D57            br	.65A[bx]
30396                       00008D57            .65A:
30397 8D57                      8CDF            .word	.64A
30398 8D59                      8CDF            .word	.64B
30399 8D5B                      8CDF            .word	.64C
30400 8D5D                      8CDF            .word	.64D
30401 8D5F                      8CDF            .word	.64E
30402 8D61                      8CDF            .word	.64F
30403 8D63                      8CDF            .word	.650
30404 8D65                      8CDF            .word	.651
30405 8D67                      8CDF            .word	.652
30406 8D69                      8CDF            .word	.655
30407 8D6B                      8CDF            .word	.655
30408 8D6D                      8CDF            .word	.655
30409 8D6F                      8CDF            .word	.655
30410 8D71                      8CDF            .word	.653
30411 8D73                      8CDF            .word	.655
30412 8D75                      8CDF            .word	.654
30413                       00008D77            .659:
30414 8D77           E9         FF65            br 	.655
30415                       00008D7A            .621:
30416                       FFFFFFCA            ..FFE1	=	-$36
30417                       00008D7A            .FFE2:
30418                       FFFFFFCA            ..FFE2	=	-$36
30419                                           ! 4353     AX = ((AX & 0x00ff) | ((0x01) << 8));
30420                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30421 8D7A           8A46         16            mov	al,$16[bp]
30422                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
30423 8D7D           30E4                       xor	ah,ah
30424 8D7F           0D                   0100  or	ax,#$100
30425                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
30426 8D82           8946         16            mov	$16[bp],ax
30427                                           !BCC_EOS
30428                                           ! 4354 int13_fail_noah:
30429                       00008D85            .FFDF:
30430                       FFFFFFCA            ..FFDF	=	-$36
30431                                           ! 4355     write_byte(0x0040, 0x0074, ( AX >> 8 ));
30432                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
30433 8D85           8B46         16            mov	ax,$16[bp]
30434 8D88           88E0                       mov	al,ah
30435 8D8A           30E4                       xor	ah,ah
30436                                           ! Debug: list unsigned int = ax+0 (used reg = )
30437 8D8C           50                         push	ax
30438                                           ! Debug: list int = const $74 (used reg = )
30439 8D8D           B8                   0074  mov	ax,*$74
30440 8D90           50                         push	ax
30441                                           ! Debug: list int = const $40 (used reg = )
30442 8D91           B8                   0040  mov	ax,*$40
30443 8D94           50                         push	ax
30444                                           ! Debug: func () void = write_byte+0 (used reg = )
30445 8D95           E8         7882            call	_write_byte
30446 8D98           83C4                   06  add	sp,*6
30447                                           !BCC_EOS
30448                                           ! 4356 int13_fail_nostatus:
30449                       00008D9B            .FFDE:
30450                       FFFFFFCA            ..FFDE	=	-$36
30451                                           ! 4357     FLAGS |= 0x0001;
30452                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
30453 8D9B           8B46         1C            mov	ax,$1C[bp]
30454 8D9E           0C                     01  or	al,*1
30455 8DA0           8946         1C            mov	$1C[bp],ax
30456                                           !BCC_EOS
30457                                           ! 4358     return;
30458 8DA3           89EC                       mov	sp,bp
30459 8DA5           5D                         pop	bp
30460 8DA6           C3                         ret
30461                                           !BCC_EOS
30462                                           ! 4359 int13_success:
30463                       00008DA7            .FFE0:
30464                       FFFFFFCA            ..FFE0	=	-$36
30465                                           ! 4360     AX = ((AX & 0x00ff) | ((0x00) << 8));
30466                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
30467 8DA7           8A46         16            mov	al,$16[bp]
30468                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
30469 8DAA           0C                     00  or	al,*0
30470                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
30471 8DAC           30E4                       xor	ah,ah
30472 8DAE           8946         16            mov	$16[bp],ax
30473                                           !BCC_EOS
30474                                           ! 4361 int13_success_noah:
30475                       00008DB1            .FFDD:
30476                       FFFFFFCA            ..FFDD	=	-$36
30477                                           ! 4362     write_byte(0x0040, 0x0074, 0x00);
30478                                           ! Debug: list int = const 0 (used reg = )
30479 8DB1           31C0                       xor	ax,ax
30480 8DB3           50                         push	ax
30481                                           ! Debug: list int = const $74 (used reg = )
30482 8DB4           B8                   0074  mov	ax,*$74
30483 8DB7           50                         push	ax
30484                                           ! Debug: list int = const $40 (used reg = )
30485 8DB8           B8                   0040  mov	ax,*$40
30486 8DBB           50                         push	ax
30487                                           ! Debug: func () void = write_byte+0 (used reg = )
30488 8DBC           E8         785B            call	_write_byte
30489 8DBF           83C4                   06  add	sp,*6
30490                                           !BCC_EOS
30491                                           ! 4363     FLAGS &= 0xfffe;
30492                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
30493 8DC2           8B46         1C            mov	ax,$1C[bp]
30494 8DC5           24                     FE  and	al,#$FE
30495 8DC7           8946         1C            mov	$1C[bp],ax
30496                                           !BCC_EOS
30497                                           ! 4364     return;
30498 8DCA           89EC                       mov	sp,bp
30499 8DCC           5D                         pop	bp
30500 8DCD           C3                         ret
30501                                           !BCC_EOS
30502                                           ! 4365 }
30503                                           ! 4366 void floppy_reset_controller()
30504                                           ! Register BX used in function int13_cdemu
30505                                           ! 4367 {
30506                                           export	_floppy_reset_controller
30507                       00008DCE            _floppy_reset_controller:
30508                                           ! 4368   Bit8u val8;
30509                                           !BCC_EOS
30510                                           ! 4369   val8 = inb(0x03f2);
30511 8DCE           55                         push	bp
30512 8DCF           89E5                       mov	bp,sp
30513 8DD1           4C                         dec	sp
30514 8DD2           4C                         dec	sp
30515                                           ! Debug: list int = const $3F2 (used reg = )
30516 8DD3           B8                   03F2  mov	ax,#$3F2
30517 8DD6           50                         push	ax
30518                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30519 8DD7           E8         7764            call	_inb
30520 8DDA           44                         inc	sp
30521 8DDB           44                         inc	sp
30522                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
30523 8DDC           8846         FF            mov	-1[bp],al
30524                                           !BCC_EOS
30525                                           ! 4370   outb(0x03f2, val8 & ~0x04);
30526                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
30527 8DDF           8A46         FF            mov	al,-1[bp]
30528 8DE2           24                     FB  and	al,#$FB
30529                                           ! Debug: list unsigned char = al+0 (used reg = )
30530 8DE4           30E4                       xor	ah,ah
30531 8DE6           50                         push	ax
30532                                           ! Debug: list int = const $3F2 (used reg = )
30533 8DE7           B8                   03F2  mov	ax,#$3F2
30534 8DEA           50                         push	ax
30535                                           ! Debug: func () void = outb+0 (used reg = )
30536 8DEB           E8         7766            call	_outb
30537 8DEE           83C4                   04  add	sp,*4
30538                                           !BCC_EOS
30539                                           ! 4371   outb(0x03f2, val8 | 0x04);
30540                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
30541 8DF1           8A46         FF            mov	al,-1[bp]
30542 8DF4           0C                     04  or	al,*4
30543                                           ! Debug: list unsigned char = al+0 (used reg = )
30544 8DF6           30E4                       xor	ah,ah
30545 8DF8           50                         push	ax
30546                                           ! Debug: list int = const $3F2 (used reg = )
30547 8DF9           B8                   03F2  mov	ax,#$3F2
30548 8DFC           50                         push	ax
30549                                           ! Debug: func () void = outb+0 (used reg = )
30550 8DFD           E8         7754            call	_outb
30551 8E00           83C4                   04  add	sp,*4
30552                                           !BCC_EOS
30553                                           ! 4372   do {
30554                       00008E03            .65D:
30555                                           ! 4373     val8 = inb(0x3f4);
30556                                           ! Debug: list int = const $3F4 (used reg = )
30557 8E03           B8                   03F4  mov	ax,#$3F4
30558 8E06           50                         push	ax
30559                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30560 8E07           E8         7734            call	_inb
30561 8E0A           44                         inc	sp
30562 8E0B           44                         inc	sp
30563                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
30564 8E0C           8846         FF            mov	-1[bp],al
30565                                           !BCC_EOS
30566                                           ! 4374   } while ( (val8 & 0xc0) != 0x80 );
30567                       00008E0F            .65C:
30568                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
30569 8E0F           8A46         FF            mov	al,-1[bp]
30570 8E12           24                     C0  and	al,#$C0
30571                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30572 8E14           3C                     80  cmp	al,#$80
30573 8E16           75           EB            jne	.65D
30574                       00008E18            .65E:
30575                                           !BCC_EOS
30576                                           ! 4375 }
30577                       00008E18            .65B:
30578 8E18           89EC                       mov	sp,bp
30579 8E1A           5D                         pop	bp
30580 8E1B           C3                         ret
30581                                           ! 4376 void floppy_prepare_controller(drive)
30582                                           ! 4377   Bit16u drive;
30583                                           export	_floppy_prepare_controller
30584                       00008E1C            _floppy_prepare_controller:
30585                                           !BCC_EOS
30586                                           ! 4378 {
30587                                           ! 4379   Bit8u val8, dor, prev_reset;
30588                                           !BCC_EOS
30589                                           ! 4380   val8 = read_byte(0x0040, 0x003e);
30590 8E1C           55                         push	bp
30591 8E1D           89E5                       mov	bp,sp
30592 8E1F           83C4                   FC  add	sp,*-4
30593                                           ! Debug: list int = const $3E (used reg = )
30594 8E22           B8                   003E  mov	ax,*$3E
30595 8E25           50                         push	ax
30596                                           ! Debug: list int = const $40 (used reg = )
30597 8E26           B8                   0040  mov	ax,*$40
30598 8E29           50                         push	ax
30599                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30600 8E2A           E8         77C7            call	_read_byte
30601 8E2D           83C4                   04  add	sp,*4
30602                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30603 8E30           8846         FF            mov	-1[bp],al
30604                                           !BCC_EOS
30605                                           ! 4381   val8 &= 0x7f;
30606                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30607 8E33           8A46         FF            mov	al,-1[bp]
30608 8E36           24                     7F  and	al,*$7F
30609 8E38           8846         FF            mov	-1[bp],al
30610                                           !BCC_EOS
30611                                           ! 4382   write_byte(0x0040, 0x003e, val8);
30612                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30613 8E3B           8A46         FF            mov	al,-1[bp]
30614 8E3E           30E4                       xor	ah,ah
30615 8E40           50                         push	ax
30616                                           ! Debug: list int = const $3E (used reg = )
30617 8E41           B8                   003E  mov	ax,*$3E
30618 8E44           50                         push	ax
30619                                           ! Debug: list int = const $40 (used reg = )
30620 8E45           B8                   0040  mov	ax,*$40
30621 8E48           50                         push	ax
30622                                           ! Debug: func () void = write_byte+0 (used reg = )
30623 8E49           E8         77CE            call	_write_byte
30624 8E4C           83C4                   06  add	sp,*6
30625                                           !BCC_EOS
30626                                           ! 4383   prev_reset = inb(0x03f2) & 0x04;
30627                                           ! Debug: list int = const $3F2 (used reg = )
30628 8E4F           B8                   03F2  mov	ax,#$3F2
30629 8E52           50                         push	ax
30630                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30631 8E53           E8         76E8            call	_inb
30632 8E56           44                         inc	sp
30633 8E57           44                         inc	sp
30634                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
30635 8E58           24                     04  and	al,*4
30636                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
30637 8E5A           8846         FD            mov	-3[bp],al
30638                                           !BCC_EOS
30639                                           ! 4384   if (drive)
30640 8E5D           8B46         04            mov	ax,4[bp]
30641 8E60           85C0                       test	ax,ax
30642 8E62           74           07            je  	.65F
30643                       00008E64            .660:
30644                                           ! 4385     dor
30645                                           ! 4385  = 0x20;
30646                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
30647 8E64           B0                     20  mov	al,*$20
30648 8E66           8846         FE            mov	-2[bp],al
30649                                           !BCC_EOS
30650                                           ! 4386   else
30651                                           ! 4387     dor = 0x10;
30652 8E69           EB           05            jmp .661
30653                       00008E6B            .65F:
30654                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
30655 8E6B           B0                     10  mov	al,*$10
30656 8E6D           8846         FE            mov	-2[bp],al
30657                                           !BCC_EOS
30658                                           ! 4388   dor |= 0x0c;
30659                       00008E70            .661:
30660                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
30661 8E70           8A46         FE            mov	al,-2[bp]
30662 8E73           0C                     0C  or	al,*$C
30663 8E75           8846         FE            mov	-2[bp],al
30664                                           !BCC_EOS
30665                                           ! 4389   dor |= drive;
30666                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
30667 8E78           8B46         04            mov	ax,4[bp]
30668 8E7B           0A46         FE            or	al,-2[bp]
30669 8E7E           8846         FE            mov	-2[bp],al
30670                                           !BCC_EOS
30671                                           ! 4390   outb(0x03f2, dor);
30672                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
30673 8E81           8A46         FE            mov	al,-2[bp]
30674 8E84           30E4                       xor	ah,ah
30675 8E86           50                         push	ax
30676                                           ! Debug: list int = const $3F2 (used reg = )
30677 8E87           B8                   03F2  mov	ax,#$3F2
30678 8E8A           50                         push	ax
30679                                           ! Debug: func () void = outb+0 (used reg = )
30680 8E8B           E8         76C6            call	_outb
30681 8E8E           83C4                   04  add	sp,*4
30682                                           !BCC_EOS
30683                                           ! 4391   write_byte(0x40,0x40, 37);
30684                                           ! Debug: list int = const $25 (used reg = )
30685 8E91           B8                   0025  mov	ax,*$25
30686 8E94           50                         push	ax
30687                                           ! Debug: list int = const $40 (used reg = )
30688 8E95           B8                   0040  mov	ax,*$40
30689 8E98           50                         push	ax
30690                                           ! Debug: list int = const $40 (used reg = )
30691 8E99           B8                   0040  mov	ax,*$40
30692 8E9C           50                         push	ax
30693                                           ! Debug: func () void = write_byte+0 (used reg = )
30694 8E9D           E8         777A            call	_write_byte
30695 8EA0           83C4                   06  add	sp,*6
30696                                           !BCC_EOS
30697                                           ! 4392   do {
30698                       00008EA3            .664:
30699                                           ! 4393     val8 = inb(0x3f4);
30700                                           ! Debug: list int = const $3F4 (used reg = )
30701 8EA3           B8                   03F4  mov	ax,#$3F4
30702 8EA6           50                         push	ax
30703                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30704 8EA7           E8         7694            call	_inb
30705 8EAA           44                         inc	sp
30706 8EAB           44                         inc	sp
30707                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30708 8EAC           8846         FF            mov	-1[bp],al
30709                                           !BCC_EOS
30710                                           ! 4394   } while ( (val8 & 0xc0) != 0x80 );
30711                       00008EAF            .663:
30712                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
30713 8EAF           8A46         FF            mov	al,-1[bp]
30714 8EB2           24                     C0  and	al,#$C0
30715                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30716 8EB4           3C                     80  cmp	al,#$80
30717 8EB6           75           EB            jne	.664
30718                       00008EB8            .665:
30719                                           !BCC_EOS
30720                                           ! 4395   if (prev_reset == 0) {
30721                       00008EB8            .662:
30722                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
30723 8EB8           8A46         FD            mov	al,-3[bp]
30724 8EBB           84C0                       test	al,al
30725 8EBD           75           38            jne 	.666
30726                       00008EBF            .667:
30727                                           ! 4396 #asm
30728                                           !BCC_EOS
30729                                           !BCC_ASM
30730                       00000002            _floppy_prepare_controller.dor	set	2
30731                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30732                       00000001            _floppy_prepare_controller.prev_reset	set	1
30733                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30734                       00000003            _floppy_prepare_controller.val8	set	3
30735                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30736                       00000008            _floppy_prepare_controller.drive	set	8
30737                       00000004            .floppy_prepare_controller.drive	set	4
30738 8EBF           FB                             sti
30739                                           ! 4398 endasm
30740                                           !BCC_ENDASM
30741                                           !BCC_EOS
30742                                           ! 4399     do {
30743                       00008EC0            .66A:
30744                                           ! 4400       val8 = read_byte(0x0040, 0x003e);
30745                                           ! Debug: list int = const $3E (used reg = )
30746 8EC0           B8                   003E  mov	ax,*$3E
30747 8EC3           50                         push	ax
30748                                           ! Debug: list int = const $40 (used reg = )
30749 8EC4           B8                   0040  mov	ax,*$40
30750 8EC7           50                         push	ax
30751                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30752 8EC8           E8         7729            call	_read_byte
30753 8ECB           83C4                   04  add	sp,*4
30754                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30755 8ECE           8846         FF            mov	-1[bp],al
30756                                           !BCC_EOS
30757                                           ! 4401     } while ( (val8 & 0x80) == 0 );
30758                       00008ED1            .669:
30759                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
30760 8ED1           8A46         FF            mov	al,-1[bp]
30761 8ED4           24                     80  and	al,#$80
30762                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
30763 8ED6           84C0                       test	al,al
30764 8ED8           74           E6            je 	.66A
30765                       00008EDA            .66B:
30766                                           !BCC_EOS
30767                                           ! 4402     val8 &= 0x7f;
30768                       00008EDA            .668:
30769                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30770 8EDA           8A46         FF            mov	al,-1[bp]
30771 8EDD           24                     7F  and	al,*$7F
30772 8EDF           8846         FF            mov	-1[bp],al
30773                                           !BCC_EOS
30774                                           ! 4403 #asm
30775                                           !BCC_EOS
30776                                           !BCC_ASM
30777                       00000002            _floppy_prepare_controller.dor	set	2
30778                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30779                       00000001            _floppy_prepare_controller.prev_reset	set	1
30780                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30781                       00000003            _floppy_prepare_controller.val8	set	3
30782                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30783                       00000008            _floppy_prepare_controller.drive	set	8
30784                       00000004            .floppy_prepare_controller.drive	set	4
30785 8EE2           FA                             cli
30786                                           ! 4405 endasm
30787                                           !BCC_ENDASM
30788                                           !BCC_EOS
30789                                           ! 4406     write_byte(0x0040, 0x003e, val8);
30790                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30791 8EE3           8A46         FF            mov	al,-1[bp]
30792 8EE6           30E4                       xor	ah,ah
30793 8EE8           50                         push	ax
30794                                           ! Debug: list int = const $3E (used reg = )
30795 8EE9           B8                   003E  mov	ax,*$3E
30796 8EEC           50                         push	ax
30797                                           ! Debug: list int = const $40 (used reg = )
30798 8EED           B8                   0040  mov	ax,*$40
30799 8EF0           50                         push	ax
30800                                           ! Debug: func () void = write_byte+0 (used reg = )
30801 8EF1           E8         7726            call	_write_byte
30802 8EF4           83C4                   06  add	sp,*6
30803                                           !BCC_EOS
30804                                           ! 4407   }
30805                                           ! 4408 }
30806                       00008EF7            .666:
30807 8EF7           89EC                       mov	sp,bp
30808 8EF9           5D                         pop	bp
30809 8EFA           C3                         ret
30810                                           ! 4409   bx_bool
30811                                           ! 4410 floppy_media_known(drive)
30812                                           ! 4411   Bit16u drive;
30813                                           export	_floppy_media_known
30814                       00008EFB            _floppy_media_known:
30815                                           !BCC_EOS
30816                                           ! 4412 {
30817                                           ! 4413   Bit8u val8;
30818                                           !BCC_EOS
30819                                           ! 4414   Bit16u media_state_offset;
30820                                           !BCC_EOS
30821                                           ! 4415   val8 = read_byte(0x0040, 0x003e);
30822 8EFB           55                         push	bp
30823 8EFC           89E5                       mov	bp,sp
30824 8EFE           83C4                   FC  add	sp,*-4
30825                                           ! Debug: list int = const $3E (used reg = )
30826 8F01           B8                   003E  mov	ax,*$3E
30827 8F04           50                         push	ax
30828                                           ! Debug: list int = const $40 (used reg = )
30829 8F05           B8                   0040  mov	ax,*$40
30830 8F08           50                         push	ax
30831                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30832 8F09           E8         76E8            call	_read_byte
30833 8F0C           83C4                   04  add	sp,*4
30834                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30835 8F0F           8846         FF            mov	-1[bp],al
30836                                           !BCC_EOS
30837                                           ! 4416   if (drive)
30838 8F12           8B46         04            mov	ax,4[bp]
30839 8F15           85C0                       test	ax,ax
30840 8F17           74           0A            je  	.66C
30841                       00008F19            .66D:
30842                                           ! 4417     val8 >>= 1;
30843                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30844 8F19           8A46         FF            mov	al,-1[bp]
30845 8F1C           30E4                       xor	ah,ah
30846 8F1E           D1E8                       shr	ax,*1
30847 8F20           8846         FF            mov	-1[bp],al
30848                                           !BCC_EOS
30849                                           ! 4418   val8 &= 0x01;
30850                       00008F23            .66C:
30851                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30852 8F23           8A46         FF            mov	al,-1[bp]
30853 8F26           24                     01  and	al,*1
30854 8F28           8846         FF            mov	-1[bp],al
30855                                           !BCC_EOS
30856                                           ! 4419   if (val8 == 0)
30857                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30858 8F2B           8A46         FF            mov	al,-1[bp]
30859 8F2E           84C0                       test	al,al
30860 8F30           75           06            jne 	.66E
30861                       00008F32            .66F:
30862                                           ! 4420     return(0);
30863 8F32           31C0                       xor	ax,ax
30864 8F34           89EC                       mov	sp,bp
30865 8F36           5D                         pop	bp
30866 8F37           C3                         ret
30867                                           !BCC_EOS
30868                                           ! 4421   media_state_offset = 0x0090;
30869                       00008F38            .66E:
30870                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
30871 8F38           B8                   0090  mov	ax,#$90
30872 8F3B           8946         FC            mov	-4[bp],ax
30873                                           !BCC_EOS
30874                                           ! 4422   if (drive)
30875 8F3E           8B46         04            mov	ax,4[bp]
30876 8F41           85C0                       test	ax,ax
30877 8F43           74           07            je  	.670
30878                       00008F45            .671:
30879                                           ! 4423     media_state_offset += 1;
30880                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
30881 8F45           8B46         FC            mov	ax,-4[bp]
30882 8F48           40                         inc	ax
30883 8F49           8946         FC            mov	-4[bp],ax
30884                                           !BCC_EOS
30885                                           ! 4424   val8 = read_byte(0x0040, media_state_offset);
30886                       00008F4C            .670:
30887                                           ! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
30888 8F4C           FF76         FC            push	-4[bp]
30889                                           ! Debug: list int = const $40 (used reg = )
30890 8F4F           B8                   0040  mov	ax,*$40
30891 8F52           50                         push	ax
30892                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30893 8F53           E8         769E            call	_read_byte
30894 8F56           83C4                   04  add	sp,*4
30895                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30896 8F59           8846         FF            mov	-1[bp],al
30897                                           !BCC_EOS
30898                                           ! 4425   val8 = (val8 >> 4) & 0x01;
30899                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
30900 8F5C           8A46         FF            mov	al,-1[bp]
30901 8F5F           30E4                       xor	ah,ah
30902 8F61           B1                     04  mov	cl,*4
30903 8F63           D3E8                       shr	ax,cl
30904                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30905 8F65           24                     01  and	al,*1
30906                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30907 8F67           8846         FF            mov	-1[bp],al
30908                                           !BCC_EOS
30909                                           ! 4426   if (val8 == 0)
30910                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30911 8F6A           8A46         FF            mov	al,-1[bp]
30912 8F6D           84C0                       test	al,al
30913 8F6F           75           06            jne 	.672
30914                       00008F71            .673:
30915                                           ! 4427     return(0);
30916 8F71           31C0                       xor	ax,ax
30917 8F73           89EC                       mov	sp,bp
30918 8F75           5D                         pop	bp
30919 8F76           C3                         ret
30920                                           !BCC_EOS
30921                                           ! 4428   return(1);
30922                       00008F77            .672:
30923 8F77           B8                   0001  mov	ax,*1
30924 8F7A           89EC                       mov	sp,bp
30925 8F7C           5D                         pop	bp
30926 8F7D           C3                         ret
30927                                           !BCC_EOS
30928                                           ! 4429 }
30929                                           ! 4430   bx_bool
30930                                           ! 4431 floppy_media_sense(drive)
30931                                           ! 4432   Bit16u drive;
30932                                           export	_floppy_media_sense
30933                       00008F7E            _floppy_media_sense:
30934                                           !BCC_EOS
30935                                           ! 4433 {
30936                                           ! 4434   bx_bool retval;
30937                                           !BCC_EOS
30938                                           ! 4435   Bit16u media_state_offset;
30939                                           !BCC_EOS
30940                                           ! 4436   Bit8u drive_type, config_data, media_state;
30941                                           !BCC_EOS
30942                                           ! 4437   if (floppy_drive_recal(drive) == 0) {
30943 8F7E           55                         push	bp
30944 8F7F           89E5                       mov	bp,sp
30945 8F81           83C4                   F8  add	sp,*-8
30946                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
30947 8F84           FF76         04            push	4[bp]
30948                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
30949 8F87           E8         0153            call	_floppy_drive_recal
30950 8F8A           44                         inc	sp
30951 8F8B           44                         inc	sp
30952                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30953 8F8C           85C0                       test	ax,ax
30954 8F8E           75           06            jne 	.674
30955                       00008F90            .675:
30956                                           ! 4438     return(0);
30957 8F90           31C0                       xor	ax,ax
30958 8F92           89EC                       mov	sp,bp
30959 8F94           5D                         pop	bp
30960 8F95           C3                         ret
30961                                           !BCC_EOS
30962                                           ! 4439     }
30963                                           ! 4440   drive_type = inb_cmos(0x10);
30964                       00008F96            .674:
30965                                           ! Debug: list int = const $10 (used reg = )
30966 8F96           B8                   0010  mov	ax,*$10
30967 8F99           50                         push	ax
30968                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30969 8F9A           E8         75E6            call	_inb_cmos
30970 8F9D           44                         inc	sp
30971 8F9E           44                         inc	sp
30972                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
30973 8F9F           8846         FB            mov	-5[bp],al
30974                                           !BCC_EOS
30975                                           ! 4441   if (drive == 0)
30976                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
30977 8FA2           8B46         04            mov	ax,4[bp]
30978 8FA5           85C0                       test	ax,ax
30979 8FA7           75           0E            jne 	.676
30980                       00008FA9            .677:
30981                                           ! 4442     drive_type >>= 4;
30982                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
30983 8FA9           8A46         FB            mov	al,-5[bp]
30984 8FAC           30E4                       xor	ah,ah
30985 8FAE           B1                     04  mov	cl,*4
30986 8FB0           D3E8                       shr	ax,cl
30987 8FB2           8846         FB            mov	-5[bp],al
30988                                           !BCC_EOS
30989                                           ! 4443   else
30990                                           ! 4444     drive_type &= 0x0f;
30991 8FB5           EB           08            jmp .678
30992                       00008FB7            .676:
30993                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
30994 8FB7           8A46         FB            mov	al,-5[bp]
30995 8FBA           24                     0F  and	al,*$F
30996 8FBC           8846         FB            mov	-5[bp],al
30997                                           !BCC_EOS
30998                                           ! 4445   if ( drive_type == 1 ) {
30999                       00008FBF            .678:
31000                                           ! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
31001 8FBF           8A46         FB            mov	al,-5[bp]
31002 8FC2           3C                     01  cmp	al,*1
31003 8FC4           75           13            jne 	.679
31004                       00008FC6            .67A:
31005                                           ! 4446     config_data = 0x00;
31006                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31007 8FC6           30C0                       xor	al,al
31008 8FC8           8846         FA            mov	-6[bp],al
31009                                           !BCC_EOS
31010                                           ! 4447     media_state = 0x25;
31011                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
31012 8FCB           B0                     25  mov	al,*$25
31013 8FCD           8846         F9            mov	-7[bp],al
31014                                           !BCC_EOS
31015                                           ! 4448     retval = 1;
31016                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31017 8FD0           B8                   0001  mov	ax,*1
31018 8FD3           8946         FE            mov	-2[bp],ax
31019                                           !BCC_EOS
31020                                           ! 4449     }
31021                                           ! 4450   else if ( drive_type == 2 ) {
31022 8FD6           E9         00C1            br 	.67B
31023                       00008FD9            .679:
31024                                           ! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
31025 8FD9           8A46         FB            mov	al,-5[bp]
31026 8FDC           3C                     02  cmp	al,*2
31027 8FDE           75           13            jne 	.67C
31028                       00008FE0            .67D:
31029                                           ! 4451     config_data = 0x00;
31030                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31031 8FE0           30C0                       xor	al,al
31032 8FE2           8846         FA            mov	-6[bp],al
31033                                           !BCC_EOS
31034                                           ! 4452     media_state = 0x25;
31035                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
31036 8FE5           B0                     25  mov	al,*$25
31037 8FE7           8846         F9            mov	-7[bp],al
31038                                           !BCC_EOS
31039                                           ! 4453     retval = 1;
31040                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31041 8FEA           B8                   0001  mov	ax,*1
31042 8FED           8946         FE            mov	-2[bp],ax
31043                                           !BCC_EOS
31044                                           ! 4454     }
31045                                           ! 4455   else if ( drive_type == 3 ) {
31046 8FF0           E9         00A7            br 	.67E
31047                       00008FF3            .67C:
31048                                           ! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
31049 8FF3           8A46         FB            mov	al,-5[bp]
31050 8FF6           3C                     03  cmp	al,*3
31051 8FF8           75           13            jne 	.67F
31052                       00008FFA            .680:
31053                                           ! 4456     config_data = 0x00;
31054                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31055 8FFA           30C0                       xor	al,al
31056 8FFC           8846         FA            mov	-6[bp],al
31057                                           !BCC_EOS
31058                                           ! 4457     media_state = 0x17;
31059                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
31060 8FFF           B0                     17  mov	al,*$17
31061 9001           8846         F9            mov	-7[bp],al
31062                                           !BCC_EOS
31063                                           ! 4458     retval = 1;
31064                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31065 9004           B8                   0001  mov	ax,*1
31066 9007           8946         FE            mov	-2[bp],ax
31067                                           !BCC_EOS
31068                                           ! 4459     }
31069                                           ! 4460   else if ( drive_type == 4 ) {
31070 900A           E9         008D            br 	.681
31071                       0000900D            .67F:
31072                                           ! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
31073 900D           8A46         FB            mov	al,-5[bp]
31074 9010           3C                     04  cmp	al,*4
31075 9012           75           13            jne 	.682
31076                       00009014            .683:
31077                                           ! 4461     config_data = 0x00;
31078                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31079 9014           30C0                       xor	al,al
31080 9016           8846         FA            mov	-6[bp],al
31081                                           !BCC_EOS
31082                                           ! 4462     media_state = 0x17;
31083                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
31084 9019           B0                     17  mov	al,*$17
31085 901B           8846         F9            mov	-7[bp],al
31086                                           !BCC_EOS
31087                                           ! 4463     retval = 1;
31088                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31089 901E           B8                   0001  mov	ax,*1
31090 9021           8946         FE            mov	-2[bp],ax
31091                                           !BCC_EOS
31092                                           ! 4464     }
31093                                           ! 4465   else if ( drive_type == 5 ) {
31094 9024           E9         0073            br 	.684
31095                       00009027            .682:
31096                                           ! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
31097 9027           8A46         FB            mov	al,-5[bp]
31098 902A           3C                     05  cmp	al,*5
31099 902C           75           12            jne 	.685
31100                       0000902E            .686:
31101                                           ! 4466     config_data = 0xCC;
31102                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
31103 902E           B0                     CC  mov	al,#$CC
31104 9030           8846         FA            mov	-6[bp],al
31105                                           !BCC_EOS
31106                                           ! 4467     media_state = 0xD7;
31107                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
31108 9033           B0                     D7  mov	al,#$D7
31109 9035           8846         F9            mov	-7[bp],al
31110                                           !BCC_EOS
31111                                           ! 4468     retval = 1;
31112                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31113 9038           B8                   0001  mov	ax,*1
31114 903B           8946         FE            mov	-2[bp],ax
31115                                           !BCC_EOS
31116                                           ! 4469     }
31117                                           ! 4470   else if ( drive_type == 6 ) {
31118 903E           EB           5A            jmp .687
31119                       00009040            .685:
31120                                           ! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
31121 9040           8A46         FB            mov	al,-5[bp]
31122 9043           3C                     06  cmp	al,*6
31123 9045           75           12            jne 	.688
31124                       00009047            .689:
31125                                           ! 4471     config_data = 0x00;
31126                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31127 9047           30C0                       xor	al,al
31128 9049           8846         FA            mov	-6[bp],al
31129                                           !BCC_EOS
31130                                           ! 4472     media_state = 0x27;
31131                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31132 904C           B0                     27  mov	al,*$27
31133 904E           8846         F9            mov	-7[bp],al
31134                                           !BCC_EOS
31135                                           ! 4473     retval = 1;
31136                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31137 9051           B8                   0001  mov	ax,*1
31138 9054           8946         FE            mov	-2[bp],ax
31139                                           !BCC_EOS
31140                                           ! 4474     }
31141                                           ! 4475   else if ( drive_type == 7 ) {
31142 9057           EB           41            jmp .68A
31143                       00009059            .688:
31144                                           ! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
31145 9059           8A46         FB            mov	al,-5[bp]
31146 905C           3C                     07  cmp	al,*7
31147 905E           75           12            jne 	.68B
31148                       00009060            .68C:
31149                                           ! 4476     config_data = 0x00;
31150                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31151 9060           30C0                       xor	al,al
31152 9062           8846         FA            mov	-6[bp],al
31153                                           !BCC_EOS
31154                                           ! 4477     media_state = 0x27;
31155                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31156 9065           B0                     27  mov	al,*$27
31157 9067           8846         F9            mov	-7[bp],al
31158                                           !BCC_EOS
31159                                           ! 4478     retval = 1;
31160                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31161 906A           B8                   0001  mov	ax,*1
31162 906D           8946         FE            mov	-2[bp],ax
31163                                           !BCC_EOS
31164                                           ! 4479     }
31165                                           ! 4480   else if ( drive_type == 8 ) {
31166 9070           EB           28            jmp .68D
31167                       00009072            .68B:
31168                                           ! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
31169 9072           8A46         FB            mov	al,-5[bp]
31170 9075           3C                     08  cmp	al,*8
31171 9077           75           12            jne 	.68E
31172                       00009079            .68F:
31173                                           ! 4481     config_data = 0x00;
31174                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31175 9079           30C0                       xor	al,al
31176 907B           8846         FA            mov	-6[bp],al
31177                                           !BCC_EOS
31178                                           ! 4482     media_state = 0x27;
31179                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
31180 907E           B0                     27  mov	al,*$27
31181 9080           8846         F9            mov	-7[bp],al
31182                                           !BCC_EOS
31183                                           ! 4483     retval = 1;
31184                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
31185 9083           B8                   0001  mov	ax,*1
31186 9086           8946         FE            mov	-2[bp],ax
31187                                           !BCC_EOS
31188                                           ! 4484     }
31189                                           ! 4485   else {
31190 9089           EB           0F            jmp .690
31191                       0000908B            .68E:
31192                                           ! 4486     config_data = 0x00;
31193                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
31194 908B           30C0                       xor	al,al
31195 908D           8846         FA            mov	-6[bp],al
31196                                           !BCC_EOS
31197                                           ! 4487     media_state = 0x00;
31198                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
31199 9090           30C0                       xor	al,al
31200 9092           8846         F9            mov	-7[bp],al
31201                                           !BCC_EOS
31202                                           ! 4488     retval = 0;
31203                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
31204 9095           31C0                       xor	ax,ax
31205 9097           8946         FE            mov	-2[bp],ax
31206                                           !BCC_EOS
31207                                           ! 4489     }
31208                                           ! 4490   if (drive == 0)
31209                       0000909A            .690:
31210                       0000909A            .68D:
31211                       0000909A            .68A:
31212                       0000909A            .687:
31213                       0000909A            .684:
31214                       0000909A            .681:
31215                       0000909A            .67E:
31216                       0000909A            .67B:
31217                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
31218 909A           8B46         04            mov	ax,4[bp]
31219 909D           85C0                       test	ax,ax
31220 909F           75           08            jne 	.691
31221                       000090A1            .692:
31222                                           ! 4491     media_state_offset = 0x90
31223                                           ! 4491 ;
31224                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
31225 90A1           B8                   0090  mov	ax,#$90
31226 90A4           8946         FC            mov	-4[bp],ax
31227                                           !BCC_EOS
31228                                           ! 4492   else
31229                                           ! 4493     media_state_offset = 0x91;
31230 90A7           EB           06            jmp .693
31231                       000090A9            .691:
31232                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
31233 90A9           B8                   0091  mov	ax,#$91
31234 90AC           8946         FC            mov	-4[bp],ax
31235                                           !BCC_EOS
31236                                           ! 4494   write_byte(0x0040, 0x008B, config_data);
31237                       000090AF            .693:
31238                                           ! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
31239 90AF           8A46         FA            mov	al,-6[bp]
31240 90B2           30E4                       xor	ah,ah
31241 90B4           50                         push	ax
31242                                           ! Debug: list int = const $8B (used reg = )
31243 90B5           B8                   008B  mov	ax,#$8B
31244 90B8           50                         push	ax
31245                                           ! Debug: list int = const $40 (used reg = )
31246 90B9           B8                   0040  mov	ax,*$40
31247 90BC           50                         push	ax
31248                                           ! Debug: func () void = write_byte+0 (used reg = )
31249 90BD           E8         755A            call	_write_byte
31250 90C0           83C4                   06  add	sp,*6
31251                                           !BCC_EOS
31252                                           ! 4495   write_byte(0x0040, media_state_offset, media_state);
31253                                           ! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
31254 90C3           8A46         F9            mov	al,-7[bp]
31255 90C6           30E4                       xor	ah,ah
31256 90C8           50                         push	ax
31257                                           ! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
31258 90C9           FF76         FC            push	-4[bp]
31259                                           ! Debug: list int = const $40 (used reg = )
31260 90CC           B8                   0040  mov	ax,*$40
31261 90CF           50                         push	ax
31262                                           ! Debug: func () void = write_byte+0 (used reg = )
31263 90D0           E8         7547            call	_write_byte
31264 90D3           83C4                   06  add	sp,*6
31265                                           !BCC_EOS
31266                                           ! 4496   return(retval);
31267 90D6           8B46         FE            mov	ax,-2[bp]
31268 90D9           89EC                       mov	sp,bp
31269 90DB           5D                         pop	bp
31270 90DC           C3                         ret
31271                                           !BCC_EOS
31272                                           ! 4497 }
31273                                           ! 4498   bx_bool
31274                                           ! 4499 floppy_drive_recal(drive)
31275                                           ! 4500   Bit16u drive;
31276                                           export	_floppy_drive_recal
31277                       000090DD            _floppy_drive_recal:
31278                                           !BCC_EOS
31279                                           ! 4501 {
31280                                           ! 4502   Bit8u val8;
31281                                           !BCC_EOS
31282                                           ! 4503   Bit16u curr_cyl_offset;
31283                                           !BCC_EOS
31284                                           ! 4504   floppy_prepare_controller(drive);
31285 90DD           55                         push	bp
31286 90DE           89E5                       mov	bp,sp
31287 90E0           83C4                   FC  add	sp,*-4
31288                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
31289 90E3           FF76         04            push	4[bp]
31290                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
31291 90E6           E8         FD33            call	_floppy_prepare_controller
31292 90E9           44                         inc	sp
31293 90EA           44                         inc	sp
31294                                           !BCC_EOS
31295                                           ! 4505   outb(0x03f5, 0x07);
31296                                           ! Debug: list int = const 7 (used reg = )
31297 90EB           B8                   0007  mov	ax,*7
31298 90EE           50                         push	ax
31299                                           ! Debug: list int = const $3F5 (used reg = )
31300 90EF           B8                   03F5  mov	ax,#$3F5
31301 90F2           50                         push	ax
31302                                           ! Debug: func () void = outb+0 (used reg = )
31303 90F3           E8         745E            call	_outb
31304 90F6           83C4                   04  add	sp,*4
31305                                           !BCC_EOS
31306                                           ! 4506   outb(0x03f5, drive);
31307                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
31308 90F9           FF76         04            push	4[bp]
31309                                           ! Debug: list int = const $3F5 (used reg = )
31310 90FC           B8                   03F5  mov	ax,#$3F5
31311 90FF           50                         push	ax
31312                                           ! Debug: func () void = outb+0 (used reg = )
31313 9100           E8         7451            call	_outb
31314 9103           83C4                   04  add	sp,*4
31315                                           !BCC_EOS
31316                                           ! 4507 #asm
31317                                           !BCC_EOS
31318                                           !BCC_ASM
31319                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
31320                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
31321                       00000003            _floppy_drive_recal.val8	set	3
31322                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
31323                       00000008            _floppy_drive_recal.drive	set	8
31324                       00000004            .floppy_drive_recal.drive	set	4
31325 9106           FB                           sti
31326                                           ! 4509 endasm
31327                                           !BCC_ENDASM
31328                                           !BCC_EOS
31329                                           ! 4510   do {
31330                       00009107            .696:
31331                                           ! 4511     val8 = (read_byte(0x0040, 0x003e) & 0x80);
31332                                           ! Debug: list int = const $3E (used reg = )
31333 9107           B8                   003E  mov	ax,*$3E
31334 910A           50                         push	ax
31335                                           ! Debug: list int = const $40 (used reg = )
31336 910B           B8                   0040  mov	ax,*$40
31337 910E           50                         push	ax
31338                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31339 910F           E8         74E2            call	_read_byte
31340 9112           83C4                   04  add	sp,*4
31341                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
31342 9115           24                     80  and	al,#$80
31343                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31344 9117           8846         FF            mov	-1[bp],al
31345                                           !BCC_EOS
31346                                           ! 4512   } while ( val8 == 0 );
31347                       0000911A            .695:
31348                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31349 911A           8A46         FF            mov	al,-1[bp]
31350 911D           84C0                       test	al,al
31351 911F           74           E6            je 	.696
31352                       00009121            .697:
31353                                           !BCC_EOS
31354                                           ! 4513   val8 = 0;
31355                       00009121            .694:
31356                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
31357 9121           30C0                       xor	al,al
31358 9123           8846         FF            mov	-1[bp],al
31359                                           !BCC_EOS
31360                                           ! 4514 #asm
31361                                           !BCC_EOS
31362                                           !BCC_ASM
31363                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
31364                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
31365                       00000003            _floppy_drive_recal.val8	set	3
31366                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
31367                       00000008            _floppy_drive_recal.drive	set	8
31368                       00000004            .floppy_drive_recal.drive	set	4
31369 9126           FA                           cli
31370                                           ! 4516 endasm
31371                                           !BCC_ENDASM
31372                                           !BCC_EOS
31373                                           ! 4517   val8 = read_byte(0x0040, 0x003e);
31374                                           ! Debug: list int = const $3E (used reg = )
31375 9127           B8                   003E  mov	ax,*$3E
31376 912A           50                         push	ax
31377                                           ! Debug: list int = const $40 (used reg = )
31378 912B           B8                   0040  mov	ax,*$40
31379 912E           50                         push	ax
31380                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31381 912F           E8         74C2            call	_read_byte
31382 9132           83C4                   04  add	sp,*4
31383                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
31384 9135           8846         FF            mov	-1[bp],al
31385                                           !BCC_EOS
31386                                           ! 4518   val8 &= 0x7f;
31387                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
31388 9138           8A46         FF            mov	al,-1[bp]
31389 913B           24                     7F  and	al,*$7F
31390 913D           8846         FF            mov	-1[bp],al
31391                                           !BCC_EOS
31392                                           ! 4519   if (drive) {
31393 9140           8B46         04            mov	ax,4[bp]
31394 9143           85C0                       test	ax,ax
31395 9145           74           10            je  	.698
31396                       00009147            .699:
31397                                           ! 4520     val8 |= 0x02;
31398                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
31399 9147           8A46         FF            mov	al,-1[bp]
31400 914A           0C                     02  or	al,*2
31401 914C           8846         FF            mov	-1[bp],al
31402                                           !BCC_EOS
31403                                           ! 4521     curr_cyl_offset = 0x0095;
31404                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
31405 914F           B8                   0095  mov	ax,#$95
31406 9152           8946         FC            mov	-4[bp],ax
31407                                           !BCC_EOS
31408                                           ! 4522   } else {
31409 9155           EB           0E            jmp .69A
31410                       00009157            .698:
31411                                           ! 4523     val8 |= 0x01;
31412                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
31413 9157           8A46         FF            mov	al,-1[bp]
31414 915A           0C                     01  or	al,*1
31415 915C           8846         FF            mov	-1[bp],al
31416                                           !BCC_EOS
31417                                           ! 4524     curr_cyl_offset = 0x0094;
31418                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
31419 915F           B8                   0094  mov	ax,#$94
31420 9162           8946         FC            mov	-4[bp],ax
31421                                           !BCC_EOS
31422                                           ! 4525   }
31423                                           ! 4526   write_byte(0x0040, 0x003e, val8);
31424                       00009165            .69A:
31425                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
31426 9165           8A46         FF            mov	al,-1[bp]
31427 9168           30E4                       xor	ah,ah
31428 916A           50                         push	ax
31429                                           ! Debug: list int = const $3E (used reg = )
31430 916B           B8                   003E  mov	ax,*$3E
31431 916E           50                         push	ax
31432                                           ! Debug: list int = const $40 (used reg = )
31433 916F           B8                   0040  mov	ax,*$40
31434 9172           50                         push	ax
31435                                           ! Debug: func () void = write_byte+0 (used reg = )
31436 9173           E8         74A4            call	_write_byte
31437 9176           83C4                   06  add	sp,*6
31438                                           !BCC_EOS
31439                                           ! 4527   write_byte(0x0040, curr_cyl_offset, 0);
31440                                           ! Debug: list int = const 0 (used reg = )
31441 9179           31C0                       xor	ax,ax
31442 917B           50                         push	ax
31443                                           ! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
31444 917C           FF76         FC            push	-4[bp]
31445                                           ! Debug: list int = const $40 (used reg = )
31446 917F           B8                   0040  mov	ax,*$40
31447 9182           50                         push	ax
31448                                           ! Debug: func () void = write_byte+0 (used reg = )
31449 9183           E8         7494            call	_write_byte
31450 9186           83C4                   06  add	sp,*6
31451                                           !BCC_EOS
31452                                           ! 4528   return(1);
31453 9189           B8                   0001  mov	ax,*1
31454 918C           89EC                       mov	sp,bp
31455 918E           5D                         pop	bp
31456 918F           C3                         ret
31457                                           !BCC_EOS
31458                                           ! 4529 }
31459                                           ! 4530   bx_bool
31460                                           ! 4531 floppy_drive_exists(drive)
31461                                           ! 4532   Bit16u drive;
31462                                           export	_floppy_drive_exists
31463                       00009190            _floppy_drive_exists:
31464                                           !BCC_EOS
31465                                           ! 4533 {
31466                                           ! 4534   Bit8u drive_type;
31467                                           !BCC_EOS
31468                                           ! 4535   drive_type = inb_cmos(0x10);
31469 9190           55                         push	bp
31470 9191           89E5                       mov	bp,sp
31471 9193           4C                         dec	sp
31472 9194           4C                         dec	sp
31473                                           ! Debug: list int = const $10 (used reg = )
31474 9195           B8                   0010  mov	ax,*$10
31475 9198           50                         push	ax
31476                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31477 9199           E8         73E7            call	_inb_cmos
31478 919C           44                         inc	sp
31479 919D           44                         inc	sp
31480                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
31481 919E           8846         FF            mov	-1[bp],al
31482                                           !BCC_EOS
31483                                           ! 4536   if (drive == 0)
31484                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
31485 91A1           8B46         04            mov	ax,4[bp]
31486 91A4           85C0                       test	ax,ax
31487 91A6           75           0E            jne 	.69B
31488                       000091A8            .69C:
31489                                           ! 4537     drive_type >>= 4;
31490                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
31491 91A8           8A46         FF            mov	al,-1[bp]
31492 91AB           30E4                       xor	ah,ah
31493 91AD           B1                     04  mov	cl,*4
31494 91AF           D3E8                       shr	ax,cl
31495 91B1           8846         FF            mov	-1[bp],al
31496                                           !BCC_EOS
31497                                           ! 4538   else
31498                                           ! 4539     drive_type &= 0x0f;
31499 91B4           EB           08            jmp .69D
31500                       000091B6            .69B:
31501                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
31502 91B6           8A46         FF            mov	al,-1[bp]
31503 91B9           24                     0F  and	al,*$F
31504 91BB           8846         FF            mov	-1[bp],al
31505                                           !BCC_EOS
31506                                           ! 4540   if ( drive_type == 0 )
31507                       000091BE            .69D:
31508                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
31509 91BE           8A46         FF            mov	al,-1[bp]
31510 91C1           84C0                       test	al,al
31511 91C3           75           08            jne 	.69E
31512                       000091C5            .69F:
31513                                           ! 4541     return(0);
31514 91C5           31C0                       xor	ax,ax
31515 91C7           89EC                       mov	sp,bp
31516 91C9           5D                         pop	bp
31517 91CA           C3                         ret
31518                                           !BCC_EOS
31519                                           ! 4542   else
31520                                           ! 4543     return(1);
31521 91CB           EB           07            jmp .6A0
31522                       000091CD            .69E:
31523 91CD           B8                   0001  mov	ax,*1
31524 91D0           89EC                       mov	sp,bp
31525 91D2           5D                         pop	bp
31526 91D3           C3                         ret
31527                                           !BCC_EOS
31528                                           ! 4544 }
31529                       000091D4            .6A0:
31530 91D4           89EC                       mov	sp,bp
31531 91D6           5D                         pop	bp
31532 91D7           C3                         ret
31533                                           ! 4545   void
31534                                           ! 4546 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
31535                                           ! 4547   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
31536                                           export	_int13_diskette_function
31537                       000091D8            _int13_diskette_function:
31538                                           !BCC_EOS
31539                                           ! 4548 {
31540                                           ! 4549   Bit8u drive, num_sectors, track, sector, head, status;
31541                                           !BCC_EOS
31542                                           ! 4550   Bit16u base_address, base_count, base_es;
31543                                           !BCC_EOS
31544                                           ! 4551   Bit8u page, mode_register, val8, dor;
31545                                           !BCC_EOS
31546                                           ! 4552   Bit8u return_status[7];
31547                                           !BCC_EOS
31548                                           ! 4553   Bit8u drive_type, num_floppies, ah;
31549                                           !BCC_EOS
31550                                           ! 4554   Bit16u es, last_addr;
31551                                           !BCC_EOS
31552                                           ! 4555   ;
31553 91D8           55                         push	bp
31554 91D9           89E5                       mov	bp,sp
31555 91DB           83C4                   E2  add	sp,*-$1E
31556                                           !BCC_EOS
31557                                           ! 4556   ah = ( AX >> 8 );
31558                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
31559 91DE           8B46         16            mov	ax,$16[bp]
31560 91E1           88E0                       mov	al,ah
31561 91E3           30E4                       xor	ah,ah
31562                                           ! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
31563 91E5           8846         E6            mov	-$1A[bp],al
31564                                           !BCC_EOS
31565                                           ! 4557   switch ( ah ) {
31566 91E8           8A46         E6            mov	al,-$1A[bp]
31567 91EB           E9         10C3            br 	.6A3
31568                                           ! 4558     case 0x00:
31569                                           ! 4559 ;
31570                       000091EE            .6A4:
31571                                           !BCC_EOS
31572                                           ! 4560       drive = ( ELDX & 0x00ff );
31573                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31574 91EE           8A46         0E            mov	al,$E[bp]
31575                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31576 91F1           8846         FF            mov	-1[bp],al
31577                                           !BCC_EOS
31578                                           ! 4561       if (drive > 1) {
31579                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
31580 91F4           8A46         FF            mov	al,-1[bp]
31581 91F7           3C                     01  cmp	al,*1
31582 91F9           76           20            jbe 	.6A5
31583                       000091FB            .6A6:
31584                                           ! 4562         AX = ((AX & 0x00ff) | ((1) << 8));
31585                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31586 91FB           8A46         16            mov	al,$16[bp]
31587                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31588 91FE           30E4                       xor	ah,ah
31589 9200           0D                   0100  or	ax,#$100
31590                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31591 9203           8946         16            mov	$16[bp],ax
31592                                           !BCC_EOS
31593                                           ! 4563         set_diskette_ret_status(1);
31594                                           ! Debug: list int = const 1 (used reg = )
31595 9206           B8                   0001  mov	ax,*1
31596 9209           50                         push	ax
31597                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31598 920A           E8         10E7            call	_set_diskette_ret_status
31599 920D           44                         inc	sp
31600 920E           44                         inc	sp
31601                                           !BCC_EOS
31602                                           ! 4564         FLAGS |= 0x0001;
31603                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31604 920F           8B46         1C            mov	ax,$1C[bp]
31605 9212           0C                     01  or	al,*1
31606 9214           8946         1C            mov	$1C[bp],ax
31607                                           !BCC_EOS
31608                                           ! 4565         return;
31609 9217           89EC                       mov	sp,bp
31610 9219           5D                         pop	bp
31611 921A           C3                         ret
31612                                           !BCC_EOS
31613                                           ! 4566       }
31614                                           ! 4567       drive_type = inb_cmos(0x10);
31615                       0000921B            .6A5:
31616                                           ! Debug: list int = const $10 (used reg = )
31617 921B           B8                   0010  mov	ax,*$10
31618 921E           50                         push	ax
31619                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
31620 921F           E8         7361            call	_inb_cmos
31621 9222           44                         inc	sp
31622 9223           44                         inc	sp
31623                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31624 9224           8846         E8            mov	-$18[bp],al
31625                                           !BCC_EOS
31626                                           ! 4568       if (drive == 0)
31627                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
31628 9227           8A46         FF            mov	al,-1[bp]
31629 922A           84C0                       test	al,al
31630 922C           75           0E            jne 	.6A7
31631                       0000922E            .6A8:
31632                                           ! 4569         drive_type >>= 4;
31633                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31634 922E           8A46         E8            mov	al,-$18[bp]
31635 9231           30E4                       xor	ah,ah
31636 9233           B1                     04  mov	cl,*4
31637 9235           D3E8                       shr	ax,cl
31638 9237           8846         E8            mov	-$18[bp],al
31639                                           !BCC_EOS
31640                                           ! 4570       else
31641                                           ! 4571         drive_type &= 0x0f;
31642 923A           EB           08            jmp .6A9
31643                       0000923C            .6A7:
31644                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
31645 923C           8A46         E8            mov	al,-$18[bp]
31646 923F           24                     0F  and	al,*$F
31647 9241           8846         E8            mov	-$18[bp],al
31648                                           !BCC_EOS
31649                                           ! 4572       if (drive_type == 0) {
31650                       00009244            .6A9:
31651                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
31652 9244           8A46         E8            mov	al,-$18[bp]
31653 9247           84C0                       test	al,al
31654 9249           75           20            jne 	.6AA
31655                       0000924B            .6AB:
31656                                           ! 4573         AX = ((AX & 0x00ff) | ((0x80) << 8));
31657                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31658 924B           8A46         16            mov	al,$16[bp]
31659                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31660 924E           30E4                       xor	ah,ah
31661 9250           0D                   8000  or	ax,#-$8000
31662                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31663 9253           8946         16            mov	$16[bp],ax
31664                                           !BCC_EOS
31665                                           ! 4574         set_diskette_ret_status(0x80);
31666                                           ! Debug: list int = const $80 (used reg = )
31667 9256           B8                   0080  mov	ax,#$80
31668 9259           50                         push	ax
31669                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31670 925A           E8         1097            call	_set_diskette_ret_status
31671 925D           44                         inc	sp
31672 925E           44                         inc	sp
31673                                           !BCC_EOS
31674                                           ! 4575         FLAGS |= 0x0001;
31675                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31676 925F           8B46         1C            mov	ax,$1C[bp]
31677 9262           0C                     01  or	al,*1
31678 9264           8946         1C            mov	$1C[bp],ax
31679                                           !BCC_EOS
31680                                           ! 4576         return;
31681 9267           89EC                       mov	sp,bp
31682 9269           5D                         pop	bp
31683 926A           C3                         ret
31684                                           !BCC_EOS
31685                                           ! 4577       }
31686                                           ! 4578       AX = ((AX & 0x00ff) | ((0) << 8));
31687                       0000926B            .6AA:
31688                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31689 926B           8A46         16            mov	al,$16[bp]
31690                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
31691 926E           0C                     00  or	al,*0
31692                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
31693 9270           30E4                       xor	ah,ah
31694 9272           8946         16            mov	$16[bp],ax
31695                                           !BCC_EOS
31696                                           ! 4579       set_diskette_ret_status(0);
31697                                           ! Debug: list int = const 0 (used reg = )
31698 9275           31C0                       xor	ax,ax
31699 9277           50                         push	ax
31700                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31701 9278           E8         1079            call	_set_diskette_ret_status
31702 927B           44                         inc	sp
31703 927C           44                         inc	sp
31704                                           !BCC_EOS
31705                                           ! 4580       FLAGS &= 0xfffe;
31706                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31707 927D           8B46         1C            mov	ax,$1C[bp]
31708 9280           24                     FE  and	al,#$FE
31709 9282           8946         1C            mov	$1C[bp],ax
31710                                           !BCC_EOS
31711                                           ! 4581       set_diskette_current_cyl(drive, 0);
31712                                           ! Debug: list int = const 0 (used reg = )
31713 9285           31C0                       xor	ax,ax
31714 9287           50                         push	ax
31715                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
31716 9288           8A46         FF            mov	al,-1[bp]
31717 928B           30E4                       xor	ah,ah
31718 928D           50                         push	ax
31719                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
31720 928E           E8         107B            call	_set_diskette_current_cyl
31721 9291           83C4                   04  add	sp,*4
31722                                           !BCC_EOS
31723                                           ! 4582       return;
31724 9294           89EC                       mov	sp,bp
31725 9296           5D                         pop	bp
31726 9297           C3                         ret
31727                                           !BCC_EOS
31728                                           ! 4583     cas
31729                                           ! 4583 e 0x01:
31730                                           ! 4584       FLAGS &= 0xfffe;
31731                       00009298            .6AC:
31732                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31733 9298           8B46         1C            mov	ax,$1C[bp]
31734 929B           24                     FE  and	al,#$FE
31735 929D           8946         1C            mov	$1C[bp],ax
31736                                           !BCC_EOS
31737                                           ! 4585       val8 = read_byte(0x0000, 0x0441);
31738                                           ! Debug: list int = const $441 (used reg = )
31739 92A0           B8                   0441  mov	ax,#$441
31740 92A3           50                         push	ax
31741                                           ! Debug: list int = const 0 (used reg = )
31742 92A4           31C0                       xor	ax,ax
31743 92A6           50                         push	ax
31744                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31745 92A7           E8         734A            call	_read_byte
31746 92AA           83C4                   04  add	sp,*4
31747                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31748 92AD           8846         F1            mov	-$F[bp],al
31749                                           !BCC_EOS
31750                                           ! 4586       AX = ((AX & 0x00ff) | ((val8) << 8));
31751                                           ! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
31752 92B0           8A46         F1            mov	al,-$F[bp]
31753 92B3           30E4                       xor	ah,ah
31754 92B5           88C4                       mov	ah,al
31755 92B7           30C0                       xor	al,al
31756 92B9           50                         push	ax
31757                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
31758 92BA           8A46         16            mov	al,$16[bp]
31759                                           ! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
31760 92BD           30E4                       xor	ah,ah
31761 92BF           0B46         E0            or	ax,0+..FFDC[bp]
31762 92C2           44                         inc	sp
31763 92C3           44                         inc	sp
31764                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31765 92C4           8946         16            mov	$16[bp],ax
31766                                           !BCC_EOS
31767                                           ! 4587       if (val8) {
31768 92C7           8A46         F1            mov	al,-$F[bp]
31769 92CA           84C0                       test	al,al
31770 92CC           74           08            je  	.6AD
31771                       000092CE            .6AE:
31772                                           ! 4588         FLAGS |= 0x0001;
31773                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31774 92CE           8B46         1C            mov	ax,$1C[bp]
31775 92D1           0C                     01  or	al,*1
31776 92D3           8946         1C            mov	$1C[bp],ax
31777                                           !BCC_EOS
31778                                           ! 4589       }
31779                                           ! 4590       return;
31780                       000092D6            .6AD:
31781 92D6           89EC                       mov	sp,bp
31782 92D8           5D                         pop	bp
31783 92D9           C3                         ret
31784                                           !BCC_EOS
31785                                           ! 4591     case 0x02:
31786                                           ! 4592     case 0x03:
31787                       000092DA            .6AF:
31788                                           ! 4593     case 0x04:
31789                       000092DA            .6B0:
31790                                           ! 4594       num_sectors = ( AX & 0x00ff );
31791                       000092DA            .6B1:
31792                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31793 92DA           8A46         16            mov	al,$16[bp]
31794                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31795 92DD           8846         FE            mov	-2[bp],al
31796                                           !BCC_EOS
31797                                           ! 4595       track = ( CX >> 8 );
31798                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
31799 92E0           8B46         14            mov	ax,$14[bp]
31800 92E3           88E0                       mov	al,ah
31801 92E5           30E4                       xor	ah,ah
31802                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
31803 92E7           8846         FD            mov	-3[bp],al
31804                                           !BCC_EOS
31805                                           ! 4596       sector = ( CX & 0x00ff );
31806                                           ! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
31807 92EA           8A46         14            mov	al,$14[bp]
31808                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
31809 92ED           8846         FC            mov	-4[bp],al
31810                                           !BCC_EOS
31811                                           ! 4597       head = ( DX >> 8 );
31812                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
31813 92F0           8B46         12            mov	ax,$12[bp]
31814 92F3           88E0                       mov	al,ah
31815 92F5           30E4                       xor	ah,ah
31816                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
31817 92F7           8846         FB            mov	-5[bp],al
31818                                           !BCC_EOS
31819                                           ! 4598       drive = ( ELDX & 0x00ff );
31820                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31821 92FA           8A46         0E            mov	al,$E[bp]
31822                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31823 92FD           8846         FF            mov	-1[bp],al
31824                                           !BCC_EOS
31825                                           ! 4599       if ((drive > 1) || (head > 1) || (sector == 0) ||
31826                                           ! 4600           (num_sectors == 0) || (num_sectors > 72)) {
31827                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
31828 9300           8A46         FF            mov	al,-1[bp]
31829 9303           3C                     01  cmp	al,*1
31830 9305           77           1C            ja  	.6B3
31831                       00009307            .6B7:
31832                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
31833 9307           8A46         FB            mov	al,-5[bp]
31834 930A           3C                     01  cmp	al,*1
31835 930C           77           15            ja  	.6B3
31836                       0000930E            .6B6:
31837                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
31838 930E           8A46         FC            mov	al,-4[bp]
31839 9311           84C0                       test	al,al
31840 9313           74           0E            je  	.6B3
31841                       00009315            .6B5:
31842                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31843 9315           8A46         FE            mov	al,-2[bp]
31844 9318           84C0                       test	al,al
31845 931A           74           07            je  	.6B3
31846                       0000931C            .6B4:
31847                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
31848 931C           8A46         FE            mov	al,-2[bp]
31849 931F           3C                     48  cmp	al,*$48
31850 9321           76           38            jbe 	.6B2
31851                       00009323            .6B3:
31852                                           ! 4601         bios_printf(4, "int13_diskette: read/write/verify: parameter out of range\n");
31853                                           ! Debug: list * char = .6B8+0 (used reg = )
31854 9323           BB                   D22C  mov	bx,#.6B8
31855 9326           53                         push	bx
31856                                           ! Debug: list int = const 4 (used reg = )
31857 9327           B8                   0004  mov	ax,*4
31858 932A           50                         push	ax
31859                                           ! Debug: func () void = bios_printf+0 (used reg = )
31860 932B           E8         76EB            call	_bios_printf
31861 932E           83C4                   04  add	sp,*4
31862                                           !BCC_EOS
31863                                           ! 4602         AX = ((AX & 0x00ff) | ((1) << 8));
31864                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31865 9331           8A46         16            mov	al,$16[bp]
31866                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31867 9334           30E4                       xor	ah,ah
31868 9336           0D                   0100  or	ax,#$100
31869                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31870 9339           8946         16            mov	$16[bp],ax
31871                                           !BCC_EOS
31872                                           ! 4603         set_diskette_ret_status(1);
31873                                           ! Debug: list int = const 1 (used reg = )
31874 933C           B8                   0001  mov	ax,*1
31875 933F           50                         push	ax
31876                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31877 9340           E8         0FB1            call	_set_diskette_ret_status
31878 9343           44                         inc	sp
31879 9344           44                         inc	sp
31880                                           !BCC_EOS
31881                                           ! 4604         AX = ((AX & 0xff00) | (0));
31882                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31883 9345           8B46         16            mov	ax,$16[bp]
31884 9348           30C0                       xor	al,al
31885                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31886 934A           0C                     00  or	al,*0
31887                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31888 934C           8946         16            mov	$16[bp],ax
31889                                           !BCC_EOS
31890                                           ! 4605         FLAGS |= 0x0001;
31891                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31892 934F           8B46         1C            mov	ax,$1C[bp]
31893 9352           0C                     01  or	al,*1
31894 9354           8946         1C            mov	$1C[bp],ax
31895                                           !BCC_EOS
31896                                           ! 4606         return;
31897 9357           89EC                       mov	sp,bp
31898 9359           5D                         pop	bp
31899 935A           C3                         ret
31900                                           !BCC_EOS
31901                                           ! 4607       }
31902                                           ! 4608       if (floppy_drive_exists(drive) == 0) {
31903                       0000935B            .6B2:
31904                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31905 935B           8A46         FF            mov	al,-1[bp]
31906 935E           30E4                       xor	ah,ah
31907 9360           50                         push	ax
31908                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
31909 9361           E8         FE2C            call	_floppy_drive_exists
31910 9364           44                         inc	sp
31911 9365           44                         inc	sp
31912                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31913 9366           85C0                       test	ax,ax
31914 9368           75           2A            jne 	.6B9
31915                       0000936A            .6BA:
31916                                           ! 4609         AX = ((AX & 0x00ff) | ((0x80) << 8));
31917                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31918 936A           8A46         16            mov	al,$16[bp]
31919                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31920 936D           30E4                       xor	ah,ah
31921 936F           0D                   8000  or	ax,#-$8000
31922                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31923 9372           8946         16            mov	$16[bp],ax
31924                                           !BCC_EOS
31925                                           ! 4610         set_diskette_ret_status(0x80);
31926                                           ! Debug: list int = const $80 (used reg = )
31927 9375           B8                   0080  mov	ax,#$80
31928 9378           50                         push	ax
31929                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31930 9379           E8         0F78            call	_set_diskette_ret_status
31931 937C           44                         inc	sp
31932 937D           44                         inc	sp
31933                                           !BCC_EOS
31934                                           ! 4611         AX = ((AX & 0xff00) | (0));
31935                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31936 937E           8B46         16            mov	ax,$16[bp]
31937 9381           30C0                       xor	al,al
31938                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31939 9383           0C                     00  or	al,*0
31940                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31941 9385           8946         16            mov	$16[bp],ax
31942                                           !BCC_EOS
31943                                           ! 4612         FLAGS |= 0x0001;
31944                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31945 9388           8B46         1C            mov	ax,$1C[bp]
31946 938B           0C                     01  or	al,*1
31947 938D           8946         1C            mov	$1C[bp],ax
31948                                           !BCC_EOS
31949                                           ! 4613         return;
31950 9390           89EC                       mov	sp,bp
31951 9392           5D                         pop	bp
31952 9393           C3                         ret
31953                                           !BCC_EOS
31954                                           ! 4614       }
31955                                           ! 4615       if (floppy_media_known(drive) == 0) {
31956                       00009394            .6B9:
31957                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31958 9394           8A46         FF            mov	al,-1[bp]
31959 9397           30E4                       xor	ah,ah
31960 9399           50                         push	ax
31961                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
31962 939A           E8         FB5E            call	_floppy_media_known
31963 939D           44                         inc	sp
31964 939E           44                         inc	sp
31965                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31966 939F           85C0                       test	ax,ax
31967 93A1           75           39            jne 	.6BB
31968                       000093A3            .6BC:
31969                                           ! 4616         if (floppy_media_sense(drive) == 0) {
31970                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31971 93A3           8A46         FF            mov	al,-1[bp]
31972 93A6           30E4                       xor	ah,ah
31973 93A8           50                         push	ax
31974                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
31975 93A9           E8         FBD2            call	_floppy_media_sense
31976 93AC           44                         inc	sp
31977 93AD           44                         inc	sp
31978                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31979 93AE           85C0                       test	ax,ax
31980 93B0           75           2A            jne 	.6BD
31981                       000093B2            .6BE:
31982                                           ! 4617           AX = ((AX & 0x00ff) | ((0x0C) << 8));
31983                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31984 93B2           8A46         16            mov	al,$16[bp]
31985                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
31986 93B5           30E4                       xor	ah,ah
31987 93B7           0D                   0C00  or	ax,#$C00
31988                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31989 93BA           8946         16            mov	$16[bp],ax
31990                                           !BCC_EOS
31991                                           ! 4618           set_diskette_ret_status(0x0C);
31992                                           ! Debug: list int = const $C (used reg = )
31993 93BD           B8                   000C  mov	ax,*$C
31994 93C0           50                         push	ax
31995                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31996 93C1           E8         0F30            call	_set_diskette_ret_status
31997 93C4           44                         inc	sp
31998 93C5           44                         inc	sp
31999                                           !BCC_EOS
32000                                           ! 4619           AX = ((AX & 0xff00) | (0));
32001                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32002 93C6           8B46         16            mov	ax,$16[bp]
32003 93C9           30C0                       xor	al,al
32004                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32005 93CB           0C                     00  or	al,*0
32006                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32007 93CD           8946         16            mov	$16[bp],ax
32008                                           !BCC_EOS
32009                                           ! 4620           FLAGS |= 0x0001;
32010                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32011 93D0           8B46         1C            mov	ax,$1C[bp]
32012 93D3           0C                     01  or	al,*1
32013 93D5           8946         1C            mov	$1C[bp],ax
32014                                           !BCC_EOS
32015                                           ! 4621           return;
32016 93D8           89EC                       mov	sp,bp
32017 93DA           5D                         pop	bp
32018 93DB           C3                         ret
32019                                           !BCC_EOS
32020                                           ! 4622         }
32021                                           ! 4623       }
32022                       000093DC            .6BD:
32023                                           ! 4624       if (ah == 0x02) {
32024                       000093DC            .6BB:
32025                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
32026 93DC           8A46         E6            mov	al,-$1A[bp]
32027 93DF           3C                     02  cmp	al,*2
32028 93E1         0F85         03B4            bne 	.6BF
32029                       000093E5            .6C0:
32030                                           ! 4625         page = (ES >> 12);
32031                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
32032 93E5           8B46         06            mov	ax,6[bp]
32033 93E8           88E0                       mov	al,ah
32034 93EA           30E4                       xor	ah,ah
32035 93EC           B1                     04  mov	cl,*4
32036 93EE           D3E8                       shr	ax,cl
32037                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
32038 93F0           8846         F3            mov	-$D[bp],al
32039                                           !BCC_EOS
32040                                           ! 4626         base_es = (ES << 4);
32041                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
32042 93F3           8B46         06            mov	ax,6[bp]
32043 93F6           B1                     04  mov	cl,*4
32044 93F8           D3E0                       shl	ax,cl
32045                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
32046 93FA           8946         F4            mov	-$C[bp],ax
32047                                           !BCC_EOS
32048                                           ! 4627         base_address = base_es + BX;
32049                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
32050 93FD           8B46         F4            mov	ax,-$C[bp]
32051 9400           0346         10            add	ax,$10[bp]
32052                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
32053 9403           8946         F8            mov	-8[bp],ax
32054                                           !BCC_EOS
32055                                           ! 4628         if ( base_address < base_es ) {
32056                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
32057 9406           8B46         F8            mov	ax,-8[bp]
32058 9409           3B46         F4            cmp	ax,-$C[bp]
32059 940C           73           07            jae 	.6C1
32060                       0000940E            .6C2:
32061                                           ! 4629           page++;
32062                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
32063 940E           8A46         F3            mov	al,-$D[bp]
32064 9411           40                         inc	ax
32065 9412           8846         F3            mov	-$D[bp],al
32066                                           !BCC_EOS
32067                                           ! 4630         }
32068                                           ! 4631         base_count = (num_sectors * 512) - 1;
32069                       00009415            .6C1:
32070                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
32071 9415           8A46         FE            mov	al,-2[bp]
32072 9418           30E4                       xor	ah,ah
32073 941A           B9                   0200  mov	cx,#$200
32074 941D           F7E9                       imul	cx
32075                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32076                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
32077 941F           48                         dec	ax
32078 9420           8946         F6            mov	-$A[bp],ax
32079                                           !BCC_EOS
32080                                           ! 4632         last_addr = base_address + base_count;
32081                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
32082 9423           8B46         F8            mov	ax,-8[bp]
32083 9426           0346         F6            add	ax,-$A[bp]
32084                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
32085 9429           8946         E2            mov	-$1E[bp],ax
32086                                           !BCC_EOS
32087                                           ! 4633         if (last_addr < base_address) {
32088                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
32089 942C           8B46         E2            mov	ax,-$1E[bp]
32090 942F           3B46         F8            cmp	ax,-8[bp]
32091 9432           73           2A            jae 	.6C3
32092                       00009434            .6C4:
32093                                           ! 4634           AX = ((AX & 0x00ff) | ((0x09) << 8));
32094                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32095 9434           8A46         16            mov	al,$16[bp]
32096                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
32097 9437           30E4                       xor	ah,ah
32098 9439           0D                   0900  or	ax,#$900
32099                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32100 943C           8946         16            mov	$16[bp],ax
32101                                           !BCC_EOS
32102                                           ! 4635           set_diskette_ret_status(0x09);
32103                                           ! Debug: list int = const 9 (used reg = )
32104 943F           B8                   0009  mov	ax,*9
32105 9442           50                         push	ax
32106                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32107 9443           E8         0EAE            call	_set_diskette_ret_status
32108 9446           44                         inc	sp
32109 9447           44                         inc	sp
32110                                           !BCC_EOS
32111                                           ! 4636           AX = ((AX & 0xff00) | (0));
32112                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32113 9448           8B46         16            mov	ax,$16[bp]
32114 944B           30C0                       xor	al,al
32115                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32116 944D           0C                     00  or	al,*0
32117                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32118 944F           8946         16            mov	$16[bp],ax
32119                                           !BCC_EOS
32120                                           ! 4637           FLAGS |= 0x0001;
32121                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32122 9452           8B46         1C            mov	ax,$1C[bp]
32123 9455           0C                     01  or	al,*1
32124 9457           8946         1C            mov	$1C[bp],ax
32125                                           !BCC_EOS
32126                                           ! 4638           return;
32127 945A           89EC                       mov	sp,bp
32128 945C           5D                         pop	bp
32129 945D           C3                         ret
32130                                           !BCC_EOS
32131                                           ! 4639         }
32132                                           ! 4640         ;
32133                       0000945E            .6C3:
32134                                           !BCC_EOS
32135                                           ! 4641         outb(0x000a, 0x06);
32136                                           ! Debug: list int = const 6 (used reg = )
32137 945E           B8                   0006  mov	ax,*6
32138 9461           50                         push	ax
32139                                           ! Debug: list int = const $A (used reg = )
32140 9462           B8                   000A  mov	ax,*$A
32141 9465           50                         push	ax
32142                                           ! Debug: func () void = outb+0 (used reg = )
32143 9466           E8         70EB            call	_outb
32144 9469           83C4                   04  add	sp,*4
32145                                           !BCC_EOS
32146                                           ! 4642   ;
32147                                           !BCC_EOS
32148                                           ! 4643         outb(0x000c, 0x00);
32149                                           ! Debug: list int = const 0 (used reg = )
32150 946C           31C0                       xor	ax,ax
32151 946E           50                         push	ax
32152                                           ! Debug: list int = const $C (used reg = )
32153 946F           B8                   000C  mov	ax,*$C
32154 9472           50                         push	ax
32155                                           ! Debug: func () void = outb+0 (used reg = )
32156 9473           E8         70DE            call	_outb
32157 9476           83C4                   04  add	sp,*4
32158                                           !BCC_EOS
32159                                           ! 4644         outb(0x0004, base_address);
32160                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
32161 9479           FF76         F8            push	-8[bp]
32162                                           ! Debug: list int = const 4 (used reg = )
32163 947C           B8                   0004  mov	ax,*4
32164 947F           50                         push	ax
32165                                           ! Debug: func () void = outb+0 (used reg = )
32166 9480           E8         70D1            call	_outb
32167 9483           83C4                   04  add	sp,*4
32168                                           !BCC_EOS
32169                                           ! 4645         outb(0x0004, base_address>>8);
32170                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
32171 9486           8B46         F8            mov	ax,-8[bp]
32172 9489           88E0                       mov	al,ah
32173 948B           30E4                       xor	ah,ah
32174                                           ! Debug: list unsigned int = ax+0 (used reg = )
32175 948D           50                         push	ax
32176                                           ! Debug: list int = const 4 (used reg = )
32177 948E           B8                   0004  mov	ax,*4
32178 9491           50                         push	ax
32179                                           ! Debug: func () void = outb+0 (used reg = )
32180 9492           E8         70BF            call	_outb
32181 9495           83C4                   04  add	sp,*4
32182                                           !BCC_EOS
32183                                           ! 4646   ;
32184                                           !BCC_EOS
32185                                           ! 4647         outb(0x000c, 0x00);
32186                                           ! Debug: list int = const 0 (used reg = )
32187 9498           31C0                       xor	ax,ax
32188 949A           50                         push	ax
32189                                           ! Debug: list int = const $C (used reg = )
32190 949B           B8                   000C  mov	ax,*$C
32191 949E           50                         push	ax
32192                                           ! Debug: func () void = outb+0 (used reg = )
32193 949F           E8         70B2            call	_outb
32194 94A2           83C4                   04  add	sp,*4
32195                                           !BCC_EOS
32196                                           ! 4648         outb(0x0005, base_count);
32197                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
32198 94A5           FF76         F6            push	-$A[bp]
32199                                           ! Debug: list int = const 5 (used reg = )
32200 94A8           B8                   0005  mov	ax,*5
32201 94AB           50                         push	ax
32202                                           ! Debug: func () void = outb+0 (used reg = )
32203 94AC           E8         70A5            call	_outb
32204 94AF           83C4                   04  add	sp,*4
32205                                           !BCC_EOS
32206                                           ! 4649         outb(0x0005, base_count>>8);
32207                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
32208 94B2           8B46         F6            mov	ax,-$A[bp]
32209 94B5           88E0                       mov	al,ah
32210 94B7           30E4                       xor	ah,ah
32211                                           ! Debug: list unsigned int = ax+0 (used reg = )
32212 94B9           50                         push	ax
32213                                           ! Debug: list int = const 5 (used reg = )
32214 94BA           B8                   0005  mov	ax,*5
32215 94BD           50                         push	ax
32216                                           ! Debug: func () void = outb+0 (used reg = )
32217 94BE           E8         7093            call	_outb
32218 94C1           83C4                   04  add	sp,*4
32219                                           !BCC_EOS
32220                                           ! 4650         mode_register = 0x46;
32221                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
32222 94C4           B0                     46  mov	al,*$46
32223 94C6           8846         F2            mov	-$E[bp],al
32224                                           !BCC_EOS
32225                                           ! 4651   ;
32226                                           !BCC_EOS
32227                                           ! 4652         outb(0x000b, mode_regi
32228                                           ! 4652 ster);
32229                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
32230 94C9           8A46         F2            mov	al,-$E[bp]
32231 94CC           30E4                       xor	ah,ah
32232 94CE           50                         push	ax
32233                                           ! Debug: list int = const $B (used reg = )
32234 94CF           B8                   000B  mov	ax,*$B
32235 94D2           50                         push	ax
32236                                           ! Debug: func () void = outb+0 (used reg = )
32237 94D3           E8         707E            call	_outb
32238 94D6           83C4                   04  add	sp,*4
32239                                           !BCC_EOS
32240                                           ! 4653   ;
32241                                           !BCC_EOS
32242                                           ! 4654         outb(0x0081, page);
32243                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
32244 94D9           8A46         F3            mov	al,-$D[bp]
32245 94DC           30E4                       xor	ah,ah
32246 94DE           50                         push	ax
32247                                           ! Debug: list int = const $81 (used reg = )
32248 94DF           B8                   0081  mov	ax,#$81
32249 94E2           50                         push	ax
32250                                           ! Debug: func () void = outb+0 (used reg = )
32251 94E3           E8         706E            call	_outb
32252 94E6           83C4                   04  add	sp,*4
32253                                           !BCC_EOS
32254                                           ! 4655   ;
32255                                           !BCC_EOS
32256                                           ! 4656         outb(0x000a, 0x02);
32257                                           ! Debug: list int = const 2 (used reg = )
32258 94E9           B8                   0002  mov	ax,*2
32259 94EC           50                         push	ax
32260                                           ! Debug: list int = const $A (used reg = )
32261 94ED           B8                   000A  mov	ax,*$A
32262 94F0           50                         push	ax
32263                                           ! Debug: func () void = outb+0 (used reg = )
32264 94F1           E8         7060            call	_outb
32265 94F4           83C4                   04  add	sp,*4
32266                                           !BCC_EOS
32267                                           ! 4657         ;
32268                                           !BCC_EOS
32269                                           ! 4658         outb(0x000a, 0x02);
32270                                           ! Debug: list int = const 2 (used reg = )
32271 94F7           B8                   0002  mov	ax,*2
32272 94FA           50                         push	ax
32273                                           ! Debug: list int = const $A (used reg = )
32274 94FB           B8                   000A  mov	ax,*$A
32275 94FE           50                         push	ax
32276                                           ! Debug: func () void = outb+0 (used reg = )
32277 94FF           E8         7052            call	_outb
32278 9502           83C4                   04  add	sp,*4
32279                                           !BCC_EOS
32280                                           ! 4659         floppy_prepare_controller(drive);
32281                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32282 9505           8A46         FF            mov	al,-1[bp]
32283 9508           30E4                       xor	ah,ah
32284 950A           50                         push	ax
32285                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
32286 950B           E8         F90E            call	_floppy_prepare_controller
32287 950E           44                         inc	sp
32288 950F           44                         inc	sp
32289                                           !BCC_EOS
32290                                           ! 4660         outb(0x03f5, 0xe6);
32291                                           ! Debug: list int = const $E6 (used reg = )
32292 9510           B8                   00E6  mov	ax,#$E6
32293 9513           50                         push	ax
32294                                           ! Debug: list int = const $3F5 (used reg = )
32295 9514           B8                   03F5  mov	ax,#$3F5
32296 9517           50                         push	ax
32297                                           ! Debug: func () void = outb+0 (used reg = )
32298 9518           E8         7039            call	_outb
32299 951B           83C4                   04  add	sp,*4
32300                                           !BCC_EOS
32301                                           ! 4661         outb(0x03f5, (head << 2) | drive);
32302                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
32303 951E           8A46         FB            mov	al,-5[bp]
32304 9521           30E4                       xor	ah,ah
32305 9523           D1E0                       shl	ax,*1
32306 9525           D1E0                       shl	ax,*1
32307                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
32308 9527           0A46         FF            or	al,-1[bp]
32309                                           ! Debug: list unsigned int = ax+0 (used reg = )
32310 952A           50                         push	ax
32311                                           ! Debug: list int = const $3F5 (used reg = )
32312 952B           B8                   03F5  mov	ax,#$3F5
32313 952E           50                         push	ax
32314                                           ! Debug: func () void = outb+0 (used reg = )
32315 952F           E8         7022            call	_outb
32316 9532           83C4                   04  add	sp,*4
32317                                           !BCC_EOS
32318                                           ! 4662         outb(0x03f5, track);
32319                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32320 9535           8A46         FD            mov	al,-3[bp]
32321 9538           30E4                       xor	ah,ah
32322 953A           50                         push	ax
32323                                           ! Debug: list int = const $3F5 (used reg = )
32324 953B           B8                   03F5  mov	ax,#$3F5
32325 953E           50                         push	ax
32326                                           ! Debug: func () void = outb+0 (used reg = )
32327 953F           E8         7012            call	_outb
32328 9542           83C4                   04  add	sp,*4
32329                                           !BCC_EOS
32330                                           ! 4663         outb(0x03f5, head);
32331                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
32332 9545           8A46         FB            mov	al,-5[bp]
32333 9548           30E4                       xor	ah,ah
32334 954A           50                         push	ax
32335                                           ! Debug: list int = const $3F5 (used reg = )
32336 954B           B8                   03F5  mov	ax,#$3F5
32337 954E           50                         push	ax
32338                                           ! Debug: func () void = outb+0 (used reg = )
32339 954F           E8         7002            call	_outb
32340 9552           83C4                   04  add	sp,*4
32341                                           !BCC_EOS
32342                                           ! 4664         outb(0x03f5, sector);
32343                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
32344 9555           8A46         FC            mov	al,-4[bp]
32345 9558           30E4                       xor	ah,ah
32346 955A           50                         push	ax
32347                                           ! Debug: list int = const $3F5 (used reg = )
32348 955B           B8                   03F5  mov	ax,#$3F5
32349 955E           50                         push	ax
32350                                           ! Debug: func () void = outb+0 (used reg = )
32351 955F           E8         6FF2            call	_outb
32352 9562           83C4                   04  add	sp,*4
32353                                           !BCC_EOS
32354                                           ! 4665         outb(0x03f5, 2);
32355                                           ! Debug: list int = const 2 (used reg = )
32356 9565           B8                   0002  mov	ax,*2
32357 9568           50                         push	ax
32358                                           ! Debug: list int = const $3F5 (used reg = )
32359 9569           B8                   03F5  mov	ax,#$3F5
32360 956C           50                         push	ax
32361                                           ! Debug: func () void = outb+0 (used reg = )
32362 956D           E8         6FE4            call	_outb
32363 9570           83C4                   04  add	sp,*4
32364                                           !BCC_EOS
32365                                           ! 4666         outb(0x03f5, sector + num_sectors - 1);
32366                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
32367 9573           8A46         FC            mov	al,-4[bp]
32368 9576           30E4                       xor	ah,ah
32369 9578           0246         FE            add	al,-2[bp]
32370 957B           80D4                   00  adc	ah,*0
32371                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32372                                           ! Debug: list unsigned int = ax-1 (used reg = )
32373 957E           48                         dec	ax
32374 957F           50                         push	ax
32375                                           ! Debug: list int = const $3F5 (used reg = )
32376 9580           B8                   03F5  mov	ax,#$3F5
32377 9583           50                         push	ax
32378                                           ! Debug: func () void = outb+0 (used reg = )
32379 9584           E8         6FCD            call	_outb
32380 9587           83C4                   04  add	sp,*4
32381                                           !BCC_EOS
32382                                           ! 4667         outb(0x03f5, 0);
32383                                           ! Debug: list int = const 0 (used reg = )
32384 958A           31C0                       xor	ax,ax
32385 958C           50                         push	ax
32386                                           ! Debug: list int = const $3F5 (used reg = )
32387 958D           B8                   03F5  mov	ax,#$3F5
32388 9590           50                         push	ax
32389                                           ! Debug: func () void = outb+0 (used reg = )
32390 9591           E8         6FC0            call	_outb
32391 9594           83C4                   04  add	sp,*4
32392                                           !BCC_EOS
32393                                           ! 4668         outb(0x03f5, 0xff);
32394                                           ! Debug: list int = const $FF (used reg = )
32395 9597           B8                   00FF  mov	ax,#$FF
32396 959A           50                         push	ax
32397                                           ! Debug: list int = const $3F5 (used reg = )
32398 959B           B8                   03F5  mov	ax,#$3F5
32399 959E           50                         push	ax
32400                                           ! Debug: func () void = outb+0 (used reg = )
32401 959F           E8         6FB2            call	_outb
32402 95A2           83C4                   04  add	sp,*4
32403                                           !BCC_EOS
32404                                           ! 4669 #asm
32405                                           !BCC_EOS
32406                                           !BCC_ASM
32407                       0000002A            _int13_diskette_function.BP	set	$2A
32408                       0000000C            .int13_diskette_function.BP	set	$C
32409                       00000038            _int13_diskette_function.CS	set	$38
32410                       0000001A            .int13_diskette_function.CS	set	$1A
32411                       00000032            _int13_diskette_function.CX	set	$32
32412                       00000014            .int13_diskette_function.CX	set	$14
32413                       00000016            _int13_diskette_function.base_address	set	$16
32414                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32415                       00000026            _int13_diskette_function.DI	set	$26
32416                       00000008            .int13_diskette_function.DI	set	8
32417                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32418                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32419                       00000014            _int13_diskette_function.base_count	set	$14
32420                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32421                       0000001A            _int13_diskette_function.sector	set	$1A
32422                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32423                       00000022            _int13_diskette_function.DS	set	$22
32424                       00000004            .int13_diskette_function.DS	set	4
32425                       00000019            _int13_diskette_function.head	set	$19
32426                       FFFFFFFB            .int13_diskette_function.head	set	-5
32427                       0000002C            _int13_diskette_function.ELDX	set	$2C
32428                       0000000E            .int13_diskette_function.ELDX	set	$E
32429                       0000000E            _int13_diskette_function.dor	set	$E
32430                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32431                       00000030            _int13_diskette_function.DX	set	$30
32432                       00000012            .int13_diskette_function.DX	set	$12
32433                       00000007            _int13_diskette_function.return_status	set	7
32434                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32435                       00000002            _int13_diskette_function.es	set	2
32436                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32437                       00000010            _int13_diskette_function.mode_register	set	$10
32438                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32439                       00000024            _int13_diskette_function.ES	set	$24
32440                       00000006            .int13_diskette_function.ES	set	6
32441                       00000012            _int13_diskette_function.base_es	set	$12
32442                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32443                       0000001B            _int13_diskette_function.track	set	$1B
32444                       FFFFFFFD            .int13_diskette_function.track	set	-3
32445                       00000028            _int13_diskette_function.SI	set	$28
32446                       0000000A            .int13_diskette_function.SI	set	$A
32447                       00000006            _int13_diskette_function.drive_type	set	6
32448                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32449                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32450                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32451                       00000036            _int13_diskette_function.IP	set	$36
32452                       00000018            .int13_diskette_function.IP	set	$18
32453                       00000018            _int13_diskette_function.status	set	$18
32454                       FFFFFFFA            .int13_diskette_function.status	set	-6
32455                       00000034            _int13_diskette_function.AX	set	$34
32456                       00000016            .int13_diskette_function.AX	set	$16
32457                       0000000F            _int13_diskette_function.val8	set	$F
32458                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32459                       00000000            _int13_diskette_function.last_addr	set	0
32460                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32461                       00000011            _int13_diskette_function.page	set	$11
32462                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32463                       00000004            _int13_diskette_function.ah	set	4
32464                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32465                       0000001D            _int13_diskette_function.drive	set	$1D
32466                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32467                       00000005            _int13_diskette_function.num_floppies	set	5
32468                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32469                       0000002E            _int13_diskette_function.BX	set	$2E
32470                       00000010            .int13_diskette_function.BX	set	$10
32471 95A5           FB                                 sti
32472                                           ! 4671 endasm
32473                                           !BCC_ENDASM
32474                                           !BCC_EOS
32475                                           ! 4672         do {
32476                       000095A6            .6C7:
32477                                           ! 4673           val8 = read_byte(0x0040, 0x0040);
32478                                           ! Debug: list int = const $40 (used reg = )
32479 95A6           B8                   0040  mov	ax,*$40
32480 95A9           50                         push	ax
32481                                           ! Debug: list int = const $40 (used reg = )
32482 95AA           B8                   0040  mov	ax,*$40
32483 95AD           50                         push	ax
32484                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32485 95AE           E8         7043            call	_read_byte
32486 95B1           83C4                   04  add	sp,*4
32487                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32488 95B4           8846         F1            mov	-$F[bp],al
32489                                           !BCC_EOS
32490                                           ! 4674           if (val8 == 0) {
32491                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32492 95B7           8A46         F1            mov	al,-$F[bp]
32493 95BA           84C0                       test	al,al
32494 95BC           75           2D            jne 	.6C8
32495                       000095BE            .6C9:
32496                                           ! 4675             floppy_reset_controller();
32497                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
32498 95BE           E8         F80D            call	_floppy_reset_controller
32499                                           !BCC_EOS
32500                                           ! 4676             AX = ((AX & 0x00ff) | ((0x80) << 8));
32501                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32502 95C1           8A46         16            mov	al,$16[bp]
32503                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32504 95C4           30E4                       xor	ah,ah
32505 95C6           0D                   8000  or	ax,#-$8000
32506                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32507 95C9           8946         16            mov	$16[bp],ax
32508                                           !BCC_EOS
32509                                           ! 4677             set_diskette_ret_status(0x80);
32510                                           ! Debug: list int = const $80 (used reg = )
32511 95CC           B8                   0080  mov	ax,#$80
32512 95CF           50                         push	ax
32513                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32514 95D0           E8         0D21            call	_set_diskette_ret_status
32515 95D3           44                         inc	sp
32516 95D4           44                         inc	sp
32517                                           !BCC_EOS
32518                                           ! 4678             AX = ((AX & 0xff00) | (0));
32519                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32520 95D5           8B46         16            mov	ax,$16[bp]
32521 95D8           30C0                       xor	al,al
32522                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32523 95DA           0C                     00  or	al,*0
32524                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32525 95DC           8946         16            mov	$16[bp],ax
32526                                           !BCC_EOS
32527                                           ! 4679             FLAGS |= 0x0001;
32528                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32529 95DF           8B46         1C            mov	ax,$1C[bp]
32530 95E2           0C                     01  or	al,*1
32531 95E4           8946         1C            mov	$1C[bp],ax
32532                                           !BCC_EOS
32533                                           ! 4680             return;
32534 95E7           89EC                       mov	sp,bp
32535 95E9           5D                         pop	bp
32536 95EA           C3                         ret
32537                                           !BCC_EOS
32538                                           ! 4681           }
32539                                           ! 4682           val8 = (read_byte(0x0040, 0x003e) & 0x80);
32540                       000095EB            .6C8:
32541                                           ! Debug: list int = const $3E (used reg = )
32542 95EB           B8                   003E  mov	ax,*$3E
32543 95EE           50                         push	ax
32544                                           ! Debug: list int = const $40 (used reg = )
32545 95EF           B8                   0040  mov	ax,*$40
32546 95F2           50                         push	ax
32547                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32548 95F3           E8         6FFE            call	_read_byte
32549 95F6           83C4                   04  add	sp,*4
32550                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32551 95F9           24                     80  and	al,#$80
32552                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32553 95FB           8846         F1            mov	-$F[bp],al
32554                                           !BCC_EOS
32555                                           ! 4683         } while ( val8 == 0 );
32556                       000095FE            .6C6:
32557                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32558 95FE           8A46         F1            mov	al,-$F[bp]
32559 9601           84C0                       test	al,al
32560 9603           74           A1            je 	.6C7
32561                       00009605            .6CA:
32562                                           !BCC_EOS
32563                                           ! 4684         val8 = 0;
32564                       00009605            .6C5:
32565                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32566 9605           30C0                       xor	al,al
32567 9607           8846         F1            mov	-$F[bp],al
32568                                           !BCC_EOS
32569                                           ! 4685 #asm
32570                                           !BCC_EOS
32571                                           !BCC_ASM
32572                       0000002A            _int13_diskette_function.BP	set	$2A
32573                       0000000C            .int13_diskette_function.BP	set	$C
32574                       00000038            _int13_diskette_function.CS	set	$38
32575                       0000001A            .int13_diskette_function.CS	set	$1A
32576                       00000032            _int13_diskette_function.CX	set	$32
32577                       00000014            .int13_diskette_function.CX	set	$14
32578                       00000016            _int13_diskette_function.base_address	set	$16
32579                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32580                       00000026            _int13_diskette_function.DI	set	$26
32581                       00000008            .int13_diskette_function.DI	set	8
32582                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32583                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32584                       00000014            _int13_diskette_function.base_count	set	$14
32585                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32586                       0000001A            _int13_diskette_function.sector	set	$1A
32587                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32588                       00000022            _int13_diskette_function.DS	set	$22
32589                       00000004            .int13_diskette_function.DS	set	4
32590                       00000019            _int13_diskette_function.head	set	$19
32591                       FFFFFFFB            .int13_diskette_function.head	set	-5
32592                       0000002C            _int13_diskette_function.ELDX	set	$2C
32593                       0000000E            .int13_diskette_function.ELDX	set	$E
32594                       0000000E            _int13_diskette_function.dor	set	$E
32595                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32596                       00000030            _int13_diskette_function.DX	set	$30
32597                       00000012            .int13_diskette_function.DX	set	$12
32598                       00000007            _int13_diskette_function.return_status	set	7
32599                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32600                       00000002            _int13_diskette_function.es	set	2
32601                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32602                       00000010            _int13_diskette_function.mode_register	set	$10
32603                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32604                       00000024            _int13_diskette_function.ES	set	$24
32605                       00000006            .int13_diskette_function.ES	set	6
32606                       00000012            _int13_diskette_function.base_es	set	$12
32607                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32608                       0000001B            _int13_diskette_function.track	set	$1B
32609                       FFFFFFFD            .int13_diskette_function.track	set	-3
32610                       00000028            _int13_diskette_function.SI	set	$28
32611                       0000000A            .int13_diskette_function.SI	set	$A
32612                       00000006            _int13_diskette_function.drive_type	set	6
32613                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32614                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32615                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32616                       00000036            _int13_diskette_function.IP	set	$36
32617                       00000018            .int13_diskette_function.IP	set	$18
32618                       00000018            _int13_diskette_function.status	set	$18
32619                       FFFFFFFA            .int13_diskette_function.status	set	-6
32620                       00000034            _int13_diskette_function.AX	set	$34
32621                       00000016            .int13_diskette_function.AX	set	$16
32622                       0000000F            _int13_diskette_function.val8	set	$F
32623                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32624                       00000000            _int13_diskette_function.last_addr	set	0
32625                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32626                       00000011            _int13_diskette_function.page	set	$11
32627                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32628                       00000004            _int13_diskette_function.ah	set	4
32629                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32630                       0000001D            _int13_diskette_function.drive	set	$1D
32631                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32632                       00000005            _int13_diskette_function.num_floppies	set	5
32633                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32634                       0000002E            _int13_diskette_function.BX	set	$2E
32635                       00000010            .int13_diskette_function.BX	set	$10
32636 960A           FA                                 cli
32637                                           ! 4687 endasm
32638                                           !BCC_ENDASM
32639                                           !BCC_EOS
32640                                           ! 4688         val8 = read_byte(0x0040, 0x003e);
32641                                           ! Debug: list int = const $3E (used reg = )
32642 960B           B8                   003E  mov	ax,*$3E
32643 960E           50                         push	ax
32644                                           ! Debug: list int = const $40 (used reg = )
32645 960F           B8                   0040  mov	ax,*$40
32646 9612           50                         push	ax
32647                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32648 9613           E8         6FDE            call	_read_byte
32649 9616           83C4                   04  add	sp,*4
32650                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32651 9619           8846         F1            mov	-$F[bp],al
32652                                           !BCC_EOS
32653                                           ! 4689         val8 &= 0x7f;
32654                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
32655 961C           8A46         F1            mov	al,-$F[bp]
32656 961F           24                     7F  and	al,*$7F
32657 9621           8846         F1            mov	-$F[bp],al
32658                                           !BCC_EOS
32659                                           ! 4690         write_byte(0x0040, 0x003e, val8);
32660                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
32661 9624           8A46         F1            mov	al,-$F[bp]
32662 9627           30E4                       xor	ah,ah
32663 9629           50                         push	ax
32664                                           ! Debug: list int = const $3E (used reg = )
32665 962A           B8                   003E  mov	ax,*$3E
32666 962D           50                         push	ax
32667                                           ! Debug: list int = const $40 (used reg = )
32668 962E           B8                   0040  mov	ax,*$40
32669 9631           50                         push	ax
32670                                           ! Debug: func () void = write_byte+0 (used reg = )
32671 9632           E8         6FE5            call	_write_byte
32672 9635           83C4                   06  add	sp,*6
32673                                           !BCC_EOS
32674                                           ! 4691         val8 = inb(0x3f4);
32675                                           ! Debug: list int = const $3F4 (used reg = )
32676 9638           B8                   03F4  mov	ax,#$3F4
32677 963B           50                         push	ax
32678                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32679 963C           E8         6EFF            call	_inb
32680 963F           44                         inc	sp
32681 9640           44                         inc	sp
32682                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32683 9641           8846         F1            mov	-$F[bp],al
32684                                           !BCC_EOS
32685                                           ! 4692         if ( (val8 & 0xc0) != 0xc0 )
32686                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
32687 9644           8A46         F1            mov	al,-$F[bp]
32688 9647           24                     C0  and	al,#$C0
32689                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
32690 9649           3C                     C0  cmp	al,#$C0
32691 964B           74           0E            je  	.6CB
32692                       0000964D            .6CC:
32693                                           ! 4693           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32694                                           ! Debug: list * char = .6CD+0 (used reg = )
32695 964D           BB                   D20C  mov	bx,#.6CD
32696 9650           53                         push	bx
32697                                           ! Debug: list int = const 7 (used reg = )
32698 9651           B8                   0007  mov	ax,*7
32699 9654           50                         push	ax
32700                                           ! Debug: func () void = bios_printf+0 (used reg = )
32701 9655           E8         73C1            call	_bios_printf
32702 9658           83C4                   04  add	sp,*4
32703                                           !BCC_EOS
32704                                           ! 4694         return_status[0] = inb(0x3f5);
32705                       0000965B            .6CB:
32706                                           ! Debug: list int = const $3F5 (used reg = )
32707 965B           B8                   03F5  mov	ax,#$3F5
32708 965E           50                         push	ax
32709                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32710 965F           E8         6EDC            call	_inb
32711 9662           44                         inc	sp
32712 9663           44                         inc	sp
32713                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32714 9664           8846         E9            mov	-$17[bp],al
32715                                           !BCC_EOS
32716                                           ! 4695         return_status[1] = inb(0x3f5);
32717                                           ! Debug: list int = const $3F5 (used reg = )
32718 9667           B8                   03F5  mov	ax,#$3F5
32719 966A           50                         push	ax
32720                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32721 966B           E8         6ED0            call	_inb
32722 966E           44                         inc	sp
32723 966F           44                         inc	sp
32724                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32725 9670           8846         EA            mov	-$16[bp],al
32726                                           !BCC_EOS
32727                                           ! 4696         return_status[2] = inb(0x3f5);
32728                                           ! Debug: list int = const $3F5 (used reg = )
32729 9673           B8                   03F5  mov	ax,#$3F5
32730 9676           50                         push	ax
32731                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32732 9677           E8         6EC4            call	_inb
32733 967A           44                         inc	sp
32734 967B           44                         inc	sp
32735                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32736 967C           8846         EB            mov	-$15[bp],al
32737                                           !BCC_EOS
32738                                           ! 4697         return_status[3] = inb(0x3f5);
32739                                           ! Debug: list int = const $3F5 (used reg = )
32740 967F           B8                   03F5  mov	ax,#$3F5
32741 9682           50                         push	ax
32742                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32743 9683           E8         6EB8            call	_inb
32744 9686           44                         inc	sp
32745 9687           44                         inc	sp
32746                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32747 9688           8846         EC            mov	-$14[bp],al
32748                                           !BCC_EOS
32749                                           ! 4698         return_status[4] = inb(0x3f5);
32750                                           ! Debug: list int = const $3F5 (used reg = )
32751 968B           B8                   03F5  mov	ax,#$3F5
32752 968E           50                         push	ax
32753                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32754 968F           E8         6EAC            call	_inb
32755 9692           44                         inc	sp
32756 9693           44                         inc	sp
32757                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32758 9694           8846         ED            mov	-$13[bp],al
32759                                           !BCC_EOS
32760                                           ! 4699         return_status[5] = inb(0x3f5);
32761                                           ! Debug: list int = const $3F5 (used reg = )
32762 9697           B8                   03F5  mov	ax,#$3F5
32763 969A           50                         push	ax
32764                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32765 969B           E8         6EA0            call	_inb
32766 969E           44                         inc	sp
32767 969F           44                         inc	sp
32768                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
32769 96A0           8846         EE            mov	-$12[bp],al
32770                                           !BCC_EOS
32771                                           ! 4700         return_status[6] = inb(0x3f5);
32772                                           ! Debug: list int = const $3F5 (used reg = )
32773 96A3           B8                   03F5  mov	ax,#$3F5
32774 96A6           50                         push	ax
32775                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32776 96A7           E8         6E94            call	_inb
32777 96AA           44                         inc	sp
32778 96AB           44                         inc	sp
32779                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
32780 96AC           8846         EF            mov	-$11[bp],al
32781                                           !BCC_EOS
32782                                           ! 4701         write_byte(0x0040, 0x0042, return_status[0]);
32783                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
32784 96AF           8A46         E9            mov	al,-$17[bp]
32785 96B2           30E4                       xor	ah,ah
32786 96B4           50                         push	ax
32787                                           ! Debug: list int = const $42 (used reg = )
32788 96B5           B8                   0042  mov	ax,*$42
32789 96B8           50                         push	ax
32790                                           ! Debug: list int = const $40 (used reg = )
32791 96B9           B8                   0040  mov	ax,*$40
32792 96BC           50                         push	ax
32793                                           ! Debug: func () void = write_byte+0 (used reg = )
32794 96BD           E8         6F5A            call	_write_byte
32795 96C0           83C4                   06  add	sp,*6
32796                                           !BCC_EOS
32797                                           ! 4702         write_byte(0x0040, 0x0043, return_status[1]);
32798                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
32799 96C3           8A46         EA            mov	al,-$16[bp]
32800 96C6           30E4                       xor	ah,ah
32801 96C8           50                         push	ax
32802                                           ! Debug: list int = const $43 (used reg = )
32803 96C9           B8                   0043  mov	ax,*$43
32804 96CC           50                         push	ax
32805                                           ! Debug: list int = const $40 (used reg = )
32806 96CD           B8                   0040  mov	ax,*$40
32807 96D0           50                         push	ax
32808                                           ! Debug: func () void = write_byte+0 (used reg = )
32809 96D1           E8         6F46            call	_write_byte
32810 96D4           83C4                   06  add	sp,*6
32811                                           !BCC_EOS
32812                                           ! 4703         write_byte(0x0040, 0x0044, return_status[2]);
32813                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
32814 96D7           8A46         EB            mov	al,-$15[bp]
32815 96DA           30E4                       xor	ah,ah
32816 96DC           50                         push	ax
32817                                           ! Debug: list int = const $44 (used reg = )
32818 96DD           B8                   0044  mov	ax,*$44
32819 96E0           50                         push	ax
32820                                           ! Debug: list int = const $40 (used reg = )
32821 96E1           B8                   0040  mov	ax,*$40
32822 96E4           50                         push	ax
32823                                           ! Debug: func () void = write_byte+0 (used reg = )
32824 96E5           E8         6F32            call	_write_byte
32825 96E8           83C4                   06  add	sp,*6
32826                                           !BCC_EOS
32827                                           ! 4704         write_byte(0x0040, 0x0045, return_status[3]);
32828                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
32829 96EB           8A46         EC            mov	al,-$14[bp]
32830 96EE           30E4                       xor	ah,ah
32831 96F0           50                         push	ax
32832                                           ! Debug: list int = const $45 (used reg = )
32833 96F1           B8                   0045  mov	ax,*$45
32834 96F4           50                         push	ax
32835                                           ! Debug: list int = const $40 (used reg = )
32836 96F5           B8                   0040  mov	ax,*$40
32837 96F8           50                         push	ax
32838                                           ! Debug: func () void = write_byte+0 (used reg = )
32839 96F9           E8         6F1E            call	_write_byte
32840 96FC           83C4                   06  add	sp,*6
32841                                           !BCC_EOS
32842                                           ! 4705         write_byte(0x0040, 0x0046, return_status[4]);
32843                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
32844 96FF           8A46         ED            mov	al,-$13[bp]
32845 9702           30E4                       xor	ah,ah
32846 9704           50                         push	ax
32847                                           ! Debug: list int = const $46 (used reg = )
32848 9705           B8                   0046  mov	ax,*$46
32849 9708           50                         push	ax
32850                                           ! Debug: list int = const $40 (used reg = )
32851 9709           B8                   0040  mov	ax,*$40
32852 970C           50                         push	ax
32853                                           ! Debug: func () void = write_byte+0 (used reg = )
32854 970D           E8         6F0A            call	_write_byte
32855 9710           83C4                   06  add	sp,*6
32856                                           !BCC_EOS
32857                                           ! 4706         write_byte(0x0040, 0x0047, return_status[5]);
32858                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
32859 9713           8A46         EE            mov	al,-$12[bp]
32860 9716           30E4                       xor	ah,ah
32861 9718           50                         push	ax
32862                                           ! Debug: list int = const $47 (used reg = )
32863 9719           B8                   0047  mov	ax,*$47
32864 971C           50                         push	ax
32865                                           ! Debug: list int = const $40 (used reg = )
32866 971D           B8                   0040  mov	ax,*$40
32867 9720           50                         push	ax
32868                                           ! Debug: func () void = write_byte+0 (used reg = )
32869 9721           E8         6EF6            call	_write_byte
32870 9724           83C4                   06  add	sp,*6
32871                                           !BCC_EOS
32872                                           ! 4707         write_byte(0x0040, 0x0048, return_status[6]);
32873                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
32874 9727           8A46         EF            mov	al,-$11[bp]
32875 972A           30E4                       xor	ah,ah
32876 972C           50                         push	ax
32877                                           ! Debug: list int = const $48 (used reg = )
32878 972D           B8                   0048  mov	ax,*$48
32879 9730           50                         push	ax
32880                                           ! Debug: list int = const $40 (used reg = )
32881 9731           B8                   0040  mov	ax,*$40
32882 9734           50                         push	ax
32883                                           ! Debug: func () void = write_byte+0 (used reg = )
32884 9735           E8         6EE2            call	_write_byte
32885 9738           83C4                   06  add	sp,*6
32886                                           !BCC_EOS
32887                                           ! 4708         if ( (return_status[0] & 0xc0) != 0 ) {
32888                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
32889 973B           8A46         E9            mov	al,-$17[bp]
32890 973E           24                     C0  and	al,#$C0
32891                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32892 9740           84C0                       test	al,al
32893 9742           74           2A            je  	.6CE
32894                       00009744            .6CF:
32895                                           ! 4709           AX = ((AX & 0x00ff) | ((0x20) << 8));
32896                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32897 9744           8A46         16            mov	al,$16[bp]
32898                                           ! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
32899 9747           30E4                       xor	ah,ah
32900 9749           0D                   2000  or	ax,#$2000
32901                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32902 974C           8946         16            mov	$16[bp],ax
32903                                           !BCC_EOS
32904                                           ! 4710           set_diskette_ret_status(0x20);
32905                                           ! Debug: list int = const $20 (used reg = )
32906 974F           B8                   0020  mov	ax,*$20
32907 9752           50                         push	ax
32908                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32909 9753           E8         0B9E            call	_set_diskette_ret_status
32910 9756           44                         inc	sp
32911 9757           44                         inc	sp
32912                                           !BCC_EOS
32913                                           ! 4711           AX = ((AX & 0xff00) | (0));
32914                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32915 9758           8B46         16            mov	ax,$16[bp]
32916 975B           30C0                       xor	al,al
32917                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32918 975D           0C                     00  or	al,*0
32919                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32920 975F           8946         16            mov	$16[bp],ax
32921                                           !BCC_EOS
32922                                           ! 4712           FLAGS |= 0x0001;
32923                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32924 9762           8B46         1C            mov	ax,$1C[bp]
32925 9765           0C                     01  or	al,*1
32926 9767           8946         1C            mov	$1C[bp],ax
32927                                           !BCC_EOS
32928                                           ! 4713           return;
32929 976A           89EC                       mov	sp,bp
32930 976C           5D                         pop	bp
32931 976D           C3                         ret
32932                                           !BCC_EOS
32933                                           ! 4714         }
32934                                           ! 4715         set_diskette_
32935                                           ! 4715 current_cyl(drive, track);
32936                       0000976E            .6CE:
32937                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32938 976E           8A46         FD            mov	al,-3[bp]
32939 9771           30E4                       xor	ah,ah
32940 9773           50                         push	ax
32941                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
32942 9774           8A46         FF            mov	al,-1[bp]
32943 9777           30E4                       xor	ah,ah
32944 9779           50                         push	ax
32945                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
32946 977A           E8         0B8F            call	_set_diskette_current_cyl
32947 977D           83C4                   04  add	sp,*4
32948                                           !BCC_EOS
32949                                           ! 4716         AX = ((AX & 0x00ff) | ((0x00) << 8));
32950                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32951 9780           8A46         16            mov	al,$16[bp]
32952                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32953 9783           0C                     00  or	al,*0
32954                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
32955 9785           30E4                       xor	ah,ah
32956 9787           8946         16            mov	$16[bp],ax
32957                                           !BCC_EOS
32958                                           ! 4717         FLAGS &= 0xfffe;
32959                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32960 978A           8B46         1C            mov	ax,$1C[bp]
32961 978D           24                     FE  and	al,#$FE
32962 978F           8946         1C            mov	$1C[bp],ax
32963                                           !BCC_EOS
32964                                           ! 4718         return;
32965 9792           89EC                       mov	sp,bp
32966 9794           5D                         pop	bp
32967 9795           C3                         ret
32968                                           !BCC_EOS
32969                                           ! 4719       } else if (ah == 0x03) {
32970 9796           E9         03D7            br 	.6D0
32971                       00009799            .6BF:
32972                                           ! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
32973 9799           8A46         E6            mov	al,-$1A[bp]
32974 979C           3C                     03  cmp	al,*3
32975 979E         0F85         03A6            bne 	.6D1
32976                       000097A2            .6D2:
32977                                           ! 4720         page = (ES >> 12);
32978                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
32979 97A2           8B46         06            mov	ax,6[bp]
32980 97A5           88E0                       mov	al,ah
32981 97A7           30E4                       xor	ah,ah
32982 97A9           B1                     04  mov	cl,*4
32983 97AB           D3E8                       shr	ax,cl
32984                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
32985 97AD           8846         F3            mov	-$D[bp],al
32986                                           !BCC_EOS
32987                                           ! 4721         base_es = (ES << 4);
32988                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
32989 97B0           8B46         06            mov	ax,6[bp]
32990 97B3           B1                     04  mov	cl,*4
32991 97B5           D3E0                       shl	ax,cl
32992                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
32993 97B7           8946         F4            mov	-$C[bp],ax
32994                                           !BCC_EOS
32995                                           ! 4722         base_address = base_es + BX;
32996                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
32997 97BA           8B46         F4            mov	ax,-$C[bp]
32998 97BD           0346         10            add	ax,$10[bp]
32999                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
33000 97C0           8946         F8            mov	-8[bp],ax
33001                                           !BCC_EOS
33002                                           ! 4723         if ( base_address < base_es ) {
33003                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
33004 97C3           8B46         F8            mov	ax,-8[bp]
33005 97C6           3B46         F4            cmp	ax,-$C[bp]
33006 97C9           73           07            jae 	.6D3
33007                       000097CB            .6D4:
33008                                           ! 4724           page++;
33009                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
33010 97CB           8A46         F3            mov	al,-$D[bp]
33011 97CE           40                         inc	ax
33012 97CF           8846         F3            mov	-$D[bp],al
33013                                           !BCC_EOS
33014                                           ! 4725         }
33015                                           ! 4726         base_count = (num_sectors * 512) - 1;
33016                       000097D2            .6D3:
33017                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
33018 97D2           8A46         FE            mov	al,-2[bp]
33019 97D5           30E4                       xor	ah,ah
33020 97D7           B9                   0200  mov	cx,#$200
33021 97DA           F7E9                       imul	cx
33022                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33023                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
33024 97DC           48                         dec	ax
33025 97DD           8946         F6            mov	-$A[bp],ax
33026                                           !BCC_EOS
33027                                           ! 4727         last_addr = base_address + base_count;
33028                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
33029 97E0           8B46         F8            mov	ax,-8[bp]
33030 97E3           0346         F6            add	ax,-$A[bp]
33031                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
33032 97E6           8946         E2            mov	-$1E[bp],ax
33033                                           !BCC_EOS
33034                                           ! 4728         if (last_addr < base_address) {
33035                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
33036 97E9           8B46         E2            mov	ax,-$1E[bp]
33037 97EC           3B46         F8            cmp	ax,-8[bp]
33038 97EF           73           2A            jae 	.6D5
33039                       000097F1            .6D6:
33040                                           ! 4729           AX = ((AX & 0x00ff) | ((0x09) << 8));
33041                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33042 97F1           8A46         16            mov	al,$16[bp]
33043                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
33044 97F4           30E4                       xor	ah,ah
33045 97F6           0D                   0900  or	ax,#$900
33046                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33047 97F9           8946         16            mov	$16[bp],ax
33048                                           !BCC_EOS
33049                                           ! 4730           set_diskette_ret_status(0x09);
33050                                           ! Debug: list int = const 9 (used reg = )
33051 97FC           B8                   0009  mov	ax,*9
33052 97FF           50                         push	ax
33053                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33054 9800           E8         0AF1            call	_set_diskette_ret_status
33055 9803           44                         inc	sp
33056 9804           44                         inc	sp
33057                                           !BCC_EOS
33058                                           ! 4731           AX = ((AX & 0xff00) | (0));
33059                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33060 9805           8B46         16            mov	ax,$16[bp]
33061 9808           30C0                       xor	al,al
33062                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33063 980A           0C                     00  or	al,*0
33064                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33065 980C           8946         16            mov	$16[bp],ax
33066                                           !BCC_EOS
33067                                           ! 4732           FLAGS |= 0x0001;
33068                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33069 980F           8B46         1C            mov	ax,$1C[bp]
33070 9812           0C                     01  or	al,*1
33071 9814           8946         1C            mov	$1C[bp],ax
33072                                           !BCC_EOS
33073                                           ! 4733           return;
33074 9817           89EC                       mov	sp,bp
33075 9819           5D                         pop	bp
33076 981A           C3                         ret
33077                                           !BCC_EOS
33078                                           ! 4734         }
33079                                           ! 4735         ;
33080                       0000981B            .6D5:
33081                                           !BCC_EOS
33082                                           ! 4736         outb(0x000a, 0x06);
33083                                           ! Debug: list int = const 6 (used reg = )
33084 981B           B8                   0006  mov	ax,*6
33085 981E           50                         push	ax
33086                                           ! Debug: list int = const $A (used reg = )
33087 981F           B8                   000A  mov	ax,*$A
33088 9822           50                         push	ax
33089                                           ! Debug: func () void = outb+0 (used reg = )
33090 9823           E8         6D2E            call	_outb
33091 9826           83C4                   04  add	sp,*4
33092                                           !BCC_EOS
33093                                           ! 4737         outb(0x000c, 0x00);
33094                                           ! Debug: list int = const 0 (used reg = )
33095 9829           31C0                       xor	ax,ax
33096 982B           50                         push	ax
33097                                           ! Debug: list int = const $C (used reg = )
33098 982C           B8                   000C  mov	ax,*$C
33099 982F           50                         push	ax
33100                                           ! Debug: func () void = outb+0 (used reg = )
33101 9830           E8         6D21            call	_outb
33102 9833           83C4                   04  add	sp,*4
33103                                           !BCC_EOS
33104                                           ! 4738         outb(0x0004, base_address);
33105                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
33106 9836           FF76         F8            push	-8[bp]
33107                                           ! Debug: list int = const 4 (used reg = )
33108 9839           B8                   0004  mov	ax,*4
33109 983C           50                         push	ax
33110                                           ! Debug: func () void = outb+0 (used reg = )
33111 983D           E8         6D14            call	_outb
33112 9840           83C4                   04  add	sp,*4
33113                                           !BCC_EOS
33114                                           ! 4739         outb(0x0004, base_address>>8);
33115                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
33116 9843           8B46         F8            mov	ax,-8[bp]
33117 9846           88E0                       mov	al,ah
33118 9848           30E4                       xor	ah,ah
33119                                           ! Debug: list unsigned int = ax+0 (used reg = )
33120 984A           50                         push	ax
33121                                           ! Debug: list int = const 4 (used reg = )
33122 984B           B8                   0004  mov	ax,*4
33123 984E           50                         push	ax
33124                                           ! Debug: func () void = outb+0 (used reg = )
33125 984F           E8         6D02            call	_outb
33126 9852           83C4                   04  add	sp,*4
33127                                           !BCC_EOS
33128                                           ! 4740         outb(0x000c, 0x00);
33129                                           ! Debug: list int = const 0 (used reg = )
33130 9855           31C0                       xor	ax,ax
33131 9857           50                         push	ax
33132                                           ! Debug: list int = const $C (used reg = )
33133 9858           B8                   000C  mov	ax,*$C
33134 985B           50                         push	ax
33135                                           ! Debug: func () void = outb+0 (used reg = )
33136 985C           E8         6CF5            call	_outb
33137 985F           83C4                   04  add	sp,*4
33138                                           !BCC_EOS
33139                                           ! 4741         outb(0x0005, base_count);
33140                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
33141 9862           FF76         F6            push	-$A[bp]
33142                                           ! Debug: list int = const 5 (used reg = )
33143 9865           B8                   0005  mov	ax,*5
33144 9868           50                         push	ax
33145                                           ! Debug: func () void = outb+0 (used reg = )
33146 9869           E8         6CE8            call	_outb
33147 986C           83C4                   04  add	sp,*4
33148                                           !BCC_EOS
33149                                           ! 4742         outb(0x0005, base_count>>8);
33150                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
33151 986F           8B46         F6            mov	ax,-$A[bp]
33152 9872           88E0                       mov	al,ah
33153 9874           30E4                       xor	ah,ah
33154                                           ! Debug: list unsigned int = ax+0 (used reg = )
33155 9876           50                         push	ax
33156                                           ! Debug: list int = const 5 (used reg = )
33157 9877           B8                   0005  mov	ax,*5
33158 987A           50                         push	ax
33159                                           ! Debug: func () void = outb+0 (used reg = )
33160 987B           E8         6CD6            call	_outb
33161 987E           83C4                   04  add	sp,*4
33162                                           !BCC_EOS
33163                                           ! 4743         mode_register = 0x4a;
33164                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
33165 9881           B0                     4A  mov	al,*$4A
33166 9883           8846         F2            mov	-$E[bp],al
33167                                           !BCC_EOS
33168                                           ! 4744         outb(0x000b, mode_register);
33169                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
33170 9886           8A46         F2            mov	al,-$E[bp]
33171 9889           30E4                       xor	ah,ah
33172 988B           50                         push	ax
33173                                           ! Debug: list int = const $B (used reg = )
33174 988C           B8                   000B  mov	ax,*$B
33175 988F           50                         push	ax
33176                                           ! Debug: func () void = outb+0 (used reg = )
33177 9890           E8         6CC1            call	_outb
33178 9893           83C4                   04  add	sp,*4
33179                                           !BCC_EOS
33180                                           ! 4745         outb(0x0081, page);
33181                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
33182 9896           8A46         F3            mov	al,-$D[bp]
33183 9899           30E4                       xor	ah,ah
33184 989B           50                         push	ax
33185                                           ! Debug: list int = const $81 (used reg = )
33186 989C           B8                   0081  mov	ax,#$81
33187 989F           50                         push	ax
33188                                           ! Debug: func () void = outb+0 (used reg = )
33189 98A0           E8         6CB1            call	_outb
33190 98A3           83C4                   04  add	sp,*4
33191                                           !BCC_EOS
33192                                           ! 4746         ;
33193                                           !BCC_EOS
33194                                           ! 4747         outb(0x000a, 0x02);
33195                                           ! Debug: list int = const 2 (used reg = )
33196 98A6           B8                   0002  mov	ax,*2
33197 98A9           50                         push	ax
33198                                           ! Debug: list int = const $A (used reg = )
33199 98AA           B8                   000A  mov	ax,*$A
33200 98AD           50                         push	ax
33201                                           ! Debug: func () void = outb+0 (used reg = )
33202 98AE           E8         6CA3            call	_outb
33203 98B1           83C4                   04  add	sp,*4
33204                                           !BCC_EOS
33205                                           ! 4748         floppy_prepare_controller(drive);
33206                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33207 98B4           8A46         FF            mov	al,-1[bp]
33208 98B7           30E4                       xor	ah,ah
33209 98B9           50                         push	ax
33210                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
33211 98BA           E8         F55F            call	_floppy_prepare_controller
33212 98BD           44                         inc	sp
33213 98BE           44                         inc	sp
33214                                           !BCC_EOS
33215                                           ! 4749         outb(0x03f5, 0xc5);
33216                                           ! Debug: list int = const $C5 (used reg = )
33217 98BF           B8                   00C5  mov	ax,#$C5
33218 98C2           50                         push	ax
33219                                           ! Debug: list int = const $3F5 (used reg = )
33220 98C3           B8                   03F5  mov	ax,#$3F5
33221 98C6           50                         push	ax
33222                                           ! Debug: func () void = outb+0 (used reg = )
33223 98C7           E8         6C8A            call	_outb
33224 98CA           83C4                   04  add	sp,*4
33225                                           !BCC_EOS
33226                                           ! 4750         outb(0x03f5, (head << 2) | drive);
33227                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
33228 98CD           8A46         FB            mov	al,-5[bp]
33229 98D0           30E4                       xor	ah,ah
33230 98D2           D1E0                       shl	ax,*1
33231 98D4           D1E0                       shl	ax,*1
33232                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
33233 98D6           0A46         FF            or	al,-1[bp]
33234                                           ! Debug: list unsigned int = ax+0 (used reg = )
33235 98D9           50                         push	ax
33236                                           ! Debug: list int = const $3F5 (used reg = )
33237 98DA           B8                   03F5  mov	ax,#$3F5
33238 98DD           50                         push	ax
33239                                           ! Debug: func () void = outb+0 (used reg = )
33240 98DE           E8         6C73            call	_outb
33241 98E1           83C4                   04  add	sp,*4
33242                                           !BCC_EOS
33243                                           ! 4751         outb(0x03f5, track);
33244                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33245 98E4           8A46         FD            mov	al,-3[bp]
33246 98E7           30E4                       xor	ah,ah
33247 98E9           50                         push	ax
33248                                           ! Debug: list int = const $3F5 (used reg = )
33249 98EA           B8                   03F5  mov	ax,#$3F5
33250 98ED           50                         push	ax
33251                                           ! Debug: func () void = outb+0 (used reg = )
33252 98EE           E8         6C63            call	_outb
33253 98F1           83C4                   04  add	sp,*4
33254                                           !BCC_EOS
33255                                           ! 4752         outb(0x03f5, head);
33256                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
33257 98F4           8A46         FB            mov	al,-5[bp]
33258 98F7           30E4                       xor	ah,ah
33259 98F9           50                         push	ax
33260                                           ! Debug: list int = const $3F5 (used reg = )
33261 98FA           B8                   03F5  mov	ax,#$3F5
33262 98FD           50                         push	ax
33263                                           ! Debug: func () void = outb+0 (used reg = )
33264 98FE           E8         6C53            call	_outb
33265 9901           83C4                   04  add	sp,*4
33266                                           !BCC_EOS
33267                                           ! 4753         outb(0x03f5, sector);
33268                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
33269 9904           8A46         FC            mov	al,-4[bp]
33270 9907           30E4                       xor	ah,ah
33271 9909           50                         push	ax
33272                                           ! Debug: list int = const $3F5 (used reg = )
33273 990A           B8                   03F5  mov	ax,#$3F5
33274 990D           50                         push	ax
33275                                           ! Debug: func () void = outb+0 (used reg = )
33276 990E           E8         6C43            call	_outb
33277 9911           83C4                   04  add	sp,*4
33278                                           !BCC_EOS
33279                                           ! 4754         outb(0x03f5, 2);
33280                                           ! Debug: list int = const 2 (used reg = )
33281 9914           B8                   0002  mov	ax,*2
33282 9917           50                         push	ax
33283                                           ! Debug: list int = const $3F5 (used reg = )
33284 9918           B8                   03F5  mov	ax,#$3F5
33285 991B           50                         push	ax
33286                                           ! Debug: func () void = outb+0 (used reg = )
33287 991C           E8         6C35            call	_outb
33288 991F           83C4                   04  add	sp,*4
33289                                           !BCC_EOS
33290                                           ! 4755         outb(0x03f5, sector + num_sectors - 1);
33291                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
33292 9922           8A46         FC            mov	al,-4[bp]
33293 9925           30E4                       xor	ah,ah
33294 9927           0246         FE            add	al,-2[bp]
33295 992A           80D4                   00  adc	ah,*0
33296                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33297                                           ! Debug: list unsigned int = ax-1 (used reg = )
33298 992D           48                         dec	ax
33299 992E           50                         push	ax
33300                                           ! Debug: list int = const $3F5 (used reg = )
33301 992F           B8                   03F5  mov	ax,#$3F5
33302 9932           50                         push	ax
33303                                           ! Debug: func () void = outb+0 (used reg = )
33304 9933           E8         6C1E            call	_outb
33305 9936           83C4                   04  add	sp,*4
33306                                           !BCC_EOS
33307                                           ! 4756         outb(0x03f5, 0);
33308                                           ! Debug: list int = const 0 (used reg = )
33309 9939           31C0                       xor	ax,ax
33310 993B           50                         push	ax
33311                                           ! Debug: list int = const $3F5 (used reg = )
33312 993C           B8                   03F5  mov	ax,#$3F5
33313 993F           50                         push	ax
33314                                           ! Debug: func () void = outb+0 (used reg = )
33315 9940           E8         6C11            call	_outb
33316 9943           83C4                   04  add	sp,*4
33317                                           !BCC_EOS
33318                                           ! 4757         outb(0x03f5, 0xff);
33319                                           ! Debug: list int = const $FF (used reg = )
33320 9946           B8                   00FF  mov	ax,#$FF
33321 9949           50                         push	ax
33322                                           ! Debug: list int = const $3F5 (used reg = )
33323 994A           B8                   03F5  mov	ax,#$3F5
33324 994D           50                         push	ax
33325                                           ! Debug: func () void = outb+0 (used reg = )
33326 994E           E8         6C03            call	_outb
33327 9951           83C4                   04  add	sp,*4
33328                                           !BCC_EOS
33329                                           ! 4758 #asm
33330                                           !BCC_EOS
33331                                           !BCC_ASM
33332                       0000002A            _int13_diskette_function.BP	set	$2A
33333                       0000000C            .int13_diskette_function.BP	set	$C
33334                       00000038            _int13_diskette_function.CS	set	$38
33335                       0000001A            .int13_diskette_function.CS	set	$1A
33336                       00000032            _int13_diskette_function.CX	set	$32
33337                       00000014            .int13_diskette_function.CX	set	$14
33338                       00000016            _int13_diskette_function.base_address	set	$16
33339                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33340                       00000026            _int13_diskette_function.DI	set	$26
33341                       00000008            .int13_diskette_function.DI	set	8
33342                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33343                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33344                       00000014            _int13_diskette_function.base_count	set	$14
33345                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33346                       0000001A            _int13_diskette_function.sector	set	$1A
33347                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33348                       00000022            _int13_diskette_function.DS	set	$22
33349                       00000004            .int13_diskette_function.DS	set	4
33350                       00000019            _int13_diskette_function.head	set	$19
33351                       FFFFFFFB            .int13_diskette_function.head	set	-5
33352                       0000002C            _int13_diskette_function.ELDX	set	$2C
33353                       0000000E            .int13_diskette_function.ELDX	set	$E
33354                       0000000E            _int13_diskette_function.dor	set	$E
33355                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33356                       00000030            _int13_diskette_function.DX	set	$30
33357                       00000012            .int13_diskette_function.DX	set	$12
33358                       00000007            _int13_diskette_function.return_status	set	7
33359                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33360                       00000002            _int13_diskette_function.es	set	2
33361                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33362                       00000010            _int13_diskette_function.mode_register	set	$10
33363                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33364                       00000024            _int13_diskette_function.ES	set	$24
33365                       00000006            .int13_diskette_function.ES	set	6
33366                       00000012            _int13_diskette_function.base_es	set	$12
33367                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33368                       0000001B            _int13_diskette_function.track	set	$1B
33369                       FFFFFFFD            .int13_diskette_function.track	set	-3
33370                       00000028            _int13_diskette_function.SI	set	$28
33371                       0000000A            .int13_diskette_function.SI	set	$A
33372                       00000006            _int13_diskette_function.drive_type	set	6
33373                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33374                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33375                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33376                       00000036            _int13_diskette_function.IP	set	$36
33377                       00000018            .int13_diskette_function.IP	set	$18
33378                       00000018            _int13_diskette_function.status	set	$18
33379                       FFFFFFFA            .int13_diskette_function.status	set	-6
33380                       00000034            _int13_diskette_function.AX	set	$34
33381                       00000016            .int13_diskette_function.AX	set	$16
33382                       0000000F            _int13_diskette_function.val8	set	$F
33383                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33384                       00000000            _int13_diskette_function.last_addr	set	0
33385                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33386                       00000011            _int13_diskette_function.page	set	$11
33387                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33388                       00000004            _int13_diskette_function.ah	set	4
33389                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33390                       0000001D            _int13_diskette_function.drive	set	$1D
33391                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33392                       00000005            _int13_diskette_function.num_floppies	set	5
33393                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33394                       0000002E            _int13_diskette_function.BX	set	$2E
33395                       00000010            .int13_diskette_function.BX	set	$10
33396 9954           FB                                 sti
33397                                           ! 4760 endasm
33398                                           !BCC_ENDASM
33399                                           !BCC_EOS
33400                                           ! 4761         do {
33401                       00009955            .6D9:
33402                                           ! 4762           val8 = read_byte(0x0040, 0x0040);
33403                                           ! Debug: list int = const $40 (used reg = )
33404 9955           B8                   0040  mov	ax,*$40
33405 9958           50                         push	ax
33406                                           ! Debug: list int = const $40 (used reg = )
33407 9959           B8                   0040  mov	ax,*$40
33408 995C           50                         push	ax
33409                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33410 995D           E8         6C94            call	_read_byte
33411 9960           83C4                   04  add	sp,*4
33412                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33413 9963           8846         F1            mov	-$F[bp],al
33414                                           !BCC_EOS
33415                                           ! 4763           if (val8 == 0) {
33416                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33417 9966           8A46         F1            mov	al,-$F[bp]
33418 9969           84C0                       test	al,al
33419 996B           75           2D            jne 	.6DA
33420                       0000996D            .6DB:
33421                                           ! 4764             floppy_reset_controller();
33422                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
33423 996D           E8         F45E            call	_floppy_reset_controller
33424                                           !BCC_EOS
33425                                           ! 4765             AX = ((AX & 0x00ff) | ((0x80) << 8));
33426                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33427 9970           8A46         16            mov	al,$16[bp]
33428                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33429 9973           30E4                       xor	ah,ah
33430 9975           0D                   8000  or	ax,#-$8000
33431                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33432 9978           8946         16            mov	$16[bp],ax
33433                                           !BCC_EOS
33434                                           ! 4766             set_diskette_ret_status(0x80);
33435                                           ! Debug: list int = const $80 (used reg = )
33436 997B           B8                   0080  mov	ax,#$80
33437 997E           50                         push	ax
33438                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33439 997F           E8         0972            call	_set_diskette_ret_status
33440 9982           44                         inc	sp
33441 9983           44                         inc	sp
33442                                           !BCC_EOS
33443                                           ! 4767             AX = ((AX & 0xff00) | (0));
33444                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33445 9984           8B46         16            mov	ax,$16[bp]
33446 9987           30C0                       xor	al,al
33447                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33448 9989           0C                     00  or	al,*0
33449                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33450 998B           8946         16            mov	$16[bp],ax
33451                                           !BCC_EOS
33452                                           ! 4768             FLAGS |= 0x0001;
33453                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33454 998E           8B46         1C            mov	ax,$1C[bp]
33455 9991           0C                     01  or	al,*1
33456 9993           8946         1C            mov	$1C[bp],ax
33457                                           !BCC_EOS
33458                                           ! 4769             return;
33459 9996           89EC                       mov	sp,bp
33460 9998           5D                         pop	bp
33461 9999           C3                         ret
33462                                           !BCC_EOS
33463                                           ! 4770           }
33464                                           ! 4771           val8 = (read_byte(0x0040, 0x003e) & 0x80);
33465                       0000999A            .6DA:
33466                                           ! Debug: list int = const $3E (used reg = )
33467 999A           B8                   003E  mov	ax,*$3E
33468 999D           50                         push	ax
33469                                           ! Debug: list int = const $40 (used reg = )
33470 999E           B8                   0040  mov	ax,*$40
33471 99A1           50                         push	ax
33472                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33473 99A2           E8         6C4F            call	_read_byte
33474 99A5           83C4                   04  add	sp,*4
33475                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
33476 99A8           24                     80  and	al,#$80
33477                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33478 99AA           8846         F1            mov	-$F[bp],al
33479                                           !BCC_EOS
33480                                           ! 4772         } while ( val8 == 0 );
33481                       000099AD            .6D8:
33482                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33483 99AD           8A46         F1            mov	al,-$F[bp]
33484 99B0           84C0                       test	al,al
33485 99B2           74           A1            je 	.6D9
33486                       000099B4            .6DC:
33487                                           !BCC_EOS
33488                                           ! 4773         val8 = 0;
33489                       000099B4            .6D7:
33490                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33491 99B4           30C0                       xor	al,al
33492 99B6           8846         F1            mov	-$F[bp],al
33493                                           !BCC_EOS
33494                                           ! 4774 #asm
33495                                           !BCC_EOS
33496                                           !BCC_ASM
33497                       0000002A            _int13_diskette_function.BP	set	$2A
33498                       0000000C            .int13_diskette_function.BP	set	$C
33499                       00000038            _int13_diskette_function.CS	set	$38
33500                       0000001A            .int13_diskette_function.CS	set	$1A
33501                       00000032            _int13_diskette_function.CX	set	$32
33502                       00000014            .int13_diskette_function.CX	set	$14
33503                       00000016            _int13_diskette_function.base_address	set	$16
33504                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33505                       00000026            _int13_diskette_function.DI	set	$26
33506                       00000008            .int13_diskette_function.DI	set	8
33507                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33508                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33509                       00000014            _int13_diskette_function.base_count	set	$14
33510                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33511                       0000001A            _int13_diskette_function.sector	set	$1A
33512                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33513                       00000022            _int13_diskette_function.DS	set	$22
33514                       00000004            .int13_diskette_function.DS	set	4
33515                       00000019            _int13_diskette_function.head	set	$19
33516                       FFFFFFFB            .int13_diskette_function.head	set	-5
33517                       0000002C            _int13_diskette_function.ELDX	set	$2C
33518                       0000000E            .int13_diskette_function.ELDX	set	$E
33519                       0000000E            _int13_diskette_function.dor	set	$E
33520                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33521                       00000030            _int13_diskette_function.DX	set	$30
33522                       00000012            .int13_diskette_function.DX	set	$12
33523                       00000007            _int13_diskette_function.return_status	set	7
33524                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33525                       00000002            _int13_diskette_function.es	set	2
33526                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33527                       00000010            _int13_diskette_function.mode_register	set	$10
33528                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33529                       00000024            _int13_diskette_function.ES	set	$24
33530                       00000006            .int13_diskette_function.ES	set	6
33531                       00000012            _int13_diskette_function.base_es	set	$12
33532                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33533                       0000001B            _int13_diskette_function.track	set	$1B
33534                       FFFFFFFD            .int13_diskette_function.track	set	-3
33535                       00000028            _int13_diskette_function.SI	set	$28
33536                       0000000A            .int13_diskette_function.SI	set	$A
33537                       00000006            _int13_diskette_function.drive_type	set	6
33538                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33539                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33540                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33541                       00000036            _int13_diskette_function.IP	set	$36
33542                       00000018            .int13_diskette_function.IP	set	$18
33543                       00000018            _int13_diskette_function.status	set	$18
33544                       FFFFFFFA            .int13_diskette_function.status	set	-6
33545                       00000034            _int13_diskette_function.AX	set	$34
33546                       00000016            .int13_diskette_function.AX	set	$16
33547                       0000000F            _int13_diskette_function.val8	set	$F
33548                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33549                       00000000            _int13_diskette_function.last_addr	set	0
33550                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33551                       00000011            _int13_diskette_function.page	set	$11
33552                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33553                       00000004            _int13_diskette_function.ah	set	4
33554                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33555                       0000001D            _int13_diskette_function.drive	set	$1D
33556                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33557                       00000005            _int13_diskette_function.num_floppies	set	5
33558                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33559                       0000002E            _int13_diskette_function.BX	set	$2E
33560                       00000010            .int13_diskette_function.BX	set	$10
33561 99B9           FA                                 cli
33562                                           ! 4776 endasm
33563                                           !BCC_ENDASM
33564                                           !BCC_EOS
33565                                           ! 4777         val8 = read_byte(0x0040, 0x003e);
33566                                           ! Debug: list int = const $3E (used reg = )
33567 99BA           B8                   003E  mov	ax,*$3E
33568 99BD           50                         push	ax
33569                                           ! Debug: list int = const $40 (used reg = )
33570 99BE           B8                   0040  mov	ax,*$40
33571 99C1           50                         push	ax
33572                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33573 99C2           E8         6C2F            call	_read_byte
33574 99C5           83C4                   04  add	sp,*4
33575                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33576 99C8           8846         F1            mov	-$F[bp],al
33577                                           !BCC_EOS
33578                                           ! 4778         val8 &= 0x7f;
33579                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
33580 99CB           8A46         F1            mov	al,-$F[bp]
33581 99CE           24                     7F  and	al,*$7F
33582 99D0           8846         F1            mov	-$F[bp],al
33583                                           !BCC_EOS
33584                                           ! 4779         write_byte(0x0040, 0x003e, val8);
33585                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
33586 99D3           8A46         F1            mov	al,-$F[bp]
33587 99D6           30E4                       xor	ah,ah
33588 99D8           50                         push	ax
33589                                           ! Debug: list int = const $3E (used reg = )
33590 99D9           B8                   003E  mov	ax,*$3E
33591 99DC           50                         push	ax
33592                                           ! Debug: list int = const $40 (used reg = )
33593 99DD           B8                   0040  mov	ax,*$40
33594 99E0           50                         push	ax
33595                                           ! Debug: func () void = write_byte+0 (used reg = )
33596 99E1           E8         6C36            call	_write_byte
33597 99E4           83C4                   06  add	sp,*6
33598                                           !BCC_EOS
33599                                           ! 4780         val8 = inb(0x3f4);
33600                                           ! Debug: list int = const $3F4 (used reg = )
33601 99E7           B8                   03F4  mov	ax,#$3F4
33602 99EA           50                         push	ax
33603                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33604 99EB           E8         6B50            call	_inb
33605 99EE           44                         inc	sp
33606 99EF           44                         inc	sp
33607                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33608 99F0           8846         F1            mov	-$F[bp],al
33609                                           !BCC_EOS
33610                                           ! 4781         if ( (val8 & 0xc0) != 0xc0 )
33611                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
33612 99F3           8A46         F1            mov	al,-$F[bp]
33613 99F6           24                     C0  and	al,#$C0
33614                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
33615 99F8           3C                     C0  cmp	al,#$C0
33616 99FA           74           0E            je  	.6DD
33617                       000099FC            .6DE:
33618                                           ! 4782           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
33619                                           ! Debug: list * char = .6DF+0 (used reg = )
33620 99FC           BB                   D1EC  mov	bx,#.6DF
33621 99FF           53                         push	bx
33622                                           ! Debug: list int = const 7 (used reg = )
33623 9A00           B8                   0007  mov	ax,*7
33624 9A03           50                         push	ax
33625                                           ! Debug: func () void = bios_printf+0 (used reg = )
33626 9A04           E8         7012            call	_bios_printf
33627 9A07           83C4                   04  add	sp,*4
33628                                           !BCC_EOS
33629                                           ! 4783         return_st
33630                                           ! 4783 atus[0] = inb(0x3f5);
33631                       00009A0A            .6DD:
33632                                           ! Debug: list int = const $3F5 (used reg = )
33633 9A0A           B8                   03F5  mov	ax,#$3F5
33634 9A0D           50                         push	ax
33635                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33636 9A0E           E8         6B2D            call	_inb
33637 9A11           44                         inc	sp
33638 9A12           44                         inc	sp
33639                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
33640 9A13           8846         E9            mov	-$17[bp],al
33641                                           !BCC_EOS
33642                                           ! 4784         return_status[1] = inb(0x3f5);
33643                                           ! Debug: list int = const $3F5 (used reg = )
33644 9A16           B8                   03F5  mov	ax,#$3F5
33645 9A19           50                         push	ax
33646                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33647 9A1A           E8         6B21            call	_inb
33648 9A1D           44                         inc	sp
33649 9A1E           44                         inc	sp
33650                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
33651 9A1F           8846         EA            mov	-$16[bp],al
33652                                           !BCC_EOS
33653                                           ! 4785         return_status[2] = inb(0x3f5);
33654                                           ! Debug: list int = const $3F5 (used reg = )
33655 9A22           B8                   03F5  mov	ax,#$3F5
33656 9A25           50                         push	ax
33657                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33658 9A26           E8         6B15            call	_inb
33659 9A29           44                         inc	sp
33660 9A2A           44                         inc	sp
33661                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
33662 9A2B           8846         EB            mov	-$15[bp],al
33663                                           !BCC_EOS
33664                                           ! 4786         return_status[3] = inb(0x3f5);
33665                                           ! Debug: list int = const $3F5 (used reg = )
33666 9A2E           B8                   03F5  mov	ax,#$3F5
33667 9A31           50                         push	ax
33668                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33669 9A32           E8         6B09            call	_inb
33670 9A35           44                         inc	sp
33671 9A36           44                         inc	sp
33672                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
33673 9A37           8846         EC            mov	-$14[bp],al
33674                                           !BCC_EOS
33675                                           ! 4787         return_status[4] = inb(0x3f5);
33676                                           ! Debug: list int = const $3F5 (used reg = )
33677 9A3A           B8                   03F5  mov	ax,#$3F5
33678 9A3D           50                         push	ax
33679                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33680 9A3E           E8         6AFD            call	_inb
33681 9A41           44                         inc	sp
33682 9A42           44                         inc	sp
33683                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
33684 9A43           8846         ED            mov	-$13[bp],al
33685                                           !BCC_EOS
33686                                           ! 4788         return_status[5] = inb(0x3f5);
33687                                           ! Debug: list int = const $3F5 (used reg = )
33688 9A46           B8                   03F5  mov	ax,#$3F5
33689 9A49           50                         push	ax
33690                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33691 9A4A           E8         6AF1            call	_inb
33692 9A4D           44                         inc	sp
33693 9A4E           44                         inc	sp
33694                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
33695 9A4F           8846         EE            mov	-$12[bp],al
33696                                           !BCC_EOS
33697                                           ! 4789         return_status[6] = inb(0x3f5);
33698                                           ! Debug: list int = const $3F5 (used reg = )
33699 9A52           B8                   03F5  mov	ax,#$3F5
33700 9A55           50                         push	ax
33701                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33702 9A56           E8         6AE5            call	_inb
33703 9A59           44                         inc	sp
33704 9A5A           44                         inc	sp
33705                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
33706 9A5B           8846         EF            mov	-$11[bp],al
33707                                           !BCC_EOS
33708                                           ! 4790         write_byte(0x0040, 0x0042, return_status[0]);
33709                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
33710 9A5E           8A46         E9            mov	al,-$17[bp]
33711 9A61           30E4                       xor	ah,ah
33712 9A63           50                         push	ax
33713                                           ! Debug: list int = const $42 (used reg = )
33714 9A64           B8                   0042  mov	ax,*$42
33715 9A67           50                         push	ax
33716                                           ! Debug: list int = const $40 (used reg = )
33717 9A68           B8                   0040  mov	ax,*$40
33718 9A6B           50                         push	ax
33719                                           ! Debug: func () void = write_byte+0 (used reg = )
33720 9A6C           E8         6BAB            call	_write_byte
33721 9A6F           83C4                   06  add	sp,*6
33722                                           !BCC_EOS
33723                                           ! 4791         write_byte(0x0040, 0x0043, return_status[1]);
33724                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
33725 9A72           8A46         EA            mov	al,-$16[bp]
33726 9A75           30E4                       xor	ah,ah
33727 9A77           50                         push	ax
33728                                           ! Debug: list int = const $43 (used reg = )
33729 9A78           B8                   0043  mov	ax,*$43
33730 9A7B           50                         push	ax
33731                                           ! Debug: list int = const $40 (used reg = )
33732 9A7C           B8                   0040  mov	ax,*$40
33733 9A7F           50                         push	ax
33734                                           ! Debug: func () void = write_byte+0 (used reg = )
33735 9A80           E8         6B97            call	_write_byte
33736 9A83           83C4                   06  add	sp,*6
33737                                           !BCC_EOS
33738                                           ! 4792         write_byte(0x0040, 0x0044, return_status[2]);
33739                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
33740 9A86           8A46         EB            mov	al,-$15[bp]
33741 9A89           30E4                       xor	ah,ah
33742 9A8B           50                         push	ax
33743                                           ! Debug: list int = const $44 (used reg = )
33744 9A8C           B8                   0044  mov	ax,*$44
33745 9A8F           50                         push	ax
33746                                           ! Debug: list int = const $40 (used reg = )
33747 9A90           B8                   0040  mov	ax,*$40
33748 9A93           50                         push	ax
33749                                           ! Debug: func () void = write_byte+0 (used reg = )
33750 9A94           E8         6B83            call	_write_byte
33751 9A97           83C4                   06  add	sp,*6
33752                                           !BCC_EOS
33753                                           ! 4793         write_byte(0x0040, 0x0045, return_status[3]);
33754                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
33755 9A9A           8A46         EC            mov	al,-$14[bp]
33756 9A9D           30E4                       xor	ah,ah
33757 9A9F           50                         push	ax
33758                                           ! Debug: list int = const $45 (used reg = )
33759 9AA0           B8                   0045  mov	ax,*$45
33760 9AA3           50                         push	ax
33761                                           ! Debug: list int = const $40 (used reg = )
33762 9AA4           B8                   0040  mov	ax,*$40
33763 9AA7           50                         push	ax
33764                                           ! Debug: func () void = write_byte+0 (used reg = )
33765 9AA8           E8         6B6F            call	_write_byte
33766 9AAB           83C4                   06  add	sp,*6
33767                                           !BCC_EOS
33768                                           ! 4794         write_byte(0x0040, 0x0046, return_status[4]);
33769                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
33770 9AAE           8A46         ED            mov	al,-$13[bp]
33771 9AB1           30E4                       xor	ah,ah
33772 9AB3           50                         push	ax
33773                                           ! Debug: list int = const $46 (used reg = )
33774 9AB4           B8                   0046  mov	ax,*$46
33775 9AB7           50                         push	ax
33776                                           ! Debug: list int = const $40 (used reg = )
33777 9AB8           B8                   0040  mov	ax,*$40
33778 9ABB           50                         push	ax
33779                                           ! Debug: func () void = write_byte+0 (used reg = )
33780 9ABC           E8         6B5B            call	_write_byte
33781 9ABF           83C4                   06  add	sp,*6
33782                                           !BCC_EOS
33783                                           ! 4795         write_byte(0x0040, 0x0047, return_status[5]);
33784                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
33785 9AC2           8A46         EE            mov	al,-$12[bp]
33786 9AC5           30E4                       xor	ah,ah
33787 9AC7           50                         push	ax
33788                                           ! Debug: list int = const $47 (used reg = )
33789 9AC8           B8                   0047  mov	ax,*$47
33790 9ACB           50                         push	ax
33791                                           ! Debug: list int = const $40 (used reg = )
33792 9ACC           B8                   0040  mov	ax,*$40
33793 9ACF           50                         push	ax
33794                                           ! Debug: func () void = write_byte+0 (used reg = )
33795 9AD0           E8         6B47            call	_write_byte
33796 9AD3           83C4                   06  add	sp,*6
33797                                           !BCC_EOS
33798                                           ! 4796         write_byte(0x0040, 0x0048, return_status[6]);
33799                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
33800 9AD6           8A46         EF            mov	al,-$11[bp]
33801 9AD9           30E4                       xor	ah,ah
33802 9ADB           50                         push	ax
33803                                           ! Debug: list int = const $48 (used reg = )
33804 9ADC           B8                   0048  mov	ax,*$48
33805 9ADF           50                         push	ax
33806                                           ! Debug: list int = const $40 (used reg = )
33807 9AE0           B8                   0040  mov	ax,*$40
33808 9AE3           50                         push	ax
33809                                           ! Debug: func () void = write_byte+0 (used reg = )
33810 9AE4           E8         6B33            call	_write_byte
33811 9AE7           83C4                   06  add	sp,*6
33812                                           !BCC_EOS
33813                                           ! 4797         if ( (return_status[0] & 0xc0) != 0 ) {
33814                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
33815 9AEA           8A46         E9            mov	al,-$17[bp]
33816 9AED           24                     C0  and	al,#$C0
33817                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33818 9AEF           84C0                       test	al,al
33819 9AF1           74           2B            je  	.6E0
33820                       00009AF3            .6E1:
33821                                           ! 4798           if ( (return_status[1] & 0x02) != 0 ) {
33822                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
33823 9AF3           8A46         EA            mov	al,-$16[bp]
33824 9AF6           24                     02  and	al,*2
33825                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33826 9AF8           84C0                       test	al,al
33827 9AFA           74           14            je  	.6E2
33828                       00009AFC            .6E3:
33829                                           ! 4799             AX = 0x0300;
33830                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
33831 9AFC           B8                   0300  mov	ax,#$300
33832 9AFF           8946         16            mov	$16[bp],ax
33833                                           !BCC_EOS
33834                                           ! 4800             FLAGS |= 0x0001;
33835                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33836 9B02           8B46         1C            mov	ax,$1C[bp]
33837 9B05           0C                     01  or	al,*1
33838 9B07           8946         1C            mov	$1C[bp],ax
33839                                           !BCC_EOS
33840                                           ! 4801             return;
33841 9B0A           89EC                       mov	sp,bp
33842 9B0C           5D                         pop	bp
33843 9B0D           C3                         ret
33844                                           !BCC_EOS
33845                                           ! 4802           } else {
33846 9B0E           EB           0E            jmp .6E4
33847                       00009B10            .6E2:
33848                                           ! 4803             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
33849                                           ! Debug: list * char = .6E5+0 (used reg = )
33850 9B10           BB                   D1C7  mov	bx,#.6E5
33851 9B13           53                         push	bx
33852                                           ! Debug: list int = const 7 (used reg = )
33853 9B14           B8                   0007  mov	ax,*7
33854 9B17           50                         push	ax
33855                                           ! Debug: func () void = bios_printf+0 (used reg = )
33856 9B18           E8         6EFE            call	_bios_printf
33857 9B1B           83C4                   04  add	sp,*4
33858                                           !BCC_EOS
33859                                           ! 4804           }
33860                                           ! 4805         }
33861                       00009B1E            .6E4:
33862                                           ! 4806         set_diskette_current_cyl(drive, track);
33863                       00009B1E            .6E0:
33864                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33865 9B1E           8A46         FD            mov	al,-3[bp]
33866 9B21           30E4                       xor	ah,ah
33867 9B23           50                         push	ax
33868                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33869 9B24           8A46         FF            mov	al,-1[bp]
33870 9B27           30E4                       xor	ah,ah
33871 9B29           50                         push	ax
33872                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33873 9B2A           E8         07DF            call	_set_diskette_current_cyl
33874 9B2D           83C4                   04  add	sp,*4
33875                                           !BCC_EOS
33876                                           ! 4807         AX = ((AX & 0x00ff) | ((0x00) << 8));
33877                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33878 9B30           8A46         16            mov	al,$16[bp]
33879                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33880 9B33           0C                     00  or	al,*0
33881                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33882 9B35           30E4                       xor	ah,ah
33883 9B37           8946         16            mov	$16[bp],ax
33884                                           !BCC_EOS
33885                                           ! 4808         FLAGS &= 0xfffe;
33886                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33887 9B3A           8B46         1C            mov	ax,$1C[bp]
33888 9B3D           24                     FE  and	al,#$FE
33889 9B3F           8946         1C            mov	$1C[bp],ax
33890                                           !BCC_EOS
33891                                           ! 4809         return;
33892 9B42           89EC                       mov	sp,bp
33893 9B44           5D                         pop	bp
33894 9B45           C3                         ret
33895                                           !BCC_EOS
33896                                           ! 4810       } else {
33897 9B46           EB           28            jmp .6E6
33898                       00009B48            .6D1:
33899                                           ! 4811         set_diskette_current_cyl(drive, track);
33900                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33901 9B48           8A46         FD            mov	al,-3[bp]
33902 9B4B           30E4                       xor	ah,ah
33903 9B4D           50                         push	ax
33904                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33905 9B4E           8A46         FF            mov	al,-1[bp]
33906 9B51           30E4                       xor	ah,ah
33907 9B53           50                         push	ax
33908                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33909 9B54           E8         07B5            call	_set_diskette_current_cyl
33910 9B57           83C4                   04  add	sp,*4
33911                                           !BCC_EOS
33912                                           ! 4812         FLAGS &= 0xfffe;
33913                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33914 9B5A           8B46         1C            mov	ax,$1C[bp]
33915 9B5D           24                     FE  and	al,#$FE
33916 9B5F           8946         1C            mov	$1C[bp],ax
33917                                           !BCC_EOS
33918                                           ! 4813         AX = ((AX & 0x00ff) | ((0x00) << 8));
33919                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33920 9B62           8A46         16            mov	al,$16[bp]
33921                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33922 9B65           0C                     00  or	al,*0
33923                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33924 9B67           30E4                       xor	ah,ah
33925 9B69           8946         16            mov	$16[bp],ax
33926                                           !BCC_EOS
33927                                           ! 4814         return;
33928 9B6C           89EC                       mov	sp,bp
33929 9B6E           5D                         pop	bp
33930 9B6F           C3                         ret
33931                                           !BCC_EOS
33932                                           ! 4815       }
33933                                           ! 4816       break;
33934                       00009B70            .6E6:
33935                       00009B70            .6D0:
33936 9B70           E9         077D            br 	.6A1
33937                                           !BCC_EOS
33938                                           ! 4817     case 0x05:
33939                                           ! 4818 ;
33940                       00009B73            .6E7:
33941                                           !BCC_EOS
33942                                           ! 4819       num_sectors = ( AX & 0x00ff );
33943                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33944 9B73           8A46         16            mov	al,$16[bp]
33945                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33946 9B76           8846         FE            mov	-2[bp],al
33947                                           !BCC_EOS
33948                                           ! 4820       track = ( CX >> 8 );
33949                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
33950 9B79           8B46         14            mov	ax,$14[bp]
33951 9B7C           88E0                       mov	al,ah
33952 9B7E           30E4                       xor	ah,ah
33953                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
33954 9B80           8846         FD            mov	-3[bp],al
33955                                           !BCC_EOS
33956                                           ! 4821       head = ( DX >> 8 );
33957                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
33958 9B83           8B46         12            mov	ax,$12[bp]
33959 9B86           88E0                       mov	al,ah
33960 9B88           30E4                       xor	ah,ah
33961                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
33962 9B8A           8846         FB            mov	-5[bp],al
33963                                           !BCC_EOS
33964                                           ! 4822       drive = ( ELDX & 0x00ff );
33965                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
33966 9B8D           8A46         0E            mov	al,$E[bp]
33967                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
33968 9B90           8846         FF            mov	-1[bp],al
33969                                           !BCC_EOS
33970                                           ! 4823       if ((drive > 1) || (head > 1) || (track > 79) ||
33971                                           ! 4824           (num_sectors == 0) || (num_sectors > 18)) {
33972                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
33973 9B93           8A46         FF            mov	al,-1[bp]
33974 9B96           3C                     01  cmp	al,*1
33975 9B98           77           1C            ja  	.6E9
33976                       00009B9A            .6ED:
33977                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
33978 9B9A           8A46         FB            mov	al,-5[bp]
33979 9B9D           3C                     01  cmp	al,*1
33980 9B9F           77           15            ja  	.6E9
33981                       00009BA1            .6EC:
33982                                           ! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
33983 9BA1           8A46         FD            mov	al,-3[bp]
33984 9BA4           3C                     4F  cmp	al,*$4F
33985 9BA6           77           0E            ja  	.6E9
33986                       00009BA8            .6EB:
33987                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33988 9BA8           8A46         FE            mov	al,-2[bp]
33989 9BAB           84C0                       test	al,al
33990 9BAD           74           07            je  	.6E9
33991                       00009BAF            .6EA:
33992                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
33993 9BAF           8A46         FE            mov	al,-2[bp]
33994 9BB2           3C                     12  cmp	al,*$12
33995 9BB4           76           1C            jbe 	.6E8
33996                       00009BB6            .6E9:
33997                                           ! 4825         AX = ((AX & 0x00ff) | ((1) << 8));
33998                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33999 9BB6           8A46         16            mov	al,$16[bp]
34000                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34001 9BB9           30E4                       xor	ah,ah
34002 9BBB           0D                   0100  or	ax,#$100
34003                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34004 9BBE           8946         16            mov	$16[bp],ax
34005                                           !BCC_EOS
34006                                           ! 4826         set_diskette_ret_status(1);
34007                                           ! Debug: list int = const 1 (used reg = )
34008 9BC1           B8                   0001  mov	ax,*1
34009 9BC4           50                         push	ax
34010                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34011 9BC5           E8         072C            call	_set_diskette_ret_status
34012 9BC8           44                         inc	sp
34013 9BC9           44                         inc	sp
34014                                           !BCC_EOS
34015                                           ! 4827         FLAGS |= 0x0001;
34016                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34017 9BCA           8B46         1C            mov	ax,$1C[bp]
34018 9BCD           0C                     01  or	al,*1
34019 9BCF           8946         1C            mov	$1C[bp],ax
34020                                           !BCC_EOS
34021                                           ! 4828       }
34022                                           ! 4829       if (floppy_drive_exists(drive) == 0) {
34023                       00009BD2            .6E8:
34024                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34025 9BD2           8A46         FF            mov	al,-1[bp]
34026 9BD5           30E4                       xor	ah,ah
34027 9BD7           50                         push	ax
34028                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
34029 9BD8           E8         F5B5            call	_floppy_drive_exists
34030 9BDB           44                         inc	sp
34031 9BDC           44                         inc	sp
34032                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34033 9BDD           85C0                       test	ax,ax
34034 9BDF           75           20            jne 	.6EE
34035                       00009BE1            .6EF:
34036                                           ! 4830         AX = ((AX & 0x00ff) | ((0x80) << 8));
34037                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34038 9BE1           8A46         16            mov	al,$16[bp]
34039                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
34040 9BE4           30E4                       xor	ah,ah
34041 9BE6           0D                   8000  or	ax,#-$8000
34042                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34043 9BE9           8946         16            mov	$16[bp],ax
34044                                           !BCC_EOS
34045                                           ! 4831         set_diskette_ret_status(0x80);
34046                                           ! Debug: list int = const $80 (used reg = )
34047 9BEC           B8                   0080  mov	ax,#$80
34048 9BEF           50                         push	ax
34049                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34050 9BF0           E8         0701            call	_set_diskette_ret_status
34051 9BF3           44                         inc	sp
34052 9BF4           44                         inc	sp
34053                                           !BCC_EOS
34054                                           ! 4832         FLAGS |= 0x0001;
34055                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34056 9BF5           8B46         1C            mov	ax,$1C[bp]
34057 9BF8           0C                     01  or	al,*1
34058 9BFA           8946         1C            mov	$1C[bp],ax
34059                                           !BCC_EOS
34060                                           ! 4833         return;
34061 9BFD           89EC                       mov	sp,bp
34062 9BFF           5D                         pop	bp
34063 9C00           C3                         ret
34064                                           !BCC_EOS
34065                                           ! 4834       }
34066                                           ! 4835       if (floppy_media_known(drive) == 0) {
34067                       00009C01            .6EE:
34068                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34069 9C01           8A46         FF            mov	al,-1[bp]
34070 9C04           30E4                       xor	ah,ah
34071 9C06           50                         push	ax
34072                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
34073 9C07           E8         F2F1            call	_floppy_media_known
34074 9C0A           44                         inc	sp
34075 9C0B           44                         inc	sp
34076                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34077 9C0C           85C0                       test	ax,ax
34078 9C0E           75           39            jne 	.6F0
34079                       00009C10            .6F1:
34080                                           ! 4836         if (floppy_media_sense(drive) == 0) {
34081                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34082 9C10           8A46         FF            mov	al,-1[bp]
34083 9C13           30E4                       xor	ah,ah
34084 9C15           50                         push	ax
34085                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
34086 9C16           E8         F365            call	_floppy_media_sense
34087 9C19           44                         inc	sp
34088 9C1A           44                         inc	sp
34089                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
34090 9C1B           85C0                       test	ax,ax
34091 9C1D           75           2A            jne 	.6F2
34092                       00009C1F            .6F3:
34093                                           ! 4837           AX = ((AX & 0x00ff) | ((0x0C) << 8));
34094                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34095 9C1F           8A46         16            mov	al,$16[bp]
34096                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
34097 9C22           30E4                       xor	ah,ah
34098 9C24           0D                   0C00  or	ax,#$C00
34099                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34100 9C27           8946         16            mov	$16[bp],ax
34101                                           !BCC_EOS
34102                                           ! 4838           set_diskette_ret_status(0x0C);
34103                                           ! Debug: list int = const $C (used reg = )
34104 9C2A           B8                   000C  mov	ax,*$C
34105 9C2D           50                         push	ax
34106                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34107 9C2E           E8         06C3            call	_set_diskette_ret_status
34108 9C31           44                         inc	sp
34109 9C32           44                         inc	sp
34110                                           !BCC_EOS
34111                                           ! 4839           AX = ((AX & 0xff00) | (0));
34112                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34113 9C33           8B46         16            mov	ax,$16[bp]
34114 9C36           30C0                       xor	al,al
34115                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34116 9C38           0C                     00  or	al,*0
34117                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34118 9C3A           8946         16            mov	$16[bp],ax
34119                                           !BCC_EOS
34120                                           ! 4840           FLAGS |= 0x0001;
34121                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34122 9C3D           8B46         1C            mov	ax,$1C[bp]
34123 9C40           0C                     01  or	al,*1
34124 9C42           8946         1C            mov	$1C[bp],ax
34125                                           !BCC_EOS
34126                                           ! 4841           return;
34127 9C45           89EC                       mov	sp,bp
34128 9C47           5D                         pop	bp
34129 9C48           C3                         ret
34130                                           !BCC_EOS
34131                                           ! 4842         }
34132                                           ! 4843     
34133                                           ! 4843   }
34134                       00009C49            .6F2:
34135                                           ! 4844       page = (ES >> 12);
34136                       00009C49            .6F0:
34137                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
34138 9C49           8B46         06            mov	ax,6[bp]
34139 9C4C           88E0                       mov	al,ah
34140 9C4E           30E4                       xor	ah,ah
34141 9C50           B1                     04  mov	cl,*4
34142 9C52           D3E8                       shr	ax,cl
34143                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
34144 9C54           8846         F3            mov	-$D[bp],al
34145                                           !BCC_EOS
34146                                           ! 4845       base_es = (ES << 4);
34147                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
34148 9C57           8B46         06            mov	ax,6[bp]
34149 9C5A           B1                     04  mov	cl,*4
34150 9C5C           D3E0                       shl	ax,cl
34151                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
34152 9C5E           8946         F4            mov	-$C[bp],ax
34153                                           !BCC_EOS
34154                                           ! 4846       base_address = base_es + BX;
34155                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
34156 9C61           8B46         F4            mov	ax,-$C[bp]
34157 9C64           0346         10            add	ax,$10[bp]
34158                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
34159 9C67           8946         F8            mov	-8[bp],ax
34160                                           !BCC_EOS
34161                                           ! 4847       if ( base_address < base_es ) {
34162                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
34163 9C6A           8B46         F8            mov	ax,-8[bp]
34164 9C6D           3B46         F4            cmp	ax,-$C[bp]
34165 9C70           73           07            jae 	.6F4
34166                       00009C72            .6F5:
34167                                           ! 4848         page++;
34168                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
34169 9C72           8A46         F3            mov	al,-$D[bp]
34170 9C75           40                         inc	ax
34171 9C76           8846         F3            mov	-$D[bp],al
34172                                           !BCC_EOS
34173                                           ! 4849       }
34174                                           ! 4850       base_count = (num_sectors * 4) - 1;
34175                       00009C79            .6F4:
34176                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
34177 9C79           8A46         FE            mov	al,-2[bp]
34178 9C7C           30E4                       xor	ah,ah
34179 9C7E           D1E0                       shl	ax,*1
34180 9C80           D1E0                       shl	ax,*1
34181                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
34182                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
34183 9C82           48                         dec	ax
34184 9C83           8946         F6            mov	-$A[bp],ax
34185                                           !BCC_EOS
34186                                           ! 4851       last_addr = base_address + base_count;
34187                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
34188 9C86           8B46         F8            mov	ax,-8[bp]
34189 9C89           0346         F6            add	ax,-$A[bp]
34190                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
34191 9C8C           8946         E2            mov	-$1E[bp],ax
34192                                           !BCC_EOS
34193                                           ! 4852       if (last_addr < base_address) {
34194                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
34195 9C8F           8B46         E2            mov	ax,-$1E[bp]
34196 9C92           3B46         F8            cmp	ax,-8[bp]
34197 9C95           73           2A            jae 	.6F6
34198                       00009C97            .6F7:
34199                                           ! 4853         AX = ((AX & 0x00ff) | ((0x09) << 8));
34200                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34201 9C97           8A46         16            mov	al,$16[bp]
34202                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
34203 9C9A           30E4                       xor	ah,ah
34204 9C9C           0D                   0900  or	ax,#$900
34205                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34206 9C9F           8946         16            mov	$16[bp],ax
34207                                           !BCC_EOS
34208                                           ! 4854         set_diskette_ret_status(0x09);
34209                                           ! Debug: list int = const 9 (used reg = )
34210 9CA2           B8                   0009  mov	ax,*9
34211 9CA5           50                         push	ax
34212                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34213 9CA6           E8         064B            call	_set_diskette_ret_status
34214 9CA9           44                         inc	sp
34215 9CAA           44                         inc	sp
34216                                           !BCC_EOS
34217                                           ! 4855         AX = ((AX & 0xff00) | (0));
34218                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34219 9CAB           8B46         16            mov	ax,$16[bp]
34220 9CAE           30C0                       xor	al,al
34221                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34222 9CB0           0C                     00  or	al,*0
34223                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34224 9CB2           8946         16            mov	$16[bp],ax
34225                                           !BCC_EOS
34226                                           ! 4856         FLAGS |= 0x0001;
34227                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34228 9CB5           8B46         1C            mov	ax,$1C[bp]
34229 9CB8           0C                     01  or	al,*1
34230 9CBA           8946         1C            mov	$1C[bp],ax
34231                                           !BCC_EOS
34232                                           ! 4857         return;
34233 9CBD           89EC                       mov	sp,bp
34234 9CBF           5D                         pop	bp
34235 9CC0           C3                         ret
34236                                           !BCC_EOS
34237                                           ! 4858       }
34238                                           ! 4859       outb(0x000a, 0x06);
34239                       00009CC1            .6F6:
34240                                           ! Debug: list int = const 6 (used reg = )
34241 9CC1           B8                   0006  mov	ax,*6
34242 9CC4           50                         push	ax
34243                                           ! Debug: list int = const $A (used reg = )
34244 9CC5           B8                   000A  mov	ax,*$A
34245 9CC8           50                         push	ax
34246                                           ! Debug: func () void = outb+0 (used reg = )
34247 9CC9           E8         6888            call	_outb
34248 9CCC           83C4                   04  add	sp,*4
34249                                           !BCC_EOS
34250                                           ! 4860       outb(0x000c, 0x00);
34251                                           ! Debug: list int = const 0 (used reg = )
34252 9CCF           31C0                       xor	ax,ax
34253 9CD1           50                         push	ax
34254                                           ! Debug: list int = const $C (used reg = )
34255 9CD2           B8                   000C  mov	ax,*$C
34256 9CD5           50                         push	ax
34257                                           ! Debug: func () void = outb+0 (used reg = )
34258 9CD6           E8         687B            call	_outb
34259 9CD9           83C4                   04  add	sp,*4
34260                                           !BCC_EOS
34261                                           ! 4861       outb(0x0004, base_address);
34262                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
34263 9CDC           FF76         F8            push	-8[bp]
34264                                           ! Debug: list int = const 4 (used reg = )
34265 9CDF           B8                   0004  mov	ax,*4
34266 9CE2           50                         push	ax
34267                                           ! Debug: func () void = outb+0 (used reg = )
34268 9CE3           E8         686E            call	_outb
34269 9CE6           83C4                   04  add	sp,*4
34270                                           !BCC_EOS
34271                                           ! 4862       outb(0x0004, base_address>>8);
34272                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
34273 9CE9           8B46         F8            mov	ax,-8[bp]
34274 9CEC           88E0                       mov	al,ah
34275 9CEE           30E4                       xor	ah,ah
34276                                           ! Debug: list unsigned int = ax+0 (used reg = )
34277 9CF0           50                         push	ax
34278                                           ! Debug: list int = const 4 (used reg = )
34279 9CF1           B8                   0004  mov	ax,*4
34280 9CF4           50                         push	ax
34281                                           ! Debug: func () void = outb+0 (used reg = )
34282 9CF5           E8         685C            call	_outb
34283 9CF8           83C4                   04  add	sp,*4
34284                                           !BCC_EOS
34285                                           ! 4863       outb(0x000c, 0x00);
34286                                           ! Debug: list int = const 0 (used reg = )
34287 9CFB           31C0                       xor	ax,ax
34288 9CFD           50                         push	ax
34289                                           ! Debug: list int = const $C (used reg = )
34290 9CFE           B8                   000C  mov	ax,*$C
34291 9D01           50                         push	ax
34292                                           ! Debug: func () void = outb+0 (used reg = )
34293 9D02           E8         684F            call	_outb
34294 9D05           83C4                   04  add	sp,*4
34295                                           !BCC_EOS
34296                                           ! 4864       outb(0x0005, base_count);
34297                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
34298 9D08           FF76         F6            push	-$A[bp]
34299                                           ! Debug: list int = const 5 (used reg = )
34300 9D0B           B8                   0005  mov	ax,*5
34301 9D0E           50                         push	ax
34302                                           ! Debug: func () void = outb+0 (used reg = )
34303 9D0F           E8         6842            call	_outb
34304 9D12           83C4                   04  add	sp,*4
34305                                           !BCC_EOS
34306                                           ! 4865       outb(0x0005, base_count>>8);
34307                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
34308 9D15           8B46         F6            mov	ax,-$A[bp]
34309 9D18           88E0                       mov	al,ah
34310 9D1A           30E4                       xor	ah,ah
34311                                           ! Debug: list unsigned int = ax+0 (used reg = )
34312 9D1C           50                         push	ax
34313                                           ! Debug: list int = const 5 (used reg = )
34314 9D1D           B8                   0005  mov	ax,*5
34315 9D20           50                         push	ax
34316                                           ! Debug: func () void = outb+0 (used reg = )
34317 9D21           E8         6830            call	_outb
34318 9D24           83C4                   04  add	sp,*4
34319                                           !BCC_EOS
34320                                           ! 4866       mode_register = 0x4a;
34321                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
34322 9D27           B0                     4A  mov	al,*$4A
34323 9D29           8846         F2            mov	-$E[bp],al
34324                                           !BCC_EOS
34325                                           ! 4867       outb(0x000b, mode_register);
34326                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
34327 9D2C           8A46         F2            mov	al,-$E[bp]
34328 9D2F           30E4                       xor	ah,ah
34329 9D31           50                         push	ax
34330                                           ! Debug: list int = const $B (used reg = )
34331 9D32           B8                   000B  mov	ax,*$B
34332 9D35           50                         push	ax
34333                                           ! Debug: func () void = outb+0 (used reg = )
34334 9D36           E8         681B            call	_outb
34335 9D39           83C4                   04  add	sp,*4
34336                                           !BCC_EOS
34337                                           ! 4868       outb(0x0081, page);
34338                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
34339 9D3C           8A46         F3            mov	al,-$D[bp]
34340 9D3F           30E4                       xor	ah,ah
34341 9D41           50                         push	ax
34342                                           ! Debug: list int = const $81 (used reg = )
34343 9D42           B8                   0081  mov	ax,#$81
34344 9D45           50                         push	ax
34345                                           ! Debug: func () void = outb+0 (used reg = )
34346 9D46           E8         680B            call	_outb
34347 9D49           83C4                   04  add	sp,*4
34348                                           !BCC_EOS
34349                                           ! 4869       outb(0x000a, 0x02);
34350                                           ! Debug: list int = const 2 (used reg = )
34351 9D4C           B8                   0002  mov	ax,*2
34352 9D4F           50                         push	ax
34353                                           ! Debug: list int = const $A (used reg = )
34354 9D50           B8                   000A  mov	ax,*$A
34355 9D53           50                         push	ax
34356                                           ! Debug: func () void = outb+0 (used reg = )
34357 9D54           E8         67FD            call	_outb
34358 9D57           83C4                   04  add	sp,*4
34359                                           !BCC_EOS
34360                                           ! 4870       floppy_prepare_controller(drive);
34361                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
34362 9D5A           8A46         FF            mov	al,-1[bp]
34363 9D5D           30E4                       xor	ah,ah
34364 9D5F           50                         push	ax
34365                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
34366 9D60           E8         F0B9            call	_floppy_prepare_controller
34367 9D63           44                         inc	sp
34368 9D64           44                         inc	sp
34369                                           !BCC_EOS
34370                                           ! 4871       outb(0x03f5, 0x4d);
34371                                           ! Debug: list int = const $4D (used reg = )
34372 9D65           B8                   004D  mov	ax,*$4D
34373 9D68           50                         push	ax
34374                                           ! Debug: list int = const $3F5 (used reg = )
34375 9D69           B8                   03F5  mov	ax,#$3F5
34376 9D6C           50                         push	ax
34377                                           ! Debug: func () void = outb+0 (used reg = )
34378 9D6D           E8         67E4            call	_outb
34379 9D70           83C4                   04  add	sp,*4
34380                                           !BCC_EOS
34381                                           ! 4872       outb(0x03f5, (head << 2) | drive);
34382                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
34383 9D73           8A46         FB            mov	al,-5[bp]
34384 9D76           30E4                       xor	ah,ah
34385 9D78           D1E0                       shl	ax,*1
34386 9D7A           D1E0                       shl	ax,*1
34387                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
34388 9D7C           0A46         FF            or	al,-1[bp]
34389                                           ! Debug: list unsigned int = ax+0 (used reg = )
34390 9D7F           50                         push	ax
34391                                           ! Debug: list int = const $3F5 (used reg = )
34392 9D80           B8                   03F5  mov	ax,#$3F5
34393 9D83           50                         push	ax
34394                                           ! Debug: func () void = outb+0 (used reg = )
34395 9D84           E8         67CD            call	_outb
34396 9D87           83C4                   04  add	sp,*4
34397                                           !BCC_EOS
34398                                           ! 4873       outb(0x03f5, 2);
34399                                           ! Debug: list int = const 2 (used reg = )
34400 9D8A           B8                   0002  mov	ax,*2
34401 9D8D           50                         push	ax
34402                                           ! Debug: list int = const $3F5 (used reg = )
34403 9D8E           B8                   03F5  mov	ax,#$3F5
34404 9D91           50                         push	ax
34405                                           ! Debug: func () void = outb+0 (used reg = )
34406 9D92           E8         67BF            call	_outb
34407 9D95           83C4                   04  add	sp,*4
34408                                           !BCC_EOS
34409                                           ! 4874       outb(0x03f5, num_sectors);
34410                                           ! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
34411 9D98           8A46         FE            mov	al,-2[bp]
34412 9D9B           30E4                       xor	ah,ah
34413 9D9D           50                         push	ax
34414                                           ! Debug: list int = const $3F5 (used reg = )
34415 9D9E           B8                   03F5  mov	ax,#$3F5
34416 9DA1           50                         push	ax
34417                                           ! Debug: func () void = outb+0 (used reg = )
34418 9DA2           E8         67AF            call	_outb
34419 9DA5           83C4                   04  add	sp,*4
34420                                           !BCC_EOS
34421                                           ! 4875       outb(0x03f5, 0);
34422                                           ! Debug: list int = const 0 (used reg = )
34423 9DA8           31C0                       xor	ax,ax
34424 9DAA           50                         push	ax
34425                                           ! Debug: list int = const $3F5 (used reg = )
34426 9DAB           B8                   03F5  mov	ax,#$3F5
34427 9DAE           50                         push	ax
34428                                           ! Debug: func () void = outb+0 (used reg = )
34429 9DAF           E8         67A2            call	_outb
34430 9DB2           83C4                   04  add	sp,*4
34431                                           !BCC_EOS
34432                                           ! 4876       outb(0x03f5, 0xf6);
34433                                           ! Debug: list int = const $F6 (used reg = )
34434 9DB5           B8                   00F6  mov	ax,#$F6
34435 9DB8           50                         push	ax
34436                                           ! Debug: list int = const $3F5 (used reg = )
34437 9DB9           B8                   03F5  mov	ax,#$3F5
34438 9DBC           50                         push	ax
34439                                           ! Debug: func () void = outb+0 (used reg = )
34440 9DBD           E8         6794            call	_outb
34441 9DC0           83C4                   04  add	sp,*4
34442                                           !BCC_EOS
34443                                           ! 4877 #asm
34444                                           !BCC_EOS
34445                                           !BCC_ASM
34446                       0000002A            _int13_diskette_function.BP	set	$2A
34447                       0000000C            .int13_diskette_function.BP	set	$C
34448                       00000038            _int13_diskette_function.CS	set	$38
34449                       0000001A            .int13_diskette_function.CS	set	$1A
34450                       00000032            _int13_diskette_function.CX	set	$32
34451                       00000014            .int13_diskette_function.CX	set	$14
34452                       00000016            _int13_diskette_function.base_address	set	$16
34453                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34454                       00000026            _int13_diskette_function.DI	set	$26
34455                       00000008            .int13_diskette_function.DI	set	8
34456                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34457                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34458                       00000014            _int13_diskette_function.base_count	set	$14
34459                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34460                       0000001A            _int13_diskette_function.sector	set	$1A
34461                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34462                       00000022            _int13_diskette_function.DS	set	$22
34463                       00000004            .int13_diskette_function.DS	set	4
34464                       00000019            _int13_diskette_function.head	set	$19
34465                       FFFFFFFB            .int13_diskette_function.head	set	-5
34466                       0000002C            _int13_diskette_function.ELDX	set	$2C
34467                       0000000E            .int13_diskette_function.ELDX	set	$E
34468                       0000000E            _int13_diskette_function.dor	set	$E
34469                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34470                       00000030            _int13_diskette_function.DX	set	$30
34471                       00000012            .int13_diskette_function.DX	set	$12
34472                       00000007            _int13_diskette_function.return_status	set	7
34473                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34474                       00000002            _int13_diskette_function.es	set	2
34475                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34476                       00000010            _int13_diskette_function.mode_register	set	$10
34477                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34478                       00000024            _int13_diskette_function.ES	set	$24
34479                       00000006            .int13_diskette_function.ES	set	6
34480                       00000012            _int13_diskette_function.base_es	set	$12
34481                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34482                       0000001B            _int13_diskette_function.track	set	$1B
34483                       FFFFFFFD            .int13_diskette_function.track	set	-3
34484                       00000028            _int13_diskette_function.SI	set	$28
34485                       0000000A            .int13_diskette_function.SI	set	$A
34486                       00000006            _int13_diskette_function.drive_type	set	6
34487                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34488                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34489                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34490                       00000036            _int13_diskette_function.IP	set	$36
34491                       00000018            .int13_diskette_function.IP	set	$18
34492                       00000018            _int13_diskette_function.status	set	$18
34493                       FFFFFFFA            .int13_diskette_function.status	set	-6
34494                       00000034            _int13_diskette_function.AX	set	$34
34495                       00000016            .int13_diskette_function.AX	set	$16
34496                       0000000F            _int13_diskette_function.val8	set	$F
34497                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34498                       00000000            _int13_diskette_function.last_addr	set	0
34499                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34500                       00000011            _int13_diskette_function.page	set	$11
34501                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34502                       00000004            _int13_diskette_function.ah	set	4
34503                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34504                       0000001D            _int13_diskette_function.drive	set	$1D
34505                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34506                       00000005            _int13_diskette_function.num_floppies	set	5
34507                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34508                       0000002E            _int13_diskette_function.BX	set	$2E
34509                       00000010            .int13_diskette_function.BX	set	$10
34510 9DC3           FB                               sti
34511                                           ! 4879 endasm
34512                                           !BCC_ENDASM
34513                                           !BCC_EOS
34514                                           ! 4880       do {
34515                       00009DC4            .6FA:
34516                                           ! 4881         val8 = read_byte(0x0040, 0x0040);
34517                                           ! Debug: list int = const $40 (used reg = )
34518 9DC4           B8                   0040  mov	ax,*$40
34519 9DC7           50                         push	ax
34520                                           ! Debug: list int = const $40 (used reg = )
34521 9DC8           B8                   0040  mov	ax,*$40
34522 9DCB           50                         push	ax
34523                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34524 9DCC           E8         6825            call	_read_byte
34525 9DCF           83C4                   04  add	sp,*4
34526                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34527 9DD2           8846         F1            mov	-$F[bp],al
34528                                           !BCC_EOS
34529                                           ! 4882         if (val8 == 0) {
34530                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34531 9DD5           8A46         F1            mov	al,-$F[bp]
34532 9DD8           84C0                       test	al,al
34533 9DDA           75           23            jne 	.6FB
34534                       00009DDC            .6FC:
34535                                           ! 4883           floppy_reset_controller();
34536                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
34537 9DDC           E8         EFEF            call	_floppy_reset_controller
34538                                           !BCC_EOS
34539                                           ! 4884           AX = ((AX & 0x00ff) | ((0x80) << 8));
34540                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34541 9DDF           8A46         16            mov	al,$16[bp]
34542                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
34543 9DE2           30E4                       xor	ah,ah
34544 9DE4           0D                   8000  or	ax,#-$8000
34545                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34546 9DE7           8946         16            mov	$16[bp],ax
34547                                           !BCC_EOS
34548                                           ! 4885           set_diskette_ret_status(0x80);
34549                                           ! Debug: list int = const $80 (used reg = )
34550 9DEA           B8                   0080  mov	ax,#$80
34551 9DED           50                         push	ax
34552                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34553 9DEE           E8         0503            call	_set_diskette_ret_status
34554 9DF1           44                         inc	sp
34555 9DF2           44                         inc	sp
34556                                           !BCC_EOS
34557                                           ! 4886           FLAGS |= 0x0001;
34558                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34559 9DF3           8B46         1C            mov	ax,$1C[bp]
34560 9DF6           0C                     01  or	al,*1
34561 9DF8           8946         1C            mov	$1C[bp],ax
34562                                           !BCC_EOS
34563                                           ! 4887           return;
34564 9DFB           89EC                       mov	sp,bp
34565 9DFD           5D                         pop	bp
34566 9DFE           C3                         ret
34567                                           !BCC_EOS
34568                                           ! 4888         }
34569                                           ! 4889         val8 = (read_byte(0x0040, 0x003e) & 0x80);
34570                       00009DFF            .6FB:
34571                                           ! Debug: list int = const $3E (used reg = )
34572 9DFF           B8                   003E  mov	ax,*$3E
34573 9E02           50                         push	ax
34574                                           ! Debug: list int = const $40 (used reg = )
34575 9E03           B8                   0040  mov	ax,*$40
34576 9E06           50                         push	ax
34577                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34578 9E07           E8         67EA            call	_read_byte
34579 9E0A           83C4                   04  add	sp,*4
34580                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
34581 9E0D           24                     80  and	al,#$80
34582                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34583 9E0F           8846         F1            mov	-$F[bp],al
34584                                           !BCC_EOS
34585                                           ! 4890       } while ( val8 == 0 );
34586                       00009E12            .6F9:
34587                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34588 9E12           8A46         F1            mov	al,-$F[bp]
34589 9E15           84C0                       test	al,al
34590 9E17           74           AB            je 	.6FA
34591                       00009E19            .6FD:
34592                                           !BCC_EOS
34593                                           ! 4891       val8 = 0;
34594                       00009E19            .6F8:
34595                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
34596 9E19           30C0                       xor	al,al
34597 9E1B           8846         F1            mov	-$F[bp],al
34598                                           !BCC_EOS
34599                                           ! 4892 #asm
34600                                           !BCC_EOS
34601                                           !BCC_ASM
34602                       0000002A            _int13_diskette_function.BP	set	$2A
34603                       0000000C            .int13_diskette_function.BP	set	$C
34604                       00000038            _int13_diskette_function.CS	set	$38
34605                       0000001A            .int13_diskette_function.CS	set	$1A
34606                       00000032            _int13_diskette_function.CX	set	$32
34607                       00000014            .int13_diskette_function.CX	set	$14
34608                       00000016            _int13_diskette_function.base_address	set	$16
34609                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34610                       00000026            _int13_diskette_function.DI	set	$26
34611                       00000008            .int13_diskette_function.DI	set	8
34612                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34613                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34614                       00000014            _int13_diskette_function.base_count	set	$14
34615                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34616                       0000001A            _int13_diskette_function.sector	set	$1A
34617                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34618                       00000022            _int13_diskette_function.DS	set	$22
34619                       00000004            .int13_diskette_function.DS	set	4
34620                       00000019            _int13_diskette_function.head	set	$19
34621                       FFFFFFFB            .int13_diskette_function.head	set	-5
34622                       0000002C            _int13_diskette_function.ELDX	set	$2C
34623                       0000000E            .int13_diskette_function.ELDX	set	$E
34624                       0000000E            _int13_diskette_function.dor	set	$E
34625                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34626                       00000030            _int13_diskette_function.DX	set	$30
34627                       00000012            .int13_diskette_function.DX	set	$12
34628                       00000007            _int13_diskette_function.return_status	set	7
34629                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34630                       00000002            _int13_diskette_function.es	set	2
34631                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34632                       00000010            _int13_diskette_function.mode_register	set	$10
34633                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34634                       00000024            _int13_diskette_function.ES	set	$24
34635                       00000006            .int13_diskette_function.ES	set	6
34636                       00000012            _int13_diskette_function.base_es	set	$12
34637                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34638                       0000001B            _int13_diskette_function.track	set	$1B
34639                       FFFFFFFD            .int13_diskette_function.track	set	-3
34640                       00000028            _int13_diskette_function.SI	set	$28
34641                       0000000A            .int13_diskette_function.SI	set	$A
34642                       00000006            _int13_diskette_function.drive_type	set	6
34643                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34644                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34645                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34646                       00000036            _int13_diskette_function.IP	set	$36
34647                       00000018            .int13_diskette_function.IP	set	$18
34648                       00000018            _int13_diskette_function.status	set	$18
34649                       FFFFFFFA            .int13_diskette_function.status	set	-6
34650                       00000034            _int13_diskette_function.AX	set	$34
34651                       00000016            .int13_diskette_function.AX	set	$16
34652                       0000000F            _int13_diskette_function.val8	set	$F
34653                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34654                       00000000            _int13_diskette_function.last_addr	set	0
34655                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34656                       00000011            _int13_diskette_function.page	set	$11
34657                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34658                       00000004            _int13_diskette_function.ah	set	4
34659                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34660                       0000001D            _int13_diskette_function.drive	set	$1D
34661                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34662                       00000005            _int13_diskette_function.num_floppies	set	5
34663                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34664                       0000002E            _int13_diskette_function.BX	set	$2E
34665                       00000010            .int13_diskette_function.BX	set	$10
34666 9E1E           FA                               cli
34667                                           ! 4894 endasm
34668                                           !BCC_ENDASM
34669                                           !BCC_EOS
34670                                           ! 4895       val8 = read_byte(0x0040, 0x003e);
34671                                           ! Debug: list int = const $3E (used reg = )
34672 9E1F           B8                   003E  mov	ax,*$3E
34673 9E22           50                         push	ax
34674                                           ! Debug: list int = const $40 (used reg = )
34675 9E23           B8                   0040  mov	ax,*$40
34676 9E26           50                         push	ax
34677                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
34678 9E27           E8         67CA            call	_read_byte
34679 9E2A           83C4                   04  add	sp,*4
34680                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34681 9E2D           8846         F1            mov	-$F[bp],al
34682                                           !BCC_EOS
34683                                           ! 4896       val8 &= 0x7f;
34684                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
34685 9E30           8A46         F1            mov	al,-$F[bp]
34686 9E33           24                     7F  and	al,*$7F
34687 9E35           8846         F1            mov	-$F[bp],al
34688                                           !BCC_EOS
34689                                           ! 4897       write_byte(0x0040, 0x003e, val8);
34690                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
34691 9E38           8A46         F1            mov	al,-$F[bp]
34692 9E3B           30E4                       xor	ah,ah
34693 9E3D           50                         push	ax
34694                                           ! Debug: list int = const $3E (used reg = )
34695 9E3E           B8                   003E  mov	ax,*$3E
34696 9E41           50                         push	ax
34697                                           ! Debug: list int = const $40 (used reg = )
34698 9E42           B8                   0040  mov	ax,*$40
34699 9E45           50                         push	ax
34700                                           ! Debug: func () void = write_byte+0 (used reg = )
34701 9E46           E8         67D1            call	_write_byte
34702 9E49           83C4                   06  add	sp,*6
34703                                           !BCC_EOS
34704                                           ! 4898       val8 = inb(0x3f4);
34705                                           ! Debug: list int = const $3F4 (used reg = )
34706 9E4C           B8                   03F4  mov	ax,#$3F4
34707 9E4F           50                         push	ax
34708                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34709 9E50           E8         66EB            call	_inb
34710 9E53           44                         inc	sp
34711 9E54           44                         inc	sp
34712                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34713 9E55           8846         F1            mov	-$F[bp],al
34714                                           !BCC_EOS
34715                                           ! 4899       if ( (val8 & 0xc0) != 0xc0 )
34716                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
34717 9E58           8A46         F1            mov	al,-$F[bp]
34718 9E5B           24                     C0  and	al,#$C0
34719                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
34720 9E5D           3C                     C0  cmp	al,#$C0
34721 9E5F           74           0E            je  	.6FE
34722                       00009E61            .6FF:
34723                                           ! 4900         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
34724                                           ! Debug: list * char = .700+0 (used reg = )
34725 9E61           BB                   D1A7  mov	bx,#.700
34726 9E64           53                         push	bx
34727                                           ! Debug: list int = const 7 (used reg = )
34728 9E65           B8                   0007  mov	ax,*7
34729 9E68           50                         push	ax
34730                                           ! Debug: func () void = bios_printf+0 (used reg = )
34731 9E69           E8         6BAD            call	_bios_printf
34732 9E6C           83C4                   04  add	sp,*4
34733                                           !BCC_EOS
34734                                           ! 4901       return_status[0] = inb(0x3f5);
34735                       00009E6F            .6FE:
34736                                           ! Debug: list int = const $3F5 (used reg = )
34737 9E6F           B8                   03F5  mov	ax,#$3F5
34738 9E72           50                         push	ax
34739                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34740 9E73           E8         66C8            call	_inb
34741 9E76           44                         inc	sp
34742 9E77           44                         inc	sp
34743                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
34744 9E78           8846         E9            mov	-$17[bp],al
34745                                           !BCC_EOS
34746                                           ! 4902       return_status[1] = inb(0x3f5);
34747                                           ! Debug: list int = const $3F5 (used reg = )
34748 9E7B           B8                   03F5  mov	ax,#$3F5
34749 9E7E           50                         push	ax
34750                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34751 9E7F           E8         66BC            call	_inb
34752 9E82           44                         inc	sp
34753 9E83           44                         inc	sp
34754                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
34755 9E84           8846         EA            mov	-$16[bp],al
34756                                           !BCC_EOS
34757                                           ! 4903       return_status[2] = inb(0x3f5);
34758                                           ! Debug: list int = const $3F5 (used reg = )
34759 9E87           B8                   03F5  mov	ax,#$3F5
34760 9E8A           50                         push	ax
34761                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34762 9E8B           E8         66B0            call	_inb
34763 9E8E           44                         inc	sp
34764 9E8F           44                         inc	sp
34765                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
34766 9E90           8846         EB            mov	-$15[bp],al
34767                                           !BCC_EOS
34768                                           ! 4904       return_status[3] = inb(0x3f5);
34769                                           ! Debug: list int = const $3F5 (used reg = )
34770 9E93           B8                   03F5  mov	ax,#$3F5
34771 9E96           50                         push	ax
34772                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34773 9E97           E8         66A4            call	_inb
34774 9E9A           44                         inc	sp
34775 9E9B           44                         inc	sp
34776                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
34777 9E9C           8846         EC            mov	-$14[bp],al
34778                                           !BCC_EOS
34779                                           ! 4905       return_status[4] = inb(0x3f5);
34780                                           ! Debug: list int = const $3F5 (used reg = )
34781 9E9F           B8                   03F5  mov	ax,#$3F5
34782 9EA2           50                         push	ax
34783                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34784 9EA3           E8         6698            call	_inb
34785 9EA6           44                         inc	sp
34786 9EA7           44                         inc	sp
34787                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
34788 9EA8           8846         ED            mov	-$13[bp],al
34789                                           !BCC_EOS
34790                                           ! 4906       return_status[5] = inb(0x3f5);
34791                                           ! Debug: list int = const $3F5 (used reg = )
34792 9EAB           B8                   03F5  mov	ax,#$3F5
34793 9EAE           50                         push	ax
34794                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34795 9EAF           E8         668C            call	_inb
34796 9EB2           44                         inc	sp
34797 9EB3           44                         inc	sp
34798                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
34799 9EB4           8846         EE            mov	-$12[bp],al
34800                                           !BCC_EOS
34801                                           ! 4907       return_status[6] = inb(0x3f5);
34802                                           ! Debug: list int = const $3F5 (used reg = )
34803 9EB7           B8                   03F5  mov	ax,#$3F5
34804 9EBA           50                         push	ax
34805                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34806 9EBB           E8         6680            call	_inb
34807 9EBE           44                         inc	sp
34808 9EBF           44                         inc	sp
34809                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
34810 9EC0           8846         EF            mov	-$11[bp],al
34811                                           !BCC_EOS
34812                                           ! 4908       write_byte(0x0040, 0x0042, return_status[0]);
34813                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
34814 9EC3           8A46         E9            mov	al,-$17[bp]
34815 9EC6           30E4                       xor	ah,ah
34816 9EC8           50                         push	ax
34817                                           ! Debug: list int = const $42 (used reg = )
34818 9EC9           B8                   0042  mov	ax,*$42
34819 9ECC           50                         push	ax
34820                                           ! Debug: list int = const $40 (used reg = )
34821 9ECD           B8                   0040  mov	ax,*$40
34822 9ED0           50                         push	ax
34823                                           ! Debug: func () void = write_byte+0 (used reg = )
34824 9ED1           E8         6746            call	_write_byte
34825 9ED4           83C4                   06  add	sp,*6
34826                                           !BCC_EOS
34827                                           ! 4909       write_byte(0x0040, 0x0043, return_status[1]);
34828                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
34829 9ED7           8A46         EA            mov	al,-$16[bp]
34830 9EDA           30E4                       xor	ah,ah
34831 9EDC           50                         push	ax
34832                                           ! Debug: list int = const $43 (used reg = )
34833 9EDD           B8                   0043  mov	ax,*$43
34834 9EE0           50                         push	ax
34835                                           ! Debug: list int = const $40 (used reg = )
34836 9EE1           B8                   0040  mov	ax,*$40
34837 9EE4           50                         push	ax
34838                                           ! Debug: func () void = write_byte+0 (used reg = )
34839 9EE5           E8         6732            call	_write_byte
34840 9EE8           83C4                   06  add	sp,*6
34841                                           !BCC_EOS
34842                                           ! 4910       write_byte(0x0040, 0x0044, return_status[2]);
34843                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
34844 9EEB           8A46         EB            mov	al,-$15[bp]
34845 9EEE           30E4                       xor	ah,ah
34846 9EF0           50                         push	ax
34847                                           ! Debug: list int = const $44 (used reg = )
34848 9EF1           B8                   0044  mov	ax,*$44
34849 9EF4           50                         push	ax
34850                                           ! Debug: list int = const $40 (used reg = )
34851 9EF5           B8                   0040  mov	ax,*$40
34852 9EF8           50                         push	ax
34853                                           ! Debug: func () void = write_byte+0 (used reg = )
34854 9EF9           E8         671E            call	_write_byte
34855 9EFC           83C4                   06  add	sp,*6
34856                                           !BCC_EOS
34857                                           ! 4911       write
34858                                           ! 4911 _byte(0x0040, 0x0045, return_status[3]);
34859                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
34860 9EFF           8A46         EC            mov	al,-$14[bp]
34861 9F02           30E4                       xor	ah,ah
34862 9F04           50                         push	ax
34863                                           ! Debug: list int = const $45 (used reg = )
34864 9F05           B8                   0045  mov	ax,*$45
34865 9F08           50                         push	ax
34866                                           ! Debug: list int = const $40 (used reg = )
34867 9F09           B8                   0040  mov	ax,*$40
34868 9F0C           50                         push	ax
34869                                           ! Debug: func () void = write_byte+0 (used reg = )
34870 9F0D           E8         670A            call	_write_byte
34871 9F10           83C4                   06  add	sp,*6
34872                                           !BCC_EOS
34873                                           ! 4912       write_byte(0x0040, 0x0046, return_status[4]);
34874                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
34875 9F13           8A46         ED            mov	al,-$13[bp]
34876 9F16           30E4                       xor	ah,ah
34877 9F18           50                         push	ax
34878                                           ! Debug: list int = const $46 (used reg = )
34879 9F19           B8                   0046  mov	ax,*$46
34880 9F1C           50                         push	ax
34881                                           ! Debug: list int = const $40 (used reg = )
34882 9F1D           B8                   0040  mov	ax,*$40
34883 9F20           50                         push	ax
34884                                           ! Debug: func () void = write_byte+0 (used reg = )
34885 9F21           E8         66F6            call	_write_byte
34886 9F24           83C4                   06  add	sp,*6
34887                                           !BCC_EOS
34888                                           ! 4913       write_byte(0x0040, 0x0047, return_status[5]);
34889                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
34890 9F27           8A46         EE            mov	al,-$12[bp]
34891 9F2A           30E4                       xor	ah,ah
34892 9F2C           50                         push	ax
34893                                           ! Debug: list int = const $47 (used reg = )
34894 9F2D           B8                   0047  mov	ax,*$47
34895 9F30           50                         push	ax
34896                                           ! Debug: list int = const $40 (used reg = )
34897 9F31           B8                   0040  mov	ax,*$40
34898 9F34           50                         push	ax
34899                                           ! Debug: func () void = write_byte+0 (used reg = )
34900 9F35           E8         66E2            call	_write_byte
34901 9F38           83C4                   06  add	sp,*6
34902                                           !BCC_EOS
34903                                           ! 4914       write_byte(0x0040, 0x0048, return_status[6]);
34904                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
34905 9F3B           8A46         EF            mov	al,-$11[bp]
34906 9F3E           30E4                       xor	ah,ah
34907 9F40           50                         push	ax
34908                                           ! Debug: list int = const $48 (used reg = )
34909 9F41           B8                   0048  mov	ax,*$48
34910 9F44           50                         push	ax
34911                                           ! Debug: list int = const $40 (used reg = )
34912 9F45           B8                   0040  mov	ax,*$40
34913 9F48           50                         push	ax
34914                                           ! Debug: func () void = write_byte+0 (used reg = )
34915 9F49           E8         66CE            call	_write_byte
34916 9F4C           83C4                   06  add	sp,*6
34917                                           !BCC_EOS
34918                                           ! 4915       if ( (return_status[0] & 0xc0) != 0 ) {
34919                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
34920 9F4F           8A46         E9            mov	al,-$17[bp]
34921 9F52           24                     C0  and	al,#$C0
34922                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34923 9F54           84C0                       test	al,al
34924 9F56           74           2B            je  	.701
34925                       00009F58            .702:
34926                                           ! 4916         if ( (return_status[1] & 0x02) != 0 ) {
34927                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
34928 9F58           8A46         EA            mov	al,-$16[bp]
34929 9F5B           24                     02  and	al,*2
34930                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34931 9F5D           84C0                       test	al,al
34932 9F5F           74           14            je  	.703
34933                       00009F61            .704:
34934                                           ! 4917           AX = 0x0300;
34935                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
34936 9F61           B8                   0300  mov	ax,#$300
34937 9F64           8946         16            mov	$16[bp],ax
34938                                           !BCC_EOS
34939                                           ! 4918           FLAGS |= 0x0001;
34940                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34941 9F67           8B46         1C            mov	ax,$1C[bp]
34942 9F6A           0C                     01  or	al,*1
34943 9F6C           8946         1C            mov	$1C[bp],ax
34944                                           !BCC_EOS
34945                                           ! 4919           return;
34946 9F6F           89EC                       mov	sp,bp
34947 9F71           5D                         pop	bp
34948 9F72           C3                         ret
34949                                           !BCC_EOS
34950                                           ! 4920         } else {
34951 9F73           EB           0E            jmp .705
34952                       00009F75            .703:
34953                                           ! 4921           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
34954                                           ! Debug: list * char = .706+0 (used reg = )
34955 9F75           BB                   D181  mov	bx,#.706
34956 9F78           53                         push	bx
34957                                           ! Debug: list int = const 7 (used reg = )
34958 9F79           B8                   0007  mov	ax,*7
34959 9F7C           50                         push	ax
34960                                           ! Debug: func () void = bios_printf+0 (used reg = )
34961 9F7D           E8         6A99            call	_bios_printf
34962 9F80           83C4                   04  add	sp,*4
34963                                           !BCC_EOS
34964                                           ! 4922         }
34965                                           ! 4923       }
34966                       00009F83            .705:
34967                                           ! 4924       AX = ((AX & 0x00ff) | ((0) << 8));
34968                       00009F83            .701:
34969                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34970 9F83           8A46         16            mov	al,$16[bp]
34971                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34972 9F86           0C                     00  or	al,*0
34973                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34974 9F88           30E4                       xor	ah,ah
34975 9F8A           8946         16            mov	$16[bp],ax
34976                                           !BCC_EOS
34977                                           ! 4925       set_diskette_ret_status(0);
34978                                           ! Debug: list int = const 0 (used reg = )
34979 9F8D           31C0                       xor	ax,ax
34980 9F8F           50                         push	ax
34981                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34982 9F90           E8         0361            call	_set_diskette_ret_status
34983 9F93           44                         inc	sp
34984 9F94           44                         inc	sp
34985                                           !BCC_EOS
34986                                           ! 4926       set_diskette_current_cyl(drive, 0);
34987                                           ! Debug: list int = const 0 (used reg = )
34988 9F95           31C0                       xor	ax,ax
34989 9F97           50                         push	ax
34990                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34991 9F98           8A46         FF            mov	al,-1[bp]
34992 9F9B           30E4                       xor	ah,ah
34993 9F9D           50                         push	ax
34994                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34995 9F9E           E8         036B            call	_set_diskette_current_cyl
34996 9FA1           83C4                   04  add	sp,*4
34997                                           !BCC_EOS
34998                                           ! 4927       FLAGS &= 0xfffe;
34999                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35000 9FA4           8B46         1C            mov	ax,$1C[bp]
35001 9FA7           24                     FE  and	al,#$FE
35002 9FA9           8946         1C            mov	$1C[bp],ax
35003                                           !BCC_EOS
35004                                           ! 4928       return;
35005 9FAC           89EC                       mov	sp,bp
35006 9FAE           5D                         pop	bp
35007 9FAF           C3                         ret
35008                                           !BCC_EOS
35009                                           ! 4929     case 0x08:
35010                                           ! 4930 ;
35011                       00009FB0            .707:
35012                                           !BCC_EOS
35013                                           ! 4931       drive = ( ELDX & 0x00ff );
35014                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35015 9FB0           8A46         0E            mov	al,$E[bp]
35016                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35017 9FB3           8846         FF            mov	-1[bp],al
35018                                           !BCC_EOS
35019                                           ! 4932       if (drive > 1) {
35020                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35021 9FB6           8A46         FF            mov	al,-1[bp]
35022 9FB9           3C                     01  cmp	al,*1
35023 9FBB           76           35            jbe 	.708
35024                       00009FBD            .709:
35025                                           ! 4933         AX = 0;
35026                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
35027 9FBD           31C0                       xor	ax,ax
35028 9FBF           8946         16            mov	$16[bp],ax
35029                                           !BCC_EOS
35030                                           ! 4934         BX = 0;
35031                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
35032 9FC2           31C0                       xor	ax,ax
35033 9FC4           8946         10            mov	$10[bp],ax
35034                                           !BCC_EOS
35035                                           ! 4935         CX = 0;
35036                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
35037 9FC7           31C0                       xor	ax,ax
35038 9FC9           8946         14            mov	$14[bp],ax
35039                                           !BCC_EOS
35040                                           ! 4936         DX = 0;
35041                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
35042 9FCC           31C0                       xor	ax,ax
35043 9FCE           8946         12            mov	$12[bp],ax
35044                                           !BCC_EOS
35045                                           ! 4937         ES = 0;
35046                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
35047 9FD1           31C0                       xor	ax,ax
35048 9FD3           8946         06            mov	6[bp],ax
35049                                           !BCC_EOS
35050                                           ! 4938         DI = 0;
35051                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
35052 9FD6           31C0                       xor	ax,ax
35053 9FD8           8946         08            mov	8[bp],ax
35054                                           !BCC_EOS
35055                                           ! 4939         DX = ((DX & 0xff00) | (num_floppies));
35056                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
35057 9FDB           8B46         12            mov	ax,$12[bp]
35058 9FDE           30C0                       xor	al,al
35059                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
35060 9FE0           0A46         E7            or	al,-$19[bp]
35061                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35062 9FE3           8946         12            mov	$12[bp],ax
35063                                           !BCC_EOS
35064                                           ! 4940         FLAGS |= 0x0001;
35065                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35066 9FE6           8B46         1C            mov	ax,$1C[bp]
35067 9FE9           0C                     01  or	al,*1
35068 9FEB           8946         1C            mov	$1C[bp],ax
35069                                           !BCC_EOS
35070                                           ! 4941         return;
35071 9FEE           89EC                       mov	sp,bp
35072 9FF0           5D                         pop	bp
35073 9FF1           C3                         ret
35074                                           !BCC_EOS
35075                                           ! 4942         }
35076                                           ! 4943       drive_type = inb_cmos(0x10);
35077                       00009FF2            .708:
35078                                           ! Debug: list int = const $10 (used reg = )
35079 9FF2           B8                   0010  mov	ax,*$10
35080 9FF5           50                         push	ax
35081                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35082 9FF6           E8         658A            call	_inb_cmos
35083 9FF9           44                         inc	sp
35084 9FFA           44                         inc	sp
35085                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35086 9FFB           8846         E8            mov	-$18[bp],al
35087                                           !BCC_EOS
35088                                           ! 4944       num_floppies = 0;
35089                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
35090 9FFE           30C0                       xor	al,al
35091 A000           8846         E7            mov	-$19[bp],al
35092                                           !BCC_EOS
35093                                           ! 4945       if (drive_type & 0xf0)
35094                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35095 A003           8A46         E8            mov	al,-$18[bp]
35096 A006           24                     F0  and	al,#$F0
35097 A008           84C0                       test	al,al
35098 A00A           74           07            je  	.70A
35099                       0000A00C            .70B:
35100                                           ! 4946         num_floppies++;
35101                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
35102 A00C           8A46         E7            mov	al,-$19[bp]
35103 A00F           40                         inc	ax
35104 A010           8846         E7            mov	-$19[bp],al
35105                                           !BCC_EOS
35106                                           ! 4947       if (drive_type & 0x0f)
35107                       0000A013            .70A:
35108                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35109 A013           8A46         E8            mov	al,-$18[bp]
35110 A016           24                     0F  and	al,*$F
35111 A018           84C0                       test	al,al
35112 A01A           74           07            je  	.70C
35113                       0000A01C            .70D:
35114                                           ! 4948         num_floppies++;
35115                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
35116 A01C           8A46         E7            mov	al,-$19[bp]
35117 A01F           40                         inc	ax
35118 A020           8846         E7            mov	-$19[bp],al
35119                                           !BCC_EOS
35120                                           ! 4949       if (drive == 0)
35121                       0000A023            .70C:
35122                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
35123 A023           8A46         FF            mov	al,-1[bp]
35124 A026           84C0                       test	al,al
35125 A028           75           0E            jne 	.70E
35126                       0000A02A            .70F:
35127                                           ! 4950         drive_type >>= 4;
35128                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35129 A02A           8A46         E8            mov	al,-$18[bp]
35130 A02D           30E4                       xor	ah,ah
35131 A02F           B1                     04  mov	cl,*4
35132 A031           D3E8                       shr	ax,cl
35133 A033           8846         E8            mov	-$18[bp],al
35134                                           !BCC_EOS
35135                                           ! 4951       else
35136                                           ! 4952         drive_type &= 0x0f;
35137 A036           EB           08            jmp .710
35138                       0000A038            .70E:
35139                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35140 A038           8A46         E8            mov	al,-$18[bp]
35141 A03B           24                     0F  and	al,*$F
35142 A03D           8846         E8            mov	-$18[bp],al
35143                                           !BCC_EOS
35144                                           ! 4953       BX = ((BX & 0x00ff) | ((0) << 8));
35145                       0000A040            .710:
35146                                           ! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
35147 A040           8A46         10            mov	al,$10[bp]
35148                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35149 A043           0C                     00  or	al,*0
35150                                           ! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
35151 A045           30E4                       xor	ah,ah
35152 A047           8946         10            mov	$10[bp],ax
35153                                           !BCC_EOS
35154                                           ! 4954       BX = ((BX & 0xff00) | (drive_type));
35155                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
35156 A04A           8B46         10            mov	ax,$10[bp]
35157 A04D           30C0                       xor	al,al
35158                                           ! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
35159 A04F           0A46         E8            or	al,-$18[bp]
35160                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
35161 A052           8946         10            mov	$10[bp],ax
35162                                           !BCC_EOS
35163                                           ! 4955       AX = ((AX & 0x00ff) | ((0) << 8));
35164                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35165 A055           8A46         16            mov	al,$16[bp]
35166                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35167 A058           0C                     00  or	al,*0
35168                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35169 A05A           30E4                       xor	ah,ah
35170 A05C           8946         16            mov	$16[bp],ax
35171                                           !BCC_EOS
35172                                           ! 4956       AX = ((AX & 0xff00) | (0));
35173                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
35174 A05F           8B46         16            mov	ax,$16[bp]
35175 A062           30C0                       xor	al,al
35176                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
35177 A064           0C                     00  or	al,*0
35178                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35179 A066           8946         16            mov	$16[bp],ax
35180                                           !BCC_EOS
35181                                           ! 4957       DX = ((DX & 0xff00) | (num_floppies));
35182                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
35183 A069           8B46         12            mov	ax,$12[bp]
35184 A06C           30C0                       xor	al,al
35185                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
35186 A06E           0A46         E7            or	al,-$19[bp]
35187                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35188 A071           8946         12            mov	$12[bp],ax
35189                                           !BCC_EOS
35190                                           ! 4958       switch (drive_type) {
35191 A074           8A46         E8            mov	al,-$18[bp]
35192 A077           E9         00BC            br 	.713
35193                                           ! 4959         case 0:
35194                                           ! 4960           CX = 0;
35195                       0000A07A            .714:
35196                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
35197 A07A           31C0                       xor	ax,ax
35198 A07C           8946         14            mov	$14[bp],ax
35199                                           !BCC_EOS
35200                                           ! 4961           DX = ((DX & 0x00ff) | ((0) << 8));
35201                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35202 A07F           8A46         12            mov	al,$12[bp]
35203                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35204 A082           0C                     00  or	al,*0
35205                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35206 A084           30E4                       xor	ah,ah
35207 A086           8946         12            mov	$12[bp],ax
35208                                           !BCC_EOS
35209                                           ! 4962           break;
35210 A089           E9         00D1            br 	.711
35211                                           !BCC_EOS
35212                                           ! 4963         case 1:
35213                                           ! 4964           CX = 0x2709;
35214                       0000A08C            .715:
35215                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
35216 A08C           B8                   2709  mov	ax,#$2709
35217 A08F           8946         14            mov	$14[bp],ax
35218                                           !BCC_EOS
35219                                           ! 4965           DX = ((DX & 0x00ff) | ((1) << 8));
35220                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35221 A092           8A46         12            mov	al,$12[bp]
35222                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35223 A095           30E4                       xor	ah,ah
35224 A097           0D                   0100  or	ax,#$100
35225                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35226 A09A           8946         12            mov	$12[bp],ax
35227                                           !BCC_EOS
35228                                           ! 4966           break;
35229 A09D           E9         00BD            br 	.711
35230                                           !BCC_EOS
35231                                           ! 4967         case 2:
35232                                           ! 4968           CX = 0x4f0f;
35233                       0000A0A0            .716:
35234                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
35235 A0A0           B8                   4F0F  mov	ax,#$4F0F
35236 A0A3           8946         14            mov	$14[bp],ax
35237                                           !BCC_EOS
35238                                           ! 4969           DX = ((DX & 0x00ff) | ((1) << 8));
35239                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35240 A0A6           8A46         12            mov	al,$12[bp]
35241                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35242 A0A9           30E4                       xor	ah,ah
35243 A0AB           0D                   0100  or	ax,#$100
35244                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35245 A0AE           8946         12            mov	$12[bp],ax
35246                                           !BCC_EOS
35247                                           ! 4970           break;
35248 A0B1           E9         00A9            br 	.711
35249                                           !BCC_EOS
35250                                           ! 4971         case 3:
35251                                           ! 4972           CX = 0x4f09;
35252                       0000A0B4            .717:
35253                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
35254 A0B4           B8                   4F09  mov	ax,#$4F09
35255 A0B7           8946         14            mov	$14[bp],ax
35256                                           !BCC_EOS
35257                                           ! 4973           DX = ((DX & 0x00ff) | ((1) << 8));
35258                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35259 A0BA           8A46         12            mov	al,$12[bp]
35260                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35261 A0BD           30E4                       xor	ah,ah
35262 A0BF           0D                   0100  or	ax,#$100
35263                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35264 A0C2           8946         12            mov	$12[bp],ax
35265                                           !BCC_EOS
35266                                           ! 4974           break;
35267 A0C5           E9         0095            br 	.711
35268                                           !BCC_EOS
35269                                           ! 4975         case 4:
35270                                           ! 4976           CX = 0x4f12;
35271                       0000A0C8            .718:
35272                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
35273 A0C8           B8                   4F12  mov	ax,#$4F12
35274 A0CB           8946         14            mov	$14[bp],ax
35275                                           !BCC_EOS
35276                                           ! 4977           DX = ((DX & 0x00ff) | ((1) << 8));
35277                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35278 A0CE           8A46         12            mov	al,$12[bp]
35279                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35280 A0D1           30E4                       xor	ah,ah
35281 A0D3           0D                   0100  or	ax,#$100
35282                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35283 A0D6           8946         12            mov	$12[bp],ax
35284                                           !BCC_EOS
35285                                           ! 4978           break;
35286 A0D9           E9         0081            br 	.711
35287                                           !BCC_EOS
35288                                           ! 4979         case 5:
35289                                           ! 4980           CX = 0x4f24;
35290                       0000A0DC            .719:
35291                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
35292 A0DC           B8                   4F24  mov	ax,#$4F24
35293 A0DF           8946         14            mov	$14[bp],ax
35294                                           !BCC_EOS
35295                                           ! 4981           DX = ((DX & 0x00ff) | ((1) << 8));
35296                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35297 A0E2           8A46         12            mov	al,$12[bp]
35298                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35299 A0E5           30E4                       xor	ah,ah
35300 A0E7           0D                   0100  or	ax,#$100
35301                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35302 A0EA           8946         12            mov	$12[bp],ax
35303                                           !BCC_EOS
35304                                           ! 4982           break;
35305 A0ED           EB           6E            jmp .711
35306                                           !BCC_EOS
35307                                           ! 4983         case 6:
35308                                           ! 4984           CX = 0x2708;
35309                       0000A0EF            .71A:
35310                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
35311 A0EF           B8                   2708  mov	ax,#$2708
35312 A0F2           8946         14            mov	$14[bp],ax
35313                                           !BCC_EOS
35314                                           ! 4985           DX = ((DX & 0x00ff) |
35315                                           ! 4985  ((0) << 8));
35316                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35317 A0F5           8A46         12            mov	al,$12[bp]
35318                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35319 A0F8           0C                     00  or	al,*0
35320                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35321 A0FA           30E4                       xor	ah,ah
35322 A0FC           8946         12            mov	$12[bp],ax
35323                                           !BCC_EOS
35324                                           ! 4986           break;
35325 A0FF           EB           5C            jmp .711
35326                                           !BCC_EOS
35327                                           ! 4987         case 7:
35328                                           ! 4988           CX = 0x2709;
35329                       0000A101            .71B:
35330                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
35331 A101           B8                   2709  mov	ax,#$2709
35332 A104           8946         14            mov	$14[bp],ax
35333                                           !BCC_EOS
35334                                           ! 4989           DX = ((DX & 0x00ff) | ((0) << 8));
35335                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35336 A107           8A46         12            mov	al,$12[bp]
35337                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35338 A10A           0C                     00  or	al,*0
35339                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
35340 A10C           30E4                       xor	ah,ah
35341 A10E           8946         12            mov	$12[bp],ax
35342                                           !BCC_EOS
35343                                           ! 4990           break;
35344 A111           EB           4A            jmp .711
35345                                           !BCC_EOS
35346                                           ! 4991         case 8:
35347                                           ! 4992           CX = 0x2708;
35348                       0000A113            .71C:
35349                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
35350 A113           B8                   2708  mov	ax,#$2708
35351 A116           8946         14            mov	$14[bp],ax
35352                                           !BCC_EOS
35353                                           ! 4993           DX = ((DX & 0x00ff) | ((1) << 8));
35354                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
35355 A119           8A46         12            mov	al,$12[bp]
35356                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35357 A11C           30E4                       xor	ah,ah
35358 A11E           0D                   0100  or	ax,#$100
35359                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
35360 A121           8946         12            mov	$12[bp],ax
35361                                           !BCC_EOS
35362                                           ! 4994           break;
35363 A124           EB           37            jmp .711
35364                                           !BCC_EOS
35365                                           ! 4995         default:
35366                                           ! 4996           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
35367                       0000A126            .71D:
35368                                           ! Debug: list * char = .71E+0 (used reg = )
35369 A126           BB                   D161  mov	bx,#.71E
35370 A129           53                         push	bx
35371                                           ! Debug: list int = const 7 (used reg = )
35372 A12A           B8                   0007  mov	ax,*7
35373 A12D           50                         push	ax
35374                                           ! Debug: func () void = bios_printf+0 (used reg = )
35375 A12E           E8         68E8            call	_bios_printf
35376 A131           83C4                   04  add	sp,*4
35377                                           !BCC_EOS
35378                                           ! 4997         }
35379                                           ! 4998 #asm
35380 A134           EB           27            jmp .711
35381                       0000A136            .713:
35382 A136           2C                     00  sub	al,*0
35383 A138           72           EC            jb 	.71D
35384 A13A           3C                     08  cmp	al,*8
35385 A13C           77           1D            ja  	.71F
35386 A13E           30E4                       xor	ah,ah
35387 A140           D1E0                       shl	ax,*1
35388 A142           89C3                       mov	bx,ax
35389 A144           2E                         seg	cs
35390 A145           FFA7       A149            br	.720[bx]
35391                       0000A149            .720:
35392 A149                      A07A            .word	.714
35393 A14B                      A08C            .word	.715
35394 A14D                      A0A0            .word	.716
35395 A14F                      A0B4            .word	.717
35396 A151                      A0C8            .word	.718
35397 A153                      A0DC            .word	.719
35398 A155                      A0EF            .word	.71A
35399 A157                      A101            .word	.71B
35400 A159                      A113            .word	.71C
35401                       0000A15B            .71F:
35402 A15B           EB           C9            jmp	.71D
35403                       0000A15D            .711:
35404                                           !BCC_EOS
35405                                           !BCC_ASM
35406                       0000002A            _int13_diskette_function.BP	set	$2A
35407                       0000000C            .int13_diskette_function.BP	set	$C
35408                       00000038            _int13_diskette_function.CS	set	$38
35409                       0000001A            .int13_diskette_function.CS	set	$1A
35410                       00000032            _int13_diskette_function.CX	set	$32
35411                       00000014            .int13_diskette_function.CX	set	$14
35412                       00000016            _int13_diskette_function.base_address	set	$16
35413                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
35414                       00000026            _int13_diskette_function.DI	set	$26
35415                       00000008            .int13_diskette_function.DI	set	8
35416                       0000003A            _int13_diskette_function.FLAGS	set	$3A
35417                       0000001C            .int13_diskette_function.FLAGS	set	$1C
35418                       00000014            _int13_diskette_function.base_count	set	$14
35419                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
35420                       0000001A            _int13_diskette_function.sector	set	$1A
35421                       FFFFFFFC            .int13_diskette_function.sector	set	-4
35422                       00000022            _int13_diskette_function.DS	set	$22
35423                       00000004            .int13_diskette_function.DS	set	4
35424                       00000019            _int13_diskette_function.head	set	$19
35425                       FFFFFFFB            .int13_diskette_function.head	set	-5
35426                       0000002C            _int13_diskette_function.ELDX	set	$2C
35427                       0000000E            .int13_diskette_function.ELDX	set	$E
35428                       0000000E            _int13_diskette_function.dor	set	$E
35429                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
35430                       00000030            _int13_diskette_function.DX	set	$30
35431                       00000012            .int13_diskette_function.DX	set	$12
35432                       00000007            _int13_diskette_function.return_status	set	7
35433                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
35434                       00000002            _int13_diskette_function.es	set	2
35435                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
35436                       00000010            _int13_diskette_function.mode_register	set	$10
35437                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
35438                       00000024            _int13_diskette_function.ES	set	$24
35439                       00000006            .int13_diskette_function.ES	set	6
35440                       00000012            _int13_diskette_function.base_es	set	$12
35441                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
35442                       0000001B            _int13_diskette_function.track	set	$1B
35443                       FFFFFFFD            .int13_diskette_function.track	set	-3
35444                       00000028            _int13_diskette_function.SI	set	$28
35445                       0000000A            .int13_diskette_function.SI	set	$A
35446                       00000006            _int13_diskette_function.drive_type	set	6
35447                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
35448                       0000001C            _int13_diskette_function.num_sectors	set	$1C
35449                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
35450                       00000036            _int13_diskette_function.IP	set	$36
35451                       00000018            .int13_diskette_function.IP	set	$18
35452                       00000018            _int13_diskette_function.status	set	$18
35453                       FFFFFFFA            .int13_diskette_function.status	set	-6
35454                       00000034            _int13_diskette_function.AX	set	$34
35455                       00000016            .int13_diskette_function.AX	set	$16
35456                       0000000F            _int13_diskette_function.val8	set	$F
35457                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
35458                       00000000            _int13_diskette_function.last_addr	set	0
35459                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
35460                       00000011            _int13_diskette_function.page	set	$11
35461                       FFFFFFF3            .int13_diskette_function.page	set	-$D
35462                       00000004            _int13_diskette_function.ah	set	4
35463                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
35464                       0000001D            _int13_diskette_function.drive	set	$1D
35465                       FFFFFFFF            .int13_diskette_function.drive	set	-1
35466                       00000005            _int13_diskette_function.num_floppies	set	5
35467                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
35468                       0000002E            _int13_diskette_function.BX	set	$2E
35469                       00000010            .int13_diskette_function.BX	set	$10
35470 A15D           55                               push bp
35471 A15E           89E5                             mov bp, sp
35472 A160           B8                   EFDE        mov ax, #diskette_param_table2
35473 A163           8946         28                  mov _int13_diskette_function.DI+2[bp], ax
35474 A166           8C4E         26                  mov _int13_diskette_function.ES+2[bp], cs
35475 A169           5D                               pop bp
35476                                           ! 5005 endasm
35477                                           !BCC_ENDASM
35478                                           !BCC_EOS
35479                                           ! 5006       FLAGS &= 0xfffe;
35480                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35481 A16A           8B46         1C            mov	ax,$1C[bp]
35482 A16D           24                     FE  and	al,#$FE
35483 A16F           8946         1C            mov	$1C[bp],ax
35484                                           !BCC_EOS
35485                                           ! 5007       return;
35486 A172           89EC                       mov	sp,bp
35487 A174           5D                         pop	bp
35488 A175           C3                         ret
35489                                           !BCC_EOS
35490                                           ! 5008     case 0x15:
35491                                           ! 5009 ;
35492                       0000A176            .721:
35493                                           !BCC_EOS
35494                                           ! 5010       drive = ( ELDX & 0x00ff );
35495                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35496 A176           8A46         0E            mov	al,$E[bp]
35497                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35498 A179           8846         FF            mov	-1[bp],al
35499                                           !BCC_EOS
35500                                           ! 5011       if (drive > 1) {
35501                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35502 A17C           8A46         FF            mov	al,-1[bp]
35503 A17F           3C                     01  cmp	al,*1
35504 A181           76           16            jbe 	.722
35505                       0000A183            .723:
35506                                           ! 5012         AX = ((AX & 0x00ff) | ((0) << 8));
35507                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35508 A183           8A46         16            mov	al,$16[bp]
35509                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35510 A186           0C                     00  or	al,*0
35511                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35512 A188           30E4                       xor	ah,ah
35513 A18A           8946         16            mov	$16[bp],ax
35514                                           !BCC_EOS
35515                                           ! 5013         FLAGS |= 0x0001;
35516                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35517 A18D           8B46         1C            mov	ax,$1C[bp]
35518 A190           0C                     01  or	al,*1
35519 A192           8946         1C            mov	$1C[bp],ax
35520                                           !BCC_EOS
35521                                           ! 5014         return;
35522 A195           89EC                       mov	sp,bp
35523 A197           5D                         pop	bp
35524 A198           C3                         ret
35525                                           !BCC_EOS
35526                                           ! 5015         }
35527                                           ! 5016       drive_type = inb_cmos(0x10);
35528                       0000A199            .722:
35529                                           ! Debug: list int = const $10 (used reg = )
35530 A199           B8                   0010  mov	ax,*$10
35531 A19C           50                         push	ax
35532                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35533 A19D           E8         63E3            call	_inb_cmos
35534 A1A0           44                         inc	sp
35535 A1A1           44                         inc	sp
35536                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35537 A1A2           8846         E8            mov	-$18[bp],al
35538                                           !BCC_EOS
35539                                           ! 5017       if (drive == 0)
35540                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
35541 A1A5           8A46         FF            mov	al,-1[bp]
35542 A1A8           84C0                       test	al,al
35543 A1AA           75           0E            jne 	.724
35544                       0000A1AC            .725:
35545                                           ! 5018         drive_type >>= 4;
35546                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35547 A1AC           8A46         E8            mov	al,-$18[bp]
35548 A1AF           30E4                       xor	ah,ah
35549 A1B1           B1                     04  mov	cl,*4
35550 A1B3           D3E8                       shr	ax,cl
35551 A1B5           8846         E8            mov	-$18[bp],al
35552                                           !BCC_EOS
35553                                           ! 5019       else
35554                                           ! 5020         drive_type &= 0x0f;
35555 A1B8           EB           08            jmp .726
35556                       0000A1BA            .724:
35557                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
35558 A1BA           8A46         E8            mov	al,-$18[bp]
35559 A1BD           24                     0F  and	al,*$F
35560 A1BF           8846         E8            mov	-$18[bp],al
35561                                           !BCC_EOS
35562                                           ! 5021       FLAGS &= 0xfffe;
35563                       0000A1C2            .726:
35564                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35565 A1C2           8B46         1C            mov	ax,$1C[bp]
35566 A1C5           24                     FE  and	al,#$FE
35567 A1C7           8946         1C            mov	$1C[bp],ax
35568                                           !BCC_EOS
35569                                           ! 5022       if (drive_type==0) {
35570                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
35571 A1CA           8A46         E8            mov	al,-$18[bp]
35572 A1CD           84C0                       test	al,al
35573 A1CF           75           0C            jne 	.727
35574                       0000A1D1            .728:
35575                                           ! 5023         AX = ((AX & 0x00ff) | ((0) << 8));
35576                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35577 A1D1           8A46         16            mov	al,$16[bp]
35578                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
35579 A1D4           0C                     00  or	al,*0
35580                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
35581 A1D6           30E4                       xor	ah,ah
35582 A1D8           8946         16            mov	$16[bp],ax
35583                                           !BCC_EOS
35584                                           ! 5024         }
35585                                           ! 5025       else {
35586 A1DB           EB           0B            jmp .729
35587                       0000A1DD            .727:
35588                                           ! 5026         AX = ((AX & 0x00ff) | ((1) << 8));
35589                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35590 A1DD           8A46         16            mov	al,$16[bp]
35591                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35592 A1E0           30E4                       xor	ah,ah
35593 A1E2           0D                   0100  or	ax,#$100
35594                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35595 A1E5           8946         16            mov	$16[bp],ax
35596                                           !BCC_EOS
35597                                           ! 5027         }
35598                                           ! 5028       return;
35599                       0000A1E8            .729:
35600 A1E8           89EC                       mov	sp,bp
35601 A1EA           5D                         pop	bp
35602 A1EB           C3                         ret
35603                                           !BCC_EOS
35604                                           ! 5029     case 0x16:
35605                                           ! 5030 ;
35606                       0000A1EC            .72A:
35607                                           !BCC_EOS
35608                                           ! 5031       drive = ( ELDX & 0x00ff );
35609                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
35610 A1EC           8A46         0E            mov	al,$E[bp]
35611                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
35612 A1EF           8846         FF            mov	-1[bp],al
35613                                           !BCC_EOS
35614                                           ! 5032       if (drive > 1) {
35615                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
35616 A1F2           8A46         FF            mov	al,-1[bp]
35617 A1F5           3C                     01  cmp	al,*1
35618 A1F7           76           20            jbe 	.72B
35619                       0000A1F9            .72C:
35620                                           ! 5033         AX = ((AX & 0x00ff) | ((0x01) << 8));
35621                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35622 A1F9           8A46         16            mov	al,$16[bp]
35623                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35624 A1FC           30E4                       xor	ah,ah
35625 A1FE           0D                   0100  or	ax,#$100
35626                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35627 A201           8946         16            mov	$16[bp],ax
35628                                           !BCC_EOS
35629                                           ! 5034         set_diskette_ret_status(0x01);
35630                                           ! Debug: list int = const 1 (used reg = )
35631 A204           B8                   0001  mov	ax,*1
35632 A207           50                         push	ax
35633                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35634 A208           E8         00E9            call	_set_diskette_ret_status
35635 A20B           44                         inc	sp
35636 A20C           44                         inc	sp
35637                                           !BCC_EOS
35638                                           ! 5035         FLAGS |= 0x0001;
35639                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35640 A20D           8B46         1C            mov	ax,$1C[bp]
35641 A210           0C                     01  or	al,*1
35642 A212           8946         1C            mov	$1C[bp],ax
35643                                           !BCC_EOS
35644                                           ! 5036         return;
35645 A215           89EC                       mov	sp,bp
35646 A217           5D                         pop	bp
35647 A218           C3                         ret
35648                                           !BCC_EOS
35649                                           ! 5037         }
35650                                           ! 5038       AX = ((AX & 0x00ff) | ((0x06) << 8));
35651                       0000A219            .72B:
35652                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35653 A219           8A46         16            mov	al,$16[bp]
35654                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
35655 A21C           30E4                       xor	ah,ah
35656 A21E           0D                   0600  or	ax,#$600
35657                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35658 A221           8946         16            mov	$16[bp],ax
35659                                           !BCC_EOS
35660                                           ! 5039       set_diskette_ret_status(0x06);
35661                                           ! Debug: list int = const 6 (used reg = )
35662 A224           B8                   0006  mov	ax,*6
35663 A227           50                         push	ax
35664                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35665 A228           E8         00C9            call	_set_diskette_ret_status
35666 A22B           44                         inc	sp
35667 A22C           44                         inc	sp
35668                                           !BCC_EOS
35669                                           ! 5040       FLAGS |= 0x0001;
35670                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35671 A22D           8B46         1C            mov	ax,$1C[bp]
35672 A230           0C                     01  or	al,*1
35673 A232           8946         1C            mov	$1C[bp],ax
35674                                           !BCC_EOS
35675                                           ! 5041       return;
35676 A235           89EC                       mov	sp,bp
35677 A237           5D                         pop	bp
35678 A238           C3                         ret
35679                                           !BCC_EOS
35680                                           ! 5042     case 0x17:
35681                                           ! 5043 ;
35682                       0000A239            .72D:
35683                                           !BCC_EOS
35684                                           ! 5044       AX = ((AX & 0x00ff) | ((0x01) << 8));
35685                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35686 A239           8A46         16            mov	al,$16[bp]
35687                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35688 A23C           30E4                       xor	ah,ah
35689 A23E           0D                   0100  or	ax,#$100
35690                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35691 A241           8946         16            mov	$16[bp],ax
35692                                           !BCC_EOS
35693                                           ! 5045       set_diskette_ret_status(1);
35694                                           ! Debug: list int = const 1 (used reg = )
35695 A244           B8                   0001  mov	ax,*1
35696 A247           50                         push	ax
35697                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35698 A248           E8         00A9            call	_set_diskette_ret_status
35699 A24B           44                         inc	sp
35700 A24C           44                         inc	sp
35701                                           !BCC_EOS
35702                                           ! 5046       FLAGS |= 0x0001;
35703                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35704 A24D           8B46         1C            mov	ax,$1C[bp]
35705 A250           0C                     01  or	al,*1
35706 A252           8946         1C            mov	$1C[bp],ax
35707                                           !BCC_EOS
35708                                           ! 5047       return;
35709 A255           89EC                       mov	sp,bp
35710 A257           5D                         pop	bp
35711 A258           C3                         ret
35712                                           !BCC_EOS
35713                                           ! 5048     case 0x18:
35714                                           ! 5049 ;
35715                       0000A259            .72E:
35716                                           !BCC_EOS
35717                                           ! 5050       AX = ((AX & 0x00ff) | ((0x01) << 8));
35718                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35719 A259           8A46         16            mov	al,$16[bp]
35720                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35721 A25C           30E4                       xor	ah,ah
35722 A25E           0D                   0100  or	ax,#$100
35723                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35724 A261           8946         16            mov	$16[bp],ax
35725                                           !BCC_EOS
35726                                           ! 5051       set_diskette_ret_status(1);
35727                                           ! Debug: list int = const 1 (used reg = )
35728 A264           B8                   0001  mov	ax,*1
35729 A267           50                         push	ax
35730                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35731 A268           E8         0089            call	_set_diskette_ret_status
35732 A26B           44                         inc	sp
35733 A26C           44                         inc	sp
35734                                           !BCC_EOS
35735                                           ! 5052       FLAGS |= 0x0001;
35736                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35737 A26D           8B46         1C            mov	ax,$1C[bp]
35738 A270           0C                     01  or	al,*1
35739 A272           8946         1C            mov	$1C[bp],ax
35740                                           !BCC_EOS
35741                                           ! 5053       return;
35742 A275           89EC                       mov	sp,bp
35743 A277           5D                         pop	bp
35744 A278           C3                         ret
35745                                           !BCC_EOS
35746                                           ! 5054     default:
35747                                           ! 5055         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", ( AX >> 8 ));
35748                       0000A279            .72F:
35749                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
35750 A279           8B46         16            mov	ax,$16[bp]
35751 A27C           88E0                       mov	al,ah
35752 A27E           30E4                       xor	ah,ah
35753                                           ! Debug: list unsigned int = ax+0 (used reg = )
35754 A280           50                         push	ax
35755                                           ! Debug: list * char = .730+0 (used reg = )
35756 A281           BB                   D13C  mov	bx,#.730
35757 A284           53                         push	bx
35758                                           ! Debug: list int = const 4 (used reg = )
35759 A285           B8                   0004  mov	ax,*4
35760 A288           50                         push	ax
35761                                           ! Debug: func () void = bios_printf+0 (used reg = )
35762 A289           E8         678D            call	_bios_printf
35763 A28C           83C4                   06  add	sp,*6
35764                                           !BCC_EOS
35765                                           ! 5056         AX = ((AX & 0x00ff) | ((0x01) << 8));
35766                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35767 A28F           8A46         16            mov	al,$16[bp]
35768                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35769 A292           30E4                       xor	ah,ah
35770 A294           0D                   0100  or	ax,#$100
35771                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35772 A297           8946         16            mov	$16[bp],ax
35773                                           !BCC_EOS
35774                                           ! 5057         set_diskette_ret_status(1);
35775                                           ! Debug: list int = const 1 (used reg = )
35776 A29A           B8                   0001  mov	ax,*1
35777 A29D           50                         push	ax
35778                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35779 A29E           E8         0053            call	_set_diskette_ret_status
35780 A2A1           44                         inc	sp
35781 A2A2           44                         inc	sp
35782                                           !BCC_EOS
35783                                           ! 5058         FLAGS |= 0x0001;
35784                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35785 A2A3           8B46         1C            mov	ax,$1C[bp]
35786 A2A6           0C                     01  or	al,*1
35787 A2A8           8946         1C            mov	$1C[bp],ax
35788                                           !BCC_EOS
35789                                           ! 5059         return;
35790 A2AB           89EC                       mov	sp,bp
35791 A2AD           5D                         pop	bp
35792 A2AE           C3                         ret
35793                                           !BCC_EOS
35794                                           ! 5060     }
35795                                           ! 5061 }
35796 A2AF           EB           3F            jmp .6A1
35797                       0000A2B1            .6A3:
35798 A2B1           2C                     00  sub	al,*0
35799 A2B3           72           C4            jb 	.72F
35800 A2B5           3C                     08  cmp	al,*8
35801 A2B7           77           1D            ja  	.731
35802 A2B9           30E4                       xor	ah,ah
35803 A2BB           D1E0                       shl	ax,*1
35804 A2BD           89C3                       mov	bx,ax
35805 A2BF           2E                         seg	cs
35806 A2C0           FFA7       A2C4            br	.732[bx]
35807                       0000A2C4            .732:
35808 A2C4                      91EE            .word	.6A4
35809 A2C6                      9298            .word	.6AC
35810 A2C8                      92DA            .word	.6AF
35811 A2CA                      92DA            .word	.6B0
35812 A2CC                      92DA            .word	.6B1
35813 A2CE                      9B73            .word	.6E7
35814 A2D0                      A279            .word	.72F
35815 A2D2                      A279            .word	.72F
35816 A2D4                      9FB0            .word	.707
35817                       0000A2D6            .731:
35818 A2D6           2C                     15  sub	al,*$15
35819 A2D8         0F84         FE9A            beq 	.721
35820 A2DC           2C                     01  sub	al,*1
35821 A2DE         0F84         FF0A            beq 	.72A
35822 A2E2           2C                     01  sub	al,*1
35823 A2E4         0F84         FF51            beq 	.72D
35824 A2E8           2C                     01  sub	al,*1
35825 A2EA         0F84         FF6B            beq 	.72E
35826 A2EE           EB           89            jmp	.72F
35827                       0000A2F0            .6A1:
35828                       FFFFFFE0            ..FFDC	=	-$20
35829 A2F0           89EC                       mov	sp,bp
35830 A2F2           5D                         pop	bp
35831 A2F3           C3                         ret
35832                                           ! 5062  void
35833                                           ! Register BX used in function int13_diskette_function
35834                                           ! 5063 set_diskette_ret_status(value)
35835                                           ! 5064   Bit8u value;
35836                                           export	_set_diskette_ret_status
35837                       0000A2F4            _set_diskette_ret_status:
35838                                           !BCC_EOS
35839                                           ! 5065 {
35840                                           ! 5066   write_byte(0x0040, 0x0041, value);
35841 A2F4           55                         push	bp
35842 A2F5           89E5                       mov	bp,sp
35843                                           ! Debug: list unsigned char value = [S+2+2] (used reg = )
35844 A2F7           8A46         04            mov	al,4[bp]
35845 A2FA           30E4                       xor	ah,ah
35846 A2FC           50                         push	ax
35847                                           ! Debug: list int = const $41 (used reg = )
35848 A2FD           B8                   0041  mov	ax,*$41
35849 A300           50                         push	ax
35850                                           ! Debug: list int = const $40 (used reg = )
35851 A301           B8                   0040  mov	ax,*$40
35852 A304           50                         push	ax
35853                                           ! Debug: func () void = write_byte+0 (used reg = )
35854 A305           E8         6312            call	_write_byte
35855 A308           89EC                       mov	sp,bp
35856                                           !BCC_EOS
35857                                           ! 5067 }
35858 A30A           5D                         pop	bp
35859 A30B           C3                         ret
35860                                           ! 5068   void
35861                                           ! 5069 set_diskette_current_cyl(drive, cyl)
35862                                           ! 5070   Bit8u drive;
35863                                           export	_set_diskette_current_cyl
35864                       0000A30C            _set_diskette_current_cyl:
35865                                           !BCC_EOS
35866                                           ! 5071   Bit8u cyl;
35867                                           !BCC_EOS
35868                                           ! 5072 {
35869                                           ! 5073   if (drive > 1)
35870 A30C           55                         push	bp
35871 A30D           89E5                       mov	bp,sp
35872                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
35873 A30F           8A46         04            mov	al,4[bp]
35874 A312           3C                     01  cmp	al,*1
35875 A314           76           0D            jbe 	.733
35876                       0000A316            .734:
35877                                           ! 5074     bios_printf((2 |
35878                                           ! 5074  4 | 1), "set_diskette_current_cyl(): drive > 1\n");
35879                                           ! Debug: list * char = .735+0 (used reg = )
35880 A316           BB                   D115  mov	bx,#.735
35881 A319           53                         push	bx
35882                                           ! Debug: list int = const 7 (used reg = )
35883 A31A           B8                   0007  mov	ax,*7
35884 A31D           50                         push	ax
35885                                           ! Debug: func () void = bios_printf+0 (used reg = )
35886 A31E           E8         66F8            call	_bios_printf
35887 A321           89EC                       mov	sp,bp
35888                                           !BCC_EOS
35889                                           ! 5075   write_byte(0x0040, 0x0094+drive, cyl);
35890                       0000A323            .733:
35891                                           ! Debug: list unsigned char cyl = [S+2+4] (used reg = )
35892 A323           8A46         06            mov	al,6[bp]
35893 A326           30E4                       xor	ah,ah
35894 A328           50                         push	ax
35895                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
35896                                           ! Debug: expression subtree swapping
35897 A329           8A46         04            mov	al,4[bp]
35898 A32C           30E4                       xor	ah,ah
35899                                           ! Debug: list unsigned int = ax+$94 (used reg = )
35900 A32E           05                   0094  add	ax,#$94
35901 A331           50                         push	ax
35902                                           ! Debug: list int = const $40 (used reg = )
35903 A332           B8                   0040  mov	ax,*$40
35904 A335           50                         push	ax
35905                                           ! Debug: func () void = write_byte+0 (used reg = )
35906 A336           E8         62E1            call	_write_byte
35907 A339           89EC                       mov	sp,bp
35908                                           !BCC_EOS
35909                                           ! 5076 }
35910 A33B           5D                         pop	bp
35911 A33C           C3                         ret
35912                                           ! 5077   void
35913                                           ! Register BX used in function set_diskette_current_cyl
35914                                           ! 5078 determine_floppy_media(drive)
35915                                           ! 5079   Bit16u drive;
35916                                           export	_determine_floppy_media
35917                       0000A33D            _determine_floppy_media:
35918                                           !BCC_EOS
35919                                           ! 5080 {
35920                                           ! 5081 }
35921 A33D           C3                         ret
35922                                           ! 5082   void
35923                                           ! 5083 int17_function(regs, ds, iret_addr)
35924                                           ! 5084   pusha_regs_t regs;
35925                                           export	_int17_function
35926                       0000A33E            _int17_function:
35927                                           !BCC_EOS
35928                                           ! 5085   Bit16u ds;
35929                                           !BCC_EOS
35930                                           ! 5086   iret_addr_t iret_addr;
35931                                           !BCC_EOS
35932                                           ! 5087 {
35933                                           ! 5088   Bit16u addr,timeout;
35934                                           !BCC_EOS
35935                                           ! 5089   Bit8u val8;
35936                                           !BCC_EOS
35937                                           ! 5090 #asm
35938 A33E           55                         push	bp
35939 A33F           89E5                       mov	bp,sp
35940 A341           83C4                   FA  add	sp,*-6
35941                                           !BCC_EOS
35942                                           !BCC_ASM
35943                       0000001A            _int17_function.ds	set	$1A
35944                       00000014            .int17_function.ds	set	$14
35945                       00000002            _int17_function.timeout	set	2
35946                       FFFFFFFC            .int17_function.timeout	set	-4
35947                       00000001            _int17_function.val8	set	1
35948                       FFFFFFFB            .int17_function.val8	set	-5
35949                       0000001C            _int17_function.iret_addr	set	$1C
35950                       00000016            .int17_function.iret_addr	set	$16
35951                       00000004            _int17_function.addr	set	4
35952                       FFFFFFFE            .int17_function.addr	set	-2
35953                       0000000A            _int17_function.regs	set	$A
35954                       00000004            .int17_function.regs	set	4
35955 A344           FB                           sti
35956                                           ! 5092 endasm
35957                                           !BCC_ENDASM
35958                                           !BCC_EOS
35959                                           ! 5093   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
35960                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
35961 A345           8B46         0E            mov	ax,$E[bp]
35962 A348           D1E0                       shl	ax,*1
35963                                           ! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
35964                                           ! Debug: list unsigned int = ax+8 (used reg = )
35965 A34A           05                   0008  add	ax,*8
35966 A34D           50                         push	ax
35967                                           ! Debug: list int = const $40 (used reg = )
35968 A34E           B8                   0040  mov	ax,*$40
35969 A351           50                         push	ax
35970                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35971 A352           E8         62B2            call	_read_word
35972 A355           83C4                   04  add	sp,*4
35973                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
35974 A358           8946         FE            mov	-2[bp],ax
35975                                           !BCC_EOS
35976                                           ! 5094   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
35977                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
35978 A35B           8A46         13            mov	al,$13[bp]
35979 A35E           3C                     03  cmp	al,*3
35980 A360         0F83         0106            bhis	.736
35981                       0000A364            .739:
35982                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
35983 A364           8B46         0E            mov	ax,$E[bp]
35984 A367           3D                   0003  cmp	ax,*3
35985 A36A         0F83         00FC            bhis	.736
35986                       0000A36E            .738:
35987                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
35988 A36E           8B46         FE            mov	ax,-2[bp]
35989 A371           85C0                       test	ax,ax
35990 A373         0F84         00F3            beq 	.736
35991                       0000A377            .737:
35992                                           ! 5095     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
35993                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
35994                                           ! Debug: expression subtree swapping
35995 A377           8B46         0E            mov	ax,$E[bp]
35996                                           ! Debug: list unsigned int = ax+$78 (used reg = )
35997 A37A           05                   0078  add	ax,*$78
35998 A37D           50                         push	ax
35999                                           ! Debug: list int = const $40 (used reg = )
36000 A37E           B8                   0040  mov	ax,*$40
36001 A381           50                         push	ax
36002                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
36003 A382           E8         626F            call	_read_byte
36004 A385           83C4                   04  add	sp,*4
36005                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
36006 A388           30E4                       xor	ah,ah
36007 A38A           88C4                       mov	ah,al
36008 A38C           30C0                       xor	al,al
36009                                           ! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
36010 A38E           8946         FC            mov	-4[bp],ax
36011                                           !BCC_EOS
36012                                           ! 5096     if (regs.u.r8.ah == 0) {
36013                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
36014 A391           8A46         13            mov	al,$13[bp]
36015 A394           84C0                       test	al,al
36016 A396           75           66            jne 	.73A
36017                       0000A398            .73B:
36018                                           ! 5097       outb(addr, regs.u.r8.al);
36019                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
36020 A398           8A46         12            mov	al,$12[bp]
36021 A39B           30E4                       xor	ah,ah
36022 A39D           50                         push	ax
36023                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
36024 A39E           FF76         FE            push	-2[bp]
36025                                           ! Debug: func () void = outb+0 (used reg = )
36026 A3A1           E8         61B0            call	_outb
36027 A3A4           83C4                   04  add	sp,*4
36028                                           !BCC_EOS
36029                                           ! 5098       val8 = inb(addr+2);
36030                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
36031 A3A7           8B46         FE            mov	ax,-2[bp]
36032                                           ! Debug: list unsigned int = ax+2 (used reg = )
36033 A3AA           40                         inc	ax
36034 A3AB           40                         inc	ax
36035 A3AC           50                         push	ax
36036                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36037 A3AD           E8         618E            call	_inb
36038 A3B0           44                         inc	sp
36039 A3B1           44                         inc	sp
36040                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36041 A3B2           8846         FB            mov	-5[bp],al
36042                                           !BCC_EOS
36043                                           ! 5099       outb(addr+2, val8 | 0x01);
36044                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
36045 A3B5           8A46         FB            mov	al,-5[bp]
36046 A3B8           0C                     01  or	al,*1
36047                                           ! Debug: list unsigned char = al+0 (used reg = )
36048 A3BA           30E4                       xor	ah,ah
36049 A3BC           50                         push	ax
36050                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36051 A3BD           8B46         FE            mov	ax,-2[bp]
36052                                           ! Debug: list unsigned int = ax+2 (used reg = )
36053 A3C0           40                         inc	ax
36054 A3C1           40                         inc	ax
36055 A3C2           50                         push	ax
36056                                           ! Debug: func () void = outb+0 (used reg = )
36057 A3C3           E8         618E            call	_outb
36058 A3C6           83C4                   04  add	sp,*4
36059                                           !BCC_EOS
36060                                           ! 5100 #asm
36061                                           !BCC_EOS
36062                                           !BCC_ASM
36063                       0000001A            _int17_function.ds	set	$1A
36064                       00000014            .int17_function.ds	set	$14
36065                       00000002            _int17_function.timeout	set	2
36066                       FFFFFFFC            .int17_function.timeout	set	-4
36067                       00000001            _int17_function.val8	set	1
36068                       FFFFFFFB            .int17_function.val8	set	-5
36069                       0000001C            _int17_function.iret_addr	set	$1C
36070                       00000016            .int17_function.iret_addr	set	$16
36071                       00000004            _int17_function.addr	set	4
36072                       FFFFFFFE            .int17_function.addr	set	-2
36073                       0000000A            _int17_function.regs	set	$A
36074                       00000004            .int17_function.regs	set	4
36075 A3C9           90                               nop
36076                                           ! 5102 endasm
36077                                           !BCC_ENDASM
36078                                           !BCC_EOS
36079                                           ! 5103       outb(addr+2, val8 & ~0x01);
36080                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
36081 A3CA           8A46         FB            mov	al,-5[bp]
36082 A3CD           24                     FE  and	al,#$FE
36083                                           ! Debug: list unsigned char = al+0 (used reg = )
36084 A3CF           30E4                       xor	ah,ah
36085 A3D1           50                         push	ax
36086                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36087 A3D2           8B46         FE            mov	ax,-2[bp]
36088                                           ! Debug: list unsigned int = ax+2 (used reg = )
36089 A3D5           40                         inc	ax
36090 A3D6           40                         inc	ax
36091 A3D7           50                         push	ax
36092                                           ! Debug: func () void = outb+0 (used reg = )
36093 A3D8           E8         6179            call	_outb
36094 A3DB           83C4                   04  add	sp,*4
36095                                           !BCC_EOS
36096                                           ! 5104       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
36097 A3DE           EB           07            jmp .73D
36098                       0000A3E0            .73E:
36099                                           ! 5105         timeout--;
36100                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
36101 A3E0           8B46         FC            mov	ax,-4[bp]
36102 A3E3           48                         dec	ax
36103 A3E4           8946         FC            mov	-4[bp],ax
36104                                           !BCC_EOS
36105                                           ! 5106       }
36106                                           ! 5107     }
36107                       0000A3E7            .73D:
36108                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
36109 A3E7           8B46         FE            mov	ax,-2[bp]
36110                                           ! Debug: list unsigned int = ax+1 (used reg = )
36111 A3EA           40                         inc	ax
36112 A3EB           50                         push	ax
36113                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36114 A3EC           E8         614F            call	_inb
36115 A3EF           44                         inc	sp
36116 A3F0           44                         inc	sp
36117                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
36118 A3F1           24                     40  and	al,*$40
36119                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
36120 A3F3           3C                     40  cmp	al,*$40
36121 A3F5           75           07            jne 	.73F
36122                       0000A3F7            .740:
36123 A3F7           8B46         FC            mov	ax,-4[bp]
36124 A3FA           85C0                       test	ax,ax
36125 A3FC           75           E2            jne	.73E
36126                       0000A3FE            .73F:
36127                       0000A3FE            .73C:
36128                                           ! 5108     if (regs.u.r8.ah == 1) {
36129                       0000A3FE            .73A:
36130                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
36131 A3FE           8A46         13            mov	al,$13[bp]
36132 A401           3C                     01  cmp	al,*1
36133 A403           75           37            jne 	.741
36134                       0000A405            .742:
36135                                           ! 5109       val8 = inb(addr+2);
36136                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
36137 A405           8B46         FE            mov	ax,-2[bp]
36138                                           ! Debug: list unsigned int = ax+2 (used reg = )
36139 A408           40                         inc	ax
36140 A409           40                         inc	ax
36141 A40A           50                         push	ax
36142                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36143 A40B           E8         6130            call	_inb
36144 A40E           44                         inc	sp
36145 A40F           44                         inc	sp
36146                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36147 A410           8846         FB            mov	-5[bp],al
36148                                           !BCC_EOS
36149                                           ! 5110       outb(addr+2, val8 & ~0x04);
36150                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
36151 A413           8A46         FB            mov	al,-5[bp]
36152 A416           24                     FB  and	al,#$FB
36153                                           ! Debug: list unsigned char = al+0 (used reg = )
36154 A418           30E4                       xor	ah,ah
36155 A41A           50                         push	ax
36156                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36157 A41B           8B46         FE            mov	ax,-2[bp]
36158                                           ! Debug: list unsigned int = ax+2 (used reg = )
36159 A41E           40                         inc	ax
36160 A41F           40                         inc	ax
36161 A420           50                         push	ax
36162                                           ! Debug: func () void = outb+0 (used reg = )
36163 A421           E8         6130            call	_outb
36164 A424           83C4                   04  add	sp,*4
36165                                           !BCC_EOS
36166                                           ! 5111 #asm
36167                                           !BCC_EOS
36168                                           !BCC_ASM
36169                       0000001A            _int17_function.ds	set	$1A
36170                       00000014            .int17_function.ds	set	$14
36171                       00000002            _int17_function.timeout	set	2
36172                       FFFFFFFC            .int17_function.timeout	set	-4
36173                       00000001            _int17_function.val8	set	1
36174                       FFFFFFFB            .int17_function.val8	set	-5
36175                       0000001C            _int17_function.iret_addr	set	$1C
36176                       00000016            .int17_function.iret_addr	set	$16
36177                       00000004            _int17_function.addr	set	4
36178                       FFFFFFFE            .int17_function.addr	set	-2
36179                       0000000A            _int17_function.regs	set	$A
36180                       00000004            .int17_function.regs	set	4
36181 A427           90                               nop
36182                                           ! 5113 endasm
36183                                           !BCC_ENDASM
36184                                           !BCC_EOS
36185                                           ! 5114       outb(addr+2, val8 | 0x04);
36186                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
36187 A428           8A46         FB            mov	al,-5[bp]
36188 A42B           0C                     04  or	al,*4
36189                                           ! Debug: list unsigned char = al+0 (used reg = )
36190 A42D           30E4                       xor	ah,ah
36191 A42F           50                         push	ax
36192                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
36193 A430           8B46         FE            mov	ax,-2[bp]
36194                                           ! Debug: list unsigned int = ax+2 (used reg = )
36195 A433           40                         inc	ax
36196 A434           40                         inc	ax
36197 A435           50                         push	ax
36198                                           ! Debug: func () void = outb+0 (used reg = )
36199 A436           E8         611B            call	_outb
36200 A439           83C4                   04  add	sp,*4
36201                                           !BCC_EOS
36202                                           ! 5115     }
36203                                           ! 5116     val8 = inb(addr+1);
36204                       0000A43C            .741:
36205                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
36206 A43C           8B46         FE            mov	ax,-2[bp]
36207                                           ! Debug: list unsigned int = ax+1 (used reg = )
36208 A43F           40                         inc	ax
36209 A440           50                         push	ax
36210                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36211 A441           E8         60FA            call	_inb
36212 A444           44                         inc	sp
36213 A445           44                         inc	sp
36214                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
36215 A446           8846         FB            mov	-5[bp],al
36216                                           !BCC_EOS
36217                                           ! 5117     regs.u.r8.ah = (val8 ^ 0x48);
36218                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
36219 A449           8A46         FB            mov	al,-5[bp]
36220 A44C           34                     48  xor	al,*$48
36221                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
36222 A44E           8846         13            mov	$13[bp],al
36223                                           !BCC_EOS
36224                                           ! 5118     if (!timeout) regs.u.r8.ah |= 0x01;
36225 A451           8B46         FC            mov	ax,-4[bp]
36226 A454           85C0                       test	ax,ax
36227 A456           75           08            jne 	.743
36228                       0000A458            .744:
36229                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
36230 A458           8A46         13            mov	al,$13[bp]
36231 A45B           0C                     01  or	al,*1
36232 A45D           8846         13            mov	$13[bp],al
36233                                           !BCC_EOS
36234                                           ! 5119     iret_addr.flags.u.r8.flagsl &= 0xfe;
36235                       0000A460            .743:
36236                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
36237 A460           8A46         1A            mov	al,$1A[bp]
36238 A463           24                     FE  and	al,#$FE
36239 A465           8846         1A            mov	$1A[bp],al
36240                                           !BCC_EOS
36241                                           ! 5120   } else {
36242 A468           EB           08            jmp .745
36243                       0000A46A            .736:
36244                                           ! 5121     iret_addr.flags.u.r8.flagsl |= 0x01;
36245                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
36246 A46A           8A46         1A            mov	al,$1A[bp]
36247 A46D           0C                     01  or	al,*1
36248 A46F           8846         1A            mov	$1A[bp],al
36249                                           !BCC_EOS
36250                                           ! 5122   }
36251                                           ! 5123 }
36252                       0000A472            .745:
36253 A472           89EC                       mov	sp,bp
36254 A474           5D                         pop	bp
36255 A475           C3                         ret
36256                                           ! 5124 void
36257                                           ! 5125 int18_function(seq_nr)
36258                                           ! 5126 Bit16u seq_nr;
36259                                           export	_int18_function
36260                       0000A476            _int18_function:
36261                                           !BCC_EOS
36262                                           ! 5127 {
36263                                           ! 5128   Bit16u ebda_seg=read_word(0x0040,0x000E);
36264 A476           55                         push	bp
36265 A477           89E5                       mov	bp,sp
36266 A479           4C                         dec	sp
36267 A47A           4C                         dec	sp
36268                                           ! Debug: list int = const $E (used reg = )
36269 A47B           B8                   000E  mov	ax,*$E
36270 A47E           50                         push	ax
36271                                           ! Debug: list int = const $40 (used reg = )
36272 A47F           B8                   0040  mov	ax,*$40
36273 A482           50                         push	ax
36274                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36275 A483           E8         6181            call	_read_word
36276 A486           83C4                   04  add	sp,*4
36277                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
36278 A489           8946         FE            mov	-2[bp],ax
36279                                           !BCC_EOS
36280                                           ! 5129   Bit16u bootdev;
36281                                           !BCC_EOS
36282                                           ! 5130   Bit8u bootdrv;
36283                                           !BCC_EOS
36284                                           ! 5131   Bit8u bootchk;
36285                                           !BCC_EOS
36286                                           ! 5132   Bit16u bootseg;
36287                                           !BCC_EOS
36288                                           ! 5133   Bit16u bootip;
36289                                           !BCC_EOS
36290                                           ! 5134   Bit16u status;
36291                                           !BCC_EOS
36292                                           ! 5135   Bit16u bootfirst;
36293                                           !BCC_EOS
36294                                           ! 5136   ipl_entry_t e;
36295                                           !BCC_EOS
36296                                           ! 5137   bootdev = inb_cmos(0x3d);
36297 A48C           83C4                   E4  add	sp,*-$1C
36298                                           ! Debug: list int = const $3D (used reg = )
36299 A48F           B8                   003D  mov	ax,*$3D
36300 A492           50                         push	ax
36301                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36302 A493           E8         60ED            call	_inb_cmos
36303 A496           44                         inc	sp
36304 A497           44                         inc	sp
36305                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36306 A498           30E4                       xor	ah,ah
36307 A49A           8946         FC            mov	-4[bp],ax
36308                                           !BCC_EOS
36309                                           ! 5138   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
36310                                           ! Debug: list int = const $38 (used reg = )
36311 A49D           B8                   0038  mov	ax,*$38
36312 A4A0           50                         push	ax
36313                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36314 A4A1           E8         60DF            call	_inb_cmos
36315 A4A4           44                         inc	sp
36316 A4A5           44                         inc	sp
36317                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
36318 A4A6           24                     F0  and	al,#$F0
36319                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
36320 A4A8           30E4                       xor	ah,ah
36321 A4AA           B1                     04  mov	cl,*4
36322 A4AC           D3E0                       shl	ax,cl
36323                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36324 A4AE           0B46         FC            or	ax,-4[bp]
36325 A4B1           8946         FC            mov	-4[bp],ax
36326                                           !BCC_EOS
36327                                           ! 5139   bootdev >>= 4 * seq_nr;
36328                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
36329                                           ! Debug: expression subtree swapping
36330 A4B4           8B46         04            mov	ax,4[bp]
36331 A4B7           D1E0                       shl	ax,*1
36332 A4B9           D1E0                       shl	ax,*1
36333                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
36334 A4BB           89C3                       mov	bx,ax
36335 A4BD           8B46         FC            mov	ax,-4[bp]
36336 A4C0           89D9                       mov	cx,bx
36337 A4C2           D3E8                       shr	ax,cl
36338 A4C4           8946         FC            mov	-4[bp],ax
36339                                           !BCC_EOS
36340                                           ! 5140   bootdev &= 0xf;
36341                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
36342 A4C7           8A46         FC            mov	al,-4[bp]
36343 A4CA           24                     0F  and	al,*$F
36344 A4CC           30E4                       xor	ah,ah
36345 A4CE           8946         FC            mov	-4[bp],ax
36346                                           !BCC_EOS
36347                                           ! 5141   bootfirst = read_word(ebda_seg, 0x0384);
36348                                           ! Debug: list int = const $384 (used reg = )
36349 A4D1           B8                   0384  mov	ax,#$384
36350 A4D4           50                         push	ax
36351                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
36352 A4D5           FF76         FE            push	-2[bp]
36353                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36354 A4D8           E8         612C            call	_read_word
36355 A4DB           83C4                   04  add	sp,*4
36356                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
36357 A4DE           8946         F2            mov	-$E[bp],ax
36358                                           !BCC_EOS
36359                                           ! 5142   if (bootfirst != 0xFFFF) {
36360                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
36361 A4E1           8B46         F2            mov	ax,-$E[bp]
36362 A4E4           3D                   FFFF  cmp	ax,#$FFFF
36363 A4E7           74           2A            je  	.746
36364                       0000A4E9            .747:
36365                                           ! 5143     bootdev = bootfirst;
36366                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
36367 A4E9           8B46         F2            mov	ax,-$E[bp]
36368 A4EC           8946         FC            mov	-4[bp],ax
36369                                           !BCC_EOS
36370                                           ! 5144     write_word(ebda_seg, 0x0384, 0xFFFF);
36371                                           ! Debug: list unsigned int = const $FFFF (used reg = )
36372 A4EF           B8                   FFFF  mov	ax,#$FFFF
36373 A4F2           50                         push	ax
36374                                           ! Debug: list int = const $384 (used reg = )
36375 A4F3           B8                   0384  mov	ax,#$384
36376 A4F6           50                         push	ax
36377                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
36378 A4F7           FF76         FE            push	-2[bp]
36379                                           ! Debug: func () void = write_word+0 (used reg = )
36380 A4FA           E8         6135            call	_write_word
36381 A4FD           83C4                   06  add	sp,*6
36382                                           !BCC_EOS
36383                                           ! 5145     write_word(ebda_seg, 0x0382, 0xFFFF);
36384                                           ! Debug: list unsigned int = const $FFFF (used reg = )
36385 A500           B8                   FFFF  mov	ax,#$FFFF
36386 A503           50                         push	ax
36387                                           ! Debug: list int = const $382 (used reg = )
36388 A504           B8                   0382  mov	ax,#$382
36389 A507           50                         push	ax
36390                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
36391 A508           FF76         FE            push	-2[bp]
36392                                           ! Debug: func () void = write_word+0 (used reg = )
36393 A50B           E8         6124            call	_write_word
36394 A50E           83C4                   06  add	sp,*6
36395                                           !BCC_EOS
36396                                           ! 5146   } else if (bootdev == 0) {
36397 A511           EB           3C            jmp .748
36398                       0000A513            .746:
36399                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
36400 A513           8B46         FC            mov	ax,-4[bp]
36401 A516           85C0                       test	ax,ax
36402 A518           75           35            jne 	.749
36403                       0000A51A            .74A:
36404                                           ! 5147     bios_printf(2, "\nNo bootable device.\n");
36405                                           ! Debug: list * char = .74B+0 (used reg = )
36406 A51A           BB                   D0FF  mov	bx,#.74B
36407 A51D           53                         push	bx
36408                                           ! Debug: list int = const 2 (used reg = )
36409 A51E           B8                   0002  mov	ax,*2
36410 A521           50                         push	ax
36411                                           ! Debug: func () void = bios_printf+0 (used reg = )
36412 A522           E8         64F4            call	_bios_printf
36413 A525           83C4                   04  add	sp,*4
36414                                           !BCC_EOS
36415                                           ! 5148     bios_printf(2, "Powering off in 30 seconds.\n");
36416                                           ! Debug: list * char = .74C+0 (used reg = )
36417 A528           BB                   D0E2  mov	bx,#.74C
36418 A52B           53                         push	bx
36419                                           ! Debug: list int = const 2 (used reg = )
36420 A52C           B8                   0002  mov	ax,*2
36421 A52F           50                         push	ax
36422                                           ! Debug: func () void = bios_printf+0 (used reg = )
36423 A530           E8         64E6            call	_bios_printf
36424 A533           83C4                   04  add	sp,*4
36425                                           !BCC_EOS
36426                                           ! 5149 #asm
36427                                           !BCC_EOS
36428                                           !BCC_ASM
36429                       00000014            _int18_function.bootip	set	$14
36430                       FFFFFFF6            .int18_function.bootip	set	-$A
36431                       00000022            _int18_function.seq_nr	set	$22
36432                       00000004            .int18_function.seq_nr	set	4
36433                       00000018            _int18_function.bootchk	set	$18
36434                       FFFFFFFA            .int18_function.bootchk	set	-6
36435                       00000016            _int18_function.bootseg	set	$16
36436                       FFFFFFF8            .int18_function.bootseg	set	-8
36437                       0000001C            _int18_function.ebda_seg	set	$1C
36438                       FFFFFFFE            .int18_function.ebda_seg	set	-2
36439                       00000012            _int18_function.status	set	$12
36440                       FFFFFFF4            .int18_function.status	set	-$C
36441                       00000010            _int18_function.bootfirst	set	$10
36442                       FFFFFFF2            .int18_function.bootfirst	set	-$E
36443                       00000019            _int18_function.bootdrv	set	$19
36444                       FFFFFFFB            .int18_function.bootdrv	set	-5
36445                       0000001A            _int18_function.bootdev	set	$1A
36446                       FFFFFFFC            .int18_function.bootdev	set	-4
36447                       00000000            _int18_function.e	set	0
36448                       FFFFFFE2            .int18_function.e	set	-$1E
36449 A536           FB                             sti
36450 A537           B9                   01C9      mov cx, #0x01c9
36451 A53A           BA                   C380      mov dx, #0xc380
36452 A53D           B4                     86      mov ah, #0x86 ;; INT 15/86: wait CX:DX usec.
36453 A53F           CD                     15      int #0x15
36454                                           ! 5155 endasm
36455                                           !BCC_ENDASM
36456                                           !BCC_EOS
36457                                           ! 5156     bios_printf(1, "");
36458                                           ! Debug: list * char = .74D+0 (used reg = )
36459 A541           BB                   D0E1  mov	bx,#.74D
36460 A544           53                         push	bx
36461                                           ! Debug: list int = const 1 (used reg = )
36462 A545           B8                   0001  mov	ax,*1
36463 A548           50                         push	ax
36464                                           ! Debug: func () void = bios_printf+0 (used reg = )
36465 A549           E8         64CD            call	_bios_printf
36466 A54C           83C4                   04  add	sp,*4
36467                                           !BCC_EOS
36468                                           ! 5157   }
36469                                           ! 5158   bootdev -= 1;
36470                       0000A54F            .749:
36471                       0000A54F            .748:
36472                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
36473 A54F           8B46         FC            mov	ax,-4[bp]
36474 A552           48                         dec	ax
36475 A553           8946         FC            mov	-4[bp],ax
36476                                           !BCC_EOS
36477                                           ! 5159   if (get_boot_vector(bootdev, &e) == 0) {
36478                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
36479 A556           8D5E         E2            lea	bx,-$1E[bp]
36480 A559           53                         push	bx
36481                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
36482 A55A           FF76         FC            push	-4[bp]
36483                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
36484 A55D           E8         6FA1            call	_get_boot_vector
36485 A560           83C4                   04  add	sp,*4
36486                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
36487 A563           84C0                       test	al,al
36488 A565           75           15            jne 	.74E
36489                       0000A567            .74F:
36490                                           ! 5160     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
36491                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
36492 A567           FF76         FC            push	-4[bp]
36493                                           ! Debug: list * char = .750+0 (used reg = )
36494 A56A           BB                   D0C5  mov	bx,#.750
36495 A56D           53                         push	bx
36496                                           ! Debug: list int = const 4 (used reg = )
36497 A56E           B8                   0004  mov	ax,*4
36498 A571           50                         push	ax
36499                                           ! Debug: func () void = bios_printf+0 (used reg = )
36500 A572           E8         64A4            call	_bios_printf
36501 A575           83C4                   06  add	sp,*6
36502                                           !BCC_EOS
36503                                           ! 5161     ret
36504                                           ! 5161 urn;
36505 A578           89EC                       mov	sp,bp
36506 A57A           5D                         pop	bp
36507 A57B           C3                         ret
36508                                           !BCC_EOS
36509                                           ! 5162   }
36510                                           ! 5163   print_boot_device(e.type, e.description);
36511                       0000A57C            .74E:
36512                                           ! Debug: list unsigned long e = [S+$20-$18] (used reg = )
36513 A57C           FF76         EC            push	-$14[bp]
36514 A57F           FF76         EA            push	-$16[bp]
36515                                           ! Debug: list unsigned short e = [S+$24-$20] (used reg = )
36516 A582           FF76         E2            push	-$1E[bp]
36517                                           ! Debug: func () void = print_boot_device+0 (used reg = )
36518 A585           E8         71D2            call	_print_boot_device
36519 A588           83C4                   06  add	sp,*6
36520                                           !BCC_EOS
36521                                           ! 5164   switch(e.type) {
36522 A58B           8B46         E2            mov	ax,-$1E[bp]
36523 A58E           E9         012A            br 	.753
36524                                           ! 5165   case 0x01:
36525                                           ! 5166   case 0x02:
36526                       0000A591            .754:
36527                                           ! 5167     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
36528                       0000A591            .755:
36529                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
36530 A591           8B46         E2            mov	ax,-$1E[bp]
36531 A594           3D                   0002  cmp	ax,*2
36532 A597           75           04            jne 	.756
36533                       0000A599            .757:
36534 A599           B0                     80  mov	al,#$80
36535 A59B           EB           02            jmp .758
36536                       0000A59D            .756:
36537 A59D           30C0                       xor	al,al
36538                       0000A59F            .758:
36539                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36540 A59F           8846         FB            mov	-5[bp],al
36541                                           !BCC_EOS
36542                                           ! 5168     bootseg = 0x07c0;
36543                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36544 A5A2           B8                   07C0  mov	ax,#$7C0
36545 A5A5           8946         F8            mov	-8[bp],ax
36546                                           !BCC_EOS
36547                                           ! 5169     status = 0;
36548                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
36549 A5A8           31C0                       xor	ax,ax
36550 A5AA           8946         F4            mov	-$C[bp],ax
36551                                           !BCC_EOS
36552                                           ! 5170 #asm
36553                                           !BCC_EOS
36554                                           !BCC_ASM
36555                       00000014            _int18_function.bootip	set	$14
36556                       FFFFFFF6            .int18_function.bootip	set	-$A
36557                       00000022            _int18_function.seq_nr	set	$22
36558                       00000004            .int18_function.seq_nr	set	4
36559                       00000018            _int18_function.bootchk	set	$18
36560                       FFFFFFFA            .int18_function.bootchk	set	-6
36561                       00000016            _int18_function.bootseg	set	$16
36562                       FFFFFFF8            .int18_function.bootseg	set	-8
36563                       0000001C            _int18_function.ebda_seg	set	$1C
36564                       FFFFFFFE            .int18_function.ebda_seg	set	-2
36565                       00000012            _int18_function.status	set	$12
36566                       FFFFFFF4            .int18_function.status	set	-$C
36567                       00000010            _int18_function.bootfirst	set	$10
36568                       FFFFFFF2            .int18_function.bootfirst	set	-$E
36569                       00000019            _int18_function.bootdrv	set	$19
36570                       FFFFFFFB            .int18_function.bootdrv	set	-5
36571                       0000001A            _int18_function.bootdev	set	$1A
36572                       FFFFFFFC            .int18_function.bootdev	set	-4
36573                       00000000            _int18_function.e	set	0
36574                       FFFFFFE2            .int18_function.e	set	-$1E
36575 A5AD           55                             push bp
36576 A5AE           89E5                           mov bp, sp
36577 A5B0           50                             push ax
36578 A5B1           53                             push bx
36579 A5B2           51                             push cx
36580 A5B3           52                             push dx
36581 A5B4           8A56         1B                mov dl, _int18_function.bootdrv + 2[bp]
36582 A5B7           8B46         18                mov ax, _int18_function.bootseg + 2[bp]
36583 A5BA           8EC0                           mov es, ax ;; segment
36584 A5BC           31DB                           xor bx, bx ;; offset
36585 A5BE           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
36586 A5C0           B0                     01      mov al, #0x01 ;; read 1 sector
36587 A5C2           B5                     00      mov ch, #0x00 ;; track 0
36588 A5C4           B1                     01      mov cl, #0x01 ;; sector 1
36589 A5C6           B6                     00      mov dh, #0x00 ;; head 0
36590 A5C8           CD                     13      int #0x13 ;; read sector
36591 A5CA           73           06                jnc int19_load_done
36592 A5CC           B8                   0001      mov ax, #0x0001
36593 A5CF           8946         14                mov _int18_function.status + 2[bp], ax
36594                       0000A5D2            int19_load_done:
36595 A5D2           5A                             pop dx
36596 A5D3           59                             pop cx
36597 A5D4           5B                             pop bx
36598 A5D5           58                             pop ax
36599 A5D6           5D                             pop bp
36600                                           ! 5196 endasm
36601                                           !BCC_ENDASM
36602                                           !BCC_EOS
36603                                           ! 5197     if (status != 0) {
36604                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
36605 A5D7           8B46         F4            mov	ax,-$C[bp]
36606 A5DA           85C0                       test	ax,ax
36607 A5DC           74           11            je  	.759
36608                       0000A5DE            .75A:
36609                                           ! 5198       print_boot_failure(e.type, 1);
36610                                           ! Debug: list int = const 1 (used reg = )
36611 A5DE           B8                   0001  mov	ax,*1
36612 A5E1           50                         push	ax
36613                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36614 A5E2           FF76         E2            push	-$1E[bp]
36615                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36616 A5E5           E8         723B            call	_print_boot_failure
36617 A5E8           83C4                   04  add	sp,*4
36618                                           !BCC_EOS
36619                                           ! 5199       return;
36620 A5EB           89EC                       mov	sp,bp
36621 A5ED           5D                         pop	bp
36622 A5EE           C3                         ret
36623                                           !BCC_EOS
36624                                           ! 5200     }
36625                                           ! 5201     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
36626                       0000A5EF            .759:
36627                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
36628 A5EF           8B46         E2            mov	ax,-$1E[bp]
36629 A5F2           3D                   0001  cmp	ax,*1
36630 A5F5           75           0F            jne 	.75C
36631                       0000A5F7            .75D:
36632                                           ! Debug: list int = const $38 (used reg = )
36633 A5F7           B8                   0038  mov	ax,*$38
36634 A5FA           50                         push	ax
36635                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36636 A5FB           E8         5F85            call	_inb_cmos
36637 A5FE           44                         inc	sp
36638 A5FF           44                         inc	sp
36639                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
36640 A600           24                     01  and	al,*1
36641 A602           84C0                       test	al,al
36642 A604           75           22            jne 	.75B
36643                       0000A606            .75C:
36644                                           ! 5202       if (read_word(bootseg,0x1fe) != 0xaa55) {
36645                                           ! Debug: list int = const $1FE (used reg = )
36646 A606           B8                   01FE  mov	ax,#$1FE
36647 A609           50                         push	ax
36648                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
36649 A60A           FF76         F8            push	-8[bp]
36650                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36651 A60D           E8         5FF7            call	_read_word
36652 A610           83C4                   04  add	sp,*4
36653                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
36654 A613           3D                   AA55  cmp	ax,#$AA55
36655 A616           74           10            je  	.75E
36656                       0000A618            .75F:
36657                                           ! 5203         print_boot_failure(e.type, 0);
36658                                           ! Debug: list int = const 0 (used reg = )
36659 A618           31C0                       xor	ax,ax
36660 A61A           50                         push	ax
36661                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36662 A61B           FF76         E2            push	-$1E[bp]
36663                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36664 A61E           E8         7202            call	_print_boot_failure
36665 A621           83C4                   04  add	sp,*4
36666                                           !BCC_EOS
36667                                           ! 5204         return;
36668 A624           89EC                       mov	sp,bp
36669 A626           5D                         pop	bp
36670 A627           C3                         ret
36671                                           !BCC_EOS
36672                                           ! 5205       }
36673                                           ! 5206     }
36674                       0000A628            .75E:
36675                                           ! 5207     bootip = (bootseg & 0x0fff) << 4;
36676                       0000A628            .75B:
36677                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
36678 A628           8B46         F8            mov	ax,-8[bp]
36679 A62B           25                   0FFF  and	ax,#$FFF
36680                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
36681 A62E           B1                     04  mov	cl,*4
36682 A630           D3E0                       shl	ax,cl
36683                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36684 A632           8946         F6            mov	-$A[bp],ax
36685                                           !BCC_EOS
36686                                           ! 5208     bootseg &= 0xf000;
36687                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
36688 A635           8B46         F8            mov	ax,-8[bp]
36689 A638           25                   F000  and	ax,#$F000
36690 A63B           8946         F8            mov	-8[bp],ax
36691                                           !BCC_EOS
36692                                           ! 5209   break;
36693 A63E           E9         0096            br 	.751
36694                                           !BCC_EOS
36695                                           ! 5210   case 0x03:
36696                                           ! 5211     status = cdrom_boot();
36697                       0000A641            .760:
36698                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
36699 A641           E8         99E9            call	_cdrom_boot
36700                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
36701 A644           8946         F4            mov	-$C[bp],ax
36702                                           !BCC_EOS
36703                                           ! 5212     if ( (status & 0x00ff) !=0 ) {
36704                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
36705 A647           8A46         F4            mov	al,-$C[bp]
36706                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
36707 A64A           84C0                       test	al,al
36708 A64C           74           19            je  	.761
36709                       0000A64E            .762:
36710                                           ! 5213       print_cdromboot_failure(status);
36711                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
36712 A64E           FF76         F4            push	-$C[bp]
36713                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
36714 A651           E8         7247            call	_print_cdromboot_failure
36715 A654           44                         inc	sp
36716 A655           44                         inc	sp
36717                                           !BCC_EOS
36718                                           ! 5214       print_boot_failure(e.type, 1);
36719                                           ! Debug: list int = const 1 (used reg = )
36720 A656           B8                   0001  mov	ax,*1
36721 A659           50                         push	ax
36722                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36723 A65A           FF76         E2            push	-$1E[bp]
36724                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36725 A65D           E8         71C3            call	_print_boot_failure
36726 A660           83C4                   04  add	sp,*4
36727                                           !BCC_EOS
36728                                           ! 5215       return;
36729 A663           89EC                       mov	sp,bp
36730 A665           5D                         pop	bp
36731 A666           C3                         ret
36732                                           !BCC_EOS
36733                                           ! 5216     }
36734                                           ! 5217     bootdrv = (Bit8u)(status>>8);
36735                       0000A667            .761:
36736                                           ! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
36737 A667           8B46         F4            mov	ax,-$C[bp]
36738 A66A           88E0                       mov	al,ah
36739 A66C           30E4                       xor	ah,ah
36740                                           ! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
36741                                           ! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36742 A66E           8846         FB            mov	-5[bp],al
36743                                           !BCC_EOS
36744                                           ! 5218     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
36745                                           ! Debug: list * unsigned short = const $266 (used reg = )
36746 A671           B8                   0266  mov	ax,#$266
36747 A674           50                         push	ax
36748                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
36749 A675           FF76         FE            push	-2[bp]
36750                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36751 A678           E8         5F8C            call	_read_word
36752 A67B           83C4                   04  add	sp,*4
36753                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36754 A67E           8946         F8            mov	-8[bp],ax
36755                                           !BCC_EOS
36756                                           ! 5219     bootip = (bootseg & 0x0fff) << 4;
36757                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
36758 A681           8B46         F8            mov	ax,-8[bp]
36759 A684           25                   0FFF  and	ax,#$FFF
36760                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
36761 A687           B1                     04  mov	cl,*4
36762 A689           D3E0                       shl	ax,cl
36763                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36764 A68B           8946         F6            mov	-$A[bp],ax
36765                                           !BCC_EOS
36766                                           ! 5220     bootseg &= 0xf000;
36767                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
36768 A68E           8B46         F8            mov	ax,-8[bp]
36769 A691           25                   F000  and	ax,#$F000
36770 A694           8946         F8            mov	-8[bp],ax
36771                                           !BCC_EOS
36772                                           ! 5221     break;
36773 A697           EB           3E            jmp .751
36774                                           !BCC_EOS
36775                                           ! 5222   case 0x80:
36776                                           ! 5223     bootseg = e.vector >> 16;
36777                       0000A699            .763:
36778                                           ! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
36779 A699           8B46         E6            mov	ax,-$1A[bp]
36780 A69C           8B5E         E8            mov	bx,-$18[bp]
36781 A69F           93                         xchg	bx,ax
36782 A6A0           31DB                       xor	bx,bx
36783                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36784 A6A2           8946         F8            mov	-8[bp],ax
36785                                           !BCC_EOS
36786                                           ! 5224     bootip = e.vector & 0xffff;
36787                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
36788                                           ! Debug: expression subtree swapping
36789 A6A5           B8                   FFFF  mov	ax,#$FFFF
36790 A6A8           31DB                       xor	bx,bx
36791 A6AA           8D7E         E6            lea	di,-$1A[bp]
36792 A6AD           E8         5A0B            call	landul
36793                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36794 A6B0           8946         F6            mov	-$A[bp],ax
36795                                           !BCC_EOS
36796                                           ! 5225     break;
36797 A6B3           EB           22            jmp .751
36798                                           !BCC_EOS
36799                                           ! 5226   default: return;
36800                       0000A6B5            .764:
36801 A6B5           89EC                       mov	sp,bp
36802 A6B7           5D                         pop	bp
36803 A6B8           C3                         ret
36804                                           !BCC_EOS
36805                                           ! 5227   }
36806                                           ! 5228   bios_printf(4, "Booting from %x:%x\n", bootseg, bootip);
36807 A6B9           EB           1C            jmp .751
36808                       0000A6BB            .753:
36809 A6BB           2D                   0001  sub	ax,*1
36810 A6BE         0F84         FECF            beq 	.754
36811 A6C2           2D                   0001  sub	ax,*1
36812 A6C5         0F84         FEC8            beq 	.755
36813 A6C9           2D                   0001  sub	ax,*1
36814 A6CC         0F84         FF71            beq 	.760
36815 A6D0           2D                   007D  sub	ax,*$7D
36816 A6D3           74           C4            je 	.763
36817 A6D5           EB           DE            jmp	.764
36818                       0000A6D7            .751:
36819                       FFFFFFE0            ..FFDB	=	-$20
36820                                           ! Debug: list unsigned short bootip = [S+$20-$C] (used reg = )
36821 A6D7           FF76         F6            push	-$A[bp]
36822                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
36823 A6DA           FF76         F8            push	-8[bp]
36824                                           ! Debug: list * char = .765+0 (used reg = )
36825 A6DD           BB                   D0B1  mov	bx,#.765
36826 A6E0           53                         push	bx
36827                                           ! Debug: list int = const 4 (used reg = )
36828 A6E1           B8                   0004  mov	ax,*4
36829 A6E4           50                         push	ax
36830                                           ! Debug: func () void = bios_printf+0 (used reg = )
36831 A6E5           E8         6331            call	_bios_printf
36832 A6E8           83C4                   08  add	sp,*8
36833                                           !BCC_EOS
36834                                           ! 5229 #asm
36835                                           !BCC_EOS
36836                                           !BCC_ASM
36837                       00000014            _int18_function.bootip	set	$14
36838                       FFFFFFF6            .int18_function.bootip	set	-$A
36839                       00000022            _int18_function.seq_nr	set	$22
36840                       00000004            .int18_function.seq_nr	set	4
36841                       00000018            _int18_function.bootchk	set	$18
36842                       FFFFFFFA            .int18_function.bootchk	set	-6
36843                       00000016            _int18_function.bootseg	set	$16
36844                       FFFFFFF8            .int18_function.bootseg	set	-8
36845                       0000001C            _int18_function.ebda_seg	set	$1C
36846                       FFFFFFFE            .int18_function.ebda_seg	set	-2
36847                       00000012            _int18_function.status	set	$12
36848                       FFFFFFF4            .int18_function.status	set	-$C
36849                       00000010            _int18_function.bootfirst	set	$10
36850                       FFFFFFF2            .int18_function.bootfirst	set	-$E
36851                       00000019            _int18_function.bootdrv	set	$19
36852                       FFFFFFFB            .int18_function.bootdrv	set	-5
36853                       0000001A            _int18_function.bootdev	set	$1A
36854                       FFFFFFFC            .int18_function.bootdev	set	-4
36855                       00000000            _int18_function.e	set	0
36856                       FFFFFFE2            .int18_function.e	set	-$1E
36857 A6EB           89E5                           mov bp, sp
36858 A6ED           0E                             push cs
36859 A6EE           68                   ACA7      push #int18_handler
36860                                               ;; Build an iret stack frame that will take us to the boot vector.
36861                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
36862 A6F1           9C                             pushf
36863 A6F2           8B46         16                mov ax, _int18_function.bootseg + 0[bp]
36864 A6F5           50                             push ax
36865 A6F6           8B46         14                mov ax, _int18_function.bootip + 0[bp]
36866 A6F9           50                             push ax
36867                                               ;; Set the magic number in ax and the boot drive in dl.
36868 A6FA           B8                   AA55      mov ax, #0xaa55
36869 A6FD           8A56         19                mov dl, _int18_function.bootdrv + 0[bp]
36870                                               ;; Zero some of the other registers.
36871 A700           31DB                           xor bx, bx
36872 A702           8EDB                           mov ds, bx
36873 A704           8EC3                           mov es, bx
36874 A706           89DD                           mov bp, bx
36875                                               ;; Go!
36876 A708           CF                             iret
36877                                           ! 5250 endasm
36878                                           !BCC_ENDASM
36879                                           !BCC_EOS
36880                                           ! 5251 }
36881 A709           89EC                       mov	sp,bp
36882 A70B           5D                         pop	bp
36883 A70C           C3                         ret
36884                                           ! 5252   void
36885                                           ! Register BX used in function int18_function
36886                                           ! 5253 int1a_function(regs, ds, iret_addr)
36887                                           ! 5254   pusha_regs_t regs;
36888                                           export	_int1a_function
36889                       0000A70D            _int1a_function:
36890                                           !BCC_EOS
36891                                           ! 5255   Bit16u ds;
36892                                           !BCC_EOS
36893                                           ! 5256   iret_addr_t iret_addr;
36894                                           !BCC_EOS
36895                                           ! 5257 {
36896                                           ! 5258   Bit8u val8;
36897                                           !BCC_EOS
36898                                           ! 5259   ;
36899 A70D           55                         push	bp
36900 A70E           89E5                       mov	bp,sp
36901 A710           4C                         dec	sp
36902 A711           4C                         dec	sp
36903                                           !BCC_EOS
36904                                           ! 5260 #asm
36905                                           !BCC_EOS
36906                                           !BCC_ASM
36907                       00000016            _int1a_function.ds	set	$16
36908                       00000014            .int1a_function.ds	set	$14
36909                       00000001            _int1a_function.val8	set	1
36910                       FFFFFFFF            .int1a_function.val8	set	-1
36911                       00000018            _int1a_function.iret_addr	set	$18
36912                       00000016            .int1a_function.iret_addr	set	$16
36913                       00000006            _int1a_function.regs	set	6
36914                       00000004            .int1a_function.regs	set	4
36915 A712           FB                           sti
36916                                           ! 5262 endasm
36917                                           !BCC_ENDASM
36918                                           !BCC_EOS
36919                                           ! 5263   switch (regs.u.r8.ah) {
36920 A713           8A46         13            mov	al,$13[bp]
36921 A716           E9         036F            br 	.768
36922                                           ! 5264     case 0:
36923                                           ! 5265 #asm
36924                       0000A719            .769:
36925                                           !BCC_EOS
36926                                           !BCC_ASM
36927                       00000016            _int1a_function.ds	set	$16
36928                       00000014            .int1a_function.ds	set	$14
36929                       00000001            _int1a_function.val8	set	1
36930                       FFFFFFFF            .int1a_function.val8	set	-1
36931                       00000018            _int1a_function.iret_addr	set	$18
36932                       00000016            .int1a_function.iret_addr	set	$16
36933                       00000006            _int1a_function.regs	set	6
36934                       00000004            .int1a_function.regs	set	4
36935 A719           FA                               cli
36936                                           ! 5267 endasm
36937                                           !BCC_ENDASM
36938                                           !BCC_EOS
36939                                           ! 5268       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
36940                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
36941 A71A           A1         046E            mov	ax,[$46E]
36942 A71D           8946         10            mov	$10[bp],ax
36943                                           !BCC_EOS
36944                                           ! 5269       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
36945                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
36946 A720           A1         046C            mov	ax,[$46C]
36947 A723           8946         0E            mov	$E[bp],ax
36948                                           !BCC_EOS
36949                                           ! 5270       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
36950                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
36951 A726           A0         0470            mov	al,[$470]
36952 A729           8846         12            mov	$12[bp],al
36953                                           !BCC_EOS
36954                                           ! 5271       ((bios_data_t *) 0)->midnight_flag = 0;
36955                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
36956 A72C           30C0                       xor	al,al
36957 A72E           A2         0470            mov	[$470],al
36958                                           !BCC_EOS
36959                                           ! 5272 #asm
36960                                           !BCC_EOS
36961                                           !BCC_ASM
36962                       00000016            _int1a_function.ds	set	$16
36963                       00000014            .int1a_function.ds	set	$14
36964                       00000001            _int1a_function.val8	set	1
36965                       FFFFFFFF            .int1a_function.val8	set	-1
36966                       00000018            _int1a_function.iret_addr	set	$18
36967                       00000016            .int1a_function.iret_addr	set	$16
36968                       00000006            _int1a_function.regs	set	6
36969                       00000004            .int1a_function.regs	set	4
36970 A731           FB                               sti
36971                                           ! 5274 endasm
36972                                           !BCC_ENDASM
36973                                           !BCC_EOS
36974                                           ! 5275       iret_addr.flags.u.r8.flagsl &= 0xfe;
36975                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36976 A732           8A46         1A            mov	al,$1A[bp]
36977 A735           24                     FE  and	al,#$FE
36978 A737           8846         1A            mov	$1A[bp],al
36979                                           !BCC_EOS
36980                                           ! 5276       break;
36981 A73A           E9         0376            br 	.766
36982                                           !BCC_EOS
36983                                           ! 5277     case 1:
36984                                           ! 5278 #asm
36985                       0000A73D            .76A:
36986                                           !BCC_EOS
36987                                           !BCC_ASM
36988                       00000016            _int1a_function.ds	set	$16
36989                       00000014            .int1a_function.ds	set	$14
36990                       00000001            _int1a_function.val8	set	1
36991                       FFFFFFFF            .int1a_function.val8	set	-1
36992                       00000018            _int1a_function.iret_addr	set	$18
36993                       00000016            .int1a_function.iret_addr	set	$16
36994                       00000006            _int1a_function.regs	set	6
36995                       00000004            .int1a_function.regs	set	4
36996 A73D           FA                               cli
36997                                           ! 5280 endasm
36998                                           !BCC_ENDASM
36999                                           !BCC_EOS
37000                                           ! 5281       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
37001                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
37002 A73E           8B46         10            mov	ax,$10[bp]
37003 A741           A3         046E            mov	[$46E],ax
37004                                           !BCC_EOS
37005                                           ! 5282       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
37006                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
37007 A744           8B46         0E            mov	ax,$E[bp]
37008 A747           A3         046C            mov	[$46C],ax
37009                                           !BCC_EOS
37010                                           ! 5283       ((bios_data_t *) 0)->midnight_flag = 0;
37011                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
37012 A74A           30C0                       xor	al,al
37013 A74C           A2         0470            mov	[$470],al
37014                                           !BCC_EOS
37015                                           ! 5284 #asm
37016                                           !BCC_EOS
37017                                           !BCC_ASM
37018                       00000016            _int1a_function.ds	set	$16
37019                       00000014            .int1a_function.ds	set	$14
37020                       00000001            _int1a_function.val8	set	1
37021                       FFFFFFFF            .int1a_function.val8	set	-1
37022                       00000018            _int1a_function.iret_addr	set	$18
37023                       00000016            .int1a_function.iret_addr	set	$16
37024                       00000006            _int1a_function.regs	set	6
37025                       00000004            .int1a_function.regs	set	4
37026 A74F           FB                               sti
37027                                           ! 5286 endasm
37028                                           !BCC_ENDASM
37029                                           !BCC_EOS
37030                                           ! 5287       regs.u.r8.ah = 0;
37031                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37032 A750           30C0                       xor	al,al
37033 A752           8846         13            mov	$13[bp],al
37034                                           !BCC_EOS
37035                                           ! 5288       iret_addr.flags.u.r8.flagsl &= 0xfe;
37036                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37037 A755           8A46         1A            mov	al,$1A[bp]
37038 A758           24                     FE  and	al,#$FE
37039 A75A           8846         1A            mov	$1A[bp],al
37040                                           !BCC_EOS
37041                                           ! 5289       break;
37042 A75D           E9         0353            br 	.766
37043                                           !BCC_EOS
37044                                           ! 5290     case 2:
37045                                           ! 5291       if (rtc_updating()) {
37046                       0000A760            .76B:
37047                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37048 A760           E8         5E5D            call	_rtc_updating
37049 A763           85C0                       test	ax,ax
37050 A765           74           0B            je  	.76C
37051                       0000A767            .76D:
37052                                           ! 5292         iret_addr.flags.u.r8.flagsl |= 0x01;
37053                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37054 A767           8A46         1A            mov	al,$1A[bp]
37055 A76A           0C                     01  or	al,*1
37056 A76C           8846         1A            mov	$1A[bp],al
37057                                           !BCC_EOS
37058                                           ! 5293         break;
37059 A76F           E9         0341            br 	.766
37060                                           !BCC_EOS
37061                                           ! 5294         }
37062                                           ! 5295       regs.u.r8.dh = inb_cmos(0x00);
37063                       0000A772            .76C:
37064                                           ! Debug: list int = const 0 (used reg = )
37065 A772           31C0                       xor	ax,ax
37066 A774           50                         push	ax
37067                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37068 A775           E8         5E0B            call	_inb_cmos
37069 A778           44                         inc	sp
37070 A779           44                         inc	sp
37071                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
37072 A77A           8846         0F            mov	$F[bp],al
37073                                           !BCC_EOS
37074                                           ! 5296       regs.u.r8.cl = inb_cmos(0x02);
37075                                           ! Debug: list int = const 2 (used reg = )
37076 A77D           B8                   0002  mov	ax,*2
37077 A780           50                         push	ax
37078                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37079 A781           E8         5DFF            call	_inb_cmos
37080 A784           44                         inc	sp
37081 A785           44                         inc	sp
37082                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
37083 A786           8846         10            mov	$10[bp],al
37084                                           !BCC_EOS
37085                                           ! 5297       regs.u.r8.ch = inb_cmos(0x04);
37086                                           ! Debug: list int = const 4 (used reg = )
37087 A789           B8                   0004  mov	ax,*4
37088 A78C           50                         push	ax
37089                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37090 A78D           E8         5DF3            call	_inb_cmos
37091 A790           44                         inc	sp
37092 A791           44                         inc	sp
37093                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
37094 A792           8846         11            mov	$11[bp],al
37095                                           !BCC_EOS
37096                                           ! 5298       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
37097                                           ! Debug: list int = const $B (used reg = )
37098 A795           B8                   000B  mov	ax,*$B
37099 A798           50                         push	ax
37100                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37101 A799           E8         5DE7            call	_inb_cmos
37102 A79C           44                         inc	sp
37103 A79D           44                         inc	sp
37104                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
37105 A79E           24                     01  and	al,*1
37106                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
37107 A7A0           8846         0E            mov	$E[bp],al
37108                                           !BCC_EOS
37109                                           ! 5299       regs.u.r8.ah = 0;
37110                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37111 A7A3           30C0                       xor	al,al
37112 A7A5           8846         13            mov	$13[bp],al
37113                                           !BCC_EOS
37114                                           ! 5300       regs.u.r8.al = regs.u.r8.ch;
37115                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
37116 A7A8           8A46         11            mov	al,$11[bp]
37117 A7AB           8846         12            mov	$12[bp],al
37118                                           !BCC_EOS
37119                                           ! 5301       iret_addr.flags.u.r8.flagsl &= 0xfe;
37120                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37121 A7AE           8A46         1A            mov	al,$1A[bp]
37122 A7B1           24                     FE  and	al,#$FE
37123 A7B3           8846         1A            mov	$1A[bp],al
37124                                           !BCC_EOS
37125                                           ! 5302       break;
37126 A7B6           E9         02FA            br 	.766
37127                                           !BCC_EOS
37128                                           ! 5303     case 3:
37129                                           ! 5304       if (rtc_updating()) {
37130                       0000A7B9            .76E:
37131                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37132 A7B9           E8         5E04            call	_rtc_updating
37133 A7BC           85C0                       test	ax,ax
37134 A7BE           74           03            je  	.76F
37135                       0000A7C0            .770:
37136                                           ! 5305         init_rtc();
37137                                           ! Debug: func () void = init_rtc+0 (used reg = )
37138 A7C0           E8         5DCC            call	_init_rtc
37139                                           !BCC_EOS
37140                                           ! 5306         }
37141                                           ! 5307       outb_cmos(0x00, regs.u.r8.dh);
37142                       0000A7C3            .76F:
37143                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37144 A7C3           8A46         0F            mov	al,$F[bp]
37145 A7C6           30E4                       xor	ah,ah
37146 A7C8           50                         push	ax
37147                                           ! Debug: list int = const 0 (used reg = )
37148 A7C9           31C0                       xor	ax,ax
37149 A7CB           50                         push	ax
37150                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37151 A7CC           E8         5DA5            call	_outb_cmos
37152 A7CF           83C4                   04  add	sp,*4
37153                                           !BCC_EOS
37154                                           ! 5308       outb_cmos(0x02, regs.u.r8.cl);
37155                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37156 A7D2           8A46         10            mov	al,$10[bp]
37157 A7D5           30E4                       xor	ah,ah
37158 A7D7           50                         push	ax
37159                                           ! Debug: list int = const 2 (used reg = )
37160 A7D8           B8                   0002  mov	ax,*2
37161 A7DB           50                         push	ax
37162                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37163 A7DC           E8         5D95            call	_outb_cmos
37164 A7DF           83C4                   04  add	sp,*4
37165                                           !BCC_EOS
37166                                           ! 5309       outb_cmos(0x04, regs.u.r8.ch);
37167                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37168 A7E2           8A46         11            mov	al,$11[bp]
37169 A7E5           30E4                       xor	ah,ah
37170 A7E7           50                         push	ax
37171                                           ! Debug: list int = const 4 (used reg = )
37172 A7E8           B8                   0004  mov	ax,*4
37173 A7EB           50                         push	ax
37174                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37175 A7EC           E8         5D85            call	_outb_cmos
37176 A7EF           83C4                   04  add	sp,*4
37177                                           !BCC_EOS
37178                                           ! 5310       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
37179                                           ! Debug: expression subtree swapping
37180                                           ! Debug: list int = const $B (used reg = )
37181 A7F2           B8                   000B  mov	ax,*$B
37182 A7F5           50                         push	ax
37183                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37184 A7F6           E8         5D8A            call	_inb_cmos
37185 A7F9           44                         inc	sp
37186 A7FA           44                         inc	sp
37187                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
37188 A7FB           24                     60  and	al,*$60
37189                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
37190 A7FD           0C                     02  or	al,*2
37191 A7FF           50                         push	ax
37192                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
37193 A800           8A46         0E            mov	al,$E[bp]
37194 A803           24                     01  and	al,*1
37195                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
37196 A805           0A46         FC            or	al,0+..FFDA[bp]
37197 A808           44                         inc	sp
37198 A809           44                         inc	sp
37199                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37200 A80A           8846         FF            mov	-1[bp],al
37201                                           !BCC_EOS
37202                                           ! 5311       outb_cmos(0x0b, val8);
37203                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
37204 A80D           8A46         FF            mov	al,-1[bp]
37205 A810           30E4                       xor	ah,ah
37206 A812           50                         push	ax
37207                                           ! Debug: list int = const $B (used reg = )
37208 A813           B8                   000B  mov	ax,*$B
37209 A816           50                         push	ax
37210                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37211 A817           E8         5D5A            call	_outb_cmos
37212 A81A           83C4                   04  add	sp,*4
37213                                           !BCC_EOS
37214                                           ! 5312       regs.u.r8.ah = 0;
37215                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37216 A81D           30C0                       xor	al,al
37217 A81F           8846         13            mov	$13[bp],al
37218                                           !BCC_EOS
37219                                           ! 5313       regs.u.r8.al = val8;
37220                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37221 A822           8A46         FF            mov	al,-1[bp]
37222 A825           8846         12            mov	$12[bp],al
37223                                           !BCC_EOS
37224                                           ! 5314       iret_addr.flags.u.r8.flagsl &= 0xfe;
37225                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37226 A828           8A46         1A            mov	al,$1A[bp]
37227 A82B           24                     FE  and	al,#$FE
37228 A82D           8846         1A            mov	$1A[bp],al
37229                                           !BCC_EOS
37230                                           ! 5315       break;
37231 A830           E9         0280            br 	.766
37232                                           !BCC_EOS
37233                                           ! 5316     case 4:
37234                                           ! 5317       regs.u.r8.ah = 0;
37235                       0000A833            .771:
37236                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37237 A833           30C0                       xor	al,al
37238 A835           8846         13            mov	$13[bp],al
37239                                           !BCC_EOS
37240                                           ! 5318       if (rtc_updating()) {
37241                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37242 A838           E8         5D85            call	_rtc_updating
37243 A83B           85C0                       test	ax,ax
37244 A83D           74           0B            je  	.772
37245                       0000A83F            .773:
37246                                           ! 5319         iret_addr.flags.u.r8.flagsl |= 0x01;
37247                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37248 A83F           8A46         1A            mov	al,$1A[bp]
37249 A842           0C                     01  or	al,*1
37250 A844           8846         1A            mov	$1A[bp],al
37251                                           !BCC_EOS
37252                                           ! 5320         break;
37253 A847           E9         0269            br 	.766
37254                                           !BCC_EOS
37255                                           ! 5321         }
37256                                           ! 5322       regs.u.r8.cl = inb_cmos(0x09);
37257                       0000A84A            .772:
37258                                           ! Debug: list int = const 9 (used reg = )
37259 A84A           B8                   0009  mov	ax,*9
37260 A84D           50                         push	ax
37261                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37262 A84E           E8         5D32            call	_inb_cmos
37263 A851           44                         inc	sp
37264 A852           44                         inc	sp
37265                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
37266 A853           8846         10            mov	$10[bp],al
37267                                           !BCC_EOS
37268                                           ! 5323       regs.u.r8.dh = inb_cmos(0x08);
37269                                           ! Debug: list int = const 8 (used reg = )
37270 A856           B8                   0008  mov	ax,*8
37271 A859           50                         push	ax
37272                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37273 A85A           E8         5D26            call	_inb_cmos
37274 A85D           44                         inc	sp
37275 A85E           44                         inc	sp
37276                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
37277 A85F           8846         0F            mov	$F[bp],al
37278                                           !BCC_EOS
37279                                           ! 5324       regs.u.r8.dl = inb_cmos(0x07);
37280                                           ! Debug: list int = const 7 (used reg = )
37281 A862           B8                   0007  mov	ax,*7
37282 A865           50                         push	ax
37283                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37284 A866           E8         5D1A            call	_inb_cmos
37285 A869           44                         inc	sp
37286 A86A           44                         inc	sp
37287                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
37288 A86B           8846         0E            mov	$E[bp],al
37289                                           !BCC_EOS
37290                                           ! 5325       regs.u.r8.ch = inb_cmos(0x32);
37291                                           ! Debug: list int = const $32 (used reg = )
37292 A86E           B8                   0032  mov	ax,*$32
37293 A871           50                         push	ax
37294                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37295 A872           E8         5D0E            call	_inb_cmos
37296 A875           44                         inc	sp
37297 A876           44                         inc	sp
37298                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
37299 A877           8846         11            mov	$11[bp],al
37300                                           !BCC_EOS
37301                                           ! 5326       regs.u.r8.al = regs.u.r8.ch;
37302                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
37303 A87A           8A46         11            mov	al,$11[bp]
37304 A87D           8846         12            mov	$12[bp],al
37305                                           !BCC_EOS
37306                                           ! 5327       iret_addr.flags.u.r8.
37307                                           ! 5327 flagsl &= 0xfe;
37308                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37309 A880           8A46         1A            mov	al,$1A[bp]
37310 A883           24                     FE  and	al,#$FE
37311 A885           8846         1A            mov	$1A[bp],al
37312                                           !BCC_EOS
37313                                           ! 5328       break;
37314 A888           E9         0228            br 	.766
37315                                           !BCC_EOS
37316                                           ! 5329     case 5:
37317                                           ! 5330       if (rtc_updating()) {
37318                       0000A88B            .774:
37319                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37320 A88B           E8         5D32            call	_rtc_updating
37321 A88E           85C0                       test	ax,ax
37322 A890           74           0E            je  	.775
37323                       0000A892            .776:
37324                                           ! 5331         init_rtc();
37325                                           ! Debug: func () void = init_rtc+0 (used reg = )
37326 A892           E8         5CFA            call	_init_rtc
37327                                           !BCC_EOS
37328                                           ! 5332         iret_addr.flags.u.r8.flagsl |= 0x01;
37329                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37330 A895           8A46         1A            mov	al,$1A[bp]
37331 A898           0C                     01  or	al,*1
37332 A89A           8846         1A            mov	$1A[bp],al
37333                                           !BCC_EOS
37334                                           ! 5333         break;
37335 A89D           E9         0213            br 	.766
37336                                           !BCC_EOS
37337                                           ! 5334         }
37338                                           ! 5335       outb_cmos(0x09, regs.u.r8.cl);
37339                       0000A8A0            .775:
37340                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37341 A8A0           8A46         10            mov	al,$10[bp]
37342 A8A3           30E4                       xor	ah,ah
37343 A8A5           50                         push	ax
37344                                           ! Debug: list int = const 9 (used reg = )
37345 A8A6           B8                   0009  mov	ax,*9
37346 A8A9           50                         push	ax
37347                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37348 A8AA           E8         5CC7            call	_outb_cmos
37349 A8AD           83C4                   04  add	sp,*4
37350                                           !BCC_EOS
37351                                           ! 5336       outb_cmos(0x08, regs.u.r8.dh);
37352                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37353 A8B0           8A46         0F            mov	al,$F[bp]
37354 A8B3           30E4                       xor	ah,ah
37355 A8B5           50                         push	ax
37356                                           ! Debug: list int = const 8 (used reg = )
37357 A8B6           B8                   0008  mov	ax,*8
37358 A8B9           50                         push	ax
37359                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37360 A8BA           E8         5CB7            call	_outb_cmos
37361 A8BD           83C4                   04  add	sp,*4
37362                                           !BCC_EOS
37363                                           ! 5337       outb_cmos(0x07, regs.u.r8.dl);
37364                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
37365 A8C0           8A46         0E            mov	al,$E[bp]
37366 A8C3           30E4                       xor	ah,ah
37367 A8C5           50                         push	ax
37368                                           ! Debug: list int = const 7 (used reg = )
37369 A8C6           B8                   0007  mov	ax,*7
37370 A8C9           50                         push	ax
37371                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37372 A8CA           E8         5CA7            call	_outb_cmos
37373 A8CD           83C4                   04  add	sp,*4
37374                                           !BCC_EOS
37375                                           ! 5338       outb_cmos(0x32, regs.u.r8.ch);
37376                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37377 A8D0           8A46         11            mov	al,$11[bp]
37378 A8D3           30E4                       xor	ah,ah
37379 A8D5           50                         push	ax
37380                                           ! Debug: list int = const $32 (used reg = )
37381 A8D6           B8                   0032  mov	ax,*$32
37382 A8D9           50                         push	ax
37383                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37384 A8DA           E8         5C97            call	_outb_cmos
37385 A8DD           83C4                   04  add	sp,*4
37386                                           !BCC_EOS
37387                                           ! 5339       val8 = inb_cmos(0x0b) & 0x7f;
37388                                           ! Debug: list int = const $B (used reg = )
37389 A8E0           B8                   000B  mov	ax,*$B
37390 A8E3           50                         push	ax
37391                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37392 A8E4           E8         5C9C            call	_inb_cmos
37393 A8E7           44                         inc	sp
37394 A8E8           44                         inc	sp
37395                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
37396 A8E9           24                     7F  and	al,*$7F
37397                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37398 A8EB           8846         FF            mov	-1[bp],al
37399                                           !BCC_EOS
37400                                           ! 5340       outb_cmos(0x0b, val8);
37401                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
37402 A8EE           8A46         FF            mov	al,-1[bp]
37403 A8F1           30E4                       xor	ah,ah
37404 A8F3           50                         push	ax
37405                                           ! Debug: list int = const $B (used reg = )
37406 A8F4           B8                   000B  mov	ax,*$B
37407 A8F7           50                         push	ax
37408                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37409 A8F8           E8         5C79            call	_outb_cmos
37410 A8FB           83C4                   04  add	sp,*4
37411                                           !BCC_EOS
37412                                           ! 5341       regs.u.r8.ah = 0;
37413                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37414 A8FE           30C0                       xor	al,al
37415 A900           8846         13            mov	$13[bp],al
37416                                           !BCC_EOS
37417                                           ! 5342       regs.u.r8.al = val8;
37418                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37419 A903           8A46         FF            mov	al,-1[bp]
37420 A906           8846         12            mov	$12[bp],al
37421                                           !BCC_EOS
37422                                           ! 5343       iret_addr.flags.u.r8.flagsl &= 0xfe;
37423                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37424 A909           8A46         1A            mov	al,$1A[bp]
37425 A90C           24                     FE  and	al,#$FE
37426 A90E           8846         1A            mov	$1A[bp],al
37427                                           !BCC_EOS
37428                                           ! 5344       break;
37429 A911           E9         019F            br 	.766
37430                                           !BCC_EOS
37431                                           ! 5345     case 6:
37432                                           ! 5346       val8 = inb_cmos(0x0b);
37433                       0000A914            .777:
37434                                           ! Debug: list int = const $B (used reg = )
37435 A914           B8                   000B  mov	ax,*$B
37436 A917           50                         push	ax
37437                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37438 A918           E8         5C68            call	_inb_cmos
37439 A91B           44                         inc	sp
37440 A91C           44                         inc	sp
37441                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37442 A91D           8846         FF            mov	-1[bp],al
37443                                           !BCC_EOS
37444                                           ! 5347       regs.u.r16.ax = 0;
37445                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
37446 A920           31C0                       xor	ax,ax
37447 A922           8946         12            mov	$12[bp],ax
37448                                           !BCC_EOS
37449                                           ! 5348       if (val8 & 0x20) {
37450                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
37451 A925           8A46         FF            mov	al,-1[bp]
37452 A928           24                     20  and	al,*$20
37453 A92A           84C0                       test	al,al
37454 A92C           74           0B            je  	.778
37455                       0000A92E            .779:
37456                                           ! 5349         iret_addr.flags.u.r8.flagsl |= 0x01;
37457                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37458 A92E           8A46         1A            mov	al,$1A[bp]
37459 A931           0C                     01  or	al,*1
37460 A933           8846         1A            mov	$1A[bp],al
37461                                           !BCC_EOS
37462                                           ! 5350         break;
37463 A936           E9         017A            br 	.766
37464                                           !BCC_EOS
37465                                           ! 5351         }
37466                                           ! 5352       if (rtc_updating()) {
37467                       0000A939            .778:
37468                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
37469 A939           E8         5C84            call	_rtc_updating
37470 A93C           85C0                       test	ax,ax
37471 A93E           74           03            je  	.77A
37472                       0000A940            .77B:
37473                                           ! 5353         init_rtc();
37474                                           ! Debug: func () void = init_rtc+0 (used reg = )
37475 A940           E8         5C4C            call	_init_rtc
37476                                           !BCC_EOS
37477                                           ! 5354         }
37478                                           ! 5355       outb_cmos(0x01, regs.u.r8.dh);
37479                       0000A943            .77A:
37480                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
37481 A943           8A46         0F            mov	al,$F[bp]
37482 A946           30E4                       xor	ah,ah
37483 A948           50                         push	ax
37484                                           ! Debug: list int = const 1 (used reg = )
37485 A949           B8                   0001  mov	ax,*1
37486 A94C           50                         push	ax
37487                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37488 A94D           E8         5C24            call	_outb_cmos
37489 A950           83C4                   04  add	sp,*4
37490                                           !BCC_EOS
37491                                           ! 5356       outb_cmos(0x03, regs.u.r8.cl);
37492                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
37493 A953           8A46         10            mov	al,$10[bp]
37494 A956           30E4                       xor	ah,ah
37495 A958           50                         push	ax
37496                                           ! Debug: list int = const 3 (used reg = )
37497 A959           B8                   0003  mov	ax,*3
37498 A95C           50                         push	ax
37499                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37500 A95D           E8         5C14            call	_outb_cmos
37501 A960           83C4                   04  add	sp,*4
37502                                           !BCC_EOS
37503                                           ! 5357       outb_cmos(0x05, regs.u.r8.ch);
37504                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
37505 A963           8A46         11            mov	al,$11[bp]
37506 A966           30E4                       xor	ah,ah
37507 A968           50                         push	ax
37508                                           ! Debug: list int = const 5 (used reg = )
37509 A969           B8                   0005  mov	ax,*5
37510 A96C           50                         push	ax
37511                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37512 A96D           E8         5C04            call	_outb_cmos
37513 A970           83C4                   04  add	sp,*4
37514                                           !BCC_EOS
37515                                           ! 5358       outb(0xa1, inb(0xa1) & 0xfe);
37516                                           ! Debug: list int = const $A1 (used reg = )
37517 A973           B8                   00A1  mov	ax,#$A1
37518 A976           50                         push	ax
37519                                           ! Debug: func () unsigned char = inb+0 (used reg = )
37520 A977           E8         5BC4            call	_inb
37521 A97A           44                         inc	sp
37522 A97B           44                         inc	sp
37523                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
37524 A97C           24                     FE  and	al,#$FE
37525                                           ! Debug: list unsigned char = al+0 (used reg = )
37526 A97E           30E4                       xor	ah,ah
37527 A980           50                         push	ax
37528                                           ! Debug: list int = const $A1 (used reg = )
37529 A981           B8                   00A1  mov	ax,#$A1
37530 A984           50                         push	ax
37531                                           ! Debug: func () void = outb+0 (used reg = )
37532 A985           E8         5BCC            call	_outb
37533 A988           83C4                   04  add	sp,*4
37534                                           !BCC_EOS
37535                                           ! 5359       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
37536                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
37537 A98B           8A46         FF            mov	al,-1[bp]
37538 A98E           24                     7F  and	al,*$7F
37539                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
37540 A990           0C                     20  or	al,*$20
37541                                           ! Debug: list unsigned char = al+0 (used reg = )
37542 A992           30E4                       xor	ah,ah
37543 A994           50                         push	ax
37544                                           ! Debug: list int = const $B (used reg = )
37545 A995           B8                   000B  mov	ax,*$B
37546 A998           50                         push	ax
37547                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37548 A999           E8         5BD8            call	_outb_cmos
37549 A99C           83C4                   04  add	sp,*4
37550                                           !BCC_EOS
37551                                           ! 5360       iret_addr.flags.u.r8.flagsl &= 0xfe;
37552                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37553 A99F           8A46         1A            mov	al,$1A[bp]
37554 A9A2           24                     FE  and	al,#$FE
37555 A9A4           8846         1A            mov	$1A[bp],al
37556                                           !BCC_EOS
37557                                           ! 5361       break;
37558 A9A7           E9         0109            br 	.766
37559                                           !BCC_EOS
37560                                           ! 5362     case 7:
37561                                           ! 5363       val8 = inb_cmos(0x0b);
37562                       0000A9AA            .77C:
37563                                           ! Debug: list int = const $B (used reg = )
37564 A9AA           B8                   000B  mov	ax,*$B
37565 A9AD           50                         push	ax
37566                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37567 A9AE           E8         5BD2            call	_inb_cmos
37568 A9B1           44                         inc	sp
37569 A9B2           44                         inc	sp
37570                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
37571 A9B3           8846         FF            mov	-1[bp],al
37572                                           !BCC_EOS
37573                                           ! 5364       outb_cmos(0x0b, val8 & 0x57);
37574                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
37575 A9B6           8A46         FF            mov	al,-1[bp]
37576 A9B9           24                     57  and	al,*$57
37577                                           ! Debug: list unsigned char = al+0 (used reg = )
37578 A9BB           30E4                       xor	ah,ah
37579 A9BD           50                         push	ax
37580                                           ! Debug: list int = const $B (used reg = )
37581 A9BE           B8                   000B  mov	ax,*$B
37582 A9C1           50                         push	ax
37583                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37584 A9C2           E8         5BAF            call	_outb_cmos
37585 A9C5           83C4                   04  add	sp,*4
37586                                           !BCC_EOS
37587                                           ! 5365       regs.u.r8.ah = 0;
37588                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
37589 A9C8           30C0                       xor	al,al
37590 A9CA           8846         13            mov	$13[bp],al
37591                                           !BCC_EOS
37592                                           ! 5366       regs.u.r8.al = val8;
37593                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
37594 A9CD           8A46         FF            mov	al,-1[bp]
37595 A9D0           8846         12            mov	$12[bp],al
37596                                           !BCC_EOS
37597                                           ! 5367       iret_addr.flags.u.r8.flagsl &= 0xfe;
37598                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
37599 A9D3           8A46         1A            mov	al,$1A[bp]
37600 A9D6           24                     FE  and	al,#$FE
37601 A9D8           8846         1A            mov	$1A[bp],al
37602                                           !BCC_EOS
37603                                           ! 5368       break;
37604 A9DB           E9         00D5            br 	.766
37605                                           !BCC_EOS
37606                                           ! 5369     case 0xb1:
37607                                           ! 5370       if (regs.u.r8.bl == 0xff) {
37608                       0000A9DE            .77D:
37609                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
37610 A9DE           8A46         0C            mov	al,$C[bp]
37611 A9E1           3C                     FF  cmp	al,#$FF
37612 A9E3           75           11            jne 	.77E
37613                       0000A9E5            .77F:
37614                                           ! 5371         bios_printf(4, "PCI BIOS: PCI not present\n");
37615                                           ! Debug: list * char = .780+0 (used reg = )
37616 A9E5           BB                   D096  mov	bx,#.780
37617 A9E8           53                         push	bx
37618                                           ! Debug: list int = const 4 (used reg = )
37619 A9E9           B8                   0004  mov	ax,*4
37620 A9EC           50                         push	ax
37621                                           ! Debug: func () void = bios_printf+0 (used reg = )
37622 A9ED           E8         6029            call	_bios_printf
37623 A9F0           83C4                   04  add	sp,*4
37624                                           !BCC_EOS
37625                                           ! 5372       } else if (regs.u.r8.bl == 0x81) {
37626 A9F3           E9         0078            br 	.781
37627                       0000A9F6            .77E:
37628                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
37629 A9F6           8A46         0C            mov	al,$C[bp]
37630 A9F9           3C                     81  cmp	al,#$81
37631 A9FB           75           16            jne 	.782
37632                       0000A9FD            .783:
37633                                           ! 5373         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
37634                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
37635 A9FD           8A46         12            mov	al,$12[bp]
37636 AA00           30E4                       xor	ah,ah
37637 AA02           50                         push	ax
37638                                           ! Debug: list * char = .784+0 (used reg = )
37639 AA03           BB                   D070  mov	bx,#.784
37640 AA06           53                         push	bx
37641                                           ! Debug: list int = const 4 (used reg = )
37642 AA07           B8                   0004  mov	ax,*4
37643 AA0A           50                         push	ax
37644                                           ! Debug: func () void = bios_printf+0 (used reg = )
37645 AA0B           E8         600B            call	_bios_printf
37646 AA0E           83C4                   06  add	sp,*6
37647                                           !BCC_EOS
37648                                           ! 5374       } else if (regs.u.r8.bl == 0x83) {
37649 AA11           EB           5B            jmp .785
37650                       0000AA13            .782:
37651                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
37652 AA13           8A46         0C            mov	al,$C[bp]
37653 AA16           3C                     83  cmp	al,#$83
37654 AA18           75           13            jne 	.786
37655                       0000AA1A            .787:
37656                                           ! 5375         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
37657                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
37658 AA1A           FF76         0E            push	$E[bp]
37659                                           ! Debug: list * char = .788+0 (used reg = )
37660 AA1D           BB                   D058  mov	bx,#.788
37661 AA20           53                         push	bx
37662                                           ! Debug: list int = const 4 (used reg = )
37663 AA21           B8                   0004  mov	ax,*4
37664 AA24           50                         push	ax
37665                                           ! Debug: func () void = bios_printf+0 (used reg = )
37666 AA25           E8         5FF1            call	_bios_printf
37667 AA28           83C4                   06  add	sp,*6
37668                                           !BCC_EOS
37669                                           ! 5376       } else if (regs.u.r8.bl == 0x86) {
37670 AA2B           EB           41            jmp .789
37671                       0000AA2D            .786:
37672                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
37673 AA2D           8A46         0C            mov	al,$C[bp]
37674 AA30           3C                     86  cmp	al,#$86
37675 AA32           75           3A            jne 	.78A
37676                       0000AA34            .78B:
37677                                           ! 5377         if (regs.u.r8.al == 0x02) {
37678                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
37679 AA34           8A46         12            mov	al,$12[bp]
37680 AA37           3C                     02  cmp	al,*2
37681 AA39           75           19            jne 	.78C
37682                       0000AA3B            .78D:
37683                                           ! 5378           bios_printf(4, "PCI device %04x:%04x not found at index %d\n", regs.u.r16.dx, regs.u.r16.cx, regs.u.r16.si);
37684                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
37685 AA3B           FF76         06            push	6[bp]
37686                                           ! Debug: list unsigned short regs = [S+6+$E] (used reg = )
37687 AA3E           FF76         10            push	$10[bp]
37688                                           ! Debug: list unsigned short regs = [S+8+$C] (used reg = )
37689 AA41           FF76         0E            push	$E[bp]
37690                                           ! Debug: list * char = .78E+0 (used reg = )
37691 AA44           BB                   D02C  mov	bx,#.78E
37692 AA47           53                         push	bx
37693                                           ! Debug: list int = const 4 (used reg = )
37694 AA48           B8                   0004  mov	ax,*4
37695 AA4B           50                         push	ax
37696                                           ! Debug: func () void = bios_printf+0 (used reg = )
37697 AA4C           E8         5FCA            call	_bios_printf
37698 AA4F           83C4                   0A  add	sp,*$A
37699                                           !BCC_EOS
37700                                           ! 5379         } else {
37701 AA52           EB           1A            jmp .78F
37702                       0000AA54            .78C:
37703                                           ! 5380           bios_printf(4, "no PCI device with class code 0x%02x%04x found at index %d\n", regs.u.r8.cl, regs.u.r16.dx, regs.u.r16.si);
37704                                           ! Debug: list unsigned short regs = [S+4+4] (used reg = )
37705 AA54           FF76         06            push	6[bp]
37706                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
37707 AA57           FF76         0E            push	$E[bp]
37708                                           ! Debug: list unsigned char regs = [S+8+$E] (used reg = )
37709 AA5A           8A46         10            mov	al,$10[bp]
37710 AA5D           30E4                       xor	ah,ah
37711 AA5F           50                         push	ax
37712                                           ! Debug: list * char = .790+0 (used reg = )
37713 AA60           BB                   CFF0  mov	bx,#.790
37714 AA63           53                         push	bx
37715                                           ! Debug: list int = const 4 (used reg = )
37716 AA64           B8                   0004  mov	ax,*4
37717 AA67           50                         push	ax
37718                                           ! Debug: func () void = bios_printf+0 (used reg = )
37719 AA68           E8         5FAE            call	_bios_printf
37720 AA6B           83C4                   0A  add	sp,*$A
37721                                           !BCC_EOS
37722                                           ! 5381         }
37723                                           ! 5382       }
37724                       0000AA6E            .78F:
37725                                           ! 5383       regs.u.r8.ah = regs.u.r8.bl;
37726                       0000AA6E            .78A:
37727                       0000AA6E            .789:
37728                       0000AA6E            .785:
37729                       0000AA6E            .781:
37730                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
37731 AA6E           8A46         0C            mov	al,$C[bp]
37732 AA71           8846         13            mov	$13[bp],al
37733                                           !BCC_EOS
37734                                           ! 5384       iret_addr.flags.u.r8.flagsl |= 0x01;
37735                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37736 AA74           8A46         1A            mov	al,$1A[bp]
37737 AA77           0C                     01  or	al,*1
37738 AA79           8846         1A            mov	$1A[bp],al
37739                                           !BCC_EOS
37740                                           ! 5385       break;
37741 AA7C           EB           35            jmp .766
37742                                           !BCC_EOS
37743                                           ! 5386     default:
37744                                           ! 5387       iret_addr.flags.u.r8.flagsl |= 0x01;
37745                       0000AA7E            .791:
37746                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
37747 AA7E           8A46         1A            mov	al,$1A[bp]
37748 AA81           0C                     01  or	al,*1
37749 AA83           8846         1A            mov	$1A[bp],al
37750                                           !BCC_EOS
37751                                           ! 5388     }
37752                                           ! 5389 }
37753 AA86           EB           2B            jmp .766
37754                       0000AA88            .768:
37755 AA88           2C                     00  sub	al,*0
37756 AA8A           72           F2            jb 	.791
37757 AA8C           3C                     07  cmp	al,*7
37758 AA8E           77           1B            ja  	.792
37759 AA90           30E4                       xor	ah,ah
37760 AA92           D1E0                       shl	ax,*1
37761 AA94           89C3                       mov	bx,ax
37762 AA96           2E                         seg	cs
37763 AA97           FFA7       AA9B            br	.793[bx]
37764                       0000AA9B            .793:
37765 AA9B                      A719            .word	.769
37766 AA9D                      A73D            .word	.76A
37767 AA9F                      A760            .word	.76B
37768 AAA1                      A7B9            .word	.76E
37769 AAA3                      A833            .word	.771
37770 AAA5                      A88B            .word	.774
37771 AAA7                      A914            .word	.777
37772 AAA9                      A9AA            .word	.77C
37773                       0000AAAB            .792:
37774 AAAB           2C                     B1  sub	al,#$B1
37775 AAAD         0F84         FF2D            beq 	.77D
37776 AAB1           EB           CB            jmp	.791
37777                       0000AAB3            .766:
37778                       FFFFFFFC            ..FFDA	=	-4
37779 AAB3           89EC                       mov	sp,bp
37780 AAB5           5D                         pop	bp
37781 AAB6           C3                         ret
37782                                           ! 5390   void
37783                                           ! Register BX used in function int1a_function
37784                                           ! 5391 int70_function(regs, ds, iret_addr)
37785                                           ! 5392   pusha_regs_t regs;
37786                                           export	_int70_function
37787                       0000AAB7            _int70_function:
37788                                           !BCC_EOS
37789                                           ! 5393  
37790                                           ! 5393  Bit16u ds;
37791                                           !BCC_EOS
37792                                           ! 5394   iret_addr_t iret_addr;
37793                                           !BCC_EOS
37794                                           ! 5395 {
37795                                           ! 5396   Bit8u registerB = 0, registerC = 0;
37796 AAB7           55                         push	bp
37797 AAB8           89E5                       mov	bp,sp
37798 AABA           4C                         dec	sp
37799                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
37800 AABB           30C0                       xor	al,al
37801 AABD           8846         FF            mov	-1[bp],al
37802 AAC0           4C                         dec	sp
37803                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
37804 AAC1           30C0                       xor	al,al
37805 AAC3           8846         FE            mov	-2[bp],al
37806                                           !BCC_EOS
37807                                           ! 5397   registerB = inb_cmos( 0xB );
37808                                           ! Debug: list int = const $B (used reg = )
37809 AAC6           B8                   000B  mov	ax,*$B
37810 AAC9           50                         push	ax
37811                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37812 AACA           E8         5AB6            call	_inb_cmos
37813 AACD           44                         inc	sp
37814 AACE           44                         inc	sp
37815                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
37816 AACF           8846         FF            mov	-1[bp],al
37817                                           !BCC_EOS
37818                                           ! 5398   registerC = inb_cmos( 0xC );
37819                                           ! Debug: list int = const $C (used reg = )
37820 AAD2           B8                   000C  mov	ax,*$C
37821 AAD5           50                         push	ax
37822                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37823 AAD6           E8         5AAA            call	_inb_cmos
37824 AAD9           44                         inc	sp
37825 AADA           44                         inc	sp
37826                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
37827 AADB           8846         FE            mov	-2[bp],al
37828                                           !BCC_EOS
37829                                           ! 5399   if( ( registerB & 0x60 ) != 0 ) {
37830                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
37831 AADE           8A46         FF            mov	al,-1[bp]
37832 AAE1           24                     60  and	al,*$60
37833                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37834 AAE3           84C0                       test	al,al
37835 AAE5         0F84         00EF            beq 	.794
37836                       0000AAE9            .795:
37837                                           ! 5400     if( ( registerC & 0x20 ) != 0 ) {
37838                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
37839 AAE9           8A46         FE            mov	al,-2[bp]
37840 AAEC           24                     20  and	al,*$20
37841                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37842 AAEE           84C0                       test	al,al
37843 AAF0           74           04            je  	.796
37844                       0000AAF2            .797:
37845                                           ! 5401 #asm
37846                                           !BCC_EOS
37847                                           !BCC_ASM
37848                       00000000            _int70_function.registerC	set	0
37849                       FFFFFFFE            .int70_function.registerC	set	-2
37850                       00000016            _int70_function.ds	set	$16
37851                       00000014            .int70_function.ds	set	$14
37852                       00000001            _int70_function.registerB	set	1
37853                       FFFFFFFF            .int70_function.registerB	set	-1
37854                       00000018            _int70_function.iret_addr	set	$18
37855                       00000016            .int70_function.iret_addr	set	$16
37856                       00000006            _int70_function.regs	set	6
37857                       00000004            .int70_function.regs	set	4
37858 AAF2           FB                               sti
37859 AAF3           CD                     4A        int #0x4a
37860 AAF5           FA                               cli
37861                                           ! 5405 endasm
37862                                           !BCC_ENDASM
37863                                           !BCC_EOS
37864                                           ! 5406     }
37865                                           ! 5407     if( ( registerC & 0x40 ) != 0 ) {
37866                       0000AAF6            .796:
37867                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
37868 AAF6           8A46         FE            mov	al,-2[bp]
37869 AAF9           24                     40  and	al,*$40
37870                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37871 AAFB           84C0                       test	al,al
37872 AAFD         0F84         00D7            beq 	.798
37873                       0000AB01            .799:
37874                                           ! 5408       if( read_byte( 0x40, 0xA0 ) != 0 ) {
37875                                           ! Debug: list int = const $A0 (used reg = )
37876 AB01           B8                   00A0  mov	ax,#$A0
37877 AB04           50                         push	ax
37878                                           ! Debug: list int = const $40 (used reg = )
37879 AB05           B8                   0040  mov	ax,*$40
37880 AB08           50                         push	ax
37881                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37882 AB09           E8         5AE8            call	_read_byte
37883 AB0C           83C4                   04  add	sp,*4
37884                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37885 AB0F           84C0                       test	al,al
37886 AB11         0F84         00C3            beq 	.79A
37887                       0000AB15            .79B:
37888                                           ! 5409         Bit32u time, toggle;
37889                                           !BCC_EOS
37890                                           ! 5410         time = read_dword( 0x40, 0x9C );
37891 AB15           83C4                   F8  add	sp,*-8
37892                                           ! Debug: list int = const $9C (used reg = )
37893 AB18           B8                   009C  mov	ax,#$9C
37894 AB1B           50                         push	ax
37895                                           ! Debug: list int = const $40 (used reg = )
37896 AB1C           B8                   0040  mov	ax,*$40
37897 AB1F           50                         push	ax
37898                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
37899 AB20           E8         5560            call	_read_dword
37900 AB23           89D3                       mov	bx,dx
37901 AB25           83C4                   04  add	sp,*4
37902                                           ! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
37903 AB28           8946         FA            mov	-6[bp],ax
37904 AB2B           895E         FC            mov	-4[bp],bx
37905                                           !BCC_EOS
37906                                           ! 5411         if( time < 0x3D1 ) {
37907                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
37908 AB2E           B8                   03D1  mov	ax,#$3D1
37909 AB31           31DB                       xor	bx,bx
37910 AB33           8D7E         FA            lea	di,-6[bp]
37911 AB36           E8         5592            call	lcmpul
37912 AB39           76           6A            jbe 	.79C
37913                       0000AB3B            .79D:
37914                                           ! 5412           Bit16u segment, offset;
37915                                           !BCC_EOS
37916                                           ! 5413           segment = read_word( 0x40, 0x98 );
37917 AB3B           83C4                   FC  add	sp,*-4
37918                                           ! Debug: list int = const $98 (used reg = )
37919 AB3E           B8                   0098  mov	ax,#$98
37920 AB41           50                         push	ax
37921                                           ! Debug: list int = const $40 (used reg = )
37922 AB42           B8                   0040  mov	ax,*$40
37923 AB45           50                         push	ax
37924                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
37925 AB46           E8         5ABE            call	_read_word
37926 AB49           83C4                   04  add	sp,*4
37927                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
37928 AB4C           8946         F4            mov	-$C[bp],ax
37929                                           !BCC_EOS
37930                                           ! 5414           offset = read_word( 0x40, 0x9A );
37931                                           ! Debug: list int = const $9A (used reg = )
37932 AB4F           B8                   009A  mov	ax,#$9A
37933 AB52           50                         push	ax
37934                                           ! Debug: list int = const $40 (used reg = )
37935 AB53           B8                   0040  mov	ax,*$40
37936 AB56           50                         push	ax
37937                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
37938 AB57           E8         5AAD            call	_read_word
37939 AB5A           83C4                   04  add	sp,*4
37940                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
37941 AB5D           8946         F2            mov	-$E[bp],ax
37942                                           !BCC_EOS
37943                                           ! 5415           write_byte( 0x40, 0xA0, 0 );
37944                                           ! Debug: list int = const 0 (used reg = )
37945 AB60           31C0                       xor	ax,ax
37946 AB62           50                         push	ax
37947                                           ! Debug: list int = const $A0 (used reg = )
37948 AB63           B8                   00A0  mov	ax,#$A0
37949 AB66           50                         push	ax
37950                                           ! Debug: list int = const $40 (used reg = )
37951 AB67           B8                   0040  mov	ax,*$40
37952 AB6A           50                         push	ax
37953                                           ! Debug: func () void = write_byte+0 (used reg = )
37954 AB6B           E8         5AAC            call	_write_byte
37955 AB6E           83C4                   06  add	sp,*6
37956                                           !BCC_EOS
37957                                           ! 5416           outb_cmos( 0xB, registerB & 0x37 );
37958                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
37959 AB71           8A46         FF            mov	al,-1[bp]
37960 AB74           24                     37  and	al,*$37
37961                                           ! Debug: list unsigned char = al+0 (used reg = )
37962 AB76           30E4                       xor	ah,ah
37963 AB78           50                         push	ax
37964                                           ! Debug: list int = const $B (used reg = )
37965 AB79           B8                   000B  mov	ax,*$B
37966 AB7C           50                         push	ax
37967                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37968 AB7D           E8         59F4            call	_outb_cmos
37969 AB80           83C4                   04  add	sp,*4
37970                                           !BCC_EOS
37971                                           ! 5417           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
37972                                           ! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
37973 AB83           FF76         F2            push	-$E[bp]
37974                                           ! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
37975 AB86           FF76         F4            push	-$C[bp]
37976                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37977 AB89           E8         5A68            call	_read_byte
37978 AB8C           83C4                   04  add	sp,*4
37979                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
37980 AB8F           0C                     80  or	al,#$80
37981                                           ! Debug: list unsigned char = al+0 (used reg = )
37982 AB91           30E4                       xor	ah,ah
37983 AB93           50                         push	ax
37984                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
37985 AB94           FF76         F2            push	-$E[bp]
37986                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
37987 AB97           FF76         F4            push	-$C[bp]
37988                                           ! Debug: func () void = write_byte+0 (used reg = )
37989 AB9A           E8         5A7D            call	_write_byte
37990 AB9D           83C4                   06  add	sp,*6
37991                                           !BCC_EOS
37992                                           ! 5418         } else {
37993 ABA0           83C4                   04  add	sp,*4
37994 ABA3           EB           30            jmp .79E
37995                       0000ABA5            .79C:
37996                                           ! 5419           time -= 0x3D1;
37997                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
37998 ABA5           B8                   03D1  mov	ax,#$3D1
37999 ABA8           31DB                       xor	bx,bx
38000 ABAA           53                         push	bx
38001 ABAB           50                         push	ax
38002 ABAC           8B46         FA            mov	ax,-6[bp]
38003 ABAF           8B5E         FC            mov	bx,-4[bp]
38004 ABB2           8D7E         F2            lea	di,-$E[bp]
38005 ABB5           E8         5529            call	lsubul
38006 ABB8           8946         FA            mov	-6[bp],ax
38007 ABBB           895E         FC            mov	-4[bp],bx
38008 ABBE           83C4                   04  add	sp,*4
38009                                           !BCC_EOS
38010                                           ! 5420           write_dword( 0x40, 0x9C, time );
38011                                           ! Debug: list unsigned long time = [S+$C-8] (used reg = )
38012 ABC1           FF76         FC            push	-4[bp]
38013 ABC4           FF76         FA            push	-6[bp]
38014                                           ! Debug: list int = const $9C (used reg = )
38015 ABC7           B8                   009C  mov	ax,#$9C
38016 ABCA           50                         push	ax
38017                                           ! Debug: list int = const $40 (used reg = )
38018 ABCB           B8                   0040  mov	ax,*$40
38019 ABCE           50                         push	ax
38020                                           ! Debug: func () void = write_dword+0 (used reg = )
38021 ABCF           E8         54C9            call	_write_dword
38022 ABD2           83C4                   08  add	sp,*8
38023                                           !BCC_EOS
38024                                           ! 5421         }
38025                                           ! 5422       }
38026                       0000ABD5            .79E:
38027 ABD5           83C4                   08  add	sp,*8
38028                                           ! 5423     }
38029                       0000ABD8            .79A:
38030                                           ! 5424   }
38031                       0000ABD8            .798:
38032                                           ! 5425 #asm
38033                       0000ABD8            .794:
38034                                           !BCC_EOS
38035                                           !BCC_ASM
38036                       00000000            _int70_function.registerC	set	0
38037                       FFFFFFFE            .int70_function.registerC	set	-2
38038                       00000016            _int70_function.ds	set	$16
38039                       00000014            .int70_function.ds	set	$14
38040                       00000001            _int70_function.registerB	set	1
38041                       FFFFFFFF            .int70_function.registerB	set	-1
38042                       00000018            _int70_function.iret_addr	set	$18
38043                       00000016            .int70_function.iret_addr	set	$16
38044                       00000006            _int70_function.regs	set	6
38045                       00000004            .int70_function.regs	set	4
38046 ABD8           E8         03FC              call eoi_both_pics
38047                                           ! 5427 endasm
38048                                           !BCC_ENDASM
38049                                           !BCC_EOS
38050                                           ! 5428 }
38051 ABDB           89EC                       mov	sp,bp
38052 ABDD           5D                         pop	bp
38053 ABDE           C3                         ret
38054                                           ! 5429 #asm
38055                                           !BCC_ASM
38056                       00000012            _int70_function.ds	set	$12
38057                       00000014            _int70_function.iret_addr	set	$14
38058                       00000002            _int70_function.regs	set	2
38059                                           ;------------------------------------------
38060                                           ;- INT74h : PS/2 mouse hardware interrupt -
38061                                           ;------------------------------------------
38062                       0000ABDF            int74_handler:
38063 ABDF           FB                           sti
38064 ABE0           60                           pusha
38065 ABE1           1E                           push ds ;; save DS
38066 ABE2           6A                     00    push #0x00 ;; placeholder for status
38067 ABE4           6A                     00    push #0x00 ;; placeholder for X
38068 ABE6           6A                     00    push #0x00 ;; placeholder for Y
38069 ABE8           6A                     00    push #0x00 ;; placeholder for Z
38070 ABEA           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
38071 ABEC           E8         BCFD              call _int74_function
38072 ABEF           59                           pop cx ;; remove make_far_call from stack
38073 ABF0           E3           0C              jcxz int74_done
38074                                             ;; make far call to EBDA:0022
38075 ABF2           6A                     00    push #0x00
38076 ABF4           1F                           pop ds
38077 ABF5           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
38078 ABF9           1F                           pop ds
38079 ABFA           FF1E       0022              call far ptr[0x22]
38080                       0000ABFE            int74_done:
38081 ABFE           FA                           cli
38082 ABFF           E8         03D5              call eoi_both_pics
38083 AC02           83C4                   08    add sp, #8 ;; pop status, x, y, z
38084 AC05           1F                           pop ds ;; restore DS
38085 AC06           61                           popa
38086 AC07           CF                           iret
38087                                           ;; This will perform an IRET, but will retain value of current CF
38088                                           ;; by altering flags on stack. Better than RETF #02.
38089                       0000AC08            iret_modify_cf:
38090 AC08           72           09              jc carry_set
38091 AC0A           55                           push bp
38092 AC0B           89E5                         mov bp, sp
38093 AC0D           8066         06        FE    and BYTE [bp + 0x06], #0xfe
38094 AC11           5D                           pop bp
38095 AC12           CF                           iret
38096                       0000AC13            carry_set:
38097 AC13           55                           push bp
38098 AC14           89E5                         mov bp, sp
38099 AC16           804E         06        01    or BYTE [bp + 0x06], #0x01
38100 AC1A           5D                           pop bp
38101 AC1B           CF                           iret
38102                                           ;----------------------
38103                                           ;- INT13h (relocated) -
38104                                           ;----------------------
38105                                           ;
38106                                           ; int13_relocated is a little bit messed up since I played with it
38107                                           ; I have to rewrite it:
38108                                           ; - call a function that detect which function to call
38109                                           ; - make all called C function get the same parameters list
38110                                           ;
38111                       0000AC1C            int13_relocated:
38112                                             ;; check for an eltorito function
38113 AC1C           80FC                   4A    cmp ah,#0x4a
38114 AC1F           72           10              jb int13_not_eltorito
38115 AC21           80FC                   4D    cmp ah,#0x4d
38116 AC24           77           0B              ja int13_not_eltorito
38117 AC26           60                           pusha
38118 AC27           06                           push es
38119 AC28           1E                           push ds
38120 AC29           16                           push ss
38121 AC2A           1F                           pop ds
38122 AC2B           68                   ACA3    push #int13_out
38123 AC2E           E9         D8F4              jmp _int13_eltorito ;; ELDX not used
38124                       0000AC31            int13_not_eltorito:
38125 AC31           50                           push ax
38126 AC32           53                           push bx
38127 AC33           51                           push cx
38128 AC34           52                           push dx
38129                                             ;; check if emulation active
38130 AC35           E8         9389              call _cdemu_isactive
38131 AC38           3C                     00    cmp al,#0x00
38132 AC3A           74           2B              je int13_cdemu_inactive
38133                                             ;; check if access to the emulated drive
38134 AC3C           E8         93A9              call _cdemu_emulated_drive
38135 AC3F           5A                           pop dx
38136 AC40           52                           push dx
38137 AC41           38D0                         cmp al,dl ;; int13 on emulated drive
38138 AC43           75           0F              jne int13_nocdemu
38139 AC45           5A                           pop dx
38140 AC46           59                           pop cx
38141 AC47           5B                           pop bx
38142 AC48           58                           pop ax
38143 AC49           60                           pusha
38144 AC4A           06                           push es
38145 AC4B           1E                           push ds
38146 AC4C           16                           push ss
38147 AC4D           1F                           pop ds
38148 AC4E           68                   ACA3    push #int13_out
38149 AC51           E9         DB21              jmp _int13_cdemu ;; ELDX not used
38150                       0000AC54            int13_nocdemu:
38151 AC54           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
38152 AC57           38D0                         cmp al,dl ;; al is 0x00 or 0x80
38153 AC59           75           0C              jne int13_cdemu_inactive ;; inactive for device class
38154 AC5B           5A                           pop dx
38155 AC5C           59                           pop cx
38156 AC5D           5B                           pop bx
38157 AC5E           58                           pop ax
38158 AC5F           50                           push ax
38159 AC60           51                           push cx
38160 AC61           52                           push dx
38161 AC62           53                           push bx
38162 AC63           FECA                         dec dl ;; real drive is dl - 1
38163 AC65           EB           08              jmp int13_legacy
38164                       0000AC67            int13_cdemu_inactive:
38165 AC67           5A                           pop dx
38166 AC68           59                           pop cx
38167 AC69           5B                           pop bx
38168 AC6A           58                           pop ax
38169                       0000AC6B            int13_noeltorito:
38170 AC6B           50                           push ax
38171 AC6C           51                           push cx
38172 AC6D           52                           push dx
38173 AC6E           53                           push bx
38174                       0000AC6F            int13_legacy:
38175 AC6F           52                           push dx ;; push eltorito value of dx instead of sp
38176 AC70           55                           push bp
38177 AC71           56                           push si
38178 AC72           57                           push di
38179 AC73           06                           push es
38180 AC74           1E                           push ds
38181 AC75           16                           push ss
38182 AC76           1F                           pop ds
38183                                             ;; now the 16-bit registers can be restored with:
38184                                             ;; pop ds; pop es; popa; iret
38185                                             ;; arguments passed to functions should be
38186                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
38187 AC77           F6C2                   80    test dl, #0x80
38188 AC7A           75           06              jnz int13_notfloppy
38189 AC7C           68                   ACA3    push #int13_out
38190 AC7F           E9         E556              jmp _int13_diskette_function
38191                       0000AC82            int13_notfloppy:
38192 AC82           80FA                   E0    cmp dl, #0xE0
38193 AC85           72           0F              jb int13_notcdrom
38194 AC87     66    C1EB                   10    shr ebx, #16
38195 AC8B           53                           push bx
38196 AC8C           E8         CD67              call _int13_cdrom
38197 AC8F           5B                           pop bx
38198 AC90     66    C1E3                   10    shl ebx, #16
38199 AC94           EB           0D              jmp int13_out
38200                       0000AC96            int13_notcdrom:
38201                       0000AC96            int13_disk:
38202                                             ;; int13_harddisk modifies high word of EAX
38203 AC96     66    C1E8                   10    shr eax, #16
38204 AC9A           50                           push ax
38205 AC9B           E8         BD69              call _int13_harddisk
38206 AC9E           58                           pop ax
38207 AC9F     66    C1E0                   10    shl eax, #16
38208                       0000ACA3            int13_out:
38209 ACA3           1F                           pop ds
38210 ACA4           07                           pop es
38211 ACA5           61                           popa
38212 ACA6           CF                           iret
38213                                           ;----------
38214                                           ;- INT18h -
38215                                           ;----------
38216                       0000ACA7            int18_handler: ;; Boot Failure recovery: try the next device.
38217                                             ;; Reset SP and SS
38218 ACA7           B8                   0FFE    mov ax, #0x0ffe
38219 ACAA           89C4                         mov sp, ax
38220 ACAC           B8                   9E00    mov ax, #0x9e00
38221 ACAF           8ED0                         mov ss, ax
38222                                             ;; The first time we do this it will have been set to -1 so
38223                                             ;; we will start from device 0.
38224 ACB1           31C0                         xor ax, ax
38225 ACB3           8ED8                         mov ds, ax
38226 ACB5           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
38227 ACB9           8EDB                         mov ds, bx ;; Set segment
38228 ACBB           8B1E       0382              mov bx, 0x0382 ;; BX is now the sequence number
38229 ACBF           43                           inc bx ;; ++
38230 ACC0           891E       0382              mov 0x0382, bx ;; Write it back
38231 ACC4           8ED8                         mov ds, ax ;; and reset the segment to zero.
38232                                             ;; Call the C code for the next boot device
38233 ACC6           53                           push bx
38234 ACC7           E8         F7AC              call _int18_function
38235                                             ;; Boot failed: invoke the boot recovery function...
38236 ACCA           CD                     18    int #0x18
38237                                           ;----------
38238                                           ;- INT19h -
38239                                           ;----------
38240                       0000ACCC            int19_relocated: ;; Boot function, relocated
38241                                             ;;
38242                                             ;; *** Warning: INT 19h resets the whole machine ***
38243                                             ;;
38244                                             ;; Because PV drivers in HVM guests detach some of the emulated devices,
38245                                             ;; it is not safe to do a soft reboot by just dropping to real mode and
38246                                             ;; invoking INT 19h -- the boot drives might have disappeared!
38247                                             ;; If the user asks for a soft reboot, the only thing we can do is
38248                                             ;; reset the whole machine. When it comes back up, the normal BIOS
38249                                             ;; boot sequence will start, which is more or less the required behaviour.
38250                                             ;;
38251                                             ;; Reset SP and SS
38252 ACCC           B8                   0FFE    mov ax, #0x0ffe
38253 ACCF           89C4                         mov sp, ax
38254 ACD1           B8                   9E00    mov ax, #0x9e00
38255 ACD4           8ED0                         mov ss, ax
38256 ACD6           E8         65EC              call _machine_reset
38257                                           ;----------
38258                                           ;- INT1Ch -
38259                                           ;----------
38260                       0000ACD9            int1c_handler: ;; User Timer Tick
38261 ACD9           CF                           iret
38262                                           ;----------------------
38263                                           ;- POST: Floppy Drive -
38264                                           ;----------------------
38265                       0000ACDA            floppy_drive_post:
38266 ACDA           31C0                         xor ax, ax
38267 ACDC           8ED8                         mov ds, ax
38268 ACDE           B0                     00    mov al, #0x00
38269 ACE0           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
38270 ACE3           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
38271 ACE6           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
38272 ACE9           A2         0441              mov 0x0441, al ;; diskette controller status return code
38273 ACEC           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
38274 ACEF           A2         0443              mov 0x0443, al ;; diskette controller status register 1
38275 ACF2           A2         0444              mov 0x0444, al ;; diskette controller status register 2
38276 ACF5           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
38277 ACF8           A2         0446              mov 0x0446, al ;; diskette controller head number
38278 ACFB           A2         0447              mov 0x0447, al ;; diskette controller sector number
38279 ACFE           A2         0448              mov 0x0448, al ;; diskette controller bytes written
38280 AD01           A2         048B              mov 0x048b, al ;; diskette configuration data
38281                                             ;; -----------------------------------------------------------------
38282                                             ;; (048F) diskette controller information
38283                                             ;;
38284 AD04           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
38285 AD06           E6                     70    out 0x70, AL
38286 AD08           E4                     71    in AL, 0x71
38287 AD0A           88C4                         mov ah, al ;; save byte to AH
38288                       0000AD0C            look_drive0:
38289 AD0C           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
38290 AD0F           74           04              jz f0_missing ;; jump if no drive0
38291 AD11           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
38292 AD13           EB           02              jmp look_drive1
38293                       0000AD15            f0_missing:
38294 AD15           B3                     00    mov bl, #0x00 ;; no drive0
38295                       0000AD17            look_drive1:
38296 AD17           88E0                         mov al, ah ;; restore from AH
38297 AD19           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
38298 AD1B           74           03              jz f1_missing ;; jump if no drive1
38299 AD1D           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
38300                       0000AD20            f1_missing:
38301                                                              ;; leave high bits in BL zerod
38302 AD20           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
38303                                             ;; -----------------------------------------------------------------
38304 AD24           B0                     00    mov al, #0x00
38305 AD26           A2         0490              mov 0x0490, al ;; diskette 0 media state
38306 AD29           A2         0491              mov 0x0491, al ;; diskette 1 media state
38307                                                              ;; diskette 0,1 operational starting state
38308                                                              ;; drive type has not been determined,
38309                                                              ;; has no changed detection line
38310 AD2C           A2         0492              mov 0x0492, al
38311 AD2F           A2         0493              mov 0x0493, al
38312 AD32           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
38313 AD35           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
38314 AD38           B0                     02    mov al, #0x02
38315 AD3A           E6                     0A    out #0x0a, al ;; clear DMA-1 channel 2 mask bit
38316                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   AD3C           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   AD3F           A3         0078              mov 0x1E*4, ax
 +a   AD42           B8                   F000    mov ax,  #0xF000
 +a   AD45           A3         007A              mov 0x1E*4+2, ax
38317                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   AD48           B8                   EC59    mov ax,  #int13_diskette
 +a   AD4B           A3         0100              mov 0x40*4, ax
 +a   AD4E           B8                   F000    mov ax,  #0xF000
 +a   AD51           A3         0102              mov 0x40*4+2, ax
38318                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   AD54           B8                   EF57    mov ax,  #int0e_handler
 +a   AD57           A3         0038              mov 0x0E*4, ax
 +a   AD5A           B8                   F000    mov ax,  #0xF000
 +a   AD5D           A3         003A              mov 0x0E*4+2, ax
38319 AD60           C3                           ret
38320                                           ;--------------------
38321                                           ;- POST: HARD DRIVE -
38322                                           ;--------------------
38323                                           ; relocated here because the primary POST area isnt big enough.
38324                       0000AD61            hard_drive_post:
38325 AD61           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
38326 AD63           BA                   03F6    mov dx, #0x03f6
38327 AD66           EE                           out dx, al
38328 AD67           31C0                         xor ax, ax
38329 AD69           8ED8                         mov ds, ax
38330 AD6B           A2         0474              mov 0x0474, al
38331 AD6E           A2         0477              mov 0x0477, al
38332 AD71           A2         048C              mov 0x048c, al
38333 AD74           A2         048D              mov 0x048d, al
38334 AD77           A2         048E              mov 0x048e, al
38335 AD7A           B0                     01    mov al, #0x01
38336 AD7C           A2         0475              mov 0x0475, al
38337 AD7F           B0                     C0    mov al, #0xc0
38338 AD81           A2         0476              mov 0x0476, al
38339                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   AD84           B8                   E3FE    mov ax,  #int13_handler
 +a   AD87           A3         004C              mov 0x13*4, ax
 +a   AD8A           B8                   F000    mov ax,  #0xF000
 +a   AD8D           A3         004E              mov 0x13*4+2, ax
38340                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   AD90           B8                   B066    mov ax,  #int76_handler
 +a   AD93           A3         01D8              mov 0x76*4, ax
 +a   AD96           B8                   F000    mov ax,  #0xF000
 +a   AD99           A3         01DA              mov 0x76*4+2, ax
38341                                             ;; INT 41h: hard disk 0 configuration pointer
38342                                             ;; INT 46h: hard disk 1 configuration pointer
38343                                             SET_INT_VECTOR(0x41, word ptr [0x40E], #0x003D)
 +a   AD9C           B8                   003D    mov ax,  #0x003D
 +a   AD9F           A3         0104              mov 0x41*4, ax
 +a   ADA2           A1         040E              mov ax,  word ptr [0x40E]
 +a   ADA5           A3         0106              mov 0x41*4+2, ax
38344                                             SET_INT_VECTOR(0x46, word ptr [0x40E], #0x004D)
 +a   ADA8           B8                   004D    mov ax,  #0x004D
 +a   ADAB           A3         0118              mov 0x46*4, ax
 +a   ADAE           A1         040E              mov ax,  word ptr [0x40E]
 +a   ADB1           A3         011A              mov 0x46*4+2, ax
38345                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
38346 ADB4           B0                     12    mov al, #0x12
38347 ADB6           E6                     70    out #0x70, al
38348 ADB8           E4                     71    in al, #0x71
38349 ADBA           24                     F0    and al, #0xf0
38350 ADBC           3C                     F0    cmp al, #0xf0
38351 ADBE           74           03              je post_d0_extended
38352 ADC0           E9         00D8              jmp check_for_hd1
38353                       0000ADC3            post_d0_extended:
38354 ADC3           B0                     19    mov al, #0x19
38355 ADC5           E6                     70    out #0x70, al
38356 ADC7           E4                     71    in al, #0x71
38357 ADC9           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
38358 ADCB           74           07              je post_d0_type47
38359                                             HALT(9038)
 +a   ADCD           BA                   0400    mov dx,#0x400
 +a   ADD0           B8                   234E    mov ax,#9038
 +a   ADD3           EF                           out dx,ax
38360                       0000ADD4            post_d0_type47:
38361                                             ;; CMOS purpose param table offset
38362                                             ;; 1b cylinders low 0
38363                                             ;; 1c cylinders high 1
38364                                             ;; 1d heads 2
38365                                             ;; 1e write pre-comp low 5
38366                                             ;; 1f write pre-comp high 6
38367                                             ;; 20 retries/bad map/heads>8 8
38368                                             ;; 21 landing zone low C
38369                                             ;; 22 landing zone high D
38370                                             ;; 23 sectors/track E
38371 ADD4           31C0                         xor ax, ax
38372 ADD6           8ED8                         mov ds, ax
38373 ADD8           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
38374 ADDB           8ED8                         mov ds, ax
38375                                             ;;; Filling EBDA table for hard disk 0.
38376 ADDD           B0                     1F    mov al, #0x1f
38377 ADDF           E6                     70    out #0x70, al
38378 ADE1           E4                     71    in al, #0x71
38379 ADE3           88C4                         mov ah, al
38380 ADE5           B0                     1E    mov al, #0x1e
38381 ADE7           E6                     70    out #0x70, al
38382 ADE9           E4                     71    in al, #0x71
38383 ADEB           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
38384 ADEE           B0                     20    mov al, #0x20
38385 ADF0           E6                     70    out #0x70, al
38386 ADF2           E4                     71    in al, #0x71
38387 ADF4           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
38388 ADF7           B0                     22    mov al, #0x22
38389 ADF9           E6                     70    out #0x70, al
38390 ADFB           E4                     71    in al, #0x71
38391 ADFD           88C4                         mov ah, al
38392 ADFF           B0                     21    mov al, #0x21
38393 AE01           E6                     70    out #0x70, al
38394 AE03           E4                     71    in al, #0x71
38395 AE05           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
38396 AE08           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
38397 AE0A           E6                     70    out #0x70, al
38398 AE0C           E4                     71    in al, #0x71 ;; high byte
38399 AE0E           88C4                         mov ah, al
38400 AE10           B0                     1B    mov al, #0x1b
38401 AE12           E6                     70    out #0x70, al
38402 AE14           E4                     71    in al, #0x71 ;; low byte
38403 AE16           89C3                         mov bx, ax ;; BX = cylinders
38404 AE18           B0                     1D    mov al, #0x1d
38405 AE1A           E6                     70    out #0x70, al
38406 AE1C           E4                     71    in al, #0x71
38407 AE1E           88C1                         mov cl, al ;; CL = heads
38408 AE20           B0                     23    mov al, #0x23
38409 AE22           E6                     70    out #0x70, al
38410 AE24           E4                     71    in al, #0x71
38411 AE26           88C2                         mov dl, al ;; DL = sectors
38412 AE28           81FB                 0400    cmp bx, #1024
38413 AE2C           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
38414                       0000AE2E            hd0_post_physical_chs:
38415                                             ;; no logical CHS mapping used, just physical CHS
38416                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
38417 AE2E           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
38418 AE32           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
38419 AE36           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
38420 AE3A           EB           5F              jmp check_for_hd1
38421                       0000AE3C            hd0_post_logical_chs:
38422                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
38423 AE3C           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
38424 AE40           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
38425 AE44           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
38426 AE48           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
38427 AE4C           B0                     A0    mov al, #0xa0
38428 AE4E           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
38429 AE51           81FB                 0800    cmp bx, #2048
38430 AE55           77           06              jnbe hd0_post_above_2048
38431                                             ;; 1024 < c <= 2048 cylinders
38432 AE57           D1EB                         shr bx, #0x01
38433 AE59           D0E1                         shl cl, #0x01
38434 AE5B           EB           22              jmp hd0_post_store_logical
38435                       0000AE5D            hd0_post_above_2048:
38436 AE5D           81FB                 1000    cmp bx, #4096
38437 AE61           77           08              jnbe hd0_post_above_4096
38438                                             ;; 2048 < c <= 4096 cylinders
38439 AE63           C1EB                   02    shr bx, #0x02
38440 AE66           C0E1                   02    shl cl, #0x02
38441 AE69           EB           14              jmp hd0_post_store_logical
38442                       0000AE6B            hd0_post_above_4096:
38443 AE6B           81FB                 2000    cmp bx, #8192
38444 AE6F           77           08              jnbe hd0_post_above_8192
38445                                             ;; 4096 < c <= 8192 cylinders
38446 AE71           C1EB                   03    shr bx, #0x03
38447 AE74           C0E1                   03    shl cl, #0x03
38448 AE77           EB           06              jmp hd0_post_store_logical
38449                       0000AE79            hd0_post_above_8192:
38450                                             ;; 8192 < c <= 16384 cylinders
38451 AE79           C1EB                   04    shr bx, #0x04
38452 AE7C           C0E1                   04    shl cl, #0x04
38453                       0000AE7F            hd0_post_store_logical:
38454 AE7F           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
38455 AE83           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
38456                                             ;; checksum
38457 AE87           B1                     0F    mov cl, #0x0f ;; repeat count
38458 AE89           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
38459 AE8C           B0                     00    mov al, #0x00 ;; sum
38460                       0000AE8E            hd0_post_checksum_loop:
38461 AE8E           0204                         add al, [si]
38462 AE90           46                           inc si
38463 AE91           FEC9                         dec cl
38464 AE93           75           F9              jnz hd0_post_checksum_loop
38465 AE95           F6D0                         not al ;; now take 2s complement
38466 AE97           FEC0                         inc al
38467 AE99           8804                         mov [si], al
38468                                           ;;; Done filling EBDA table for hard disk 0.
38469                       0000AE9B            check_for_hd1:
38470                                             ;; is there really a second hard disk? if not, return now
38471 AE9B           B0                     12    mov al, #0x12
38472 AE9D           E6                     70    out #0x70, al
38473 AE9F           E4                     71    in al, #0x71
38474 AEA1           24                     0F    and al, #0x0f
38475 AEA3           75           01              jnz post_d1_exists
38476 AEA5           C3                           ret
38477                       0000AEA6            post_d1_exists:
38478                                             ;; check that the hd type is really 0x0f.
38479 AEA6           3C                     0F    cmp al, #0x0f
38480 AEA8           74           07              jz post_d1_extended
38481                                             HALT(9177)
 +a   AEAA           BA                   0400    mov dx,#0x400
 +a   AEAD           B8                   23D9    mov ax,#9177
 +a   AEB0           EF                           out dx,ax
38482                       0000AEB1            post_d1_extended:
38483                                             ;; check that the extended type is 47 - user definable
38484 AEB1           B0                     1A    mov al, #0x1a
38485 AEB3           E6                     70    out #0x70, al
38486 AEB5           E4                     71    in al, #0x71
38487 AEB7           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
38488 AEB9           74           07              je post_d1_type47
38489                                             HALT(9185)
 +a   AEBB           BA                   0400    mov dx,#0x400
 +a   AEBE           B8                   23E1    mov ax,#9185
 +a   AEC1           EF                           out dx,ax
38490                       0000AEC2            post_d1_type47:
38491                                             ;; Table for disk1.
38492                                             ;; CMOS purpose param table offset
38493                                             ;; 0x24 cylinders low 0
38494                                             ;; 0x25 cylinders high 1
38495                                             ;; 0x26 heads 2
38496                                             ;; 0x27 write pre-comp low 5
38497                                             ;; 0x28 write pre-comp high 6
38498                                             ;; 0x29 heads>8 8
38499                                             ;; 0x2a landing zone low C
38500                                             ;; 0x2b landing zone high D
38501                                             ;; 0x2c sectors/track E
38502                                           ;;; Fill EBDA table for hard disk 1.
38503 AEC2           31C0                         xor ax, ax
38504 AEC4           8ED8                         mov ds, ax
38505 AEC6           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
38506 AEC9           8ED8                         mov ds, ax
38507 AECB           B0                     28    mov al, #0x28
38508 AECD           E6                     70    out #0x70, al
38509 AECF           E4                     71    in al, #0x71
38510 AED1           88C4                         mov ah, al
38511 AED3           B0                     27    mov al, #0x27
38512 AED5           E6                     70    out #0x70, al
38513 AED7           E4                     71    in al, #0x71
38514 AED9           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
38515 AEDC           B0                     29    mov al, #0x29
38516 AEDE           E6                     70    out #0x70, al
38517 AEE0           E4                     71    in al, #0x71
38518 AEE2           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
38519 AEE5           B0                     2B    mov al, #0x2b
38520 AEE7           E6                     70    out #0x70, al
38521 AEE9           E4                     71    in al, #0x71
38522 AEEB           88C4                         mov ah, al
38523 AEED           B0                     2A    mov al, #0x2a
38524 AEEF           E6                     70    out #0x70, al
38525 AEF1           E4                     71    in al, #0x71
38526 AEF3           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
38527 AEF6           B0                     25    mov al, #0x25 ;; get cylinders word in AX
38528 AEF8           E6                     70    out #0x70, al
38529 AEFA           E4                     71    in al, #0x71 ;; high byte
38530 AEFC           88C4                         mov ah, al
38531 AEFE           B0                     24    mov al, #0x24
38532 AF00           E6                     70    out #0x70, al
38533 AF02           E4                     71    in al, #0x71 ;; low byte
38534 AF04           89C3                         mov bx, ax ;; BX = cylinders
38535 AF06           B0                     26    mov al, #0x26
38536 AF08           E6                     70    out #0x70, al
38537 AF0A           E4                     71    in al, #0x71
38538 AF0C           88C1                         mov cl, al ;; CL = heads
38539 AF0E           B0                     2C    mov al, #0x2c
38540 AF10           E6                     70    out #0x70, al
38541 AF12           E4                     71    in al, #0x71
38542 AF14           88C2                         mov dl, al ;; DL = sectors
38543 AF16           81FB                 0400    cmp bx, #1024
38544 AF1A           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
38545                       0000AF1C            hd1_post_physical_chs:
38546                                             ;; no logical CHS mapping used, just physical CHS
38547                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
38548 AF1C           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
38549 AF20           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
38550 AF24           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
38551 AF28           C3                           ret
38552                       0000AF29            hd1_post_logical_chs:
38553                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
38554 AF29           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
38555 AF2D           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
38556 AF31           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
38557 AF35           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
38558 AF39           B0                     A0    mov al, #0xa0
38559 AF3B           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
38560 AF3E           81FB                 0800    cmp bx, #2048
38561 AF42           77           06              jnbe hd1_post_above_2048
38562                                             ;; 1024 < c <= 2048 cylinders
38563 AF44           D1EB                         shr bx, #0x01
38564 AF46           D0E1                         shl cl, #0x01
38565 AF48           EB           22              jmp hd1_post_store_logical
38566                       0000AF4A            hd1_post_above_2048:
38567 AF4A           81FB                 1000    cmp bx, #4096
38568 AF4E           77           08              jnbe hd1_post_above_4096
38569                                             ;; 2048 < c <= 4096 cylinders
38570 AF50           C1EB                   02    shr bx, #0x02
38571 AF53           C0E1                   02    shl cl, #0x02
38572 AF56           EB           14              jmp hd1_post_store_logical
38573                       0000AF58            hd1_post_above_4096:
38574 AF58           81FB                 2000    cmp bx, #8192
38575 AF5C           77           08              jnbe hd1_post_above_8192
38576                                             ;; 4096 < c <= 8192 cylinders
38577 AF5E           C1EB                   03    shr bx, #0x03
38578 AF61           C0E1                   03    shl cl, #0x03
38579 AF64           EB           06              jmp hd1_post_store_logical
38580                       0000AF66            hd1_post_above_8192:
38581                                             ;; 8192 < c <= 16384 cylinders
38582 AF66           C1EB                   04    shr bx, #0x04
38583 AF69           C0E1                   04    shl cl, #0x04
38584                       0000AF6C            hd1_post_store_logical:
38585 AF6C           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
38586 AF70           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
38587                                             ;; checksum
38588 AF74           B1                     0F    mov cl, #0x0f ;; repeat count
38589 AF76           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
38590 AF79           B0                     00    mov al, #0x00 ;; sum
38591                       0000AF7B            hd1_post_checksum_loop:
38592 AF7B           0204                         add al, [si]
38593 AF7D           46                           inc si
38594 AF7E           FEC9                         dec cl
38595 AF80           75           F9              jnz hd1_post_checksum_loop
38596 AF82           F6D0                         not al ;; now take 2s complement
38597 AF84           FEC0                         inc al
38598 AF86           8804                         mov [si], al
38599                                           ;;; Done filling EBDA table for hard disk 1.
38600 AF88           C3                           ret
38601                                           ;--------------------
38602                                           ;- POST: EBDA segment
38603                                           ;--------------------
38604                                           ; relocated here because the primary POST area isnt big enough.
38605                       0000AF89            ebda_post:
38606 AF89           B8                   9FC0    mov ax, #0x9FC0
38607 AF8C           8ED8                         mov ds, ax
38608 AF8E           C606       0000        01    mov byte ptr [0x0], #1
38609 AF93           31C0                         xor ax, ax ; mov EBDA seg into 40E
38610 AF95           8ED8                         mov ds, ax
38611 AF97           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
38612 AF9D           C3                           ret;;
38613                                           ;--------------------
38614                                           ;- POST: EOI + jmp via [0x40:67)
38615                                           ;--------------------
38616                                           ; relocated here because the primary POST area isnt big enough.
38617                       0000AF9E            eoi_jmp_post:
38618 AF9E           B0                     20    mov al, #0x20
38619 AFA0           E6                     A0    out #0xA0, al ;; slave PIC EOI
38620 AFA2           B0                     20    mov al, #0x20
38621 AFA4           E6                     20    out #0x20, al ;; master PIC EOI
38622                       0000AFA6            jmp_post_0x467:
38623 AFA6           31C0                         xor ax, ax
38624 AFA8           8ED8                         mov ds, ax
38625 AFAA           FF2E       0467              jmp far ptr [0x467]
38626                       0000AFAE            iret_post_0x467:
38627 AFAE           31C0                         xor ax, ax
38628 AFB0           8ED8                         mov ds, ax
38629 AFB2           8B26       0467              mov sp, [0x467]
38630 AFB6           8E16       0469              mov ss, [0x469]
38631 AFBA           CF                           iret
38632                       0000AFBB            retf_post_0x467:
38633 AFBB           31C0                         xor ax, ax
38634 AFBD           8ED8                         mov ds, ax
38635 AFBF           8B26       0467              mov sp, [0x467]
38636 AFC3           8E16       0469              mov ss, [0x469]
38637 AFC7           CB                           retf
38638                       0000AFC8            s3_post:
38639 AFC8           E8         6995              call _s3_resume
38640 AFCB           B3                     00    mov bl, #0x00
38641 AFCD           21C0                         and ax, ax
38642 AFCF   7503    E9         30D3              jz normal_post
38643 AFD4           E8         6362              call _s3_resume_panic
38644                                           ;--------------------
38645                       0000AFD7            eoi_both_pics:
38646 AFD7           B0                     20    mov al, #0x20
38647 AFD9           E6                     A0    out #0xA0, al ;; slave PIC EOI
38648                       0000AFDB            eoi_master_pic:
38649 AFDB           B0                     20    mov al, #0x20
38650 AFDD           E6                     20    out #0x20, al ;; master PIC EOI
38651 AFDF           C3                           ret
38652                                           ;--------------------
38653                       0000AFE0            BcdToBin:
38654                                             ;; in: AL in BCD format
38655                                             ;; out: AL in binary format, AH will always be 0
38656                                             ;; trashes BX
38657 AFE0           88C3                         mov bl, al
38658 AFE2           80E3                   0F    and bl, #0x0f ;; bl has low digit
38659 AFE5           C0E8                   04    shr al, #4 ;; al has high digit
38660 AFE8           B7                     0A    mov bh, #10
38661 AFEA           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
38662 AFEC           00D8                         add al, bl ;; then add low digit
38663 AFEE           C3                           ret
38664                                           ;--------------------
38665                       0000AFEF            timer_tick_post:
38666                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
38667                                             ;; Timer Ticks Roller Flag (0x470:byte)
38668                                             ;; The Timer Ticks Count needs to be set according to
38669                                             ;; the current CMOS time, as if ticks have been occurring
38670                                             ;; at 18.2hz since midnight up to this point. Calculating
38671                                             ;; this is a little complicated. Here are the factors I gather
38672                                             ;; regarding this. 14,318,180 hz was the original clock speed,
38673                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
38674                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
38675                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
38676                                             ;; the timer. With a maximum 16bit timer count, this is again
38677                                             ;; divided down by 65536 to 18.2hz.
38678                                             ;;
38679                                             ;; 14,318,180 Hz clock
38680                                             ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
38681                                             ;; /4 = 1,193,181 Hz fed to timer
38682                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
38683                                             ;; 1 second = 18.20650736 ticks
38684                                             ;; 1 minute = 1092.390442 ticks
38685                                             ;; 1 hour = 65543.42651 ticks
38686                                             ;;
38687                                             ;; Given the values in the CMOS clock, one could calculate
38688                                             ;; the number of ticks by the following:
38689                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
38690                                             ;; (BcdToBin(minutes) * 1092.3904)
38691                                             ;; (BcdToBin(hours) * 65543.427)
38692                                             ;; To get a little more accuracy, since Im using integer
38693                                             ;; arithmatic, I use:
38694                                             ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
38695                                             ;; (BcdToBin(minutes) * 10923904) / 10000 +
38696                                             ;; (BcdToBin(hours) * 65543427) / 1000
38697                                             ;; assuming DS=0000
38698                                             ;; get CMOS seconds
38699 AFEF     66    31C0                         xor eax, eax ;; clear EAX
38700 AFF2           B0                     00    mov al, #0x00
38701 AFF4           E6                     70    out #0x70, al
38702 AFF6           E4                     71    in al, #0x71 ;; AL has CMOS seconds in BCD
38703 AFF8           E8         FFE5              call BcdToBin ;; EAX now has seconds in binary
38704 AFFB     66    BA               0115CF2B    mov edx, #18206507
38705 B001     66    F7E2                         mul eax, edx
38706 B004     66    BB               000F4240    mov ebx, #1000000
38707 B00A     66    31D2                         xor edx, edx
38708 B00D     66    F7F3                         div eax, ebx
38709 B010     66    89C1                         mov ecx, eax ;; ECX will accumulate total ticks
38710                                             ;; get CMOS minutes
38711 B013     66    31C0                         xor eax, eax ;; clear EAX
38712 B016           B0                     02    mov al, #0x02
38713 B018           E6                     70    out #0x70, al
38714 B01A           E4                     71    in al, #0x71 ;; AL has CMOS minutes in BCD
38715 B01C           E8         FFC1              call BcdToBin ;; EAX now has minutes in binary
38716 B01F     66    BA               00A6AF80    mov edx, #10923904
38717 B025     66    F7E2                         mul eax, edx
38718 B028     66    BB               00002710    mov ebx, #10000
38719 B02E     66    31D2                         xor edx, edx
38720 B031     66    F7F3                         div eax, ebx
38721 B034     66    01C1                         add ecx, eax ;; add to total ticks
38722                                             ;; get CMOS hours
38723 B037     66    31C0                         xor eax, eax ;; clear EAX
38724 B03A           B0                     04    mov al, #0x04
38725 B03C           E6                     70    out #0x70, al
38726 B03E           E4                     71    in al, #0x71 ;; AL has CMOS hours in BCD
38727 B040           E8         FF9D              call BcdToBin ;; EAX now has hours in binary
38728 B043     66    BA               03E81D03    mov edx, #65543427
38729 B049     66    F7E2                         mul eax, edx
38730 B04C     66    BB               000003E8    mov ebx, #1000
38731 B052     66    31D2                         xor edx, edx
38732 B055     66    F7F3                         div eax, ebx
38733 B058     66    01C1                         add ecx, eax ;; add to total ticks
38734 B05B     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
38735 B060           30C0                         xor al, al
38736 B062           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
38737 B065           C3                           ret
38738                                           ;--------------------
38739                       0000B066            int76_handler:
38740                                             ;; record completion in BIOS task complete flag
38741 B066           50                           push ax
38742 B067           1E                           push ds
38743 B068           B8                   0040    mov ax, #0x0040
38744 B06B           8ED8                         mov ds, ax
38745 B06D           C706       008E      00FF    mov 0x008E, #0xff
38746 B073           E8         FF61              call eoi_both_pics
38747 B076           1F                           pop ds
38748 B077           58                           pop ax
38749 B078           CF                           iret
38750                                           ;--------------------
38751                                           use32 386
38752                       0000B079            apm32_out_str:
38753 B079           50                           push eax
38754 B07A           53                           push ebx
38755 B07B           89C3                         mov ebx, eax
38756                       0000B07D            apm32_out_str1:
38757 B07D           2E                           SEG CS
38758 B07E   67      8A07                         mov al, byte ptr [bx]
38759 B081           3C                     00    cmp al, #0
38760 B083           74           04              je apm32_out_str2
38761 B085           EE                           outb dx, al
38762 B086           43                           inc ebx
38763 B087           EB           F4              jmp apm32_out_str1
38764                       0000B089            apm32_out_str2:
38765 B089           5B                           pop ebx
38766 B08A           58                           pop eax
38767 B08B           C3                           ret
38768                       0000B08C            apm32_07_poweroff_str:
38769 B08C                        53              .ascii "Shutdown"
38770 B094                        00              db 0
38771                       0000B095            apm32_07_suspend_str:
38772 B095                        53              .ascii "Suspend"
38773 B09C                        00              db 0
38774                       0000B09D            apm32_07_standby_str:
38775 B09D                        53              .ascii "Standby"
38776 B0A4                        00              db 0
38777                       0000B0A5            _apm32_entry:
38778 B0A5     66    9C                           pushf
38779                                           ;-----------------
38780                                           ; APM interface disconnect
38781                       0000B0A7            apm32_04:
38782 B0A7           3C                     04    cmp al, #0x04
38783 B0A9           75           05              jne apm32_05
38784 B0AB           E9     000000A5              jmp apm32_ok
38785                                           ;-----------------
38786                                           ; APM cpu idle
38787                       0000B0B0            apm32_05:
38788 B0B0           3C                     05    cmp al, #0x05
38789 B0B2           75           0B              jne apm32_07
38790 B0B4     66    9C                           pushf ; XEN
38791 B0B6           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
38792 B0B7           F4                           hlt
38793 B0B8     66    9D                           popf ; XEN
38794 B0BA           E9     00000096              jmp apm32_ok
38795                                           ;-----------------
38796                                           ; APM Set Power State
38797                       0000B0BF            apm32_07:
38798 B0BF           3C                     07    cmp al, #0x07
38799 B0C1           75           52              jne apm32_08
38800 B0C3     66    83FB                   01    cmp bx, #1
38801 B0C7   7405    E9     00000087              jne apm32_ok
38802 B0CE     66    83F9                   03    cmp cx, #3
38803 B0D2           74           0E              je apm32_07_poweroff
38804 B0D4     66    83F9                   02    cmp cx, #2
38805 B0D8           74           19              je apm32_07_suspend
38806 B0DA     66    83F9                   01    cmp cx, #1
38807 B0DE           74           24              je apm32_07_standby
38808 B0E0           75           73              jne apm32_ok
38809                       0000B0E2            apm32_07_poweroff:
38810 B0E2           FA                           cli
38811 B0E3     66    BA                   8900    mov dx, #0x8900
38812 B0E7     66    B8                   B08C    mov ax, #apm32_07_poweroff_str
38813 B0EB           E8     FFFFFF89              call apm32_out_str
38814                       0000B0F0            apm32_07_1:
38815 B0F0           F4                           hlt
38816 B0F1           EB           FD              jmp apm32_07_1
38817                       0000B0F3            apm32_07_suspend:
38818 B0F3           52                           push edx
38819 B0F4     66    BA                   8900    mov dx, #0x8900
38820 B0F8     66    B8                   B095    mov ax, #apm32_07_suspend_str
38821 B0FC           E8     FFFFFF78              call apm32_out_str
38822 B101           5A                           pop edx
38823 B102           EB           51              jmp apm32_ok
38824                       0000B104            apm32_07_standby:
38825 B104           52                           push edx
38826 B105     66    BA                   8900    mov dx, #0x8900
38827 B109     66    B8                   B09D    mov ax, #apm32_07_standby_str
38828 B10D           E8     FFFFFF67              call apm32_out_str
38829 B112           5A                           pop edx
38830 B113           EB           40              jmp apm32_ok
38831                                           ;-----------------
38832                                           ; APM Enable / Disable
38833                       0000B115            apm32_08:
38834 B115           3C                     08    cmp al, #0x08
38835 B117           75           02              jne apm32_0a
38836 B119           EB           3A              jmp apm32_ok
38837                                           ;-----------------
38838                                           ; Get Power Status
38839                       0000B11B            apm32_0a:
38840 B11B           3C                     0A    cmp al, #0x0a
38841 B11D           75           12              jne apm32_0b
38842 B11F           B7                     01    mov bh, #0x01
38843 B121           B3                     FF    mov bl, #0xff
38844 B123           B5                     80    mov ch, #0x80
38845 B125           B1                     FF    mov cl, #0xff
38846 B127     66    BA                   FFFF    mov dx, #0xffff
38847 B12B     66    BE                   0000    mov si, #0
38848 B12F           EB           24              jmp apm32_ok
38849                                           ;-----------------
38850                                           ; Get PM Event
38851                       0000B131            apm32_0b:
38852 B131           3C                     0B    cmp al, #0x0b
38853 B133           75           04              jne apm32_0e
38854 B135           B4                     80    mov ah, #0x80
38855 B137           EB           20              jmp apm32_error
38856                                           ;-----------------
38857                                           ; APM Driver Version
38858                       0000B139            apm32_0e:
38859 B139           3C                     0E    cmp al, #0x0e
38860 B13B           75           06              jne apm32_0f
38861 B13D           B4                     01    mov ah, #1
38862 B13F           B0                     02    mov al, #2
38863 B141           EB           12              jmp apm32_ok
38864                                           ;-----------------
38865                                           ; APM Engage / Disengage
38866                       0000B143            apm32_0f:
38867 B143           3C                     0F    cmp al, #0x0f
38868 B145           75           02              jne apm32_10
38869 B147           EB           0C              jmp apm32_ok
38870                                           ;-----------------
38871                                           ; APM Get Capabilities
38872                       0000B149            apm32_10:
38873 B149           3C                     10    cmp al, #0x10
38874 B14B           75           0C              jne apm32_unimplemented
38875 B14D           B3                     00    mov bl, #0
38876 B14F     66    B9                   0000    mov cx, #0
38877 B153           EB           00              jmp apm32_ok
38878                                           ;-----------------
38879                       0000B155            apm32_ok:
38880 B155     66    9D                           popf
38881 B157           F8                           clc
38882 B158           CB                           retf
38883                       0000B159            apm32_unimplemented:
38884                       0000B159            apm32_error:
38885 B159     66    9D                           popf
38886 B15B           F9                           stc
38887 B15C           CB                           retf
38888                                           use16 386
38889                       0000B15D            apm16_out_str:
38890 B15D     66    50                           push eax
38891 B15F     66    53                           push ebx
38892 B161     66    89C3                         mov ebx, eax
38893                       0000B164            apm16_out_str1:
38894 B164           2E                           SEG CS
38895 B165           8A07                         mov al, byte ptr [bx]
38896 B167           3C                     00    cmp al, #0
38897 B169           74           05              je apm16_out_str2
38898 B16B           EE                           outb dx, al
38899 B16C     66    43                           inc ebx
38900 B16E           EB           F4              jmp apm16_out_str1
38901                       0000B170            apm16_out_str2:
38902 B170     66    5B                           pop ebx
38903 B172     66    58                           pop eax
38904 B174           C3                           ret
38905                       0000B175            apm16_07_poweroff_str:
38906 B175                        53              .ascii "Shutdown"
38907 B17D                        00              db 0
38908                       0000B17E            apm16_07_suspend_str:
38909 B17E                        53              .ascii "Suspend"
38910 B185                        00              db 0
38911                       0000B186            apm16_07_standby_str:
38912 B186                        53              .ascii "Standby"
38913 B18D                        00              db 0
38914                       0000B18E            _apm16_entry:
38915 B18E           9C                           pushf
38916                                           ;-----------------
38917                                           ; APM interface disconnect
38918                       0000B18F            apm16_04:
38919 B18F           3C                     04    cmp al, #0x04
38920 B191           75           03              jne apm16_05
38921 B193           E9         008D              jmp apm16_ok
38922                                           ;-----------------
38923                                           ; APM cpu idle
38924                       0000B196            apm16_05:
38925 B196           3C                     05    cmp al, #0x05
38926 B198           75           07              jne apm16_07
38927 B19A           9C                           pushf ; XEN
38928 B19B           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
38929 B19C           F4                           hlt
38930 B19D           9D                           popf ; XEN
38931 B19E           E9         0082              jmp apm16_ok
38932                                           ;-----------------
38933                                           ; APM Set Power State
38934                       0000B1A1            apm16_07:
38935 B1A1           3C                     07    cmp al, #0x07
38936 B1A3           75           41              jne apm16_08
38937 B1A5           83FB                   01    cmp bx, #1
38938 B1A8           75           79              jne apm16_ok
38939 B1AA           83F9                   03    cmp cx, #3
38940 B1AD           74           0C              je apm16_07_poweroff
38941 B1AF           83F9                   02    cmp cx, #2
38942 B1B2           74           14              je apm16_07_suspend
38943 B1B4           83F9                   01    cmp cx, #1
38944 B1B7           74           1E              je apm16_07_standby
38945 B1B9           75           68              jne apm16_ok
38946                       0000B1BB            apm16_07_poweroff:
38947 B1BB           FA                           cli
38948 B1BC           BA                   8900    mov dx, #0x8900
38949 B1BF           B8                   B175    mov ax, #apm16_07_poweroff_str
38950 B1C2           E8         FF98              call apm16_out_str
38951                       0000B1C5            apm16_07_1:
38952 B1C5           F4                           hlt
38953 B1C6           EB           FD              jmp apm16_07_1
38954                       0000B1C8            apm16_07_suspend:
38955 B1C8     66    52                           push edx
38956 B1CA           BA                   8900    mov dx, #0x8900
38957 B1CD           B8                   B17E    mov ax, #apm16_07_suspend_str
38958 B1D0           E8         FF8A              call apm16_out_str
38959 B1D3     66    5A                           pop edx
38960 B1D5           EB           4C              jmp apm16_ok
38961                       0000B1D7            apm16_07_standby:
38962 B1D7     66    52                           push edx
38963 B1D9           BA                   8900    mov dx, #0x8900
38964 B1DC           B8                   B186    mov ax, #apm16_07_standby_str
38965 B1DF           E8         FF7B              call apm16_out_str
38966 B1E2     66    5A                           pop edx
38967 B1E4           EB           3D              jmp apm16_ok
38968                                           ;-----------------
38969                                           ; APM Enable / Disable
38970                       0000B1E6            apm16_08:
38971 B1E6           3C                     08    cmp al, #0x08
38972 B1E8           75           02              jne apm16_0a
38973 B1EA           EB           37              jmp apm16_ok
38974                                           ;-----------------
38975                                           ; Get Power Status
38976                       0000B1EC            apm16_0a:
38977 B1EC           3C                     0A    cmp al, #0x0a
38978 B1EE           75           10              jne apm16_0b
38979 B1F0           B7                     01    mov bh, #0x01
38980 B1F2           B3                     FF    mov bl, #0xff
38981 B1F4           B5                     80    mov ch, #0x80
38982 B1F6           B1                     FF    mov cl, #0xff
38983 B1F8           BA                   FFFF    mov dx, #0xffff
38984 B1FB           BE                   0000    mov si, #0
38985 B1FE           EB           23              jmp apm16_ok
38986                                           ;-----------------
38987                                           ; Get PM Event
38988                       0000B200            apm16_0b:
38989 B200           3C                     0B    cmp al, #0x0b
38990 B202           75           04              jne apm16_0e
38991 B204           B4                     80    mov ah, #0x80
38992 B206           EB           1E              jmp apm16_error
38993                                           ;-----------------
38994                                           ; APM Driver Version
38995                       0000B208            apm16_0e:
38996 B208           3C                     0E    cmp al, #0x0e
38997 B20A           75           06              jne apm16_0f
38998 B20C           B4                     01    mov ah, #1
38999 B20E           B0                     02    mov al, #2
39000 B210           EB           11              jmp apm16_ok
39001                                           ;-----------------
39002                                           ; APM Engage / Disengage
39003                       0000B212            apm16_0f:
39004 B212           3C                     0F    cmp al, #0x0f
39005 B214           75           02              jne apm16_10
39006 B216           EB           0B              jmp apm16_ok
39007                                           ;-----------------
39008                                           ; APM Get Capabilities
39009                       0000B218            apm16_10:
39010 B218           3C                     10    cmp al, #0x10
39011 B21A           75           0A              jne apm16_unimplemented
39012 B21C           B3                     00    mov bl, #0
39013 B21E           B9                   0000    mov cx, #0
39014 B221           EB           00              jmp apm16_ok
39015                                           ;-----------------
39016                       0000B223            apm16_ok:
39017 B223           9D                           popf
39018 B224           F8                           clc
39019 B225           CB                           retf
39020                       0000B226            apm16_unimplemented:
39021                       0000B226            apm16_error:
39022 B226           9D                           popf
39023 B227           F9                           stc
39024 B228           CB                           retf
39025                       0000B229            apmreal_out_str:
39026 B229     66    50                           push eax
39027 B22B     66    53                           push ebx
39028 B22D     66    89C3                         mov ebx, eax
39029                       0000B230            apmreal_out_str1:
39030 B230           2E                           SEG CS
39031 B231           8A07                         mov al, byte ptr [bx]
39032 B233           3C                     00    cmp al, #0
39033 B235           74           05              je apmreal_out_str2
39034 B237           EE                           outb dx, al
39035 B238     66    43                           inc ebx
39036 B23A           EB           F4              jmp apmreal_out_str1
39037                       0000B23C            apmreal_out_str2:
39038 B23C     66    5B                           pop ebx
39039 B23E     66    58                           pop eax
39040 B240           C3                           ret
39041                       0000B241            apmreal_07_poweroff_str:
39042 B241                        53              .ascii "Shutdown"
39043 B249                        00              db 0
39044                       0000B24A            apmreal_07_suspend_str:
39045 B24A                        53              .ascii "Suspend"
39046 B251                        00              db 0
39047                       0000B252            apmreal_07_standby_str:
39048 B252                        53              .ascii "Standby"
39049 B259                        00              db 0
39050 B25A           9C                           pushf
39051                       0000B25B            _apmreal_entry:
39052                                           ;-----------------
39053                                           ; APM installation check
39054                       0000B25B            apmreal_00:
39055 B25B           3C                     00    cmp al, #0x00
39056 B25D           75           0E              jne apmreal_01
39057 B25F           B4                     01    mov ah, #1
39058 B261           B0                     02    mov al, #2
39059 B263           B7                     50    mov bh, #0x50
39060 B265           B3                     4D    mov bl, #0x4d
39061 B267           B9                   0003    mov cx, #0x3
39062 B26A           E9         00D0              jmp apmreal_ok
39063                                           ;-----------------
39064                                           ; APM real mode interface connect
39065                       0000B26D            apmreal_01:
39066 B26D           3C                     01    cmp al, #0x01
39067 B26F           75           03              jne apmreal_02
39068 B271           E9         00C9              jmp apmreal_ok
39069                                           ;-----------------
39070                                           ; APM 16 bit protected mode interface connect
39071                       0000B274            apmreal_02:
39072 B274           3C                     02    cmp al, #0x02
39073 B276           75           12              jne apmreal_03
39074 B278           BB                   B18E    mov bx, #_apm16_entry
39075 B27B           B8                   F000    mov ax, #0xf000
39076 B27E           BE                   FFF0    mov si, #0xfff0
39077 B281           B9                   F000    mov cx, #0xf000
39078 B284           BF                   FFF0    mov di, #0xfff0
39079 B287           E9         00B3              jmp apmreal_ok
39080                                           ;-----------------
39081                                           ; APM 32 bit protected mode interface connect
39082                       0000B28A            apmreal_03:
39083 B28A           3C                     03    cmp al, #0x03
39084 B28C           75           1B              jne apmreal_04
39085 B28E           B8                   F000    mov ax, #0xf000
39086 B291     66    BB               0000B0A5    mov ebx, #_apm32_entry
39087 B297           B9                   F000    mov cx, #0xf000
39088 B29A     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
39089 B2A0           BA                   F000    mov dx, #0xf000
39090 B2A3           BF                   FFF0    mov di, #0xfff0
39091 B2A6           E9         0094              jmp apmreal_ok
39092                                           ;-----------------
39093                                           ; APM interface disconnect
39094                       0000B2A9            apmreal_04:
39095 B2A9           3C                     04    cmp al, #0x04
39096 B2AB           75           03              jne apmreal_05
39097 B2AD           E9         008D              jmp apmreal_ok
39098                                           ;-----------------
39099                                           ; APM cpu idle
39100                       0000B2B0            apmreal_05:
39101 B2B0           3C                     05    cmp al, #0x05
39102 B2B2           75           07              jne apmreal_07
39103 B2B4           9C                           pushf ; XEN
39104 B2B5           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
39105 B2B6           F4                           hlt
39106 B2B7           9D                           popf ; XEN
39107 B2B8           E9         0082              jmp apmreal_ok
39108                                           ;-----------------
39109                                           ; APM Set Power State
39110                       0000B2BB            apmreal_07:
39111 B2BB           3C                     07    cmp al, #0x07
39112 B2BD           75           41              jne apmreal_08
39113 B2BF           83FB                   01    cmp bx, #1
39114 B2C2           75           79              jne apmreal_ok
39115 B2C4           83F9                   03    cmp cx, #3
39116 B2C7           74           0C              je apmreal_07_poweroff
39117 B2C9           83F9                   02    cmp cx, #2
39118 B2CC           74           14              je apmreal_07_suspend
39119 B2CE           83F9                   01    cmp cx, #1
39120 B2D1           74           1E              je apmreal_07_standby
39121 B2D3           75           68              jne apmreal_ok
39122                       0000B2D5            apmreal_07_poweroff:
39123 B2D5           FA                           cli
39124 B2D6           BA                   8900    mov dx, #0x8900
39125 B2D9           B8                   B241    mov ax, #apmreal_07_poweroff_str
39126 B2DC           E8         FF4A              call apmreal_out_str
39127                       0000B2DF            apmreal_07_1:
39128 B2DF           F4                           hlt
39129 B2E0           EB           FD              jmp apmreal_07_1
39130                       0000B2E2            apmreal_07_suspend:
39131 B2E2     66    52                           push edx
39132 B2E4           BA                   8900    mov dx, #0x8900
39133 B2E7           B8                   B24A    mov ax, #apmreal_07_suspend_str
39134 B2EA           E8         FF3C              call apmreal_out_str
39135 B2ED     66    5A                           pop edx
39136 B2EF           EB           4C              jmp apmreal_ok
39137                       0000B2F1            apmreal_07_standby:
39138 B2F1     66    52                           push edx
39139 B2F3           BA                   8900    mov dx, #0x8900
39140 B2F6           B8                   B252    mov ax, #apmreal_07_standby_str
39141 B2F9           E8         FF2D              call apmreal_out_str
39142 B2FC     66    5A                           pop edx
39143 B2FE           EB           3D              jmp apmreal_ok
39144                                           ;-----------------
39145                                           ; APM Enable / Disable
39146                       0000B300            apmreal_08:
39147 B300           3C                     08    cmp al, #0x08
39148 B302           75           02              jne apmreal_0a
39149 B304           EB           37              jmp apmreal_ok
39150                                           ;-----------------
39151                                           ; Get Power Status
39152                       0000B306            apmreal_0a:
39153 B306           3C                     0A    cmp al, #0x0a
39154 B308           75           10              jne apmreal_0b
39155 B30A           B7                     01    mov bh, #0x01
39156 B30C           B3                     FF    mov bl, #0xff
39157 B30E           B5                     80    mov ch, #0x80
39158 B310           B1                     FF    mov cl, #0xff
39159 B312           BA                   FFFF    mov dx, #0xffff
39160 B315           BE                   0000    mov si, #0
39161 B318           EB           23              jmp apmreal_ok
39162                                           ;-----------------
39163                                           ; Get PM Event
39164                       0000B31A            apmreal_0b:
39165 B31A           3C                     0B    cmp al, #0x0b
39166 B31C           75           04              jne apmreal_0e
39167 B31E           B4                     80    mov ah, #0x80
39168 B320           EB           20              jmp apmreal_error
39169                                           ;-----------------
39170                                           ; APM Driver Version
39171                       0000B322            apmreal_0e:
39172 B322           3C                     0E    cmp al, #0x0e
39173 B324           75           06              jne apmreal_0f
39174 B326           B4                     01    mov ah, #1
39175 B328           B0                     02    mov al, #2
39176 B32A           EB           11              jmp apmreal_ok
39177                                           ;-----------------
39178                                           ; APM Engage / Disengage
39179                       0000B32C            apmreal_0f:
39180 B32C           3C                     0F    cmp al, #0x0f
39181 B32E           75           02              jne apmreal_10
39182 B330           EB           0B              jmp apmreal_ok
39183                                           ;-----------------
39184                                           ; APM Get Capabilities
39185                       0000B332            apmreal_10:
39186 B332           3C                     10    cmp al, #0x10
39187 B334           75           0C              jne apmreal_unimplemented
39188 B336           B3                     00    mov bl, #0
39189 B338           B9                   0000    mov cx, #0
39190 B33B           EB           00              jmp apmreal_ok
39191                                           ;-----------------
39192                       0000B33D            apmreal_ok:
39193 B33D           9D                           popf
39194 B33E           F8                           clc
39195 B33F           E9         F8C6              jmp iret_modify_cf
39196                       0000B342            apmreal_unimplemented:
39197                       0000B342            apmreal_error:
39198 B342           9D                           popf
39199 B343           F9                           stc
39200 B344           E9         F8C1              jmp iret_modify_cf
39201 B347                  00000010                .align 16
39202                       0000B350            gdt_base:
39203 B350                      0000                .word 0,0
39204 B354                        00                .byte 0,0,0,0
39205                       0000B358            gdt_entry_pm_32bit_cs:
39206 B358                      FFFF                .word 0xffff, 0x0000
39207 B35C                        00                .byte 0x00, 0x9b, 0xcf, 0x00
39208                       0000B360            gdt_entry_pm_16bit_cs:
39209 B360                      FFFF                .word 0xffff, 0x0000
39210 B364                        0F                .byte 0xf0000 >> 16, 0x9b, 0x8f, 0x0
39211                       0000B368            gdt_entry_pm_32bit_ds:
39212 B368                      FFFF                .word 0xffff, 0x0000
39213 B36C                        00                .byte 0x0, 0x93, 0xcf, 0x0
39214                       0000B370            gdt_entry_pm_16bit_ds:
39215 B370                      FFFF                .word 0xffff, 0x0000
39216 B374                        00                .byte 0x0, 0x93, 0x8f, 0x0
39217                       0000B378            gdt_entry_end:
39218                       0000B378            protmode_gdtdesc:
39219 B378                      0027                .word (gdt_entry_end - gdt_base) - 1
39220 B37A                  000FB350                .long gdt_base | 0xf0000
39221                       0000B37E            realmode_gdtdesc:
39222 B37E                      FFFF                .word 0xffff
39223 B380                  00000000                .long 0x0
39224                       0000B384            Upcall:
39225                                               ; Do an upcall into 32 bit space
39226                                               ;
39227                                               ; Input:
39228                                               ; bx: index of function to call
39229                                               ; Ouput:
39230                                               ; dx, ax: 32 bit result of call (even if 'void' is expected)
39231                                               ; Save caller state, stack frame offsets listed below
39232 B384           9C                             pushf
39233 B385           FA                             cli
39234 B386           1E                             push ds
39235 B387           06                             push es
39236 B388           16                             push ss
39237 B389     66    54                             push esp
39238                                               ; Calculate protected-mode esp from ss:sp
39239 B38B     66    81E4             0000FFFF      and esp, #0xffff
39240 B392     66    31C0                           xor eax, eax
39241 B395           8CD0                           mov ax, ss
39242 B397     66    C1E0                   04      shl eax, #4
39243 B39B     66    01C4                           add esp, eax
39244                                               ; Switch to protected mode
39245 B39E           2E                             seg cs
39246 B39F         0F0116       B378                lgdt protmode_gdtdesc
39247 B3A4         0F20C0                           mov eax, cr0
39248 B3A7           0C                     01      or al, #0x1 ; protected mode on
39249 B3A9         0F22C0                           mov cr0, eax
39250 B3AC     66    EA     000FB3B4      0008      jmpf DWORD (0xf0000|upcall1), #(gdt_entry_pm_32bit_cs - gdt_base)
39251                       0000B3B4            upcall1:
39252                                               USE32
39253 B3B4     66    B8                   0018      mov ax, #(gdt_entry_pm_32bit_ds - gdt_base)
39254 B3B8           8ED8                           mov ds, ax
39255 B3BA           8EC0                           mov es, ax
39256 B3BC           8ED0                           mov ss, ax
39257                                               ; Marshal arguments and call 32-bit function
39258 B3BE           B9               00000008      mov ecx, #32/4
39259                       0000B3C3            upcall2:
39260 B3C3           FF7424       2A                push 32 -4+14[esp]
39261 B3C7           E2           FA                loop upcall2
39262 B3C9           A1     000EA014                mov eax, [0x000EA000 + 20]
39263 B3CE           FFD0                           call eax
39264 B3D0           83C4                   20      add esp, #32
39265 B3D3           89C1                           mov ecx, eax ; Result in ecx
39266                                               ; Restore real-mode stack pointer
39267 B3D5           31C0                           xor eax, eax
39268 B3D7     66    8B4424       04                mov ax, 4[esp]
39269 B3DC     66    89C3                           mov bx, ax ; Real-mode ss in bx
39270 B3DF           C1E0                   04      shl eax, 4
39271 B3E2           29C4                           sub esp, eax
39272                                               ; Return to real mode
39273 B3E4           EA     0000B3EB      0010      jmpf upcall3, #(gdt_entry_pm_16bit_cs - gdt_base)
39274                       0000B3EB            upcall3:
39275                                               USE16
39276 B3EB           B8                   0020      mov ax, #(gdt_entry_pm_16bit_ds - gdt_base)
39277 B3EE           8ED8                           mov ds, ax
39278 B3F0           8EC0                           mov es, ax
39279 B3F2           8ED0                           mov ss, ax
39280 B3F4         0F20C0                           mov eax, cr0
39281 B3F7           24                     FE      and al, #0xfe ; protected mode off
39282 B3F9         0F22C0                           mov cr0, eax
39283 B3FC           EA         B401      F000      jmpf upcall4, #0xf0000>>4
39284                       0000B401            upcall4:
39285 B401           2E                             seg cs
39286 B402         0F0116       B37E                lgdt realmode_gdtdesc
39287                                               ; Restore real-mode ss
39288 B407           8ED3                           mov ss, bx
39289                                               ; Convert result into dx:ax format
39290 B409     66    89C8                           mov eax, ecx
39291 B40C     66    C1C8                   10      ror eax, #16
39292 B410           89C2                           mov dx, ax
39293 B412     66    C1C8                   10      ror eax, #16
39294                                               ; Restore caller state and return
39295 B416     66    5C                             pop esp
39296 B418           5B                             pop bx ; skip ss
39297 B419           07                             pop es
39298 B41A           1F                             pop ds
39299 B41B           9D                             popf
39300 B41C           C3                             ret
39301                                           MACRO DoUpcall
39302                                               mov bx, #?1
39303                                               jmp Upcall
39304                                           MEND
39305                       0000B41D            _TCGInterruptHandler: DoUpcall(0)
 +a   B41D           BB                   0000      mov bx, #0
 +a   B420           E9         FF61                jmp Upcall
39306                       0000B423            _tcpa_acpi_init: DoUpcall(1)
 +a   B423           BB                   0001      mov bx, #1
 +a   B426           E9         FF5B                jmp Upcall
39307                       0000B429            _tcpa_extend_acpi_log: DoUpcall(2)
 +a   B429           BB                   0002      mov bx, #2
 +a   B42C           E9         FF55                jmp Upcall
39308                       0000B42F            _tcpa_calling_int19h: DoUpcall(3)
 +a   B42F           BB                   0003      mov bx, #3
 +a   B432           E9         FF4F                jmp Upcall
39309                       0000B435            _tcpa_returned_int19h: DoUpcall(4)
 +a   B435           BB                   0004      mov bx, #4
 +a   B438           E9         FF49                jmp Upcall
39310                       0000B43B            _tcpa_add_event_separators: DoUpcall(5)
 +a   B43B           BB                   0005      mov bx, #5
 +a   B43E           E9         FF43                jmp Upcall
39311                       0000B441            _tcpa_wake_event: DoUpcall(6)
 +a   B441           BB                   0006      mov bx, #6
 +a   B444           E9         FF3D                jmp Upcall
39312                       0000B447            _tcpa_add_bootdevice: DoUpcall(7)
 +a   B447           BB                   0007      mov bx, #7
 +a   B44A           E9         FF37                jmp Upcall
39313                       0000B44D            _tcpa_start_option_rom_scan: DoUpcall(8)
 +a   B44D           BB                   0008      mov bx, #8
 +a   B450           E9         FF31                jmp Upcall
39314                       0000B453            _tcpa_option_rom: DoUpcall(9)
 +a   B453           BB                   0009      mov bx, #9
 +a   B456           E9         FF2B                jmp Upcall
39315                       0000B459            _tcpa_ipl: DoUpcall(10)
 +a   B459           BB                   000A      mov bx, #10
 +a   B45C           E9         FF25                jmp Upcall
39316                       0000B45F            _tcpa_measure_post: DoUpcall(11)
 +a   B45F           BB                   000B      mov bx, #11
 +a   B462           E9         FF1F                jmp Upcall
39317                       0000B465            _tcpa_initialize_tpm: DoUpcall(12)
 +a   B465           BB                   000C      mov bx, #12
 +a   B468           E9         FF19                jmp Upcall
39318                       0000B46B            _get_s3_waking_vector: DoUpcall(13)
 +a   B46B           BB                   000D      mov bx, #13
 +a   B46E           E9         FF13                jmp Upcall
39319                       0000B471            _pmm: DoUpcall(14)
 +a   B471           BB                   000E      mov bx, #14
 +a   B474           E9         FF0D                jmp Upcall
39320                                           ! 6691 endasm
39321                                           !BCC_ENDASM
39322                                           ! 6692 #asm
39323                                           !BCC_ASM
39324                       00000012            _int70_function.ds	set	$12
39325                       00000014            _int70_function.iret_addr	set	$14
39326                       00000002            _int70_function.regs	set	2
39327                                           MACRO POST_MEASURE
39328                                            push word #0x000f
39329                                            push #?2
39330                                            push word #0x000f
39331                                            push #?1
39332                                            call _tcpa_measure_post
39333                                            add sp, #8
39334                                           MEND
39335                                           ! 6701 endasm
39336                                           !BCC_ENDASM
39337                                           ! 6702 void
39338                                           ! Register BX used in function int70_function
39339                                           ! 6703 tcpa_do_measure_POSTs()
39340                                           ! 6704 {
39341                                           export	_tcpa_do_measure_POSTs
39342                       0000B477            _tcpa_do_measure_POSTs:
39343                                           ! 6705 #asm
39344                                           !BCC_ASM
39345                                            POST_MEASURE(post, nmi)
 +a   B477           6A                     0F   push word #0x000f
 +a   B479           68                   E2C3   push # nmi
 +a   B47C           6A                     0F   push word #0x000f
 +a   B47E           68                   E05B   push #post
 +a   B481           E8         FFDB             call _tcpa_measure_post
 +a   B484           83C4                   08   add sp, #8
39346                                            POST_MEASURE(floppy_drive_post, hard_drive_post)
 +a   B487           6A                     0F   push word #0x000f
 +a   B489           68                   AD61   push # hard_drive_post
 +a   B48C           6A                     0F   push word #0x000f
 +a   B48E           68                   ACDA   push #floppy_drive_post
 +a   B491           E8         FFCB             call _tcpa_measure_post
 +a   B494           83C4                   08   add sp, #8
39347                                            POST_MEASURE(hard_drive_post, ebda_post)
 +a   B497           6A                     0F   push word #0x000f
 +a   B499           68                   AF89   push # ebda_post
 +a   B49C           6A                     0F   push word #0x000f
 +a   B49E           68                   AD61   push #hard_drive_post
 +a   B4A1           E8         FFBB             call _tcpa_measure_post
 +a   B4A4           83C4                   08   add sp, #8
39348                                            POST_MEASURE(ebda_post, eoi_jmp_post)
 +a   B4A7           6A                     0F   push word #0x000f
 +a   B4A9           68                   AF9E   push # eoi_jmp_post
 +a   B4AC           6A                     0F   push word #0x000f
 +a   B4AE           68                   AF89   push #ebda_post
 +a   B4B1           E8         FFAB             call _tcpa_measure_post
 +a   B4B4           83C4                   08   add sp, #8
39349                                            POST_MEASURE(eoi_jmp_post, timer_tick_post)
 +a   B4B7           6A                     0F   push word #0x000f
 +a   B4B9           68                   AFEF   push # timer_tick_post
 +a   B4BC           6A                     0F   push word #0x000f
 +a   B4BE           68                   AF9E   push #eoi_jmp_post
 +a   B4C1           E8         FF9B             call _tcpa_measure_post
 +a   B4C4           83C4                   08   add sp, #8
39350                                            POST_MEASURE(timer_tick_post, int76_handler)
 +a   B4C7           6A                     0F   push word #0x000f
 +a   B4C9           68                   B066   push # int76_handler
 +a   B4CC           6A                     0F   push word #0x000f
 +a   B4CE           68                   AFEF   push #timer_tick_post
 +a   B4D1           E8         FF8B             call _tcpa_measure_post
 +a   B4D4           83C4                   08   add sp, #8
39351 B4D7           C3                          ret
39352                                           ! 6713 endasm
39353                                           !BCC_ENDASM
39354                                           ! 6714 }
39355 B4D8           C3                         ret
39356                                           ! 6715   void
39357                                           ! 6716 int1a_function32(regs, ES, DS, FLAGS)
39358                                           ! 6717   pushad_regs_t regs;
39359                                           export	_int1a_function32
39360                       0000B4D9            _int1a_function32:
39361                                           !BCC_EOS
39362                                           ! 6718   Bit16u ES, DS, FLAGS;
39363                                           !BCC_EOS
39364                                           ! 6719 {
39365                                           ! 6720  Bit16u rc;
39366                                           !BCC_EOS
39367                                           ! 6721  ;
39368 B4D9           55                         push	bp
39369 B4DA           89E5                       mov	bp,sp
39370 B4DC           4C                         dec	sp
39371 B4DD           4C                         dec	sp
39372                                           !BCC_EOS
39373                                           ! 6722  switch (regs.u.r8.ah) {
39374 B4DE           8A46         21            mov	al,$21[bp]
39375 B4E1           E9         00BC            br 	.7A1
39376                                           ! 6723  case 0xbb:
39377                                           ! 6724   if (regs.u.r8.al != 0 &&
39378                       0000B4E4            .7A2:
39379                                           ! 6725       regs.u.r32.ebx != 0x41504354L) {
39380                                           ! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
39381 B4E4           8A46         20            mov	al,$20[bp]
39382 B4E7           84C0                       test	al,al
39383 B4E9           74           25            je  	.7A3
39384                       0000B4EB            .7A5:
39385                                           ! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
39386                                           ! Debug: expression subtree swapping
39387 B4EB           B8                   4354  mov	ax,#$4354
39388 B4EE           BB                   4150  mov	bx,#$4150
39389 B4F1           53                         push	bx
39390 B4F2           50                         push	ax
39391 B4F3           8B46         14            mov	ax,$14[bp]
39392 B4F6           8B5E         16            mov	bx,$16[bp]
39393 B4F9           8D7E         FA            lea	di,-2+..FFD9[bp]
39394 B4FC           E8         4BCC            call	lcmpul
39395 B4FF           8D66         FE            lea	sp,2+..FFD9[bp]
39396 B502           74           0C            je  	.7A3
39397                       0000B504            .7A4:
39398                                           ! 6726       FLAGS |= 0x0001;
39399                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
39400 B504           8B46         28            mov	ax,$28[bp]
39401 B507           0C                     01  or	al,*1
39402 B509           8946         28            mov	$28[bp],ax
39403                                           !BCC_EOS
39404                                           ! 6727       return;
39405 B50C           89EC                       mov	sp,bp
39406 B50E           5D                         pop	bp
39407 B50F           C3                         ret
39408                                           !BCC_EOS
39409                                           ! 6728   }
39410                                           ! 6729   switch(regs.u.r8.al) {
39411                       0000B510            .7A3:
39412 B510           8A46         20            mov	al,$20[bp]
39413 B513           EB           58            jmp .7A8
39414                                           ! 6730   case 0x00:
39415                                           ! 6731   case 0x01:
39416                       0000B515            .7A9:
39417                                           ! 6732   case 0x02:
39418                       0000B515            .7AA:
39419                                           ! 6733   case 0x03:
39420                       0000B515            .7AB:
39421                                           ! 6734   case 0x04:
39422                       0000B515            .7AC:
39423                                           ! 6735   case 0x05:
39424                       0000B515            .7AD:
39425                                           ! 6736   case 0x06:
39426                       0000B515            .7AE:
39427                                           ! 6737   case 0x07:
39428                       0000B515            .7AF:
39429                                           ! 6738    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
39430                       0000B515            .7B0:
39431                                           ! 6739                        ES, DS,
39432                                           ! 6740                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
39433                                           ! Debug: expression subtree swapping
39434                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
39435 B515           E8         5135            call	_get_SS
39436                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
39437 B518           31DB                       xor	bx,bx
39438                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
39439 B51A           BF                   0004  mov	di,*4
39440 B51D           E8         4C27            call	lslul
39441 B520           53                         push	bx
39442 B521           50                         push	ax
39443                                           ! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
39444 B522           89E8                       mov	ax,bp
39445 B524           05                   0028  add	ax,*$28
39446 B527           31DB                       xor	bx,bx
39447                                           ! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
39448 B529           8D7E         FA            lea	di,-2+..FFD9[bp]
39449 B52C           E8         4B94            call	laddul
39450 B52F           83C4                   04  add	sp,*4
39451                                           ! Debug: list unsigned long = bx+0 (used reg = )
39452 B532           53                         push	bx
39453 B533           50                         push	ax
39454                                           ! Debug: list unsigned short DS = [S+8+$24] (used reg = )
39455 B534           FF76         26            push	$26[bp]
39456                                           ! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
39457 B537           FF76         24            push	$24[bp]
39458                                           ! Debug: expression subtree swapping
39459                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
39460 B53A           E8         5110            call	_get_SS
39461                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
39462 B53D           31DB                       xor	bx,bx
39463                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
39464 B53F           BF                   0004  mov	di,*4
39465 B542           E8         4C02            call	lslul
39466 B545           53                         push	bx
39467 B546           50                         push	ax
39468                                           ! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
39469 B547           89E8                       mov	ax,bp
39470 B549           05                   0004  add	ax,*4
39471 B54C           31DB                       xor	bx,bx
39472                                           ! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
39473 B54E           8D7E         F2            lea	di,-$A+..FFD9[bp]
39474 B551           E8         4B6F            call	laddul
39475 B554           83C4                   04  add	sp,*4
39476                                           ! Debug: list unsigned long = bx+0 (used reg = )
39477 B557           53                         push	bx
39478 B558           50                         push	ax
39479                                           ! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
39480 B559           E8         FEC1            call	_TCGInterruptHandler
39481 B55C           89D3                       mov	bx,dx
39482 B55E           83C4                   0C  add	sp,*$C
39483                                           !BCC_EOS
39484                                           ! 6741    break;
39485 B561           EB           2F            jmp .7A6
39486                                           !BCC_EOS
39487                                           ! 6742   default:
39488                                           ! 6743    FLAGS |= 0x0001;
39489                       0000B563            .7B1:
39490                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
39491 B563           8B46         28            mov	ax,$28[bp]
39492 B566           0C                     01  or	al,*1
39493 B568           8946         28            mov	$28[bp],ax
39494                                           !BCC_EOS
39495                                           ! 6744   }
39496                                           ! 6745   break;
39497 B56B           EB           25            jmp .7A6
39498                       0000B56D            .7A8:
39499 B56D           2C                     00  sub	al,*0
39500 B56F           72           F2            jb 	.7B1
39501 B571           3C                     07  cmp	al,*7
39502 B573           77           1B            ja  	.7B2
39503 B575           30E4                       xor	ah,ah
39504 B577           D1E0                       shl	ax,*1
39505 B579           89C3                       mov	bx,ax
39506 B57B           2E                         seg	cs
39507 B57C           FFA7       B580            br	.7B3[bx]
39508                       0000B580            .7B3:
39509 B580                      B515            .word	.7A9
39510 B582                      B515            .word	.7AA
39511 B584                      B515            .word	.7AB
39512 B586                      B515            .word	.7AC
39513 B588                      B515            .word	.7AD
39514 B58A                      B515            .word	.7AE
39515 B58C                      B515            .word	.7AF
39516 B58E                      B515            .word	.7B0
39517                       0000B590            .7B2:
39518 B590           EB           D1            jmp	.7B1
39519                       0000B592            .7A6:
39520 B592           EB           14            jmp .79F
39521                                           !BCC_EOS
39522                                           ! 6746  default:
39523                                           ! 6747   FLAGS |= 0x0001;
39524                       0000B594            .7B4:
39525                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
39526 B594           8B46         28            mov	ax,$28[bp]
39527 B597           0C                     01  or	al,*1
39528 B599           8946         28            mov	$28[bp],ax
39529                                           !BCC_EOS
39530                                           ! 6748   break;
39531 B59C           EB           0A            jmp .79F
39532                                           !BCC_EOS
39533                                           ! 6749  }
39534                                           ! 6750  ;
39535 B59E           EB           08            jmp .79F
39536                       0000B5A0            .7A1:
39537 B5A0           2C                     BB  sub	al,#$BB
39538 B5A2         0F84         FF3E            beq 	.7A2
39539 B5A6           EB           EC            jmp	.7B4
39540                       0000B5A8            .79F:
39541                       FFFFFFFC            ..FFD9	=	-4
39542                                           !BCC_EOS
39543                                           ! 6751 }
39544 B5A8           89EC                       mov	sp,bp
39545 B5AA           5D                         pop	bp
39546 B5AB           C3                         ret
39547                                           ! 6752 #asm
39548                                           !BCC_ASM
39549                       00000026            _int1a_function32.FLAGS	set	$26
39550                       00000024            _int1a_function32.DS	set	$24
39551                       00000022            _int1a_function32.ES	set	$22
39552                       00000002            _int1a_function32.regs	set	2
39553                                           ;--------------------
39554                                           use32 386
39555 B5AC                  00000010            .align 16
39556                       0000B5B0            bios32_structure:
39557 B5B0                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
39558 B5B4                      B5C0              dw bios32_entry_point, 0xf ;; 32 bit physical address
39559 B5B8                        00              db 0 ;; revision level
39560                                             ;; length in paragraphs and checksum stored in a word to prevent errors
39561 B5B9                      5801              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
39562 B5BB                        00              db 0,0,0,0,0 ;; reserved
39563 B5C0                  00000010            .align 16
39564                       0000B5C0            bios32_entry_point:
39565 B5C0           9C                           pushfd
39566 B5C1           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
39567 B5C6           75           29              jne unknown_service
39568 B5C8           B8               80000000    mov eax, #0x80000000
39569 B5CD     66    BA                   0CF8    mov dx, #0x0cf8
39570 B5D1           EF                           out dx, eax
39571 B5D2     66    BA                   0CFC    mov dx, #0x0cfc
39572 B5D6           ED                           in eax, dx
39573 B5D7           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
39574 B5DC           75           13              jne unknown_service
39575 B5DE           BB               000F0000    mov ebx, #0x000f0000
39576 B5E3           B9               00000000    mov ecx, #0
39577 B5E8           BA               0000B600    mov edx, #pcibios_protected
39578 B5ED           30C0                         xor al, al
39579 B5EF           EB           02              jmp bios32_end
39580                       0000B5F1            unknown_service:
39581 B5F1           B0                     80    mov al, #0x80
39582                       0000B5F3            bios32_end:
39583 B5F3           9D                           popfd
39584 B5F4           CB                           retf
39585 B5F5                  00000010            .align 16
39586                       0000B600            pcibios_protected:
39587 B600           9C                           pushfd
39588 B601           FA                           cli
39589 B602           56                           push esi
39590 B603           57                           push edi
39591 B604           3C                     01    cmp al, #0x01 ;; installation check
39592 B606           75           14              jne pci_pro_f02
39593 B608     66    BB                   0210    mov bx, #0x0210
39594 B60C     66    B9                   0000    mov cx, #0
39595 B610           BA               20494350    mov edx, #0x20494350 ;; "PCI "
39596 B615           B0                     01    mov al, #0x01
39597 B617           E9     0000011B              jmp pci_pro_ok
39598                       0000B61C            pci_pro_f02: ;; find pci device
39599 B61C           3C                     02    cmp al, #0x02
39600 B61E           75           38              jne pci_pro_f03
39601 B620           C1E1                   10    shl ecx, #16
39602 B623     66    89D1                         mov cx, dx
39603 B626     66    31DB                         xor bx, bx
39604 B629     66    BF                   0000    mov di, #0x00
39605                       0000B62D            pci_pro_devloop:
39606 B62D           E8     0000010C              call pci_pro_select_reg
39607 B632     66    BA                   0CFC    mov dx, #0x0cfc
39608 B636           ED                           in eax, dx
39609 B637           39C8                         cmp eax, ecx
39610 B639           75           0D              jne pci_pro_nextdev
39611 B63B     66    83FE                   00    cmp si, #0
39612 B63F   7505    E9     000000F1              je pci_pro_ok
39613 B646     66    4E                           dec si
39614                       0000B648            pci_pro_nextdev:
39615 B648     66    43                           inc bx
39616 B64A     66    81FB                 0100    cmp bx, #0x0100
39617 B64F           75           DC              jne pci_pro_devloop
39618 B651           B4                     86    mov ah, #0x86
39619 B653           E9     000000DA              jmp pci_pro_fail
39620                       0000B658            pci_pro_f03: ;; find class code
39621 B658           3C                     03    cmp al, #0x03
39622 B65A           75           35              jne pci_pro_f08
39623 B65C     66    31DB                         xor bx, bx
39624 B65F     66    BF                   0008    mov di, #0x08
39625                       0000B663            pci_pro_devloop2:
39626 B663           E8     000000D6              call pci_pro_select_reg
39627 B668     66    BA                   0CFC    mov dx, #0x0cfc
39628 B66C           ED                           in eax, dx
39629 B66D           C1E8                   08    shr eax, #8
39630 B670           39C8                         cmp eax, ecx
39631 B672           75           0D              jne pci_pro_nextdev2
39632 B674     66    83FE                   00    cmp si, #0
39633 B678   7505    E9     000000B8              je pci_pro_ok
39634 B67F     66    4E                           dec si
39635                       0000B681            pci_pro_nextdev2:
39636 B681     66    43                           inc bx
39637 B683     66    81FB                 0100    cmp bx, #0x0100
39638 B688           75           D9              jne pci_pro_devloop2
39639 B68A           B4                     86    mov ah, #0x86
39640 B68C           E9     000000A1              jmp pci_pro_fail
39641                       0000B691            pci_pro_f08: ;; read configuration byte
39642 B691           3C                     08    cmp al, #0x08
39643 B693           75           1B              jne pci_pro_f09
39644 B695           E8     000000A4              call pci_pro_select_reg
39645 B69A           52                           push edx
39646 B69B     66    89FA                         mov dx, di
39647 B69E     66    83E2                   03    and dx, #0x03
39648 B6A2     66    81C2                 0CFC    add dx, #0x0cfc
39649 B6A7           EC                           in al, dx
39650 B6A8           5A                           pop edx
39651 B6A9           88C1                         mov cl, al
39652 B6AB           E9     00000087              jmp pci_pro_ok
39653                       0000B6B0            pci_pro_f09: ;; read configuration word
39654 B6B0           3C                     09    cmp al, #0x09
39655 B6B2           75           1A              jne pci_pro_f0a
39656 B6B4           E8     00000085              call pci_pro_select_reg
39657 B6B9           52                           push edx
39658 B6BA     66    89FA                         mov dx, di
39659 B6BD     66    83E2                   02    and dx, #0x02
39660 B6C1     66    81C2                 0CFC    add dx, #0x0cfc
39661 B6C6     66    ED                           in ax, dx
39662 B6C8           5A                           pop edx
39663 B6C9     66    89C1                         mov cx, ax
39664 B6CC           EB           69              jmp pci_pro_ok
39665                       0000B6CE            pci_pro_f0a: ;; read configuration dword
39666 B6CE           3C                     0A    cmp al, #0x0a
39667 B6D0           75           10              jne pci_pro_f0b
39668 B6D2           E8     00000067              call pci_pro_select_reg
39669 B6D7           52                           push edx
39670 B6D8     66    BA                   0CFC    mov dx, #0x0cfc
39671 B6DC           ED                           in eax, dx
39672 B6DD           5A                           pop edx
39673 B6DE           89C1                         mov ecx, eax
39674 B6E0           EB           55              jmp pci_pro_ok
39675                       0000B6E2            pci_pro_f0b: ;; write configuration byte
39676 B6E2           3C                     0B    cmp al, #0x0b
39677 B6E4           75           18              jne pci_pro_f0c
39678 B6E6           E8     00000053              call pci_pro_select_reg
39679 B6EB           52                           push edx
39680 B6EC     66    89FA                         mov dx, di
39681 B6EF     66    83E2                   03    and dx, #0x03
39682 B6F3     66    81C2                 0CFC    add dx, #0x0cfc
39683 B6F8           88C8                         mov al, cl
39684 B6FA           EE                           out dx, al
39685 B6FB           5A                           pop edx
39686 B6FC           EB           39              jmp pci_pro_ok
39687                       0000B6FE            pci_pro_f0c: ;; write configuration word
39688 B6FE           3C                     0C    cmp al, #0x0c
39689 B700           75           1A              jne pci_pro_f0d
39690 B702           E8     00000037              call pci_pro_select_reg
39691 B707           52                           push edx
39692 B708     66    89FA                         mov dx, di
39693 B70B     66    83E2                   02    and dx, #0x02
39694 B70F     66    81C2                 0CFC    add dx, #0x0cfc
39695 B714     66    89C8                         mov ax, cx
39696 B717     66    EF                           out dx, ax
39697 B719           5A                           pop edx
39698 B71A           EB           1B              jmp pci_pro_ok
39699                       0000B71C            pci_pro_f0d: ;; write configuration dword
39700 B71C           3C                     0D    cmp al, #0x0d
39701 B71E           75           10              jne pci_pro_unknown
39702 B720           E8     00000019              call pci_pro_select_reg
39703 B725           52                           push edx
39704 B726     66    BA                   0CFC    mov dx, #0x0cfc
39705 B72A           89C8                         mov eax, ecx
39706 B72C           EF                           out dx, eax
39707 B72D           5A                           pop edx
39708 B72E           EB           07              jmp pci_pro_ok
39709                       0000B730            pci_pro_unknown:
39710 B730           B4                     81    mov ah, #0x81
39711                       0000B732            pci_pro_fail:
39712 B732           5F                           pop edi
39713 B733           5E                           pop esi
39714 B734           9D                           popfd
39715 B735           F9                           stc
39716 B736           CB                           retf
39717                       0000B737            pci_pro_ok:
39718 B737           30E4                         xor ah, ah
39719 B739           5F                           pop edi
39720 B73A           5E                           pop esi
39721 B73B           9D                           popfd
39722 B73C           F8                           clc
39723 B73D           CB                           retf
39724                       0000B73E            pci_pro_select_reg:
39725 B73E           52                           push edx
39726 B73F           B8               00800000    mov eax, #0x800000
39727 B744     66    89D8                         mov ax, bx
39728 B747           C1E0                   08    shl eax, #8
39729 B74A     66    81E7                 00FF    and di, #0xff
39730 B74F     66    09F8                         or ax, di
39731 B752           24                     FC    and al, #0xfc
39732 B754     66    BA                   0CF8    mov dx, #0x0cf8
39733 B758           EF                           out dx, eax
39734 B759           5A                           pop edx
39735 B75A           C3                           ret
39736                                           use16 386
39737                       0000B75B            pcibios_real:
39738 B75B     66    50                           push eax
39739 B75D           52                           push dx
39740 B75E     66    B8               80000000    mov eax, #0x80000000
39741 B764           BA                   0CF8    mov dx, #0x0cf8
39742 B767     66    EF                           out dx, eax
39743 B769           BA                   0CFC    mov dx, #0x0cfc
39744 B76C     66    ED                           in eax, dx
39745 B76E     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
39746 B774           74           07              je pci_present
39747 B776           5A                           pop dx
39748 B777     66    58                           pop eax
39749 B779           B4                     FF    mov ah, #0xff
39750 B77B           F9                           stc
39751 B77C           C3                           ret
39752                       0000B77D            pci_present:
39753 B77D           5A                           pop dx
39754 B77E     66    58                           pop eax
39755 B780           3C                     01    cmp al, #0x01 ;; installation check
39756 B782           75           1A              jne pci_real_f02
39757 B784           B8                   0001    mov ax, #0x0001
39758 B787           BB                   0210    mov bx, #0x0210
39759 B78A           B9                   0000    mov cx, #0
39760 B78D     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
39761 B793     66    BF               000F0000    mov edi, #0xf0000
39762 B799           BF                   B600    mov di, #pcibios_protected
39763 B79C           F8                           clc
39764 B79D           C3                           ret
39765                       0000B79E            pci_real_f02: ;; find pci device
39766 B79E     66    56                           push esi
39767 B7A0     66    57                           push edi
39768 B7A2           3C                     02    cmp al, #0x02
39769 B7A4           75           34              jne pci_real_f03
39770 B7A6     66    C1E1                   10    shl ecx, #16
39771 B7AA           89D1                         mov cx, dx
39772 B7AC           31DB                         xor bx, bx
39773 B7AE           BF                   0000    mov di, #0x00
39774                       0000B7B1            pci_real_devloop:
39775 B7B1           E8         012F              call pci_real_select_reg
39776 B7B4           BA                   0CFC    mov dx, #0x0cfc
39777 B7B7     66    ED                           in eax, dx
39778 B7B9     66    39C8                         cmp eax, ecx
39779 B7BC           75           09              jne pci_real_nextdev
39780 B7BE           83FE                   00    cmp si, #0
39781 B7C1   7503    E9         0115              je pci_real_ok
39782 B7C6           4E                           dec si
39783                       0000B7C7            pci_real_nextdev:
39784 B7C7           43                           inc bx
39785 B7C8           81FB                 0100    cmp bx, #0x0100
39786 B7CC           75           E3              jne pci_real_devloop
39787 B7CE           89CA                         mov dx, cx
39788 B7D0     66    C1E9                   10    shr ecx, #16
39789 B7D4           B8                   8602    mov ax, #0x8602
39790 B7D7           E9         00FB              jmp pci_real_fail
39791                       0000B7DA            pci_real_f03: ;; find class code
39792 B7DA           3C                     03    cmp al, #0x03
39793 B7DC           75           32              jne pci_real_f08
39794 B7DE           31DB                         xor bx, bx
39795 B7E0           BF                   0008    mov di, #0x08
39796                       0000B7E3            pci_real_devloop2:
39797 B7E3           E8         00FD              call pci_real_select_reg
39798 B7E6           BA                   0CFC    mov dx, #0x0cfc
39799 B7E9     66    ED                           in eax, dx
39800 B7EB     66    C1E8                   08    shr eax, #8
39801 B7EF     66    39C8                         cmp eax, ecx
39802 B7F2           75           09              jne pci_real_nextdev2
39803 B7F4           83FE                   00    cmp si, #0
39804 B7F7   7503    E9         00DF              je pci_real_ok
39805 B7FC           4E                           dec si
39806                       0000B7FD            pci_real_nextdev2:
39807 B7FD           43                           inc bx
39808 B7FE           81FB                 0100    cmp bx, #0x0100
39809 B802           75           DF              jne pci_real_devloop2
39810 B804           89CA                         mov dx, cx
39811 B806     66    C1E9                   10    shr ecx, #16
39812 B80A           B8                   8603    mov ax, #0x8603
39813 B80D           E9         00C5              jmp pci_real_fail
39814                       0000B810            pci_real_f08: ;; read configuration byte
39815 B810           3C                     08    cmp al, #0x08
39816 B812           75           14              jne pci_real_f09
39817 B814           E8         00CC              call pci_real_select_reg
39818 B817           52                           push dx
39819 B818           89FA                         mov dx, di
39820 B81A           83E2                   03    and dx, #0x03
39821 B81D           81C2                 0CFC    add dx, #0x0cfc
39822 B821           EC                           in al, dx
39823 B822           5A                           pop dx
39824 B823           88C1                         mov cl, al
39825 B825           E9         00B3              jmp pci_real_ok
39826                       0000B828            pci_real_f09: ;; read configuration word
39827 B828           3C                     09    cmp al, #0x09
39828 B82A           75           14              jne pci_real_f0a
39829 B82C           E8         00B4              call pci_real_select_reg
39830 B82F           52                           push dx
39831 B830           89FA                         mov dx, di
39832 B832           83E2                   02    and dx, #0x02
39833 B835           81C2                 0CFC    add dx, #0x0cfc
39834 B839           ED                           in ax, dx
39835 B83A           5A                           pop dx
39836 B83B           89C1                         mov cx, ax
39837 B83D           E9         009B              jmp pci_real_ok
39838                       0000B840            pci_real_f0a: ;; read configuration dword
39839 B840           3C                     0A    cmp al, #0x0a
39840 B842           75           10              jne pci_real_f0b
39841 B844           E8         009C              call pci_real_select_reg
39842 B847           52                           push dx
39843 B848           BA                   0CFC    mov dx, #0x0cfc
39844 B84B     66    ED                           in eax, dx
39845 B84D           5A                           pop dx
39846 B84E     66    89C1                         mov ecx, eax
39847 B851           E9         0087              jmp pci_real_ok
39848                       0000B854            pci_real_f0b: ;; write configuration byte
39849 B854           3C                     0B    cmp al, #0x0b
39850 B856           75           13              jne pci_real_f0c
39851 B858           E8         0088              call pci_real_select_reg
39852 B85B           52                           push dx
39853 B85C           89FA                         mov dx, di
39854 B85E           83E2                   03    and dx, #0x03
39855 B861           81C2                 0CFC    add dx, #0x0cfc
39856 B865           88C8                         mov al, cl
39857 B867           EE                           out dx, al
39858 B868           5A                           pop dx
39859 B869           EB           70              jmp pci_real_ok
39860                       0000B86B            pci_real_f0c: ;; write configuration word
39861 B86B           3C                     0C    cmp al, #0x0c
39862 B86D           75           13              jne pci_real_f0d
39863 B86F           E8         0071              call pci_real_select_reg
39864 B872           52                           push dx
39865 B873           89FA                         mov dx, di
39866 B875           83E2                   02    and dx, #0x02
39867 B878           81C2                 0CFC    add dx, #0x0cfc
39868 B87C           89C8                         mov ax, cx
39869 B87E           EF                           out dx, ax
39870 B87F           5A                           pop dx
39871 B880           EB           59              jmp pci_real_ok
39872                       0000B882            pci_real_f0d: ;; write configuration dword
39873 B882           3C                     0D    cmp al, #0x0d
39874 B884           75           0F              jne pci_real_f0e
39875 B886           E8         005A              call pci_real_select_reg
39876 B889           52                           push dx
39877 B88A           BA                   0CFC    mov dx, #0x0cfc
39878 B88D     66    89C8                         mov eax, ecx
39879 B890     66    EF                           out dx, eax
39880 B892           5A                           pop dx
39881 B893           EB           46              jmp pci_real_ok
39882                       0000B895            pci_real_f0e: ;; get irq routing options
39883 B895           3C                     0E    cmp al, #0x0e
39884 B897           75           3A              jne pci_real_unknown
39885 B899           26                           SEG ES
39886 B89A           833D                   60    cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39887 B89D           72           2B              jb pci_real_too_small
39888 B89F           26                           SEG ES
39889 B8A0           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39890 B8A4           9C                           pushf
39891 B8A5           1E                           push ds
39892 B8A6           06                           push es
39893 B8A7           51                           push cx
39894 B8A8           56                           push si
39895 B8A9           57                           push di
39896 B8AA           FC                           cld
39897 B8AB           BE                   B920    mov si, #pci_routing_table_structure_start
39898 B8AE           0E                           push cs
39899 B8AF           1F                           pop ds
39900 B8B0           26                           SEG ES
39901 B8B1           8B4D         02              mov cx, [di+2]
39902 B8B4           26                           SEG ES
39903 B8B5           8E45         04              mov es, [di+4]
39904 B8B8           89CF                         mov di, cx
39905 B8BA           B9                   0060    mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
39906 B8BD           F3                           rep
39907 B8BE           A4                               movsb
39908 B8BF           5F                           pop di
39909 B8C0           5E                           pop si
39910 B8C1           59                           pop cx
39911 B8C2           07                           pop es
39912 B8C3           1F                           pop ds
39913 B8C4           9D                           popf
39914 B8C5           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
39915 B8C8           EB           11              jmp pci_real_ok
39916                       0000B8CA            pci_real_too_small:
39917 B8CA           26                           SEG ES
39918 B8CB           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39919 B8CF           B4                     89    mov ah, #0x89
39920 B8D1           EB           02              jmp pci_real_fail
39921                       0000B8D3            pci_real_unknown:
39922 B8D3           B4                     81    mov ah, #0x81
39923                       0000B8D5            pci_real_fail:
39924 B8D5     66    5F                           pop edi
39925 B8D7     66    5E                           pop esi
39926 B8D9           F9                           stc
39927 B8DA           C3                           ret
39928                       0000B8DB            pci_real_ok:
39929 B8DB           30E4                         xor ah, ah
39930 B8DD     66    5F                           pop edi
39931 B8DF     66    5E                           pop esi
39932 B8E1           F8                           clc
39933 B8E2           C3                           ret
39934                       0000B8E3            pci_real_select_reg:
39935 B8E3           52                           push dx
39936 B8E4     66    B8               00800000    mov eax, #0x800000
39937 B8EA           89D8                         mov ax, bx
39938 B8EC     66    C1E0                   08    shl eax, #8
39939 B8F0           81E7                 00FF    and di, #0xff
39940 B8F4           09F8                         or ax, di
39941 B8F6           24                     FC    and al, #0xfc
39942 B8F8           BA                   0CF8    mov dx, #0x0cf8
39943 B8FB     66    EF                           out dx, eax
39944 B8FD           5A                           pop dx
39945 B8FE           C3                           ret
39946 B8FF                  00000010            .align 16
39947                       0000B900            pci_routing_table_structure:
39948 B900                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
39949 B904                        00              db 0, 1 ;; version
39950 B906                      0080              dw 32 + (6 * 16) ;; table size
39951 B908                        00              db 0 ;; PCI interrupt router bus
39952 B909                        08              db 0x08 ;; PCI interrupt router DevFunc
39953 B90A                      0000              dw 0x0000 ;; PCI exclusive IRQs
39954 B90C                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
39955 B90E                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
39956 B910                      0000              dw 0,0 ;; Miniport data
39957 B914                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
39958 B91F                        37              db 0x37 ;; checksum
39959                       0000B920            pci_routing_table_structure_start:
39960                                             ;; first slot entry PCI-to-ISA (embedded)
39961 B920                        00              db 0 ;; pci bus number
39962 B921                        08              db 0x08 ;; pci device number (bit 7-3)
39963 B922                        61              db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
39964 B923                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39965 B925                        62              db 0x62 ;; link value INTB#
39966 B926                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39967 B928                        63              db 0x63 ;; link value INTC#
39968 B929                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39969 B92B                        60              db 0x60 ;; link value INTD#
39970 B92C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39971 B92E                        00              db 0 ;; physical slot (0 = embedded)
39972 B92F                        00              db 0 ;; reserved
39973                                             ;; second slot entry: 1st PCI slot
39974 B930                        00              db 0 ;; pci bus number
39975 B931                        10              db 0x10 ;; pci device number (bit 7-3)
39976 B932                        62              db 0x62 ;; link value INTA#
39977 B933                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39978 B935                        63              db 0x63 ;; link value INTB#
39979 B936                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39980 B938                        60              db 0x60 ;; link value INTC#
39981 B939                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39982 B93B                        61              db 0x61 ;; link value INTD#
39983 B93C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39984 B93E                        01              db 1 ;; physical slot (0 = embedded)
39985 B93F                        00              db 0 ;; reserved
39986                                             ;; third slot entry: 2nd PCI slot
39987 B940                        00              db 0 ;; pci bus number
39988 B941                        18              db 0x18 ;; pci device number (bit 7-3)
39989 B942                        63              db 0x63 ;; link value INTA#
39990 B943                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39991 B945                        60              db 0x60 ;; link value INTB#
39992 B946                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39993 B948                        61              db 0x61 ;; link value INTC#
39994 B949                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39995 B94B                        62              db 0x62 ;; link value INTD#
39996 B94C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39997 B94E                        02              db 2 ;; physical slot (0 = embedded)
39998 B94F                        00              db 0 ;; reserved
39999                                             ;; 4th slot entry: 3rd PCI slot
40000 B950                        00              db 0 ;; pci bus number
40001 B951                        20              db 0x20 ;; pci device number (bit 7-3)
40002 B952                        60              db 0x60 ;; link value INTA#
40003 B953                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
40004 B955                        61              db 0x61 ;; link value INTB#
40005 B956                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
40006 B958                        62              db 0x62 ;; link value INTC#
40007 B959                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
40008 B95B                        63              db 0x63 ;; link value INTD#
40009 B95C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
40010 B95E                        03              db 3 ;; physical slot (0 = embedded)
40011 B95F                        00              db 0 ;; reserved
40012                                             ;; 5th slot entry: 4rd PCI slot
40013 B960                        00              db 0 ;; pci bus number
40014 B961                        28              db 0x28 ;; pci device number (bit 7-3)
40015 B962                        61              db 0x61 ;; link value INTA#
40016 B963                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
40017 B965                        62              db 0x62 ;; link value INTB#
40018 B966                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
40019 B968                        63              db 0x63 ;; link value INTC#
40020 B969                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
40021 B96B                        60              db 0x60 ;; link value INTD#
40022 B96C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
40023 B96E                        04              db 4 ;; physical slot (0 = embedded)
40024 B96F                        00              db 0 ;; reserved
40025                                             ;; 6th slot entry: 5rd PCI slot
40026 B970                        00              db 0 ;; pci bus number
40027 B971                        30              db 0x30 ;; pci device number (bit 7-3)
40028 B972                        62              db 0x62 ;; link value INTA#
40029 B973                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
40030 B975                        63              db 0x63 ;; link value INTB#
40031 B976                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
40032 B978                        60              db 0x60 ;; link value INTC#
40033 B979                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
40034 B97B                        61              db 0x61 ;; link value INTD#
40035 B97C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
40036 B97E                        05              db 5 ;; physical slot (0 = embedded)
40037 B97F                        00              db 0 ;; reserved
40038                       0000B980            pci_routing_table_structure_end:
40039                                           ; according to POST Memory Manager Specification Version 1.01
40040 B980                  00000010            .align 16
40041                       0000B980            pmm_structure:
40042 B980                        24              db 0x24,0x50,0x4d,0x4d ;; "$PMM" signature
40043 B984                        01              db 0x01 ;; revision
40044 B985                        10              db 16 ;; length
40045 B986                        A8              db (-((pmm_entry_point>>8)+pmm_entry_point+0x20f))&0xff;; checksum
40046 B987                      B990              dw pmm_entry_point,0xf000 ;; far call entrypoint
40047 B98B                        00              db 0,0,0,0,0 ;; reserved
40048                       0000B990            pmm_entry_point:
40049 B990           9C                           pushf
40050 B991     66    60                           pushad
40051                                           ; Calculate protected-mode address of PMM function args
40052 B993     66    31C0                         xor eax, eax
40053 B996           89E0                         mov ax, sp
40054 B998     66    31DB                         xor ebx, ebx
40055 B99B           8CD3                         mov bx, ss
40056 B99D     66    C1E3                   04    shl ebx, 4
40057 B9A1   6766    8D5C18       26              lea ebx, [eax+ebx+38] ;; ebx=(ss<<4)+sp+4(far call)+2(pushf)+32(pushad)
40058 B9A7     66    53                           push ebx
40059                                           ;
40060                                           ; Stack layout at this point:
40061                                           ;
40062                                           ; : +0x0 +0x2 +0x4 +0x6 +0x8 +0xa +0xc +0xe
40063                                           ; -----------------------------------------------------------------------
40064                                           ; sp : [&arg1 ][edi ][esi ][ebp ]
40065                                           ; sp+0x10: [esp ][ebx ][edx ][ecx ]
40066                                           ; sp+0x20: [eax ][flags ][ip ][cs ][arg1 ][arg2, ...
40067                                           ;
40068 B9A9           E8         FAC5              call _pmm
40069 B9AC           89E3                         mov bx, sp
40070 B9AE           36                         SEG SS
40071 B9AF           8947         20              mov [bx+0x20], ax
40072 B9B2           36                         SEG SS
40073 B9B3           8957         18              mov [bx+0x18], dx
40074 B9B6     66    5B                           pop ebx
40075 B9B8     66    61                           popad
40076 B9BA           9D                           popf
40077 B9BB           CB                           retf
40078                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
40079                       0000B9BC            detect_parport:
40080 B9BC           52                           push dx
40081 B9BD           83C2                   02    add dx, #2
40082 B9C0           EC                           in al, dx
40083 B9C1           24                     DF    and al, #0xdf ; clear input mode
40084 B9C3           EE                           out dx, al
40085 B9C4           5A                           pop dx
40086 B9C5           B0                     AA    mov al, #0xaa
40087 B9C7           EE                           out dx, al
40088 B9C8           EC                           in al, dx
40089 B9C9           3C                     AA    cmp al, #0xaa
40090 B9CB           75           0D              jne no_parport
40091 B9CD           53                           push bx
40092 B9CE           D1E3                         shl bx, #1
40093 B9D0           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
40094 B9D4           5B                           pop bx
40095 B9D5           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
40096 B9D9           43                           inc bx
40097                       0000B9DA            no_parport:
40098 B9DA           C3                           ret
40099                                           ; serial port detection: base address in DX, index in BX, timeout in CL
40100                       0000B9DB            detect_serial:
40101 B9DB           52                           push dx
40102 B9DC           42                           inc dx
40103 B9DD           B0                     02    mov al, #0x02
40104 B9DF           EE                           out dx, al
40105 B9E0           EC                           in al, dx
40106 B9E1           3C                     02    cmp al, #0x02
40107 B9E3           75           19              jne no_serial
40108 B9E5           42                           inc dx
40109 B9E6           EC                           in al, dx
40110 B9E7           3C                     02    cmp al, #0x02
40111 B9E9           75           13              jne no_serial
40112 B9EB           4A                           dec dx
40113 B9EC           30C0                         xor al, al
40114 B9EE           EE                           out dx, al
40115 B9EF           5A                           pop dx
40116 B9F0           53                           push bx
40117 B9F1           D1E3                         shl bx, #1
40118 B9F3           8997       0400              mov [bx+0x400], dx ; Serial I/O address
40119 B9F7           5B                           pop bx
40120 B9F8           888F       047C              mov [bx+0x47c], cl ; Serial timeout
40121 B9FC           43                           inc bx
40122 B9FD           C3                           ret
40123                       0000B9FE            no_serial:
40124 B9FE           5A                           pop dx
40125 B9FF           C3                           ret
40126                       0000BA00            rom_checksum:
40127 BA00           60                           pusha
40128 BA01           1E                           push ds
40129 BA02           31C0                         xor ax, ax
40130 BA04           31DB                         xor bx, bx
40131 BA06           31C9                         xor cx, cx
40132 BA08           31D2                         xor dx, dx
40133 BA0A           8A2E       0002              mov ch, [2]
40134 BA0E           D1E1                         shl cx, #1
40135 BA10           73           05              jnc checksum_loop
40136 BA12           74           03              jz checksum_loop
40137 BA14           87CA                         xchg dx, cx
40138 BA16           49                           dec cx
40139                       0000BA17            checksum_loop:
40140 BA17           0207                         add al, [bx]
40141 BA19           43                           inc bx
40142 BA1A           E2           FB              loop checksum_loop
40143 BA1C           85D2                         test dx, dx
40144 BA1E           74           11              je checksum_out
40145 BA20           0207                         add al, [bx]
40146 BA22           89D1                         mov cx, dx
40147 BA24           8CDA                         mov dx, ds
40148 BA26           80C6                   10    add dh, #0x10
40149 BA29           8EDA                         mov ds, dx
40150 BA2B           31D2                         xor dx, dx
40151 BA2D           31DB                         xor bx, bx
40152 BA2F           EB           E6              jmp checksum_loop
40153                       0000BA31            checksum_out:
40154 BA31           24                     FF    and al, #0xff
40155 BA33           1F                           pop ds
40156 BA34           61                           popa
40157 BA35           C3                           ret
40158                                           ;; We need a copy of this string, but we are not actually a PnP BIOS,
40159                                           ;; so make sure it is *not* aligned, so OSes will not see it if they scan.
40160 BA36                  00000010            .align 16
40161 BA40                        00              db 0
40162                       0000BA41            pnp_string:
40163 BA41                        24              .ascii "$PnP"
40164                       0000BA45            rom_scan:
40165                                             ;; Scan for existence of valid expansion ROMS.
40166                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
40167                                             ;; General ROM: from 0xC8000..0xE9FFF in 2k increments
40168                                             ;; System ROM: only 0xF0000
40169                                             ;;
40170                                             ;; Header:
40171                                             ;; Offset Value
40172                                             ;; 0 0x55
40173                                             ;; 1 0xAA
40174                                             ;; 2 ROM length in 512-byte blocks
40175                                             ;; 3 ROM initialization entry point (FAR CALL)
40176                       0000BA45            rom_scan_loop:
40177 BA45           50                           push ax ;; Save AX
40178 BA46           8ED9                         mov ds, cx
40179 BA48           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
40180 BA4B           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
40181 BA51   7403    E9         00C2              jne rom_scan_increment
40182 BA56           E8         FFA7              call rom_checksum
40183 BA59   7403    E9         00BA              jnz rom_scan_increment
40184 BA5E           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
40185                                             ;; We want our increment in 512-byte quantities, rounded to
40186                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
40187 BA61           A8                     03    test al, #0x03
40188 BA63           74           04              jz block_count_rounded
40189 BA65           24                     FC    and al, #0xfc ;; needs rounding up
40190 BA67           04                     04    add al, #0x04
40191                       0000BA69            block_count_rounded:
40192 BA69           50                           push ax ;; Save AX
40193 BA6A           57                           push di ;; Save DI
40194                                             ;; Push addr of ROM entry point
40195 BA6B           51                           push cx ;; Push seg
40196 BA6C           6A                     03    push #0x0003 ;; Push offset
40197                                             ;; Get the BDF into ax before invoking the option ROM
40198 BA6E           8A1E       0002              mov bl, [2]
40199 BA72           88D8                         mov al, bl
40200 BA74           C0E8                   07    shr al, #7
40201 BA77           3C                     01    cmp al, #1
40202 BA79           75           07              jne fetch_bdf
40203 BA7B           8CD8                         mov ax, ds ;; Increment the DS since rom size larger than an segment
40204 BA7D           05                   1000    add ax, #0x1000
40205 BA80           8ED8                         mov ds, ax
40206                       0000BA82            fetch_bdf:
40207 BA82           C1E3                   09    shl bx, #9
40208 BA85           31C0                         xor ax, ax
40209 BA87           8A07                         mov al, [bx]
40210                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
40211                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
40212 BA89           BB                   F000    mov bx, #0xf000
40213 BA8C           8EC3                         mov es, bx
40214 BA8E           8D3E       BA41              lea di, pnp_string
40215 BA92           31DB                         xor bx, bx ;; Restore DS back to 0000:
40216 BA94           8EDB                         mov ds, bx
40217 BA96           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
40218 BA98                        FF              db 0xff ;; call_far ss:[bp+0]
40219 BA99                        5E              db 0x5e
40220 BA9A                        00              db 0
40221 BA9B           FA                           cli ;; In case expansion ROM BIOS turns IF on
40222 BA9C           83C4                   02    add sp, #2 ;; Pop offset value
40223 BA9F           59                           pop cx ;; Pop seg value (restore CX)
40224                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
40225                                             ;; to init all the ROMs and then go back and build an IPL table of
40226                                             ;; all the bootable devices, but we can get away with one pass.
40227 BAA0           8ED9                         mov ds, cx ;; ROM base
40228 BAA2           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
40229 BAA6           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
40230 BAA8           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
40231 BAAB           75           69              jne no_bev
40232 BAAD           8B47         02              mov ax, 2[bx]
40233 BAB0           3D                   506E    cmp ax, #0x506e
40234 BAB3           75           61              jne no_bev
40235 BAB5           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
40236 BAB8           3D                   0000    cmp ax, #0x0000
40237 BABB           74           17              je no_bcv
40238                                             ;; Option ROM has BCV. Run it now.
40239 BABD           51                           push cx ;; Push seg
40240 BABE           50                           push ax ;; Push offset
40241                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
40242 BABF           BB                   F000    mov bx, #0xf000
40243 BAC2           8EC3                         mov es, bx
40244 BAC4           8D3E       BA41              lea di, pnp_string
40245 BAC8           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
40246 BACA                        FF              db 0xff ;; call_far ss:[bp+0]
40247 BACB                        5E              db 0x5e
40248 BACC                        00              db 0
40249 BACD           FA                           cli ;; In case expansion ROM BIOS turns IF on
40250 BACE           83C4                   02    add sp, #2 ;; Pop offset value
40251 BAD1           59                           pop cx ;; Pop seg value (restore CX)
40252 BAD2           EB           42              jmp no_bev
40253                       0000BAD4            no_bcv:
40254 BAD4           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
40255 BAD7           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
40256 BADA           74           3A              je no_bev
40257                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
40258 BADC           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
40259 BADF           31DB                         xor bx, bx
40260 BAE1           8EDB                         mov ds, bx
40261 BAE3           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
40262 BAE7           8EDB                         mov ds, bx ;; Go to the segment where the IPL table lives
40263 BAE9           8B1E       0380              mov bx, 0x0380 ;; Read the number of entries so far
40264 BAED           83FB                   08    cmp bx, #8
40265 BAF0           74           24              je no_bev ;; Get out if the table is full
40266 BAF2           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
40267 BAF5           C787       0300      0080    mov 0x0300 +0[bx], #0x80 ;; This entry is a BEV device
40268 BAFB           898F       0306              mov 0x0300 +6[bx], cx ;; Build a far pointer from the segment...
40269 BAFF           8987       0304              mov 0x0300 +4[bx], ax ;; and the offset
40270 BB03           83FF                   00    cmp di, #0x0000
40271 BB06           74           06              je no_prod_str
40272 BB08           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
40273 BB0B           897F         08              mov 8[bx], di ;; and the offset
40274                       0000BB0E            no_prod_str:
40275 BB0E           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
40276 BB11           43                           inc bx ;; We have one more entry now
40277 BB12           891E       0380              mov 0x0380, bx ;; Remember that.
40278                       0000BB16            no_bev:
40279 BB16           5F                           pop di ;; Restore DI
40280 BB17           58                           pop ax ;; Restore AX
40281                       0000BB18            rom_scan_increment:
40282 BB18           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
40283                                                           ;; because the segment selector is shifted left 4 bits.
40284 BB1B           01C1                         add cx, ax
40285 BB1D           58                           pop ax ;; Restore AX
40286 BB1E           39C1                         cmp cx, ax
40287 BB20   7703    E9         FF20              jbe rom_scan_loop
40288 BB25           31C0                         xor ax, ax ;; Restore DS back to 0000:
40289 BB27           8ED8                         mov ds, ax
40290 BB29           C3                           ret
40291                                           ; Copy the SMBIOS entry point from where hvmloader left it.
40292                                           ; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
40293                                           ; but the tables themselves can be elsewhere.
40294                       0000BB2A            smbios_init:
40295 BB2A           50                           push ax
40296 BB2B           51                           push cx
40297 BB2C           06                           push es
40298 BB2D           1E                           push ds
40299 BB2E           57                           push di
40300 BB2F           56                           push si
40301 BB30           B9                   001F    mov cx, #0x001f ; 0x1f bytes to copy
40302 BB33           B8                   F000    mov ax, #0xf000
40303 BB36           8EC0                         mov es, ax ; destination segment is 0xf0000
40304 BB38           BF                   BB80    mov di, #smbios_entry_point ; destination offset
40305 BB3B           B8                   EB00    mov ax, #(0x000EB000>>4)
40306 BB3E           8ED8                         mov ds, ax
40307 BB40           BE                   0000    mov si, #(0x000EB000&15)
40308 BB43           FC                           cld
40309 BB44           F3                           rep
40310 BB45           A4                             movsb
40311 BB46           5E                           pop si
40312 BB47           5F                           pop di
40313 BB48           1F                           pop ds
40314 BB49           07                           pop es
40315 BB4A           59                           pop cx
40316 BB4B           58                           pop ax
40317 BB4C           C3                           ret
40318                       0000BB4D            post_init_pic:
40319 BB4D           B0                     11    mov al, #0x11 ; send initialisation commands
40320 BB4F           E6                     20    out 0x20, al
40321 BB51           E6                     A0    out 0xa0, al
40322 BB53           B0                     08    mov al, #0x08
40323 BB55           E6                     21    out 0x21, al
40324 BB57           B0                     70    mov al, #0x70
40325 BB59           E6                     A1    out 0xa1, al
40326 BB5B           B0                     04    mov al, #0x04
40327 BB5D           E6                     21    out 0x21, al
40328 BB5F           B0                     02    mov al, #0x02
40329 BB61           E6                     A1    out 0xa1, al
40330 BB63           B0                     01    mov al, #0x01
40331 BB65           E6                     21    out 0x21, al
40332 BB67           E6                     A1    out 0xa1, al
40333 BB69           B0                     B8    mov al, #0xb8
40334 BB6B           E6                     21    out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
40335 BB6D           B0                     8F    mov al, #0x8f
40336 BB6F           E6                     A1    out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
40337 BB71           C3                           ret
40338 BB72                  00000010              .align 16
40339                       0000BB80            smbios_entry_point:
40340 BB80                        00              db 0,0,0,0,0,0,0,0 ; 8 bytes
40341 BB88                        00              db 0,0,0,0,0,0,0,0 ; 16 bytes
40342 BB90                        00              db 0,0,0,0,0,0,0,0 ; 24 bytes
40343 BB98                        00              db 0,0,0,0,0,0,0 ; 31 bytes
40344                                           ;; the following area can be used to write dynamically generated tables
40345 BB9F                  00000010              .align 16
40346                       0000BBA0            bios_table_area_start:
40347 BBA0                        5F              db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
40348 BBA8                  00001450              dd bios_table_area_end - bios_table_area_start
40349                                           ;--------
40350                                           ;- POST -
40351                                           ;--------
40352 E05B                                      .org 0xe05b ; POST Entry Point
40353                       0000E05B            post:
40354 E05B           31C0                         xor ax, ax
40355                                             ;; first reset the DMA controllers
40356 E05D           E6                     0D    out 0x0d,al
40357 E05F           E6                     DA    out 0xda,al
40358                                             ;; then initialize the DMA controllers
40359 E061           B0                     C0    mov al, #0xC0
40360 E063           E6                     D6    out 0xD6, al ; cascade mode of channel 4 enabled
40361 E065           B0                     00    mov al, #0x00
40362 E067           E6                     D4    out 0xD4, al ; unmask channel 4
40363                                             ;; Examine CMOS shutdown status.
40364 E069           B0                     0F    mov AL, #0x0f
40365 E06B           E6                     70    out 0x70, AL
40366 E06D           E4                     71    in AL, 0x71
40367                                             ;; backup status
40368 E06F           88C3                         mov bl, al
40369                                             ;; Reset CMOS shutdown status.
40370 E071           B0                     0F    mov AL, #0x0f
40371 E073           E6                     70    out 0x70, AL ; select CMOS register Fh
40372 E075           B0                     00    mov AL, #0x00
40373 E077           E6                     71    out 0x71, AL ; set shutdown action to normal
40374                                             ;; Examine CMOS shutdown status.
40375 E079           88D8                         mov al, bl
40376                                             ;; 0x00, 0x09, 0x0D+ = normal startup
40377 E07B           3C                     00    cmp AL, #0x00
40378 E07D           74           28              jz normal_post
40379 E07F           3C                     0D    cmp AL, #0x0d
40380 E081           73           24              jae normal_post
40381 E083           3C                     09    cmp AL, #0x09
40382 E085           74           20              je normal_post
40383                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
40384 E087           3C                     05    cmp al, #0x05
40385 E089   7503    E9         CF10              je eoi_jmp_post
40386                                             ;; 0x0A = jmp via [0x40:0x67] jump
40387 E08E           3C                     0A    cmp al, #0x0a
40388 E090   7503    E9         CF11              je jmp_post_0x467
40389                                             ;; 0x0B = iret via [0x40:0x67]
40390 E095           3C                     0B    cmp al, #0x0b
40391 E097   7503    E9         CF12              je iret_post_0x467
40392                                             ;; 0x0C = retf via [0x40:0x67]
40393 E09C           3C                     0C    cmp al, #0x0c
40394 E09E   7503    E9         CF18              je retf_post_0x467
40395                                             ;; Examine CMOS shutdown status.
40396                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08 = Unimplemented shutdown status.
40397 E0A3           53                           push bx
40398 E0A4           E8         327A              call _shutdown_status_panic
40399                       0000E0A7            normal_post:
40400                                             ; case 0: normal startup
40401 E0A7           FA                           cli
40402 E0A8           B8                   0FFE    mov ax, #0x0ffe
40403 E0AB           89C4                         mov sp, ax
40404 E0AD           B8                   9E00    mov ax, #0x9e00
40405 E0B0           8ED0                         mov ss, ax
40406                                             ;; Save shutdown status
40407 E0B2           881E       04B0              mov 0x04b0, bl
40408 E0B6           80FB                   FE    cmp bl, #0xfe
40409 E0B9   7503    E9         CF0A              jz s3_post
40410                                             ;; zero out BIOS data area (40:00..40:ff)
40411 E0BE           8EC0                         mov es, ax
40412 E0C0           B9                   0080    mov cx, #0x0080 ;; 128 words
40413 E0C3           BF                   0400    mov di, #0x0400
40414 E0C6           FC                           cld
40415 E0C7           F3                           rep
40416 E0C8           AB                             stosw
40417 E0C9           E8         3808              call _log_bios_start
40418                                             ;; set all interrupts to default handler
40419 E0CC           31DB                         xor bx, bx ;; offset index
40420 E0CE           B9                   0100    mov cx, #0x0100 ;; counter (256 interrupts)
40421 E0D1           B8                   FF53    mov ax, #dummy_iret_handler
40422 E0D4           BA                   F000    mov dx, #0xF000
40423                       0000E0D7            post_default_ints:
40424 E0D7           8907                         mov [bx], ax
40425 E0D9           83C3                   02    add bx, #2
40426 E0DC           8917                         mov [bx], dx
40427 E0DE           83C3                   02    add bx, #2
40428 E0E1           E2           F4              loop post_default_ints
40429                                             ;; set vector 0x79 to zero
40430                                             ;; this is used by 'gardian angel' protection system
40431                                             SET_INT_VECTOR(0x79, #0, #0)
 +a   E0E3           B8                   0000    mov ax,  #0
 +a   E0E6           A3         01E4              mov 0x79*4, ax
 +a   E0E9           B8                   0000    mov ax,  #0
 +a   E0EC           A3         01E6              mov 0x79*4+2, ax
40432                                             ;; base memory in K 40:13 (word)
40433 E0EF           B8                   027F    mov ax, #(640 - 1)
40434 E0F2           A3         0413              mov 0x0413, ax
40435                                             ;; Manufacturing Test 40:12
40436                                             ;; zerod out above
40437                                             ;; Warm Boot Flag 0040:0072
40438                                             ;; value of 1234h = skip memory checks
40439                                             ;; zerod out above
40440                                             ;; Printer Services vector
40441                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   E0F5           B8                   EFD2    mov ax,  #int17_handler
 +a   E0F8           A3         005C              mov 0x17*4, ax
 +a   E0FB           B8                   F000    mov ax,  #0xF000
 +a   E0FE           A3         005E              mov 0x17*4+2, ax
40442                                             ;; Bootstrap failure vector
40443                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   E101           B8                   ACA7    mov ax,  #int18_handler
 +a   E104           A3         0060              mov 0x18*4, ax
 +a   E107           B8                   F000    mov ax,  #0xF000
 +a   E10A           A3         0062              mov 0x18*4+2, ax
40444                                             ;; Bootstrap Loader vector
40445                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   E10D           B8                   E6F2    mov ax,  #int19_handler
 +a   E110           A3         0064              mov 0x19*4, ax
 +a   E113           B8                   F000    mov ax,  #0xF000
 +a   E116           A3         0066              mov 0x19*4+2, ax
40446                                             ;; User Timer Tick vector
40447                                             SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
 +a   E119           B8                   ACD9    mov ax,  #int1c_handler
 +a   E11C           A3         0070              mov 0x1c*4, ax
 +a   E11F           B8                   F000    mov ax,  #0xF000
 +a   E122           A3         0072              mov 0x1c*4+2, ax
40448                                             ;; Memory Size Check vector
40449                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   E125           B8                   F841    mov ax,  #int12_handler
 +a   E128           A3         0048              mov 0x12*4, ax
 +a   E12B           B8                   F000    mov ax,  #0xF000
 +a   E12E           A3         004A              mov 0x12*4+2, ax
40450                                             ;; Equipment Configuration Check vector
40451                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   E131           B8                   F84D    mov ax,  #int11_handler
 +a   E134           A3         0044              mov 0x11*4, ax
 +a   E137           B8                   F000    mov ax,  #0xF000
 +a   E13A           A3         0046              mov 0x11*4+2, ax
40452                                             ;; System Services
40453                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   E13D           B8                   F859    mov ax,  #int15_handler
 +a   E140           A3         0054              mov 0x15*4, ax
 +a   E143           B8                   F000    mov ax,  #0xF000
 +a   E146           A3         0056              mov 0x15*4+2, ax
40454                                             ;; EBDA setup
40455 E149           E8         CE3D              call ebda_post
40456                                             ;; PIT setup
40457                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E14C           B8                   FEA5    mov ax,  #int08_handler
 +a   E14F           A3         0020              mov 0x08*4, ax
 +a   E152           B8                   F000    mov ax,  #0xF000
 +a   E155           A3         0022              mov 0x08*4+2, ax
40458                                             ;; int 1C already points at dummy_iret_handler (above)
40459 E158           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
40460 E15A           E6                     43    out 0x43, al
40461 E15C           B0                     0B    mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
40462 E15E           E6                     40    out 0x40, al ; lsb
40463 E160           B0                     E9    mov al, #0xe9
40464 E162           E6                     40    out 0x40, al ; msb
40465                                             ;; Keyboard
40466                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E164           B8                   E987    mov ax,  #int09_handler
 +a   E167           A3         0024              mov 0x09*4, ax
 +a   E16A           B8                   F000    mov ax,  #0xF000
 +a   E16D           A3         0026              mov 0x09*4+2, ax
40467                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E170           B8                   E82E    mov ax,  #int16_handler
 +a   E173           A3         0058              mov 0x16*4, ax
 +a   E176           B8                   F000    mov ax,  #0xF000
 +a   E179           A3         005A              mov 0x16*4+2, ax
40468 E17C           31C0                         xor ax, ax
40469 E17E           8ED8                         mov ds, ax
40470 E180           A2         0417              mov 0x0417, al
40471 E183           A2         0418              mov 0x0418, al
40472 E186           A2         0419              mov 0x0419, al
40473 E189           A2         0471              mov 0x0471, al
40474 E18C           A2         0497              mov 0x0497, al
40475 E18F           B0                     10    mov al, #0x10
40476 E191           A2         0496              mov 0x0496, al
40477 E194           BB                   001E    mov bx, #0x001E
40478 E197           891E       041A              mov 0x041A, bx
40479 E19B           891E       041C              mov 0x041C, bx
40480 E19F           BB                   001E    mov bx, #0x001E
40481 E1A2           891E       0480              mov 0x0480, bx
40482 E1A6           BB                   003E    mov bx, #0x003E
40483 E1A9           891E       0482              mov 0x0482, bx
40484 E1AD           E8         2C3C              call _keyboard_init
40485                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
40486 E1B0           A1         0410              mov ax, 0x0410
40487 E1B3           B0                     14    mov al, #0x14
40488 E1B5           E6                     70    out 0x70, al
40489 E1B7           E4                     71    in al, 0x71
40490 E1B9           A3         0410              mov 0x0410, ax
40491                                             ;; Parallel setup
40492                                             SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
 +a   E1BC           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1BF           A3         003C              mov 0x0F*4, ax
 +a   E1C2           B8                   F000    mov ax,  #0xF000
 +a   E1C5           A3         003E              mov 0x0F*4+2, ax
40493 E1C8           31C0                         xor ax, ax
40494 E1CA           8ED8                         mov ds, ax
40495 E1CC           31DB                         xor bx, bx
40496 E1CE           B1                     14    mov cl, #0x14 ; timeout value
40497 E1D0           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
40498 E1D3           E8         D7E6              call detect_parport
40499 E1D6           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
40500 E1D9           E8         D7E0              call detect_parport
40501 E1DC           C1E3                   0E    shl bx, #0x0e
40502 E1DF           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
40503 E1E2           25                   3FFF    and ax, #0x3fff
40504 E1E5           09D8                         or ax, bx ; set number of parallel ports
40505 E1E7           A3         0410              mov 0x410, ax
40506                                             ;; Serial setup
40507                                             SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
 +a   E1EA           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1ED           A3         0030              mov 0x0C*4, ax
 +a   E1F0           B8                   F000    mov ax,  #0xF000
 +a   E1F3           A3         0032              mov 0x0C*4+2, ax
40508                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E1F6           B8                   E739    mov ax,  #int14_handler
 +a   E1F9           A3         0050              mov 0x14*4, ax
 +a   E1FC           B8                   F000    mov ax,  #0xF000
 +a   E1FF           A3         0052              mov 0x14*4+2, ax
40509 E202           31DB                         xor bx, bx
40510 E204           B1                     0A    mov cl, #0x0a ; timeout value
40511 E206           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
40512 E209           E8         D7CF              call detect_serial
40513 E20C           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
40514 E20F           E8         D7C9              call detect_serial
40515 E212           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
40516 E215           E8         D7C3              call detect_serial
40517 E218           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
40518 E21B           E8         D7BD              call detect_serial
40519 E21E           C1E3                   09    shl bx, #0x09
40520 E221           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
40521 E224           25                   F1FF    and ax, #0xf1ff
40522 E227           09D8                         or ax, bx ; set number of serial port
40523 E229           A3         0410              mov 0x410, ax
40524                                             ;; CMOS RTC
40525                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E22C           B8                   FE6E    mov ax,  #int1a_handler
 +a   E22F           A3         0068              mov 0x1A*4, ax
 +a   E232           B8                   F000    mov ax,  #0xF000
 +a   E235           A3         006A              mov 0x1A*4+2, ax
40526                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E238           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E23B           A3         0128              mov 0x4A*4, ax
 +a   E23E           B8                   F000    mov ax,  #0xF000
 +a   E241           A3         012A              mov 0x4A*4+2, ax
40527                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E244           B8                   FE93    mov ax,  #int70_handler
 +a   E247           A3         01C0              mov 0x70*4, ax
 +a   E24A           B8                   F000    mov ax,  #0xF000
 +a   E24D           A3         01C2              mov 0x70*4+2, ax
40528                                             ;; BIOS DATA AREA 0x4CE ???
40529 E250           E8         CD9C              call timer_tick_post
40530                                             ;; PS/2 mouse setup
40531                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E253           B8                   ABDF    mov ax,  #int74_handler
 +a   E256           A3         01D0              mov 0x74*4, ax
 +a   E259           B8                   F000    mov ax,  #0xF000
 +a   E25C           A3         01D2              mov 0x74*4+2, ax
40532                                             ;; IRQ13 (FPU exception) setup
40533                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E25F           B8                   E2C7    mov ax,  #int75_handler
 +a   E262           A3         01D4              mov 0x75*4, ax
 +a   E265           B8                   F000    mov ax,  #0xF000
 +a   E268           A3         01D6              mov 0x75*4+2, ax
40534                                             ;; Video setup
40535                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E26B           B8                   F065    mov ax,  #int10_handler
 +a   E26E           A3         0040              mov 0x10*4, ax
 +a   E271           B8                   F000    mov ax,  #0xF000
 +a   E274           A3         0042              mov 0x10*4+2, ax
40536                                             ;; PIC
40537 E277           E8         D8D3              call post_init_pic
40538 E27A           B9                   C000    mov cx, #0xc000 ;; init vga bios
40539 E27D           B8                   C780    mov ax, #0xc780
40540 E280           E8         D7C2              call rom_scan
40541 E283           E8         30C5              call _print_bios_banner
40542                                             ;;
40543                                             ;; Floppy setup
40544                                             ;;
40545 E286           E8         CA51              call floppy_drive_post
40546                                             ;;
40547                                             ;; Hard Drive setup
40548                                             ;;
40549 E289           E8         CAD5              call hard_drive_post
40550                                             ;;
40551                                             ;; ATA/ATAPI driver setup
40552                                             ;;
40553 E28C           E8         37A1              call _ata_init
40554 E28F           E8         3BF0              call _ata_detect
40555                                             ;;
40556                                             ;;
40557                                             ;; eltorito floppy/harddisk emulation from cd
40558                                             ;;
40559 E292           E8         5D02              call _cdemu_init
40560                                             ;;
40561 E295           E8         23FC              call _enable_rom_write_access
40562 E298           E8         3070              call _clobber_entry_point
40563 E29B           E8         23B2              call _fixup_base_mem_in_k
40564 E29E           E8         D889              call smbios_init
40565 E2A1           E8         3100              call _init_boot_vectors
40566 E2A4           B9                   C800    mov cx, #(0x000C8000 >> 4) ;; init option roms
40567 E2A7           B8                   EA00    mov ax, #(0x000EA000 >> 4)
40568 E2AA           E8         D798              call rom_scan
40569 E2AD           E8         23F5              call _disable_rom_write_access
40570 E2B0           E8         32AF              call _interactive_bootkey
40571 E2B3           FB                           sti ;; enable interrupts
40572                                             ;; Start the boot sequence. See the comments in int19_relocated
40573                                             ;; for why we use INT 18h instead of INT 19h here.
40574 E2B4           CD                     18    int #0x18
40575 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
40576                       0000E2C3            nmi:
40577                                             ;; FIXME the NMI handler should not panic
40578                                             ;; but iret when called from int75 (fpu exception)
40579 E2C3           E8         35EA              call _nmi_handler_msg
40580 E2C6           CF                           iret
40581                       0000E2C7            int75_handler:
40582 E2C7           E6                     F0    out 0xf0, al
40583 E2C9           E8         CD0B              call eoi_both_pics
40584 E2CC           CD                     02    int 2
40585 E2CE           CF                           iret
40586                                           ;-------------------------------------------
40587                                           ;- INT 13h Fixed Disk Services Entry Point -
40588                                           ;-------------------------------------------
40589 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
40590                       0000E3FE            int13_handler:
40591 E3FE           E9         C81B              jmp int13_relocated
40592 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
40593                                           ;----------
40594                                           ;- INT19h -
40595                                           ;----------
40596 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
40597                       0000E6F2            int19_handler:
40598 E6F2           E9         C5D7              jmp int19_relocated
40599                                           ;-------------------------------------------
40600                                           ;- System BIOS Configuration Data Table
40601                                           ;-------------------------------------------
40602 E6F5                                      .org 0xe6f5
40603 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
40604 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
40605 E6F7                        FC            db 0xFC
40606 E6F8                        00            db 0x00
40607 E6F9                        01            db 1
40608                                           ; Feature byte 1
40609                                           ; b7: 1=DMA channel 3 used by hard disk
40610                                           ; b6: 1=2 interrupt controllers present
40611                                           ; b5: 1=RTC present
40612                                           ; b4: 1=BIOS calls int 15h/4Fh every key
40613                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
40614                                           ; b2: 1=extended BIOS data area used
40615                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
40616                                           ; b0: 1=Dual bus (MicroChannel + ISA)
40617 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
40618                                           ; Feature byte 2
40619                                           ; b7: 1=32-bit DMA supported
40620                                           ; b6: 1=int16h, function 9 supported
40621                                           ; b5: 1=int15h/C6h (get POS data) supported
40622                                           ; b4: 1=int15h/C7h (get mem map info) supported
40623                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
40624                                           ; b2: 1=non-8042 kb controller
40625                                           ; b1: 1=data streaming supported
40626                                           ; b0: reserved
40627 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
40628                                           ; Feature byte 3
40629                                           ; b7: not used
40630                                           ; b6: reserved
40631                                           ; b5: reserved
40632                                           ; b4: POST supports ROM-to-RAM enable/disable
40633                                           ; b3: SCSI on system board
40634                                           ; b2: info panel installed
40635                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
40636                                           ; b0: SCSI supported in IML
40637 E6FC                        00            db 0x00
40638                                           ; Feature byte 4
40639                                           ; b7: IBM private
40640                                           ; b6: EEPROM present
40641                                           ; b5-3: ABIOS presence (011 = not supported)
40642                                           ; b2: private
40643                                           ; b1: memory split above 16Mb supported
40644                                           ; b0: POSTEXT directly supported by POST
40645 E6FD                        00            db 0x00
40646                                           ; Feature byte 5 (IBM)
40647                                           ; b1: enhanced mouse
40648                                           ; b0: flash EPROM
40649 E6FE                        00            db 0x00
40650 E729                                      .org 0xe729 ; Baud Rate Generator Table
40651                                           ;----------
40652                                           ;- INT14h -
40653                                           ;----------
40654 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
40655                       0000E739            int14_handler:
40656 E739           1E                           push ds
40657 E73A           60                           pusha
40658 E73B           31C0                         xor ax, ax
40659 E73D           8ED8                         mov ds, ax
40660 E73F           E8         6083              call _int14_function
40661 E742           61                           popa
40662 E743           1F                           pop ds
40663 E744           CF                           iret
40664                                           ;----------------------------------------
40665                                           ;- INT 16h Keyboard Service Entry Point -
40666                                           ;----------------------------------------
40667 E82E                                      .org 0xe82e
40668                       0000E82E            int16_handler:
40669 E82E           FB                           sti
40670 E82F           1E                           push ds
40671 E830           9C                           pushf
40672 E831           60                           pusha
40673 E832           80FC                   00    cmp ah, #0x00
40674 E835           74           24              je int16_F00
40675 E837           80FC                   10    cmp ah, #0x10
40676 E83A           74           1F              je int16_F00
40677 E83C           BB                   F000    mov bx, #0xf000
40678 E83F           8EDB                         mov ds, bx
40679 E841           E8         7204              call _int16_function
40680 E844           61                           popa
40681 E845           9D                           popf
40682 E846           1F                           pop ds
40683 E847           74           09              jz int16_zero_set
40684                       0000E849            int16_zero_clear:
40685 E849           55                           push bp
40686 E84A           89E5                         mov bp, sp
40687 E84C           8066         06        BF    and BYTE [bp + 0x06], #0xbf
40688 E850           5D                           pop bp
40689 E851           CF                           iret
40690                       0000E852            int16_zero_set:
40691 E852           55                           push bp
40692 E853           89E5                         mov bp, sp
40693 E855           804E         06        40    or BYTE [bp + 0x06], #0x40
40694 E859           5D                           pop bp
40695 E85A           CF                           iret
40696                       0000E85B            int16_F00:
40697 E85B           BB                   0040    mov bx, #0x0040
40698 E85E           8EDB                         mov ds, bx
40699                       0000E860            int16_wait_for_key:
40700 E860           FA                           cli
40701 E861           8B1E       001A              mov bx, 0x001a
40702 E865           3B1E       001C              cmp bx, 0x001c
40703 E869           75           04              jne int16_key_found
40704 E86B           FB                           sti
40705 E86C           F4                           hlt
40706 E86D           EB           F1              jmp int16_wait_for_key
40707                       0000E86F            int16_key_found:
40708 E86F           BB                   F000    mov bx, #0xf000
40709 E872           8EDB                         mov ds, bx
40710 E874           E8         71D1              call _int16_function
40711 E877           61                           popa
40712 E878           9D                           popf
40713 E879           1F                           pop ds
40714 E87A           CF                           iret
40715                                           ;-------------------------------------------------
40716                                           ;- INT09h : Keyboard Hardware Service Entry Point -
40717                                           ;-------------------------------------------------
40718 E987                                      .org 0xe987
40719                       0000E987            int09_handler:
40720 E987           FA                           cli
40721 E988           50                           push ax
40722 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
40723 E98B           E6                     64    out #0x64, al
40724 E98D           B0                     0B    mov al, #0x0B
40725 E98F           E6                     20    out #0x20, al
40726 E991           E4                     20    in al, #0x20
40727 E993           24                     02    and al, #0x02
40728 E995           74           3E              jz int09_finish
40729 E997           E4                     60    in al, #0x60 ;;read key from keyboard controller
40730 E999           FB                           sti
40731 E99A           1E                           push ds
40732 E99B           60                           pusha
40733 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
40734 E99E           F9                           stc
40735 E99F           CD                     15    int #0x15
40736 E9A1           73           2C              jnc int09_done
40737                                             ;; check for extended key
40738 E9A3           3C                     E0    cmp al, #0xe0
40739 E9A5           75           0E              jne int09_check_pause
40740 E9A7           31C0                         xor ax, ax
40741 E9A9           8ED8                         mov ds, ax
40742 E9AB           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x02
40743 E9AE           0C                     02    or al, #0x02
40744 E9B0           A2         0496              mov BYTE [0x496], al
40745 E9B3           EB           1A              jmp int09_done
40746                       0000E9B5            int09_check_pause: ;; check for pause key
40747 E9B5           3C                     E1    cmp al, #0xe1
40748 E9B7           75           0E              jne int09_process_key
40749 E9B9           31C0                         xor ax, ax
40750 E9BB           8ED8                         mov ds, ax
40751 E9BD           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x01
40752 E9C0           0C                     01    or al, #0x01
40753 E9C2           A2         0496              mov BYTE [0x496], al
40754 E9C5           EB           08              jmp int09_done
40755                       0000E9C7            int09_process_key:
40756 E9C7           BB                   F000    mov bx, #0xf000
40757 E9CA           8EDB                         mov ds, bx
40758 E9CC           E8         77E6              call _int09_function
40759                       0000E9CF            int09_done:
40760 E9CF           61                           popa
40761 E9D0           1F                           pop ds
40762 E9D1           FA                           cli
40763 E9D2           E8         C606              call eoi_master_pic
40764                       0000E9D5            int09_finish:
40765 E9D5           B0                     AE    mov al, #0xAE ;;enable keyboard
40766 E9D7           E6                     64    out #0x64, al
40767 E9D9           58                           pop ax
40768 E9DA           CF                           iret
40769                                           ;----------------------------------------
40770                                           ;- INT 13h Diskette Service Entry Point -
40771                                           ;----------------------------------------
40772 EC59                                      .org 0xec59
40773                       0000EC59            int13_diskette:
40774 EC59           E9         C00F              jmp int13_noeltorito
40775                                           ;---------------------------------------------
40776                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
40777                                           ;---------------------------------------------
40778 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
40779                       0000EF57            int0e_handler:
40780 EF57           50                           push ax
40781 EF58           52                           push dx
40782 EF59           BA                   03F4    mov dx, #0x03f4
40783 EF5C           EC                           in al, dx
40784 EF5D           24                     C0    and al, #0xc0
40785 EF5F           3C                     C0    cmp al, #0xc0
40786 EF61           74           1E              je int0e_normal
40787 EF63           BA                   03F5    mov dx, #0x03f5
40788 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
40789 EF68           EE                           out dx, al
40790                       0000EF69            int0e_loop1:
40791 EF69           BA                   03F4    mov dx, #0x03f4
40792 EF6C           EC                           in al, dx
40793 EF6D           24                     C0    and al, #0xc0
40794 EF6F           3C                     C0    cmp al, #0xc0
40795 EF71           75           F6              jne int0e_loop1
40796                       0000EF73            int0e_loop2:
40797 EF73           BA                   03F5    mov dx, #0x03f5
40798 EF76           EC                           in al, dx
40799 EF77           BA                   03F4    mov dx, #0x03f4
40800 EF7A           EC                           in al, dx
40801 EF7B           24                     C0    and al, #0xc0
40802 EF7D           3C                     C0    cmp al, #0xc0
40803 EF7F           74           F2              je int0e_loop2
40804                       0000EF81            int0e_normal:
40805 EF81           1E                           push ds
40806 EF82           31C0                         xor ax, ax ;; segment 0000
40807 EF84           8ED8                         mov ds, ax
40808 EF86           E8         C052              call eoi_master_pic
40809 EF89           A0         043E              mov al, 0x043e
40810 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
40811 EF8E           A2         043E              mov 0x043e, al
40812 EF91           1F                           pop ds
40813 EF92           5A                           pop dx
40814 EF93           58                           pop ax
40815 EF94           CF                           iret
40816 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
40817                       0000EFC7            diskette_param_table:
40818                                           ;; Since no provisions are made for multiple drive types, most
40819                                           ;; values in this table are ignored. I set parameters for 1.44M
40820                                           ;; floppy here
40821 EFC7                        AF            db 0xAF
40822 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
40823 EFC9                        25            db 0x25
40824 EFCA                        02            db 0x02
40825 EFCB                        12            db 18
40826 EFCC                        1B            db 0x1B
40827 EFCD                        FF            db 0xFF
40828 EFCE                        6C            db 0x6C
40829 EFCF                        F6            db 0xF6
40830 EFD0                        0F            db 0x0F
40831 EFD1                        08            db 0x08
40832                                           ;----------------------------------------
40833                                           ;- INT17h : Printer Service Entry Point -
40834                                           ;----------------------------------------
40835 EFD2                                      .org 0xefd2
40836                       0000EFD2            int17_handler:
40837 EFD2           1E                           push ds
40838 EFD3           60                           pusha
40839 EFD4           31C0                         xor ax, ax
40840 EFD6           8ED8                         mov ds, ax
40841 EFD8           E8         B363              call _int17_function
40842 EFDB           61                           popa
40843 EFDC           1F                           pop ds
40844 EFDD           CF                           iret
40845                       0000EFDE            diskette_param_table2:
40846                                           ;; New diskette parameter table adding 3 parameters from IBM
40847                                           ;; Since no provisions are made for multiple drive types, most
40848                                           ;; values in this table are ignored. I set parameters for 1.44M
40849                                           ;; floppy here
40850 EFDE                        AF            db 0xAF
40851 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
40852 EFE0                        25            db 0x25
40853 EFE1                        02            db 0x02
40854 EFE2                        12            db 18
40855 EFE3                        1B            db 0x1B
40856 EFE4                        FF            db 0xFF
40857 EFE5                        6C            db 0x6C
40858 EFE6                        F6            db 0xF6
40859 EFE7                        0F            db 0x0F
40860 EFE8                        08            db 0x08
40861 EFE9                        4F            db 79 ;; maximum track
40862 EFEA                        00            db 0 ;; data transfer rate
40863 EFEB                        04            db 4 ;; drive type in cmos
40864 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
40865                                             HALT(11468)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2CCC    mov ax,#11468
 +a   F04B           EF                           out dx,ax
40866 F04C           CF                           iret
40867                                           ;----------
40868                                           ;- INT10h -
40869                                           ;----------
40870 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
40871                       0000F065            int10_handler:
40872                                             ;; dont do anything, since the VGA BIOS handles int10h requests
40873 F065           CF                           iret
40874 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
40875                                           ;----------
40876                                           ;- INT12h -
40877                                           ;----------
40878 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
40879                                           ; ??? different for Pentium (machine check)?
40880                       0000F841            int12_handler:
40881 F841           1E                           push ds
40882 F842           B8                   0040    mov ax, #0x0040
40883 F845           8ED8                         mov ds, ax
40884 F847           A1         0013              mov ax, 0x0013
40885 F84A           1F                           pop ds
40886 F84B           CF                           iret
40887                                           ;----------
40888                                           ;- INT11h -
40889                                           ;----------
40890 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
40891                       0000F84D            int11_handler:
40892 F84D           1E                           push ds
40893 F84E           B8                   0040    mov ax, #0x0040
40894 F851           8ED8                         mov ds, ax
40895 F853           A1         0010              mov ax, 0x0010
40896 F856           1F                           pop ds
40897 F857           CF                           iret
40898                                           ;----------
40899                                           ;- INT15h -
40900                                           ;----------
40901 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
40902                       0000F859            int15_handler:
40903 F859           9C                           pushf
40904 F85A           80FC                   53    cmp ah, #0x53
40905 F85D           74           1C              je apm_call
40906 F85F           1E                           push ds
40907 F860           06                           push es
40908 F861           80FC                   86    cmp ah, #0x86
40909 F864           74           1D              je int15_handler32
40910 F866           80FC                   E8    cmp ah, #0xE8
40911 F869           74           18              je int15_handler32
40912 F86B           60                           pusha
40913 F86C           80FC                   C2    cmp ah, #0xC2
40914 F86F           74           0D              je int15_handler_mouse
40915 F871           E8         51C1              call _int15_function
40916                       0000F874            int15_handler_mouse_ret:
40917 F874           61                           popa
40918                       0000F875            int15_handler32_ret:
40919 F875           07                           pop es
40920 F876           1F                           pop ds
40921 F877           9D                           popf
40922 F878           E9         B38D              jmp iret_modify_cf
40923                       0000F87B            apm_call:
40924 F87B           E9         B9DD              jmp _apmreal_entry
40925                       0000F87E            int15_handler_mouse:
40926 F87E           E8         56EE              call _int15_function_mouse
40927 F881           EB           F1              jmp int15_handler_mouse_ret
40928                       0000F883            int15_handler32:
40929 F883     66    60                           pushad
40930 F885           E8         5E40              call _int15_function32
40931 F888     66    61                           popad
40932 F88A           EB           E9              jmp int15_handler32_ret
40933                                           ;; Protected mode IDT descriptor
40934                                           ;;
40935                                           ;; I just make the limit 0, so the machine will shutdown
40936                                           ;; if an exception occurs during protected mode memory
40937                                           ;; transfers.
40938                                           ;;
40939                                           ;; Set base to f0000 to correspond to beginning of BIOS,
40940                                           ;; in case I actually define an IDT later
40941                                           ;; Set limit to 0
40942                       0000F88C            pmode_IDT_info:
40943 F88C                      0000            dw 0x0000 ;; limit 15:00
40944 F88E                      0000            dw 0x0000 ;; base 15:00
40945 F890                        0F            db 0x0f ;; base 23:16
40946                                           ;; Real mode IDT descriptor
40947                                           ;;
40948                                           ;; Set to typical real-mode values.
40949                                           ;; base = 000000
40950                                           ;; limit = 03ff
40951                       0000F891            rmode_IDT_info:
40952 F891                      03FF            dw 0x03ff ;; limit 15:00
40953 F893                      0000            dw 0x0000 ;; base 15:00
40954 F895                        00            db 0x00 ;; base 23:16
40955                                           ;----------
40956                                           ;- INT1Ah -
40957                                           ;----------
40958 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
40959                       0000FE6E            int1a_handler:
40960 FE6E           80FC                   B1    cmp ah, #0xb1
40961 FE71           75           14              jne int1a_normal
40962 FE73           E8         B8E5              call pcibios_real
40963 FE76           72           03              jc pcibios_error
40964 FE78           CA                   0002    retf 2
40965                       0000FE7B            pcibios_error:
40966 FE7B           88E3                         mov bl, ah
40967 FE7D           B4                     B1    mov ah, #0xb1
40968 FE7F           1E                           push ds
40969 FE80           60                           pusha
40970 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
40971 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
40972 FE85           EB           06              jmp int1a_callfunction
40973                       0000FE87            int1a_normal:
40974 FE87           1E                           push ds
40975 FE88           60                           pusha
40976 FE89           31C0                         xor ax, ax
40977 FE8B           8ED8                         mov ds, ax
40978                       0000FE8D            int1a_callfunction:
40979 FE8D           E8         A87D              call _int1a_function
40980 FE90           61                           popa
40981 FE91           1F                           pop ds
40982 FE92           CF                           iret
40983                                           ;;
40984                                           ;; int70h: IRQ8 - CMOS RTC
40985                                           ;;
40986                       0000FE93            int70_handler:
40987 FE93           1E                           push ds
40988 FE94     66    60                           pushad
40989 FE96           31C0                         xor ax, ax
40990 FE98           8ED8                         mov ds, ax
40991 FE9A           E8         AC1A              call _int70_function
40992 FE9D     66    61                           popad
40993 FE9F           1F                           pop ds
40994 FEA0           CF                           iret
40995                                           ;---------
40996                                           ;- INT08 -
40997                                           ;---------
40998 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
40999                       0000FEA5            int08_handler:
41000 FEA5           FB                           sti
41001 FEA6     66    50                           push eax
41002 FEA8           1E                           push ds
41003 FEA9           31C0                         xor ax, ax
41004 FEAB           8ED8                         mov ds, ax
41005                                             ;; time to turn off drive(s)?
41006 FEAD           A0         0440              mov al,0x0440
41007 FEB0           08C0                         or al,al
41008 FEB2           74           10              jz int08_floppy_off
41009 FEB4           FEC8                         dec al
41010 FEB6           A2         0440              mov 0x0440,al
41011 FEB9           75           09              jnz int08_floppy_off
41012                                             ;; turn motor(s) off
41013 FEBB           52                           push dx
41014 FEBC           BA                   03F2    mov dx,#0x03f2
41015 FEBF           EC                           in al,dx
41016 FEC0           24                     CF    and al,#0xcf
41017 FEC2           EE                           out dx,al
41018 FEC3           5A                           pop dx
41019                       0000FEC4            int08_floppy_off:
41020 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
41021 FEC8     66    40                           inc eax
41022                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
41023 FECA     66    3D               001800B0    cmp eax, #0x001800B0
41024 FED0           72           07              jb int08_store_ticks
41025                                             ;; there has been a midnight rollover at this point
41026 FED2     66    31C0                         xor eax, eax ;; zero out counter
41027 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
41028                       0000FED9            int08_store_ticks:
41029 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
41030                                             ;; chain to user timer tick INT #0x1c
41031 FEDD           CD                     1C    int #0x1c
41032 FEDF           FA                           cli
41033 FEE0           E8         B0F8              call eoi_master_pic
41034 FEE3           1F                           pop ds
41035 FEE4     66    58                           pop eax
41036 FEE6           CF                           iret
41037 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
41038 FF00                                      .org 0xff00
41039 FF00                        28            .ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
41040                                           ;------------------------------------------------
41041                                           ;- IRET Instruction for Dummy Interrupt Handler -
41042                                           ;------------------------------------------------
41043 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
41044                       0000FF53            dummy_iret_handler:
41045 FF53           CF                           iret
41046 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
41047                                             HALT(11702)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2DB6    mov ax,#11702
 +a   FF5A           EF                           out dx,ax
41048 FF5B           CF                           iret
41049 FFF0                                      .org 0xfff0 ; Power-up Entry Point
41050 FFF0           EA         E05B      F000     jmp 0xf000:post
41051 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
41052 FFF5                        30            .ascii "06/23/99"
41053 FFFE                                      .org 0xfffe ; System Model ID
41054 FFFE                        FC            db 0xFC
41055 FFFF                        00            db 0x00 ; filler
41056 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
41057                                           ! 8257 endasm
41058                                           !BCC_ENDASM
41059                                           ! 8258 static Bit8u vgafont8[128*8]=
41060                                           ! Register BX used in function int1a_function32
41061                                           ! 8259 {
41062                                           
41063                       0000FA6E            _vgafont8:
41064                                           ! 8260  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41065 FA6E                        00            .byte	0
41066 FA6F                        00            .byte	0
41067 FA70                        00            .byte	0
41068 FA71                        00            .byte	0
41069 FA72                        00            .byte	0
41070 FA73                        00            .byte	0
41071 FA74                        00            .byte	0
41072 FA75                        00            .byte	0
41073                                           ! 8261  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
41074 FA76                        7E            .byte	$7E
41075 FA77                        81            .byte	$81
41076 FA78                        A5            .byte	$A5
41077 FA79                        81            .byte	$81
41078 FA7A                        BD            .byte	$BD
41079 FA7B                        99            .byte	$99
41080 FA7C                        81            .byte	$81
41081 FA7D                        7E            .byte	$7E
41082                                           ! 8262  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
41083 FA7E                        7E            .byte	$7E
41084 FA7F                        FF            .byte	$FF
41085 FA80                        DB            .byte	$DB
41086 FA81                        FF            .byte	$FF
41087 FA82                        C3            .byte	$C3
41088 FA83                        E7            .byte	$E7
41089 FA84                        FF            .byte	$FF
41090 FA85                        7E            .byte	$7E
41091                                           ! 8263  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
41092 FA86                        6C            .byte	$6C
41093 FA87                        FE            .byte	$FE
41094 FA88                        FE            .byte	$FE
41095 FA89                        FE            .byte	$FE
41096 FA8A                        7C            .byte	$7C
41097 FA8B                        38            .byte	$38
41098 FA8C                        10            .byte	$10
41099 FA8D                        00            .byte	0
41100                                           ! 8264  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
41101 FA8E                        10            .byte	$10
41102 FA8F                        38            .byte	$38
41103 FA90                        7C            .byte	$7C
41104 FA91                        FE            .byte	$FE
41105 FA92                        7C            .byte	$7C
41106 FA93                        38            .byte	$38
41107 FA94                        10            .byte	$10
41108 FA95                        00            .byte	0
41109                                           ! 8265  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
41110 FA96                        38            .byte	$38
41111 FA97                        7C            .byte	$7C
41112 FA98                        38            .byte	$38
41113 FA99                        FE            .byte	$FE
41114 FA9A                        FE            .byte	$FE
41115 FA9B                        7C            .byte	$7C
41116 FA9C                        38            .byte	$38
41117 FA9D                        7C            .byte	$7C
41118                                           ! 8266  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
41119 FA9E                        10            .byte	$10
41120 FA9F                        10            .byte	$10
41121 FAA0                        38            .byte	$38
41122 FAA1                        7C            .byte	$7C
41123 FAA2                        FE            .byte	$FE
41124 FAA3                        7C            .byte	$7C
41125 FAA4                        38            .byte	$38
41126 FAA5                        7C            .byte	$7C
41127                                           ! 8267  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
41128 FAA6                        00            .byte	0
41129 FAA7                        00            .byte	0
41130 FAA8                        18            .byte	$18
41131 FAA9                        3C            .byte	$3C
41132 FAAA                        3C            .byte	$3C
41133 FAAB                        18            .byte	$18
41134 FAAC                        00            .byte	0
41135 FAAD                        00            .byte	0
41136                                           ! 8268  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
41137 FAAE                        FF            .byte	$FF
41138 FAAF                        FF            .byte	$FF
41139 FAB0                        E7            .byte	$E7
41140 FAB1                        C3            .byte	$C3
41141 FAB2                        C3            .byte	$C3
41142 FAB3                        E7            .byte	$E7
41143 FAB4                        FF            .byte	$FF
41144 FAB5                        FF            .byte	$FF
41145                                           ! 8269  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
41146 FAB6                        00            .byte	0
41147 FAB7                        3C            .byte	$3C
41148 FAB8                        66            .byte	$66
41149 FAB9                        42            .byte	$42
41150 FABA                        42            .byte	$42
41151 FABB                        66            .byte	$66
41152 FABC                        3C            .byte	$3C
41153 FABD                        00            .byte	0
41154                                           ! 8270  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
41155 FABE                        FF            .byte	$FF
41156 FABF                        C3            .byte	$C3
41157 FAC0                        99            .byte	$99
41158 FAC1                        BD            .byte	$BD
41159 FAC2                        BD            .byte	$BD
41160 FAC3                        99            .byte	$99
41161 FAC4                        C3            .byte	$C3
41162 FAC5                        FF            .byte	$FF
41163                                           ! 8271  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
41164 FAC6                        0F            .byte	$F
41165 FAC7                        07            .byte	7
41166 FAC8                        0F            .byte	$F
41167 FAC9                        7D            .byte	$7D
41168 FACA                        CC            .byte	$CC
41169 FACB                        CC            .byte	$CC
41170 FACC                        CC            .byte	$CC
41171 FACD                        78            .byte	$78
41172                                           ! 8272  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
41173 FACE                        3C            .byte	$3C
41174 FACF                        66            .byte	$66
41175 FAD0                        66            .byte	$66
41176 FAD1                        66            .byte	$66
41177 FAD2                        3C            .byte	$3C
41178 FAD3                        18            .byte	$18
41179 FAD4                        7E            .byte	$7E
41180 FAD5                        18            .byte	$18
41181                                           ! 8273  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
41182 FAD6                        3F            .byte	$3F
41183 FAD7                        33            .byte	$33
41184 FAD8                        3F            .byte	$3F
41185 FAD9                        30            .byte	$30
41186 FADA                        30            .byte	$30
41187 FADB                        70            .byte	$70
41188 FADC                        F0            .byte	$F0
41189 FADD                        E0            .byte	$E0
41190                                           ! 8274  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 
41191 FADE                        7F            .byte	$7F
41192 FADF                        63            .byte	$63
41193 FAE0                        7F            .byte	$7F
41194 FAE1                        63            .byte	$63
41195 FAE2                        63            .byte	$63
41196 FAE3                        67            .byte	$67
41197                                           ! 8274 0xe6, 0xc0,
41198 FAE4                        E6            .byte	$E6
41199 FAE5                        C0            .byte	$C0
41200                                           ! 8275  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
41201 FAE6                        99            .byte	$99
41202 FAE7                        5A            .byte	$5A
41203 FAE8                        3C            .byte	$3C
41204 FAE9                        E7            .byte	$E7
41205 FAEA                        E7            .byte	$E7
41206 FAEB                        3C            .byte	$3C
41207 FAEC                        5A            .byte	$5A
41208 FAED                        99            .byte	$99
41209                                           ! 8276  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
41210 FAEE                        80            .byte	$80
41211 FAEF                        E0            .byte	$E0
41212 FAF0                        F8            .byte	$F8
41213 FAF1                        FE            .byte	$FE
41214 FAF2                        F8            .byte	$F8
41215 FAF3                        E0            .byte	$E0
41216 FAF4                        80            .byte	$80
41217 FAF5                        00            .byte	0
41218                                           ! 8277  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
41219 FAF6                        02            .byte	2
41220 FAF7                        0E            .byte	$E
41221 FAF8                        3E            .byte	$3E
41222 FAF9                        FE            .byte	$FE
41223 FAFA                        3E            .byte	$3E
41224 FAFB                        0E            .byte	$E
41225 FAFC                        02            .byte	2
41226 FAFD                        00            .byte	0
41227                                           ! 8278  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
41228 FAFE                        18            .byte	$18
41229 FAFF                        3C            .byte	$3C
41230 FB00                        7E            .byte	$7E
41231 FB01                        18            .byte	$18
41232 FB02                        18            .byte	$18
41233 FB03                        7E            .byte	$7E
41234 FB04                        3C            .byte	$3C
41235 FB05                        18            .byte	$18
41236                                           ! 8279  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
41237 FB06                        66            .byte	$66
41238 FB07                        66            .byte	$66
41239 FB08                        66            .byte	$66
41240 FB09                        66            .byte	$66
41241 FB0A                        66            .byte	$66
41242 FB0B                        00            .byte	0
41243 FB0C                        66            .byte	$66
41244 FB0D                        00            .byte	0
41245                                           ! 8280  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
41246 FB0E                        7F            .byte	$7F
41247 FB0F                        DB            .byte	$DB
41248 FB10                        DB            .byte	$DB
41249 FB11                        7B            .byte	$7B
41250 FB12                        1B            .byte	$1B
41251 FB13                        1B            .byte	$1B
41252 FB14                        1B            .byte	$1B
41253 FB15                        00            .byte	0
41254                                           ! 8281  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
41255 FB16                        3E            .byte	$3E
41256 FB17                        63            .byte	$63
41257 FB18                        38            .byte	$38
41258 FB19                        6C            .byte	$6C
41259 FB1A                        6C            .byte	$6C
41260 FB1B                        38            .byte	$38
41261 FB1C                        CC            .byte	$CC
41262 FB1D                        78            .byte	$78
41263                                           ! 8282  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
41264 FB1E                        00            .byte	0
41265 FB1F                        00            .byte	0
41266 FB20                        00            .byte	0
41267 FB21                        00            .byte	0
41268 FB22                        7E            .byte	$7E
41269 FB23                        7E            .byte	$7E
41270 FB24                        7E            .byte	$7E
41271 FB25                        00            .byte	0
41272                                           ! 8283  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
41273 FB26                        18            .byte	$18
41274 FB27                        3C            .byte	$3C
41275 FB28                        7E            .byte	$7E
41276 FB29                        18            .byte	$18
41277 FB2A                        7E            .byte	$7E
41278 FB2B                        3C            .byte	$3C
41279 FB2C                        18            .byte	$18
41280 FB2D                        FF            .byte	$FF
41281                                           ! 8284  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
41282 FB2E                        18            .byte	$18
41283 FB2F                        3C            .byte	$3C
41284 FB30                        7E            .byte	$7E
41285 FB31                        18            .byte	$18
41286 FB32                        18            .byte	$18
41287 FB33                        18            .byte	$18
41288 FB34                        18            .byte	$18
41289 FB35                        00            .byte	0
41290                                           ! 8285  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
41291 FB36                        18            .byte	$18
41292 FB37                        18            .byte	$18
41293 FB38                        18            .byte	$18
41294 FB39                        18            .byte	$18
41295 FB3A                        7E            .byte	$7E
41296 FB3B                        3C            .byte	$3C
41297 FB3C                        18            .byte	$18
41298 FB3D                        00            .byte	0
41299                                           ! 8286  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
41300 FB3E                        00            .byte	0
41301 FB3F                        18            .byte	$18
41302 FB40                        0C            .byte	$C
41303 FB41                        FE            .byte	$FE
41304 FB42                        0C            .byte	$C
41305 FB43                        18            .byte	$18
41306 FB44                        00            .byte	0
41307 FB45                        00            .byte	0
41308                                           ! 8287  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
41309 FB46                        00            .byte	0
41310 FB47                        30            .byte	$30
41311 FB48                        60            .byte	$60
41312 FB49                        FE            .byte	$FE
41313 FB4A                        60            .byte	$60
41314 FB4B                        30            .byte	$30
41315 FB4C                        00            .byte	0
41316 FB4D                        00            .byte	0
41317                                           ! 8288  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
41318 FB4E                        00            .byte	0
41319 FB4F                        00            .byte	0
41320 FB50                        C0            .byte	$C0
41321 FB51                        C0            .byte	$C0
41322 FB52                        C0            .byte	$C0
41323 FB53                        FE            .byte	$FE
41324 FB54                        00            .byte	0
41325 FB55                        00            .byte	0
41326                                           ! 8289  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
41327 FB56                        00            .byte	0
41328 FB57                        24            .byte	$24
41329 FB58                        66            .byte	$66
41330 FB59                        FF            .byte	$FF
41331 FB5A                        66            .byte	$66
41332 FB5B                        24            .byte	$24
41333 FB5C                        00            .byte	0
41334 FB5D                        00            .byte	0
41335                                           ! 8290  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
41336 FB5E                        00            .byte	0
41337 FB5F                        18            .byte	$18
41338 FB60                        3C            .byte	$3C
41339 FB61                        7E            .byte	$7E
41340 FB62                        FF            .byte	$FF
41341 FB63                        FF            .byte	$FF
41342 FB64                        00            .byte	0
41343 FB65                        00            .byte	0
41344                                           ! 8291  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
41345 FB66                        00            .byte	0
41346 FB67                        FF            .byte	$FF
41347 FB68                        FF            .byte	$FF
41348 FB69                        7E            .byte	$7E
41349 FB6A                        3C            .byte	$3C
41350 FB6B                        18            .byte	$18
41351 FB6C                        00            .byte	0
41352 FB6D                        00            .byte	0
41353                                           ! 8292  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41354 FB6E                        00            .byte	0
41355 FB6F                        00            .byte	0
41356 FB70                        00            .byte	0
41357 FB71                        00            .byte	0
41358 FB72                        00            .byte	0
41359 FB73                        00            .byte	0
41360 FB74                        00            .byte	0
41361 FB75                        00            .byte	0
41362                                           ! 8293  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
41363 FB76                        30            .byte	$30
41364 FB77                        78            .byte	$78
41365 FB78                        78            .byte	$78
41366 FB79                        30            .byte	$30
41367 FB7A                        30            .byte	$30
41368 FB7B                        00            .byte	0
41369 FB7C                        30            .byte	$30
41370 FB7D                        00            .byte	0
41371                                           ! 8294  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
41372 FB7E                        6C            .byte	$6C
41373 FB7F                        6C            .byte	$6C
41374 FB80                        6C            .byte	$6C
41375 FB81                        00            .byte	0
41376 FB82                        00            .byte	0
41377 FB83                        00            .byte	0
41378 FB84                        00            .byte	0
41379 FB85                        00            .byte	0
41380                                           ! 8295  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
41381 FB86                        6C            .byte	$6C
41382 FB87                        6C            .byte	$6C
41383 FB88                        FE            .byte	$FE
41384 FB89                        6C            .byte	$6C
41385 FB8A                        FE            .byte	$FE
41386 FB8B                        6C            .byte	$6C
41387 FB8C                        6C            .byte	$6C
41388 FB8D                        00            .byte	0
41389                                           ! 8296  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
41390 FB8E                        30            .byte	$30
41391 FB8F                        7C            .byte	$7C
41392 FB90                        C0            .byte	$C0
41393 FB91                        78            .byte	$78
41394 FB92                        0C            .byte	$C
41395 FB93                        F8            .byte	$F8
41396 FB94                        30            .byte	$30
41397 FB95                        00            .byte	0
41398                                           ! 8297  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
41399 FB96                        00            .byte	0
41400 FB97                        C6            .byte	$C6
41401 FB98                        CC            .byte	$CC
41402 FB99                        18            .byte	$18
41403 FB9A                        30            .byte	$30
41404 FB9B                        66            .byte	$66
41405 FB9C                        C6            .byte	$C6
41406 FB9D                        00            .byte	0
41407                                           ! 8298  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
41408 FB9E                        38            .byte	$38
41409 FB9F                        6C            .byte	$6C
41410 FBA0                        38            .byte	$38
41411 FBA1                        76            .byte	$76
41412 FBA2                        DC            .byte	$DC
41413 FBA3                        CC            .byte	$CC
41414 FBA4                        76            .byte	$76
41415 FBA5                        00            .byte	0
41416                                           ! 8299  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
41417 FBA6                        60            .byte	$60
41418 FBA7                        60            .byte	$60
41419 FBA8                        C0            .byte	$C0
41420 FBA9                        00            .byte	0
41421 FBAA                        00            .byte	0
41422 FBAB                        00            .byte	0
41423 FBAC                        00            .byte	0
41424 FBAD                        00            .byte	0
41425                                           ! 8300  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
41426 FBAE                        18            .byte	$18
41427 FBAF                        30            .byte	$30
41428 FBB0                        60            .byte	$60
41429 FBB1                        60            .byte	$60
41430 FBB2                        60            .byte	$60
41431 FBB3                        30            .byte	$30
41432 FBB4                        18            .byte	$18
41433 FBB5                        00            .byte	0
41434                                           ! 8301  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
41435 FBB6                        60            .byte	$60
41436 FBB7                        30            .byte	$30
41437 FBB8                        18            .byte	$18
41438 FBB9                        18            .byte	$18
41439 FBBA                        18            .byte	$18
41440 FBBB                        30            .byte	$30
41441 FBBC                        60            .byte	$60
41442 FBBD                        00            .byte	0
41443                                           ! 8302  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
41444 FBBE                        00            .byte	0
41445 FBBF                        66            .byte	$66
41446 FBC0                        3C            .byte	$3C
41447 FBC1                        FF            .byte	$FF
41448 FBC2                        3C            .byte	$3C
41449 FBC3                        66            .byte	$66
41450 FBC4                        00            .byte	0
41451 FBC5                        00            .byte	0
41452                                           ! 8303  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
41453 FBC6                        00            .byte	0
41454 FBC7                        30            .byte	$30
41455 FBC8                        30            .byte	$30
41456 FBC9                        FC            .byte	$FC
41457 FBCA                        30            .byte	$30
41458 FBCB                        30            .byte	$30
41459 FBCC                        00            .byte	0
41460 FBCD                        00            .byte	0
41461                                           ! 8304  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
41462 FBCE                        00            .byte	0
41463 FBCF                        00            .byte	0
41464 FBD0                        00            .byte	0
41465 FBD1                        00            .byte	0
41466 FBD2                        00            .byte	0
41467 FBD3                        30            .byte	$30
41468 FBD4                        30            .byte	$30
41469 FBD5                        60            .byte	$60
41470                                           ! 8305  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
41471 FBD6                        00            .byte	0
41472 FBD7                        00            .byte	0
41473 FBD8                        00            .byte	0
41474 FBD9                        FC            .byte	$FC
41475 FBDA                        00            .byte	0
41476 FBDB                        00            .byte	0
41477 FBDC                        00            .byte	0
41478 FBDD                        00            .byte	0
41479                                           ! 8306  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
41480 FBDE                        00            .byte	0
41481 FBDF                        00            .byte	0
41482 FBE0                        00            .byte	0
41483 FBE1                        00            .byte	0
41484 FBE2                        00            .byte	0
41485 FBE3                        30            .byte	$30
41486 FBE4                        30            .byte	$30
41487 FBE5                        00            .byte	0
41488                                           ! 8307  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
41489 FBE6                        06            .byte	6
41490 FBE7                        0C            .byte	$C
41491 FBE8                        18            .byte	$18
41492 FBE9                        30            .byte	$30
41493 FBEA                        60            .byte	$60
41494 FBEB                        C0            .byte	$C0
41495 FBEC                        80            .byte	$80
41496 FBED                        00            .byte	0
41497                                           ! 8308  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
41498 FBEE                        7C            .byte	$7C
41499 FBEF                        C6            .byte	$C6
41500 FBF0                        CE            .byte	$CE
41501 FBF1                        DE            .byte	$DE
41502 FBF2                        F6            .byte	$F6
41503 FBF3                        E6            .byte	$E6
41504 FBF4                        7C            .byte	$7C
41505 FBF5                        00            .byte	0
41506                                           ! 8309  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
41507 FBF6                        30            .byte	$30
41508 FBF7                        70            .byte	$70
41509 FBF8                        30            .byte	$30
41510 FBF9                        30            .byte	$30
41511 FBFA                        30            .byte	$30
41512 FBFB                        30            .byte	$30
41513 FBFC                        FC            .byte	$FC
41514 FBFD                        00            .byte	0
41515                                           ! 8310  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
41516 FBFE                        78            .byte	$78
41517 FBFF                        CC            .byte	$CC
41518 FC00                        0C            .byte	$C
41519 FC01                        38            .byte	$38
41520 FC02                        60            .byte	$60
41521 FC03                        CC            .byte	$CC
41522 FC04                        FC            .byte	$FC
41523 FC05                        00            .byte	0
41524                                           ! 8311  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
41525 FC06                        78            .byte	$78
41526 FC07                        CC            .byte	$CC
41527 FC08                        0C            .byte	$C
41528 FC09                        38            .byte	$38
41529 FC0A                        0C            .byte	$C
41530 FC0B                        CC            .byte	$CC
41531 FC0C                        78            .byte	$78
41532 FC0D                        00            .byte	0
41533                                           ! 8312  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
41534 FC0E                        1C            .byte	$1C
41535 FC0F                        3C            .byte	$3C
41536 FC10                        6C            .byte	$6C
41537 FC11                        CC            .byte	$CC
41538 FC12                        FE            .byte	$FE
41539 FC13                        0C            .byte	$C
41540 FC14                        1E            .byte	$1E
41541 FC15                        00            .byte	0
41542                                           ! 8313  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
41543 FC16                        FC            .byte	$FC
41544 FC17                        C0            .byte	$C0
41545 FC18                        F8            .byte	$F8
41546 FC19                        0C            .byte	$C
41547 FC1A                        0C            .byte	$C
41548 FC1B                        CC            .byte	$CC
41549 FC1C                        78            .byte	$78
41550 FC1D                        00            .byte	0
41551                                           ! 8314  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
41552 FC1E                        38            .byte	$38
41553 FC1F                        60            .byte	$60
41554 FC20                        C0            .byte	$C0
41555 FC21                        F8            .byte	$F8
41556 FC22                        CC            .byte	$CC
41557 FC23                        CC            .byte	$CC
41558 FC24                        78            .byte	$78
41559 FC25                        00            .byte	0
41560                                           ! 8315  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
41561 FC26                        FC            .byte	$FC
41562 FC27                        CC            .byte	$CC
41563 FC28                        0C            .byte	$C
41564 FC29                        18            .byte	$18
41565 FC2A                        30            .byte	$30
41566 FC2B                        30            .byte	$30
41567 FC2C                        30            .byte	$30
41568 FC2D                        00            .byte	0
41569                                           ! 8316  0x78, 0xcc, 0xcc, 0x78, 0x
41570 FC2E                        78            .byte	$78
41571 FC2F                        CC            .byte	$CC
41572 FC30                        CC            .byte	$CC
41573 FC31                        78            .byte	$78
41574                                           ! 8316 cc, 0xcc, 0x78, 0x00,
41575 FC32                        CC            .byte	$CC
41576 FC33                        CC            .byte	$CC
41577 FC34                        78            .byte	$78
41578 FC35                        00            .byte	0
41579                                           ! 8317  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
41580 FC36                        78            .byte	$78
41581 FC37                        CC            .byte	$CC
41582 FC38                        CC            .byte	$CC
41583 FC39                        7C            .byte	$7C
41584 FC3A                        0C            .byte	$C
41585 FC3B                        18            .byte	$18
41586 FC3C                        70            .byte	$70
41587 FC3D                        00            .byte	0
41588                                           ! 8318  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
41589 FC3E                        00            .byte	0
41590 FC3F                        30            .byte	$30
41591 FC40                        30            .byte	$30
41592 FC41                        00            .byte	0
41593 FC42                        00            .byte	0
41594 FC43                        30            .byte	$30
41595 FC44                        30            .byte	$30
41596 FC45                        00            .byte	0
41597                                           ! 8319  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
41598 FC46                        00            .byte	0
41599 FC47                        30            .byte	$30
41600 FC48                        30            .byte	$30
41601 FC49                        00            .byte	0
41602 FC4A                        00            .byte	0
41603 FC4B                        30            .byte	$30
41604 FC4C                        30            .byte	$30
41605 FC4D                        60            .byte	$60
41606                                           ! 8320  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
41607 FC4E                        18            .byte	$18
41608 FC4F                        30            .byte	$30
41609 FC50                        60            .byte	$60
41610 FC51                        C0            .byte	$C0
41611 FC52                        60            .byte	$60
41612 FC53                        30            .byte	$30
41613 FC54                        18            .byte	$18
41614 FC55                        00            .byte	0
41615                                           ! 8321  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
41616 FC56                        00            .byte	0
41617 FC57                        00            .byte	0
41618 FC58                        FC            .byte	$FC
41619 FC59                        00            .byte	0
41620 FC5A                        00            .byte	0
41621 FC5B                        FC            .byte	$FC
41622 FC5C                        00            .byte	0
41623 FC5D                        00            .byte	0
41624                                           ! 8322  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
41625 FC5E                        60            .byte	$60
41626 FC5F                        30            .byte	$30
41627 FC60                        18            .byte	$18
41628 FC61                        0C            .byte	$C
41629 FC62                        18            .byte	$18
41630 FC63                        30            .byte	$30
41631 FC64                        60            .byte	$60
41632 FC65                        00            .byte	0
41633                                           ! 8323  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
41634 FC66                        78            .byte	$78
41635 FC67                        CC            .byte	$CC
41636 FC68                        0C            .byte	$C
41637 FC69                        18            .byte	$18
41638 FC6A                        30            .byte	$30
41639 FC6B                        00            .byte	0
41640 FC6C                        30            .byte	$30
41641 FC6D                        00            .byte	0
41642                                           ! 8324  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
41643 FC6E                        7C            .byte	$7C
41644 FC6F                        C6            .byte	$C6
41645 FC70                        DE            .byte	$DE
41646 FC71                        DE            .byte	$DE
41647 FC72                        DE            .byte	$DE
41648 FC73                        C0            .byte	$C0
41649 FC74                        78            .byte	$78
41650 FC75                        00            .byte	0
41651                                           ! 8325  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
41652 FC76                        30            .byte	$30
41653 FC77                        78            .byte	$78
41654 FC78                        CC            .byte	$CC
41655 FC79                        CC            .byte	$CC
41656 FC7A                        FC            .byte	$FC
41657 FC7B                        CC            .byte	$CC
41658 FC7C                        CC            .byte	$CC
41659 FC7D                        00            .byte	0
41660                                           ! 8326  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
41661 FC7E                        FC            .byte	$FC
41662 FC7F                        66            .byte	$66
41663 FC80                        66            .byte	$66
41664 FC81                        7C            .byte	$7C
41665 FC82                        66            .byte	$66
41666 FC83                        66            .byte	$66
41667 FC84                        FC            .byte	$FC
41668 FC85                        00            .byte	0
41669                                           ! 8327  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
41670 FC86                        3C            .byte	$3C
41671 FC87                        66            .byte	$66
41672 FC88                        C0            .byte	$C0
41673 FC89                        C0            .byte	$C0
41674 FC8A                        C0            .byte	$C0
41675 FC8B                        66            .byte	$66
41676 FC8C                        3C            .byte	$3C
41677 FC8D                        00            .byte	0
41678                                           ! 8328  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
41679 FC8E                        F8            .byte	$F8
41680 FC8F                        6C            .byte	$6C
41681 FC90                        66            .byte	$66
41682 FC91                        66            .byte	$66
41683 FC92                        66            .byte	$66
41684 FC93                        6C            .byte	$6C
41685 FC94                        F8            .byte	$F8
41686 FC95                        00            .byte	0
41687                                           ! 8329  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
41688 FC96                        FE            .byte	$FE
41689 FC97                        62            .byte	$62
41690 FC98                        68            .byte	$68
41691 FC99                        78            .byte	$78
41692 FC9A                        68            .byte	$68
41693 FC9B                        62            .byte	$62
41694 FC9C                        FE            .byte	$FE
41695 FC9D                        00            .byte	0
41696                                           ! 8330  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
41697 FC9E                        FE            .byte	$FE
41698 FC9F                        62            .byte	$62
41699 FCA0                        68            .byte	$68
41700 FCA1                        78            .byte	$78
41701 FCA2                        68            .byte	$68
41702 FCA3                        60            .byte	$60
41703 FCA4                        F0            .byte	$F0
41704 FCA5                        00            .byte	0
41705                                           ! 8331  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
41706 FCA6                        3C            .byte	$3C
41707 FCA7                        66            .byte	$66
41708 FCA8                        C0            .byte	$C0
41709 FCA9                        C0            .byte	$C0
41710 FCAA                        CE            .byte	$CE
41711 FCAB                        66            .byte	$66
41712 FCAC                        3E            .byte	$3E
41713 FCAD                        00            .byte	0
41714                                           ! 8332  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
41715 FCAE                        CC            .byte	$CC
41716 FCAF                        CC            .byte	$CC
41717 FCB0                        CC            .byte	$CC
41718 FCB1                        FC            .byte	$FC
41719 FCB2                        CC            .byte	$CC
41720 FCB3                        CC            .byte	$CC
41721 FCB4                        CC            .byte	$CC
41722 FCB5                        00            .byte	0
41723                                           ! 8333  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41724 FCB6                        78            .byte	$78
41725 FCB7                        30            .byte	$30
41726 FCB8                        30            .byte	$30
41727 FCB9                        30            .byte	$30
41728 FCBA                        30            .byte	$30
41729 FCBB                        30            .byte	$30
41730 FCBC                        78            .byte	$78
41731 FCBD                        00            .byte	0
41732                                           ! 8334  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
41733 FCBE                        1E            .byte	$1E
41734 FCBF                        0C            .byte	$C
41735 FCC0                        0C            .byte	$C
41736 FCC1                        0C            .byte	$C
41737 FCC2                        CC            .byte	$CC
41738 FCC3                        CC            .byte	$CC
41739 FCC4                        78            .byte	$78
41740 FCC5                        00            .byte	0
41741                                           ! 8335  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
41742 FCC6                        E6            .byte	$E6
41743 FCC7                        66            .byte	$66
41744 FCC8                        6C            .byte	$6C
41745 FCC9                        78            .byte	$78
41746 FCCA                        6C            .byte	$6C
41747 FCCB                        66            .byte	$66
41748 FCCC                        E6            .byte	$E6
41749 FCCD                        00            .byte	0
41750                                           ! 8336  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
41751 FCCE                        F0            .byte	$F0
41752 FCCF                        60            .byte	$60
41753 FCD0                        60            .byte	$60
41754 FCD1                        60            .byte	$60
41755 FCD2                        62            .byte	$62
41756 FCD3                        66            .byte	$66
41757 FCD4                        FE            .byte	$FE
41758 FCD5                        00            .byte	0
41759                                           ! 8337  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
41760 FCD6                        C6            .byte	$C6
41761 FCD7                        EE            .byte	$EE
41762 FCD8                        FE            .byte	$FE
41763 FCD9                        FE            .byte	$FE
41764 FCDA                        D6            .byte	$D6
41765 FCDB                        C6            .byte	$C6
41766 FCDC                        C6            .byte	$C6
41767 FCDD                        00            .byte	0
41768                                           ! 8338  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
41769 FCDE                        C6            .byte	$C6
41770 FCDF                        E6            .byte	$E6
41771 FCE0                        F6            .byte	$F6
41772 FCE1                        DE            .byte	$DE
41773 FCE2                        CE            .byte	$CE
41774 FCE3                        C6            .byte	$C6
41775 FCE4                        C6            .byte	$C6
41776 FCE5                        00            .byte	0
41777                                           ! 8339  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
41778 FCE6                        38            .byte	$38
41779 FCE7                        6C            .byte	$6C
41780 FCE8                        C6            .byte	$C6
41781 FCE9                        C6            .byte	$C6
41782 FCEA                        C6            .byte	$C6
41783 FCEB                        6C            .byte	$6C
41784 FCEC                        38            .byte	$38
41785 FCED                        00            .byte	0
41786                                           ! 8340  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
41787 FCEE                        FC            .byte	$FC
41788 FCEF                        66            .byte	$66
41789 FCF0                        66            .byte	$66
41790 FCF1                        7C            .byte	$7C
41791 FCF2                        60            .byte	$60
41792 FCF3                        60            .byte	$60
41793 FCF4                        F0            .byte	$F0
41794 FCF5                        00            .byte	0
41795                                           ! 8341  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
41796 FCF6                        78            .byte	$78
41797 FCF7                        CC            .byte	$CC
41798 FCF8                        CC            .byte	$CC
41799 FCF9                        CC            .byte	$CC
41800 FCFA                        DC            .byte	$DC
41801 FCFB                        78            .byte	$78
41802 FCFC                        1C            .byte	$1C
41803 FCFD                        00            .byte	0
41804                                           ! 8342  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
41805 FCFE                        FC            .byte	$FC
41806 FCFF                        66            .byte	$66
41807 FD00                        66            .byte	$66
41808 FD01                        7C            .byte	$7C
41809 FD02                        6C            .byte	$6C
41810 FD03                        66            .byte	$66
41811 FD04                        E6            .byte	$E6
41812 FD05                        00            .byte	0
41813                                           ! 8343  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
41814 FD06                        78            .byte	$78
41815 FD07                        CC            .byte	$CC
41816 FD08                        E0            .byte	$E0
41817 FD09                        70            .byte	$70
41818 FD0A                        1C            .byte	$1C
41819 FD0B                        CC            .byte	$CC
41820 FD0C                        78            .byte	$78
41821 FD0D                        00            .byte	0
41822                                           ! 8344  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41823 FD0E                        FC            .byte	$FC
41824 FD0F                        B4            .byte	$B4
41825 FD10                        30            .byte	$30
41826 FD11                        30            .byte	$30
41827 FD12                        30            .byte	$30
41828 FD13                        30            .byte	$30
41829 FD14                        78            .byte	$78
41830 FD15                        00            .byte	0
41831                                           ! 8345  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
41832 FD16                        CC            .byte	$CC
41833 FD17                        CC            .byte	$CC
41834 FD18                        CC            .byte	$CC
41835 FD19                        CC            .byte	$CC
41836 FD1A                        CC            .byte	$CC
41837 FD1B                        CC            .byte	$CC
41838 FD1C                        FC            .byte	$FC
41839 FD1D                        00            .byte	0
41840                                           ! 8346  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41841 FD1E                        CC            .byte	$CC
41842 FD1F                        CC            .byte	$CC
41843 FD20                        CC            .byte	$CC
41844 FD21                        CC            .byte	$CC
41845 FD22                        CC            .byte	$CC
41846 FD23                        78            .byte	$78
41847 FD24                        30            .byte	$30
41848 FD25                        00            .byte	0
41849                                           ! 8347  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
41850 FD26                        C6            .byte	$C6
41851 FD27                        C6            .byte	$C6
41852 FD28                        C6            .byte	$C6
41853 FD29                        D6            .byte	$D6
41854 FD2A                        FE            .byte	$FE
41855 FD2B                        EE            .byte	$EE
41856 FD2C                        C6            .byte	$C6
41857 FD2D                        00            .byte	0
41858                                           ! 8348  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
41859 FD2E                        C6            .byte	$C6
41860 FD2F                        C6            .byte	$C6
41861 FD30                        6C            .byte	$6C
41862 FD31                        38            .byte	$38
41863 FD32                        38            .byte	$38
41864 FD33                        6C            .byte	$6C
41865 FD34                        C6            .byte	$C6
41866 FD35                        00            .byte	0
41867                                           ! 8349  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
41868 FD36                        CC            .byte	$CC
41869 FD37                        CC            .byte	$CC
41870 FD38                        CC            .byte	$CC
41871 FD39                        78            .byte	$78
41872 FD3A                        30            .byte	$30
41873 FD3B                        30            .byte	$30
41874 FD3C                        78            .byte	$78
41875 FD3D                        00            .byte	0
41876                                           ! 8350  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
41877 FD3E                        FE            .byte	$FE
41878 FD3F                        C6            .byte	$C6
41879 FD40                        8C            .byte	$8C
41880 FD41                        18            .byte	$18
41881 FD42                        32            .byte	$32
41882 FD43                        66            .byte	$66
41883 FD44                        FE            .byte	$FE
41884 FD45                        00            .byte	0
41885                                           ! 8351  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
41886 FD46                        78            .byte	$78
41887 FD47                        60            .byte	$60
41888 FD48                        60            .byte	$60
41889 FD49                        60            .byte	$60
41890 FD4A                        60            .byte	$60
41891 FD4B                        60            .byte	$60
41892 FD4C                        78            .byte	$78
41893 FD4D                        00            .byte	0
41894                                           ! 8352  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
41895 FD4E                        C0            .byte	$C0
41896 FD4F                        60            .byte	$60
41897 FD50                        30            .byte	$30
41898 FD51                        18            .byte	$18
41899 FD52                        0C            .byte	$C
41900 FD53                        06            .byte	6
41901 FD54                        02            .byte	2
41902 FD55                        00            .byte	0
41903                                           ! 8353  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
41904 FD56                        78            .byte	$78
41905 FD57                        18            .byte	$18
41906 FD58                        18            .byte	$18
41907 FD59                        18            .byte	$18
41908 FD5A                        18            .byte	$18
41909 FD5B                        18            .byte	$18
41910 FD5C                        78            .byte	$78
41911 FD5D                        00            .byte	0
41912                                           ! 8354  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
41913 FD5E                        10            .byte	$10
41914 FD5F                        38            .byte	$38
41915 FD60                        6C            .byte	$6C
41916 FD61                        C6            .byte	$C6
41917 FD62                        00            .byte	0
41918 FD63                        00            .byte	0
41919 FD64                        00            .byte	0
41920 FD65                        00            .byte	0
41921                                           ! 8355  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
41922 FD66                        00            .byte	0
41923 FD67                        00            .byte	0
41924 FD68                        00            .byte	0
41925 FD69                        00            .byte	0
41926 FD6A                        00            .byte	0
41927 FD6B                        00            .byte	0
41928 FD6C                        00            .byte	0
41929 FD6D                        FF            .byte	$FF
41930                                           ! 8356  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
41931 FD6E                        30            .byte	$30
41932 FD6F                        30            .byte	$30
41933 FD70                        18            .byte	$18
41934 FD71                        00            .byte	0
41935 FD72                        00            .byte	0
41936 FD73                        00            .byte	0
41937 FD74                        00            .byte	0
41938 FD75                        00            .byte	0
41939                                           ! 8357  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
41940 FD76                        00            .byte	0
41941 FD77                        00            .byte	0
41942 FD78                        78            .byte	$78
41943 FD79                        0C            .byte	$C
41944 FD7A                        7C            .byte	$7C
41945 FD7B                        CC            .byte	$CC
41946 FD7C                        76            .byte	$76
41947 FD7D                        00            .byte	0
41948                                           ! 8358  0xe0, 0x60, 0x60
41949 FD7E                        E0            .byte	$E0
41950 FD7F                        60            .byte	$60
41951                                           ! 8358 , 0x7c, 0x66, 0x66, 0xdc, 0x00,
41952 FD80                        60            .byte	$60
41953 FD81                        7C            .byte	$7C
41954 FD82                        66            .byte	$66
41955 FD83                        66            .byte	$66
41956 FD84                        DC            .byte	$DC
41957 FD85                        00            .byte	0
41958                                           ! 8359  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
41959 FD86                        00            .byte	0
41960 FD87                        00            .byte	0
41961 FD88                        78            .byte	$78
41962 FD89                        CC            .byte	$CC
41963 FD8A                        C0            .byte	$C0
41964 FD8B                        CC            .byte	$CC
41965 FD8C                        78            .byte	$78
41966 FD8D                        00            .byte	0
41967                                           ! 8360  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
41968 FD8E                        1C            .byte	$1C
41969 FD8F                        0C            .byte	$C
41970 FD90                        0C            .byte	$C
41971 FD91                        7C            .byte	$7C
41972 FD92                        CC            .byte	$CC
41973 FD93                        CC            .byte	$CC
41974 FD94                        76            .byte	$76
41975 FD95                        00            .byte	0
41976                                           ! 8361  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
41977 FD96                        00            .byte	0
41978 FD97                        00            .byte	0
41979 FD98                        78            .byte	$78
41980 FD99                        CC            .byte	$CC
41981 FD9A                        FC            .byte	$FC
41982 FD9B                        C0            .byte	$C0
41983 FD9C                        78            .byte	$78
41984 FD9D                        00            .byte	0
41985                                           ! 8362  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
41986 FD9E                        38            .byte	$38
41987 FD9F                        6C            .byte	$6C
41988 FDA0                        60            .byte	$60
41989 FDA1                        F0            .byte	$F0
41990 FDA2                        60            .byte	$60
41991 FDA3                        60            .byte	$60
41992 FDA4                        F0            .byte	$F0
41993 FDA5                        00            .byte	0
41994                                           ! 8363  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41995 FDA6                        00            .byte	0
41996 FDA7                        00            .byte	0
41997 FDA8                        76            .byte	$76
41998 FDA9                        CC            .byte	$CC
41999 FDAA                        CC            .byte	$CC
42000 FDAB                        7C            .byte	$7C
42001 FDAC                        0C            .byte	$C
42002 FDAD                        F8            .byte	$F8
42003                                           ! 8364  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
42004 FDAE                        E0            .byte	$E0
42005 FDAF                        60            .byte	$60
42006 FDB0                        6C            .byte	$6C
42007 FDB1                        76            .byte	$76
42008 FDB2                        66            .byte	$66
42009 FDB3                        66            .byte	$66
42010 FDB4                        E6            .byte	$E6
42011 FDB5                        00            .byte	0
42012                                           ! 8365  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
42013 FDB6                        30            .byte	$30
42014 FDB7                        00            .byte	0
42015 FDB8                        70            .byte	$70
42016 FDB9                        30            .byte	$30
42017 FDBA                        30            .byte	$30
42018 FDBB                        30            .byte	$30
42019 FDBC                        78            .byte	$78
42020 FDBD                        00            .byte	0
42021                                           ! 8366  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
42022 FDBE                        0C            .byte	$C
42023 FDBF                        00            .byte	0
42024 FDC0                        0C            .byte	$C
42025 FDC1                        0C            .byte	$C
42026 FDC2                        0C            .byte	$C
42027 FDC3                        CC            .byte	$CC
42028 FDC4                        CC            .byte	$CC
42029 FDC5                        78            .byte	$78
42030                                           ! 8367  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
42031 FDC6                        E0            .byte	$E0
42032 FDC7                        60            .byte	$60
42033 FDC8                        66            .byte	$66
42034 FDC9                        6C            .byte	$6C
42035 FDCA                        78            .byte	$78
42036 FDCB                        6C            .byte	$6C
42037 FDCC                        E6            .byte	$E6
42038 FDCD                        00            .byte	0
42039                                           ! 8368  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
42040 FDCE                        70            .byte	$70
42041 FDCF                        30            .byte	$30
42042 FDD0                        30            .byte	$30
42043 FDD1                        30            .byte	$30
42044 FDD2                        30            .byte	$30
42045 FDD3                        30            .byte	$30
42046 FDD4                        78            .byte	$78
42047 FDD5                        00            .byte	0
42048                                           ! 8369  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
42049 FDD6                        00            .byte	0
42050 FDD7                        00            .byte	0
42051 FDD8                        CC            .byte	$CC
42052 FDD9                        FE            .byte	$FE
42053 FDDA                        FE            .byte	$FE
42054 FDDB                        D6            .byte	$D6
42055 FDDC                        C6            .byte	$C6
42056 FDDD                        00            .byte	0
42057                                           ! 8370  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
42058 FDDE                        00            .byte	0
42059 FDDF                        00            .byte	0
42060 FDE0                        F8            .byte	$F8
42061 FDE1                        CC            .byte	$CC
42062 FDE2                        CC            .byte	$CC
42063 FDE3                        CC            .byte	$CC
42064 FDE4                        CC            .byte	$CC
42065 FDE5                        00            .byte	0
42066                                           ! 8371  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
42067 FDE6                        00            .byte	0
42068 FDE7                        00            .byte	0
42069 FDE8                        78            .byte	$78
42070 FDE9                        CC            .byte	$CC
42071 FDEA                        CC            .byte	$CC
42072 FDEB                        CC            .byte	$CC
42073 FDEC                        78            .byte	$78
42074 FDED                        00            .byte	0
42075                                           ! 8372  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
42076 FDEE                        00            .byte	0
42077 FDEF                        00            .byte	0
42078 FDF0                        DC            .byte	$DC
42079 FDF1                        66            .byte	$66
42080 FDF2                        66            .byte	$66
42081 FDF3                        7C            .byte	$7C
42082 FDF4                        60            .byte	$60
42083 FDF5                        F0            .byte	$F0
42084                                           ! 8373  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
42085 FDF6                        00            .byte	0
42086 FDF7                        00            .byte	0
42087 FDF8                        76            .byte	$76
42088 FDF9                        CC            .byte	$CC
42089 FDFA                        CC            .byte	$CC
42090 FDFB                        7C            .byte	$7C
42091 FDFC                        0C            .byte	$C
42092 FDFD                        1E            .byte	$1E
42093                                           ! 8374  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
42094 FDFE                        00            .byte	0
42095 FDFF                        00            .byte	0
42096 FE00                        DC            .byte	$DC
42097 FE01                        76            .byte	$76
42098 FE02                        66            .byte	$66
42099 FE03                        60            .byte	$60
42100 FE04                        F0            .byte	$F0
42101 FE05                        00            .byte	0
42102                                           ! 8375  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
42103 FE06                        00            .byte	0
42104 FE07                        00            .byte	0
42105 FE08                        7C            .byte	$7C
42106 FE09                        C0            .byte	$C0
42107 FE0A                        78            .byte	$78
42108 FE0B                        0C            .byte	$C
42109 FE0C                        F8            .byte	$F8
42110 FE0D                        00            .byte	0
42111                                           ! 8376  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
42112 FE0E                        10            .byte	$10
42113 FE0F                        30            .byte	$30
42114 FE10                        7C            .byte	$7C
42115 FE11                        30            .byte	$30
42116 FE12                        30            .byte	$30
42117 FE13                        34            .byte	$34
42118 FE14                        18            .byte	$18
42119 FE15                        00            .byte	0
42120                                           ! 8377  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
42121 FE16                        00            .byte	0
42122 FE17                        00            .byte	0
42123 FE18                        CC            .byte	$CC
42124 FE19                        CC            .byte	$CC
42125 FE1A                        CC            .byte	$CC
42126 FE1B                        CC            .byte	$CC
42127 FE1C                        76            .byte	$76
42128 FE1D                        00            .byte	0
42129                                           ! 8378  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
42130 FE1E                        00            .byte	0
42131 FE1F                        00            .byte	0
42132 FE20                        CC            .byte	$CC
42133 FE21                        CC            .byte	$CC
42134 FE22                        CC            .byte	$CC
42135 FE23                        78            .byte	$78
42136 FE24                        30            .byte	$30
42137 FE25                        00            .byte	0
42138                                           ! 8379  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
42139 FE26                        00            .byte	0
42140 FE27                        00            .byte	0
42141 FE28                        C6            .byte	$C6
42142 FE29                        D6            .byte	$D6
42143 FE2A                        FE            .byte	$FE
42144 FE2B                        FE            .byte	$FE
42145 FE2C                        6C            .byte	$6C
42146 FE2D                        00            .byte	0
42147                                           ! 8380  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
42148 FE2E                        00            .byte	0
42149 FE2F                        00            .byte	0
42150 FE30                        C6            .byte	$C6
42151 FE31                        6C            .byte	$6C
42152 FE32                        38            .byte	$38
42153 FE33                        6C            .byte	$6C
42154 FE34                        C6            .byte	$C6
42155 FE35                        00            .byte	0
42156                                           ! 8381  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
42157 FE36                        00            .byte	0
42158 FE37                        00            .byte	0
42159 FE38                        CC            .byte	$CC
42160 FE39                        CC            .byte	$CC
42161 FE3A                        CC            .byte	$CC
42162 FE3B                        7C            .byte	$7C
42163 FE3C                        0C            .byte	$C
42164 FE3D                        F8            .byte	$F8
42165                                           ! 8382  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
42166 FE3E                        00            .byte	0
42167 FE3F                        00            .byte	0
42168 FE40                        FC            .byte	$FC
42169 FE41                        98            .byte	$98
42170 FE42                        30            .byte	$30
42171 FE43                        64            .byte	$64
42172 FE44                        FC            .byte	$FC
42173 FE45                        00            .byte	0
42174                                           ! 8383  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
42175 FE46                        1C            .byte	$1C
42176 FE47                        30            .byte	$30
42177 FE48                        30            .byte	$30
42178 FE49                        E0            .byte	$E0
42179 FE4A                        30            .byte	$30
42180 FE4B                        30            .byte	$30
42181 FE4C                        1C            .byte	$1C
42182 FE4D                        00            .byte	0
42183                                           ! 8384  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
42184 FE4E                        18            .byte	$18
42185 FE4F                        18            .byte	$18
42186 FE50                        18            .byte	$18
42187 FE51                        00            .byte	0
42188 FE52                        18            .byte	$18
42189 FE53                        18            .byte	$18
42190 FE54                        18            .byte	$18
42191 FE55                        00            .byte	0
42192                                           ! 8385  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
42193 FE56                        E0            .byte	$E0
42194 FE57                        30            .byte	$30
42195 FE58                        30            .byte	$30
42196 FE59                        1C            .byte	$1C
42197 FE5A                        30            .byte	$30
42198 FE5B                        30            .byte	$30
42199 FE5C                        E0            .byte	$E0
42200 FE5D                        00            .byte	0
42201                                           ! 8386  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
42202 FE5E                        76            .byte	$76
42203 FE5F                        DC            .byte	$DC
42204 FE60                        00            .byte	0
42205 FE61                        00            .byte	0
42206 FE62                        00            .byte	0
42207 FE63                        00            .byte	0
42208 FE64                        00            .byte	0
42209 FE65                        00            .byte	0
42210                                           ! 8387  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
42211 FE66                        00            .byte	0
42212 FE67                        10            .byte	$10
42213 FE68                        38            .byte	$38
42214 FE69                        6C            .byte	$6C
42215 FE6A                        C6            .byte	$C6
42216 FE6B                        C6            .byte	$C6
42217 FE6C                        FE            .byte	$FE
42218 FE6D                        00            .byte	0
42219                                           ! 8388 };
42220                                           !BCC_EOS
42221                                           ! 8389 #asm
42222                                           !BCC_ASM
42223 CFF0                                      .org 0xcff0
42224                       0000CFF0            bios_table_area_end:
42225                                           ! 8392 endasm
42226                                           !BCC_ENDASM
42227                                           ! 8393 
42228                       0000CFF0            .790:
42229                       0000CFF0            .7B5:
42230 CFF0                        6E            .ascii	"no PCI device with class code 0x%02x%04x"
42231 D018                        20            .ascii	" found at index %d"
42232 D02A                        0A            .byte	$A
42233 D02B                        00            .byte	0
42234                       0000D02C            .78E:
42235                       0000D02C            .7B6:
42236 D02C                        50            .ascii	"PCI device %04x:%04x not found at index "
42237 D054                        25            .ascii	"%d"
42238 D056                        0A            .byte	$A
42239 D057                        00            .byte	0
42240                       0000D058            .788:
42241                       0000D058            .7B7:
42242 D058                        62            .ascii	"bad PCI vendor ID %04x"
42243 D06E                        0A            .byte	$A
42244 D06F                        00            .byte	0
42245                       0000D070            .784:
42246                       0000D070            .7B8:
42247 D070                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
42248 D094                        0A            .byte	$A
42249 D095                        00            .byte	0
42250                       0000D096            .780:
42251                       0000D096            .7B9:
42252 D096                        50            .ascii	"PCI BIOS: PCI not present"
42253 D0AF                        0A            .byte	$A
42254 D0B0                        00            .byte	0
42255                       0000D0B1            .765:
42256                       0000D0B1            .7BA:
42257 D0B1                        42            .ascii	"Booting from %x:%x"
42258 D0C3                        0A            .byte	$A
42259 D0C4                        00            .byte	0
42260                       0000D0C5            .750:
42261                       0000D0C5            .7BB:
42262 D0C5                        49            .ascii	"Invalid boot device (0x%x)"
42263 D0DF                        0A            .byte	$A
42264 D0E0                        00            .byte	0
42265                       0000D0E1            .74D:
42266                       0000D0E1            .7BC:
42267 D0E1                        00            .byte	0
42268                       0000D0E2            .74C:
42269                       0000D0E2            .7BD:
42270 D0E2                        50            .ascii	"Powering off in 30 seconds."
42271 D0FD                        0A            .byte	$A
42272 D0FE                        00            .byte	0
42273                       0000D0FF            .74B:
42274                       0000D0FF            .7BE:
42275 D0FF                        0A            .byte	$A
42276 D100                        4E            .ascii	"No bootable device."
42277 D113                        0A            .byte	$A
42278 D114                        00            .byte	0
42279                       0000D115            .735:
42280                       0000D115            .7BF:
42281 D115                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
42282 D13A                        0A            .byte	$A
42283 D13B                        00            .byte	0
42284                       0000D13C            .730:
42285                       0000D13C            .7C0:
42286 D13C                        69            .ascii	"int13_diskette: unsupported AH=%02x"
42287 D15F                        0A            .byte	$A
42288 D160                        00            .byte	0
42289                       0000D161            .71E:
42290                       0000D161            .7C1:
42291 D161                        66            .ascii	"floppy: int13: bad floppy type"
42292 D17F                        0A            .byte	$A
42293 D180                        00            .byte	0
42294                       0000D181            .706:
42295                       0000D181            .7C2:
42296 D181                        69            .ascii	"int13_diskette_function: write error"
42297 D1A5                        0A            .byte	$A
42298 D1A6                        00            .byte	0
42299                       0000D1A7            .700:
42300                       0000D1A7            .7C3:
42301 D1A7                        69            .ascii	"int13_diskette: ctrl not ready"
42302 D1C5                        0A            .byte	$A
42303 D1C6                        00            .byte	0
42304                       0000D1C7            .6E5:
42305                       0000D1C7            .7C4:
42306 D1C7                        69            .ascii	"int13_diskette_function: read error"
42307 D1EA                        0A            .byte	$A
42308 D1EB                        00            .byte	0
42309                       0000D1EC            .6DF:
42310                       0000D1EC            .7C5:
42311 D1EC                        69            .ascii	"int13_diskette: ctrl not ready"
42312 D20A                        0A            .byte	$A
42313 D20B                        00            .byte	0
42314                       0000D20C            .6CD:
42315                       0000D20C            .7C6:
42316 D20C                        69            .ascii	"int13_diskette: ctrl not ready"
42317 D22A                        0A            .byte	$A
42318 D22B                        00            .byte	0
42319                       0000D22C            .6B8:
42320                       0000D22C            .7C7:
42321 D22C                        69            .ascii	"int13_diskette: read/write/verify: param"
42322 D254                        65            .ascii	"eter out of range"
42323 D265                        0A            .byte	$A
42324 D266                        00            .byte	0
42325                       0000D267            .656:
42326                       0000D267            .7C8:
42327 D267                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
42328 D28F                        2C            .ascii	", returns fail"
42329 D29D                        0A            .byte	$A
42330 D29E                        00            .byte	0
42331                       0000D29F            .63E:
42332                       0000D29F            .7C9:
42333 D29F                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
42334 D2C7                        0A            .byte	$A
42335 D2C8                        00            .byte	0
42336                       0000D2C9            .620:
42337                       0000D2C9            .7CA:
42338 D2C9                        69            .ascii	"int13_cdemu: function %02x, emulation no"
42339 D2F1                        74            .ascii	"t active for DL= %02x"
42340 D306                        0A            .byte	$A
42341 D307                        00            .byte	0
42342                       0000D308            .61C:
42343                       0000D308            .7CB:
42344 D308                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
42345 D32B                        0A            .byte	$A
42346 D32C                        00            .byte	0
42347                       0000D32D            .617:
42348                       0000D32D            .7CC:
42349 D32D                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
42350 D355                        20            .ascii	" report"
42351 D35C                        0A            .byte	$A
42352 D35D                        00            .byte	0
42353                       0000D35E            .60C:
42354                       0000D35E            .7CD:
42355 D35E                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
42356 D37E                        0A            .byte	$A
42357 D37F                        00            .byte	0
42358                       0000D380            .5C5:
42359                       0000D380            .7CE:
42360 D380                        69            .ascii	"int13_cdrom: function %02x, status %02x "
42361 D3A8                        21            .ascii	"!"
42362 D3A9                        0A            .byte	$A
42363 D3AA                        00            .byte	0
42364                       0000D3AB            .5BF:
42365                       0000D3AB            .7CF:
42366 D3AB                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
42367 D3D3                        62            .ascii	"bits lba"
42368 D3DB                        0A            .byte	$A
42369 D3DC                        00            .byte	0
42370                       0000D3DD            .5A5:
42371                       0000D3DD            .7D0:
42372 D3DD                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
42373 D405                        69            .ascii	"ice for ELDL=%02x"
42374 D416                        0A            .byte	$A
42375 D417                        00            .byte	0
42376                       0000D418            .5A2:
42377                       0000D418            .7D1:
42378 D418                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
42379 D440                        72            .ascii	"range %02x"
42380 D44A                        0A            .byte	$A
42381 D44B                        00            .byte	0
42382                       0000D44C            .59A:
42383                       0000D44C            .7D2:
42384 D44C                        69            .ascii	"int13_harddisk: function %02xh unsupport"
42385 D474                        65            .ascii	"ed, returns fail"
42386 D484                        0A            .byte	$A
42387 D485                        00            .byte	0
42388                       0000D486            .594:
42389                       0000D486            .7D3:
42390 D486                        69            .ascii	"int13_harddisk: function %02xh unimpleme"
42391 D4AE                        6E            .ascii	"nted, returns success"
42392 D4C3                        0A            .byte	$A
42393 D4C4                        00            .byte	0
42394                       0000D4C5            .553:
42395                       0000D4C5            .7D4:
42396 D4C5                        69            .ascii	"int13_harddisk: function %02x, error %02"
42397 D4ED                        78            .ascii	"x !"
42398 D4F0                        0A            .byte	$A
42399 D4F1                        00            .byte	0
42400                       0000D4F2            .54A:
42401                       0000D4F2            .7D5:
42402 D4F2                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
42403 D51A                        66            .ascii	"f range"
42404 D521                        0A            .byte	$A
42405 D522                        00            .byte	0
42406                       0000D523            .546:
42407                       0000D523            .7D6:
42408 D523                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
42409 D54B                        66            .ascii	"f range"
42410 D552                        0A            .byte	$A
42411 D553                        00            .byte	0
42412                       0000D554            .538:
42413                       0000D554            .7D7:
42414 D554                        66            .ascii	"format disk track called"
42415 D56C                        0A            .byte	$A
42416 D56D                        00            .byte	0
42417                       0000D56E            .536:
42418                       0000D56E            .7D8:
42419 D56E                        69            .ascii	"int13_harddisk: function %02x, error %02"
42420 D596                        78            .ascii	"x !"
42421 D599                        0A            .byte	$A
42422 D59A                        00            .byte	0
42423                       0000D59B            .52B:
42424                       0000D59B            .7D9:
42425 D59B                        69            .ascii	"int13_harddisk: function %02x, parameter"
42426 D5C3                        73            .ascii	"s out of range %04x/%04x/%04x!"
42427 D5E1                        0A            .byte	$A
42428 D5E2                        00            .byte	0
42429                       0000D5E3            .526:
42430                       0000D5E3            .7DA:
42431 D5E3                        69            .ascii	"int13_harddisk: function %02x, parameter"
42432 D60B                        20            .ascii	" out of range!"
42433 D619                        0A            .byte	$A
42434 D61A                        00            .byte	0
42435                       0000D61B            .516:
42436                       0000D61B            .7DB:
42437 D61B                        69            .ascii	"int13_harddisk: function %02x, unmapped "
42438 D643                        64            .ascii	"device for ELDL=%02x"
42439 D657                        0A            .byte	$A
42440 D658                        00            .byte	0
42441                       0000D659            .513:
42442                       0000D659            .7DC:
42443 D659                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
42444 D681                        6F            .ascii	"of range %02x"
42445 D68E                        0A            .byte	$A
42446 D68F                        00            .byte	0
42447                       0000D690            .500:
42448                       0000D690            .7DD:
42449 D690                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
42450 D6B8                        6F            .ascii	"ode are zero?"
42451 D6C5                        0A            .byte	$A
42452 D6C6                        00            .byte	0
42453                       0000D6C7            .4E8:
42454                       0000D6C7            .7DE:
42455 D6C7                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
42456 D6EF                        72            .ascii	"read: 0x%02x!"
42457 D6FC                        0A            .byte	$A
42458 D6FD                        00            .byte	0
42459                       0000D6FE            .4BA:
42460                       0000D6FE            .7DF:
42461 D6FE                        4B            .ascii	"KBD: int09 handler: AL=0"
42462 D716                        0A            .byte	$A
42463 D717                        00            .byte	0
42464                       0000D718            .4B7:
42465                       0000D718            .7E0:
42466 D718                        73            .ascii	"setkbdcomm"
42467 D722                        00            .byte	0
42468                       0000D723            .4B0:
42469                       0000D723            .7E1:
42470 D723                        73            .ascii	"sendmouse"
42471 D72C                        00            .byte	0
42472                       0000D72D            .4AD:
42473                       0000D72D            .7E2:
42474 D72D                        65            .ascii	"enabmouse"
42475 D736                        00            .byte	0
42476                       0000D737            .4A6:
42477                       0000D737            .7E3:
42478 D737                        65            .ascii	"enabmouse"
42479 D740                        00            .byte	0
42480                       0000D741            .4A3:
42481                       0000D741            .7E4:
42482 D741                        69            .ascii	"inhibmouse"
42483 D74B                        00            .byte	0
42484                       0000D74C            .49C:
42485                       0000D74C            .7E5:
42486 D74C                        69            .ascii	"inhibmouse"
42487 D756                        00            .byte	0
42488                       0000D757            .48F:
42489                       0000D757            .7E6:
42490 D757                        4B            .ascii	"KBD: unsupported int 16h function %02x"
42491 D77D                        0A            .byte	$A
42492 D77E                        00            .byte	0
42493                       0000D77F            .47E:
42494                       0000D77F            .7E7:
42495 D77F                        4B            .ascii	"KBD: int16h: out of keyboard input"
42496 D7A1                        0A            .byte	$A
42497 D7A2                        00            .byte	0
42498                       0000D7A3            .450:
42499                       0000D7A3            .7E8:
42500 D7A3                        4B            .ascii	"KBD: int16h: out of keyboard input"
42501 D7C5                        0A            .byte	$A
42502 D7C6                        00            .byte	0
42503                       0000D7C7            .43D:
42504                       0000D7C7            .7E9:
42505 D7C7                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42506 D7EF                        74            .ascii	"t yet supported!"
42507 D7FF                        0A            .byte	$A
42508 D800                        00            .byte	0
42509                       0000D801            .40C:
42510                       0000D801            .7EA:
42511 D801                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42512 D829                        74            .ascii	"t yet supported!"
42513 D839                        0A            .byte	$A
42514 D83A                        00            .byte	0
42515                       0000D83B            .400:
42516                       0000D83B            .7EB:
42517 D83B                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
42518 D853                        0A            .byte	$A
42519 D854                        00            .byte	0
42520                       0000D855            .3EA:
42521                       0000D855            .7EC:
42522 D855                        4D            .ascii	"Mouse status returned %02x (should be ac"
42523 D87D                        6B            .ascii	"k)"
42524 D87F                        0A            .byte	$A
42525 D880                        00            .byte	0
42526                       0000D881            .3DA:
42527                       0000D881            .7ED:
42528 D881                        4D            .ascii	"Mouse status returned %02x (should be ac"
42529 D8A9                        6B            .ascii	"k)"
42530 D8AB                        0A            .byte	$A
42531 D8AC                        00            .byte	0
42532                       0000D8AD            .3D7:
42533                       0000D8AD            .7EE:
42534 D8AD                        4D            .ascii	"Mouse status returned %02x (should be ac"
42535 D8D5                        6B            .ascii	"k)"
42536 D8D7                        0A            .byte	$A
42537 D8D8                        00            .byte	0
42538                       0000D8D9            .3B5:
42539                       0000D8D9            .7EF:
42540 D8D9                        4D            .ascii	"Mouse reset returned %02x (should be ack"
42541 D901                        29            .ascii	")"
42542 D902                        0A            .byte	$A
42543 D903                        00            .byte	0
42544                       0000D904            .38E:
42545                       0000D904            .7F0:
42546 D904                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
42547 D92C                        74            .ascii	"t yet supported!"
42548 D93C                        0A            .byte	$A
42549 D93D                        00            .byte	0
42550                       0000D93E            .38C:
42551                       0000D93E            .7F1:
42552 D93E                        45            .ascii	"EISA BIOS not present"
42553 D953                        0A            .byte	$A
42554 D954                        00            .byte	0
42555                       0000D955            .388:
42556                       0000D955            .7F2:
42557 D955                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
42558 D97D                        72            .ascii	"rted!"
42559 D982                        0A            .byte	$A
42560 D983                        00            .byte	0
42561                       0000D984            .371:
42562                       0000D984            .7F3:
42563 D984                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
42564 D9AC                        20            .ascii	" control not supported"
42565 D9C2                        0A            .byte	$A
42566 D9C3                        00            .byte	0
42567                       0000D9C4            .30A:
42568                       0000D9C4            .7F4:
42569 D9C4                        61            .ascii	"ata_is_ready returned %d"
42570 D9DC                        0A            .byte	$A
42571 D9DD                        00            .byte	0
42572                       0000D9DE            .2F4:
42573                       0000D9DE            .7F5:
42574 D9DE                        25            .ascii	"%dMB medium detected"
42575 D9F2                        0A            .byte	$A
42576 D9F3                        00            .byte	0
42577                       0000D9F4            .2EF:
42578                       0000D9F4            .7F6:
42579 D9F4                        55            .ascii	"Unsupported sector size %u"
42580 DA0E                        0A            .byte	$A
42581 DA0F                        00            .byte	0
42582                       0000DA10            .2EA:
42583                       0000DA10            .7F7:
42584 DA10                        57            .ascii	"Waiting for device to detect medium... "
42585 DA37                        00            .byte	0
42586                       0000DA38            .2DC:
42587                       0000DA38            .7F8:
42588 DA38                        6E            .ascii	"not implemented for non-ATAPI device"
42589 DA5C                        0A            .byte	$A
42590 DA5D                        00            .byte	0
42591                       0000DA5E            .2A2:
42592                       0000DA5E            .7F9:
42593 DA5E                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
42594 DA86                        65            .ascii	"et"
42595 DA88                        0A            .byte	$A
42596 DA89                        00            .byte	0
42597                       0000DA8A            .252:
42598                       0000DA8A            .7FA:
42599 DA8A                        0A            .byte	$A
42600 DA8B                        00            .byte	0
42601                       0000DA8C            .24D:
42602                       0000DA8C            .7FB:
42603 DA8C                        6D            .ascii	"master"
42604 DA92                        00            .byte	0
42605                       0000DA93            .24C:
42606                       0000DA93            .7FC:
42607 DA93                        20            .ascii	" slave"
42608 DA99                        00            .byte	0
42609                       0000DA9A            .24B:
42610                       0000DA9A            .7FD:
42611 DA9A                        61            .ascii	"ata%d %s: Unknown device"
42612 DAB2                        0A            .byte	$A
42613 DAB3                        00            .byte	0
42614                       0000DAB4            .249:
42615                       0000DAB4            .7FE:
42616 DAB4                        20            .ascii	" ATAPI-%d Device"
42617 DAC4                        0A            .byte	$A
42618 DAC5                        00            .byte	0
42619                       0000DAC6            .247:
42620                       0000DAC6            .7FF:
42621 DAC6                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
42622 DADE                        0A            .byte	$A
42623 DADF                        00            .byte	0
42624                       0000DAE0            .243:
42625                       0000DAE0            .800:
42626 DAE0                        25            .ascii	"%c"
42627 DAE2                        00            .byte	0
42628                       0000DAE3            .23C:
42629                       0000DAE3            .801:
42630 DAE3                        6D            .ascii	"master"
42631 DAE9                        00            .byte	0
42632                       0000DAEA            .23B:
42633                       0000DAEA            .802:
42634 DAEA                        20            .ascii	" slave"
42635 DAF0                        00            .byte	0
42636                       0000DAF1            .23A:
42637                       0000DAF1            .803:
42638 DAF1                        61            .ascii	"ata%d %s: "
42639 DAFB                        00            .byte	0
42640                       0000DAFC            .238:
42641                       0000DAFC            .804:
42642 DAFC                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
42643 DB1A                        0A            .byte	$A
42644 DB1B                        00            .byte	0
42645                       0000DB1C            .236:
42646                       0000DB1C            .805:
42647 DB1C                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
42648 DB3A                        0A            .byte	$A
42649 DB3B                        00            .byte	0
42650                       0000DB3C            .232:
42651                       0000DB3C            .806:
42652 DB3C                        25            .ascii	"%c"
42653 DB3E                        00            .byte	0
42654                       0000DB3F            .22B:
42655                       0000DB3F            .807:
42656 DB3F                        6D            .ascii	"master"
42657 DB45                        00            .byte	0
42658                       0000DB46            .22A:
42659                       0000DB46            .808:
42660 DB46                        20            .ascii	" slave"
42661 DB4C                        00            .byte	0
42662                       0000DB4D            .229:
42663                       0000DB4D            .809:
42664 DB4D                        61            .ascii	"ata%d %s: "
42665 DB57                        00            .byte	0
42666                       0000DB58            .1FE:
42667                       0000DB58            .80A:
42668 DB58                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
42669 DB80                        65            .ascii	"e"
42670 DB81                        0A            .byte	$A
42671 DB82                        00            .byte	0
42672                       0000DB83            .1F9:
42673                       0000DB83            .80B:
42674 DB83                        20            .ascii	" LCHS=%d/%d/%d"
42675 DB91                        0A            .byte	$A
42676 DB92                        00            .byte	0
42677                       0000DB93            .1D9:
42678                       0000DB93            .80C:
42679 DB93                        72            .ascii	"r-echs"
42680 DB99                        00            .byte	0
42681                       0000DB9A            .1D7:
42682                       0000DB9A            .80D:
42683 DB9A                        6C            .ascii	"large"
42684 DB9F                        00            .byte	0
42685                       0000DBA0            .1D5:
42686                       0000DBA0            .80E:
42687 DBA0                        6C            .ascii	"lba"
42688 DBA3                        00            .byte	0
42689                       0000DBA4            .1D3:
42690                       0000DBA4            .80F:
42691 DBA4                        6E            .ascii	"none"
42692 DBA8                        00            .byte	0
42693                       0000DBA9            .1C9:
42694                       0000DBA9            .810:
42695 DBA9                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
42696 DBCD                        00            .byte	0
42697                       0000DBCE            .1BF:
42698                       0000DBCE            .811:
42699 DBCE                        61            .ascii	"ata-detect: Failed to detect ATA device"
42700 DBF5                        0A            .byte	$A
42701 DBF6                        00            .byte	0
42702                       0000DBF7            .19E:
42703                       0000DBF7            .812:
42704 DBF7                        49            .ascii	"IDE time out"
42705 DC03                        0A            .byte	$A
42706 DC04                        00            .byte	0
42707                       0000DC05            .162:
42708                       0000DC05            .813:
42709 DC05                        53            .ascii	"S3 resume jump to %x:%x"
42710 DC1C                        0A            .byte	$A
42711 DC1D                        00            .byte	0
42712                       0000DC1E            .15E:
42713                       0000DC1E            .814:
42714 DC1E                        53            .ascii	"S3 resume called %x 0x%lx"
42715 DC37                        0A            .byte	$A
42716 DC38                        00            .byte	0
42717                       0000DC39            .158:
42718                       0000DC39            .815:
42719 DC39                        25            .ascii	"%s"
42720 DC3B                        0A            .byte	$A
42721 DC3C                        00            .byte	0
42722                       0000DC3D            .157:
42723                       0000DC3D            .816:
42724 DC3D                        49            .ascii	"INT18: BOOT FAILURE"
42725 DC50                        0A            .byte	$A
42726 DC51                        00            .byte	0
42727                       0000DC52            .156:
42728                       0000DC52            .817:
42729 DC52                        4E            .ascii	"NMI Handler called"
42730 DC64                        0A            .byte	$A
42731 DC65                        00            .byte	0
42732                       0000DC66            .155:
42733                       0000DC66            .818:
42734 DC66                        43            .ascii	"CDROM boot failure code : %04x"
42735 DC84                        0A            .byte	$A
42736 DC85                        00            .byte	0
42737                       0000DC86            .154:
42738                       0000DC86            .819:
42739 DC86                        0A            .byte	$A,$A
42740 DC88                        00            .byte	0
42741                       0000DC89            .153:
42742                       0000DC89            .81A:
42743 DC89                        3A            .ascii	": could not read the boot disk"
42744 DCA7                        00            .byte	0
42745                       0000DCA8            .151:
42746                       0000DCA8            .81B:
42747 DCA8                        3A            .ascii	": not a bootable disk"
42748 DCBD                        00            .byte	0
42749                       0000DCBE            .14C:
42750                       0000DCBE            .81C:
42751 DCBE                        42            .ascii	"Boot from %s failed"
42752 DCD1                        00            .byte	0
42753                       0000DCD2            .14B:
42754                       0000DCD2            .81D:
42755 DCD2                        42            .ascii	"Bad drive type"
42756 DCE0                        0A            .byte	$A
42757 DCE1                        00            .byte	0
42758                       0000DCE2            .147:
42759                       0000DCE2            .81E:
42760 DCE2                        2E            .ascii	"..."
42761 DCE5                        0A            .byte	$A
42762 DCE6                        00            .byte	0
42763                       0000DCE7            .146:
42764                       0000DCE7            .81F:
42765 DCE7                        20            .ascii	" [%S]"
42766 DCEC                        00            .byte	0
42767                       0000DCED            .142:
42768                       0000DCED            .820:
42769 DCED                        42            .ascii	"Booting from %s"
42770 DCFC                        00            .byte	0
42771                       0000DCFD            .141:
42772                       0000DCFD            .821:
42773 DCFD                        42            .ascii	"Bad drive type"
42774 DD0B                        0A            .byte	$A
42775 DD0C                        00            .byte	0
42776                       0000DD0D            .13A:
42777                       0000DD0D            .822:
42778 DD0D                        0A            .byte	$A
42779 DD0E                        00            .byte	0
42780                       0000DD0F            .12E:
42781                       0000DD0F            .823:
42782 DD0F                        0A            .byte	$A
42783 DD10                        00            .byte	0
42784                       0000DD11            .12D:
42785                       0000DD11            .824:
42786 DD11                        20            .ascii	" [%S]"
42787 DD16                        00            .byte	0
42788                       0000DD17            .12A:
42789                       0000DD17            .825:
42790 DD17                        25            .ascii	"%s"
42791 DD19                        00            .byte	0
42792                       0000DD1A            .128:
42793                       0000DD1A            .826:
42794 DD1A                        25            .ascii	"%s"
42795 DD1C                        0A            .byte	$A
42796 DD1D                        00            .byte	0
42797                       0000DD1E            .121:
42798                       0000DD1E            .827:
42799 DD1E                        25            .ascii	"%d. "
42800 DD22                        00            .byte	0
42801                       0000DD23            .11C:
42802                       0000DD23            .828:
42803 DD23                        53            .ascii	"Select boot device:"
42804 DD36                        0A            .byte	$A,$A
42805 DD38                        00            .byte	0
42806                       0000DD39            .112:
42807                       0000DD39            .829:
42808 DD39                        0A            .byte	$A,$A
42809 DD3B                        50            .ascii	"Press F12 for boot menu."
42810 DD53                        0A            .byte	$A,$A
42811 DD55                        00            .byte	0
42812                       0000DD56            .10A:
42813                       0000DD56            .82A:
42814 DD56                        61            .ascii	"apmbios pcibios eltorito PMM "
42815 DD73                        0A            .byte	$A,$A
42816 DD75                        00            .byte	0
42817                       0000DD76            .109:
42818                       0000DD76            .82B:
42819 DD76                        30            .ascii	"06/23/99"
42820 DD7E                        00            .byte	0
42821                       0000DD7F            .108:
42822                       0000DD7F            .82C:
42823 DD7F                        42            .ascii	"Bochs BIOS - build: %s"
42824 DD95                        0A            .byte	$A
42825 DD96                        25            .ascii	"%s"
42826 DD98                        0A            .byte	$A
42827 DD99                        4F            .ascii	"Options: "
42828 DDA2                        00            .byte	0
42829                       0000DDA3            .107:
42830                       0000DDA3            .82D:
42831 DDA3                        52            .ascii	"Returned from s3_resume."
42832 DDBB                        0A            .byte	$A
42833 DDBC                        00            .byte	0
42834                       0000DDBD            .106:
42835                       0000DDBD            .82E:
42836 DDBD                        55            .ascii	"Unimplemented shutdown status: %02x"
42837 DDE0                        0A            .byte	$A
42838 DDE1                        00            .byte	0
42839                       0000DDE2            .105:
42840                       0000DDE2            .82F:
42841 DDE2                        43            .ascii	"Couldn't reset the machine"
42842 DDFC                        0A            .byte	$A
42843 DDFD                        00            .byte	0
42844                       0000DDFE            .104:
42845                       0000DDFE            .830:
42846 DDFE                        4B            .ascii	"Keyboard error:%u"
42847 DE0F                        0A            .byte	$A
42848 DE10                        00            .byte	0
42849                       0000DE11            .8D:
42850                       0000DE11            .831:
42851 DE11                        62            .ascii	"bios_printf: unknown format"
42852 DE2C                        0A            .byte	$A
42853 DE2D                        00            .byte	0
42854                       0000DE2E            .41:
42855                       0000DE2E            .832:
42856 DE2E                        46            .ascii	"FATAL: "
42857 DE35                        00            .byte	0
42858 DE36                                      .bss
42859                                           
42860                                           ! 0 errors detected

Symbols:
..FFD9                      0 FFFC A   ..FFDA                      0 FFFC A   
..FFDB                      0 FFE0 A   ..FFDC                      0 FFE0 A   
..FFDD                      0 FFCA A   ..FFDE                      0 FFCA A   
..FFDF                      0 FFCA A   ..FFE0                      0 FFCA A   
..FFE1                      0 FFCA A   ..FFE2                      0 FFCA A   
..FFE3                      0 FFFC A   ..FFE4                      0 FFFC A   
..FFE5                      0 FFFC A   ..FFE6                      0 FFDE A   
..FFE7                      0 FFDE A   ..FFE8                      0 FFDE A   
..FFE9                      0 FFDE A   ..FFEA                      0 FFD2 A   
..FFEB                      0 FFDE A   ..FFEC                      0 FFD8 A   
..FFED                      0 FFD8 A   ..FFEE                      0 FFD8 A   
..FFEF                      0 FFD8 A   ..FFF0                      0 FFCA A   
..FFF1                      0 FFD8 A   ..FFF2                      0 FFF8 A   
..FFF3                      0 FFF4 A   ..FFF4                      0 FFE6 A   
..FFF5                      0 FFE6 A   ..FFF6                      0 FFF0 A   
..FFF7                      0 FFEC A   ..FFF8                      0 FFF6 A   
..FFF9                      0 F7E2 A   ..FFFA                      0 FFD4 A   
..FFFB                      0 FDBA A   ..FFFC                      0 FDBA A   
..FFFD                      0 FDD8 A   ..FFFE                      0 FDD8 A   
..FFFF                      0 FFC2 A   .1                          0 0194 A   
.10                         0 075D A   .100                        0 1288 A   
.101                        0 127F A   .102                        0 129E A   
.103                        0 1295 A   .104                        0 DDFE A   
.105                        0 DDE2 A   .106                        0 DDBD A   
.107                        0 DDA3 A   .108                        0 DD7F A   
.109                        0 DD76 A   .10A                        0 DD56 A   
.10B                        0 1372 A   .10C                        0 137C A   
.10D                        0 1386 A   .10E                        0 1390 A   
.10F                        0 139A A   .11                         0 0747 A   
.110                        0 153E A   .111                        0 1538 A   
.112                        0 DD39 A   .113                        0 1756 A   
.114                        0 174D A   .115                        0 1599 A   
.116                        0 15A9 A   .117                        0 15A6 A   
.118                        0 15B5 A   .119                        0 15AE A   
.11A                        0 15AB A   .11B                        0 15B5 A   
.11C                        0 DD23 A   .11D                        0 16E5 A   
.11E                        0 16D2 A   .11F                        0 16D9 A   
.12                         0 078B A   .120                        0 15DB A   
.121                        0 DD1E A   .122                        0 16D2 A   
.124                        0 16B6 A   .125                        0 1617 A   
.126                        0 1617 A   .127                        0 1617 A   
.128                        0 DD1A A   .129                        0 163A A   
.12A                        0 DD17 A   .12B                        0 16A4 A   
.12C                        0 1663 A   .12D                        0 DD11 A   
.12E                        0 DD0F A   .12F                        0 16E5 A   
.13                         0 0777 A   .130                        0 173D A   
.131                        0 1736 A   .132                        0 16EE A   
.133                        0 170A A   .134                        0 1702 A   
.135                        0 16FB A   .136                        0 1736 A   
.137                        0 1736 A   .138                        0 1714 A   
.139                        0 173D A   .13A                        0 DD0D A   
.13B                        0 1756 A   .13C                        0 1774 A   
.13D                        0 176E A   .13E                        0 1791 A   
.13F                        0 1783 A   .14                         0 076C A   
.140                        0 177B A   .141                        0 DCFD A   
.142                        0 DCED A   .143                        0 1811 A   
.144                        0 17D0 A   .145                        0 17B9 A   
.146                        0 DCE7 A   .147                        0 DCE2 A   
.148                        0 1842 A   .149                        0 1835 A   
.14A                        0 182D A   .14B                        0 DCD2 A   
.14C                        0 DCBE A   .14D                        0 188C A   
.14E                        0 1869 A   .14F                        0 187F A   
.15                         0 075F A   .150                        0 1870 A   
.151                        0 DCA8 A   .152                        0 188C A   
.153                        0 DC89 A   .154                        0 DC86 A   
.155                        0 DC66 A   .156                        0 DC52 A   
.157                        0 DC3D A   .158                        0 DC39 A   
.159                        0 1916 A   .15A                        0 1902 A   
.15B                        0 1928 A   .15C                        0 1935 A   
.15D                        0 1937 A   .15E                        0 DC1E A   
.15F                        0 19B4 A   .16                         0 0777 A   
.160                        0 19AE A   .161                        0 19A3 A   
.162                        0 DC05 A   .163                        0 1ACE A   
.164                        0 1AC0 A   .165                        0 1AC7 A   
.166                        0 1A50 A   .167                        0 1ACE A   
.168                        0 1C9F A   .169                        0 1C8F A   
.16A                        0 1C96 A   .16B                        0 1AD6 A   
.16C                        0 1C9F A   .16D                        0 1CE6 A   
.16E                        0 1CD8 A   .16F                        0 1CDF A   
.17                         0 078B A   .170                        0 1CA6 A   
.171                        0 1CE6 A   .172                        0 1E6D A   
.173                        0 1E6A A   .174                        0 1D3B A   
.175                        0 1D6A A   .176                        0 1D5F A   
.177                        0 1DFE A   .178                        0 1D86 A   
.179                        0 1D71 A   .17A                        0 1D7E A   
.17B                        0 1D7A A   .17C                        0 1D80 A   
.17D                        0 1DFE A   .17E                        0 1DAA A   
.17F                        0 1D8D A   .18                         0 077E A   
.180                        0 1DA3 A   .181                        0 1D9F A   
.182                        0 1D96 A   .183                        0 1DA5 A   
.184                        0 1DFE A   .185                        0 1DCE A   
.186                        0 1DB1 A   .187                        0 1DC7 A   
.188                        0 1DC3 A   .189                        0 1DBA A   
.18A                        0 1DC9 A   .18B                        0 1DFE A   
.18C                        0 1DF2 A   .18D                        0 1DD5 A   
.18E                        0 1DEB A   .18F                        0 1DE7 A   
.19                         0 07E0 A   .190                        0 1DDE A   
.191                        0 1DED A   .192                        0 1DFE A   
.193                        0 1DFE A   .194                        0 1DF9 A   
.195                        0 1E0B A   .196                        0 1E05 A   
.197                        0 1E2B A   .198                        0 1E1C A   
.199                        0 1E3B A   .19A                        0 1E34 A   
.19B                        0 1E6A A   .19C                        0 1E68 A   
.19D                        0 1E42 A   .19E                        0 DBF7 A   
.19F                        0 2D72 A   .1A                         0 07CA A   
.1A0                        0 2D62 A   .1A1                        0 2D69 A   
.1A2                        0 1FB8 A   .1A3                        0 202B A   
.1A4                        0 2027 A   .1A5                        0 202D A   
.1A6                        0 2221 A   .1A7                        0 20DC A   
.1A8                        0 20D2 A   .1A9                        0 2111 A   
.1AA                        0 210D A   .1AB                        0 2113 A   
.1AC                        0 2221 A   .1AD                        0 2159 A   
.1AE                        0 214F A   .1AF                        0 21BC A   
.1B                         0 080E A   .1B0                        0 219C A   
.1B1                        0 2194 A   .1B2                        0 2221 A   
.1B3                        0 21F4 A   .1B4                        0 21D4 A   
.1B5                        0 21CC A   .1B6                        0 21C4 A   
.1B7                        0 2221 A   .1B8                        0 2221 A   
.1B9                        0 2204 A   .1BA                        0 21FC A   
.1BB                        0 27F5 A   .1BC                        0 2247 A   
.1BD                        0 22CF A   .1BE                        0 22C1 A   
.1BF                        0 DBCE A   .1C                         0 07FA A   
.1C0                        0 22E8 A   .1C1                        0 22E4 A   
.1C2                        0 22EA A   .1C3                        0 2305 A   
.1C4                        0 2301 A   .1C5                        0 2307 A   
.1C6                        0 23A1 A   .1C7                        0 236D A   
.1C8                        0 23C6 A   .1C9                        0 DBA9 A   
.1CA                        0 254B A   .1CB                        0 253A A   
.1CC                        0 2543 A   .1CD                        0 252C A   
.1CE                        0 254B A   .1CF                        0 25CE A   
.1D                         0 07EF A   .1D1                        0 25BE A   
.1D2                        0 257C A   .1D3                        0 DBA4 A   
.1D4                        0 258C A   .1D5                        0 DBA0 A   
.1D6                        0 259C A   .1D7                        0 DB9A A   
.1D8                        0 25AC A   .1D9                        0 DB93 A   
.1DA                        0 274C A   .1DC                        0 2736 A   
.1DD                        0 25D5 A   .1DE                        0 25D8 A   
.1DF                        0 262F A   .1E                         0 07E2 A   
.1E0                        0 2626 A   .1E1                        0 266C A   
.1E2                        0 2641 A   .1E3                        0 2638 A   
.1E4                        0 266C A   .1E5                        0 2653 A   
.1E6                        0 264A A   .1E7                        0 266C A   
.1E8                        0 2665 A   .1E9                        0 265C A   
.1EA                        0 266C A   .1EB                        0 268D A   
.1EC                        0 2708 A   .1ED                        0 2696 A   
.1EE                        0 26C1 A   .1EF                        0 26BA A   
.1F                         0 07FA A   .1F0                        0 2708 A   
.1F1                        0 2732 A   .1F2                        0 2729 A   
.1F3                        0 270A A   .1F4                        0 2729 A   
.1F5                        0 2727 A   .1F6                        0 2732 A   
.1F7                        0 275C A   .1F8                        0 2755 A   
.1F9                        0 DB83 A   .1FA                        0 2984 A   
.1FB                        0 27FE A   .1FC                        0 2886 A   
.1FD                        0 2878 A   .1FE                        0 DB58 A   
.1FF                        0 28B4 A   .2                          0 05ED A   
.20                         0 080E A   .200                        0 28B0 A   
.201                        0 28B6 A   .202                        0 28D1 A   
.203                        0 28CD A   .204                        0 28D3 A   
.205                        0 2BA4 A   .207                        0 2B98 A   
.208                        0 298D A   .209                        0 29EE A   
.20A                        0 2A4F A   .20B                        0 2A3E A   
.20C                        0 2A47 A   .20D                        0 2A25 A   
.20E                        0 2A3E A   .20F                        0 2A3C A   
.21                         0 0801 A   .210                        0 2A4F A   
.211                        0 2ADC A   .212                        0 2AC9 A   
.213                        0 2AD2 A   .214                        0 2A57 A   
.215                        0 2ADC A   .216                        0 2B44 A   
.217                        0 2B33 A   .218                        0 2B3C A   
.219                        0 2AF6 A   .21A                        0 2B31 A   
.21B                        0 2B13 A   .21C                        0 2B33 A   
.21D                        0 2B44 A   .21E                        0 2B94 A   
.21F                        0 2B4C A   .22                         0 087B A   
.220                        0 2B94 A   .221                        0 2B83 A   
.222                        0 2B8C A   .223                        0 2B66 A   
.224                        0 2B94 A   .225                        0 2D5C A   
.227                        0 2D4C A   .228                        0 2BAA A   
.229                        0 DB4D A   .22A                        0 DB46 A   
.22B                        0 DB3F A   .22C                        0 2BB7 A   
.22D                        0 2BB2 A   .22E                        0 2BBA A   
.22F                        0 2C14 A   .23                         0 0862 A   
.230                        0 2BED A   .231                        0 2BD8 A   
.232                        0 DB3C A   .233                        0 2C14 A   
.234                        0 2C3D A   .235                        0 2C22 A   
.236                        0 DB1C A   .237                        0 2C69 A   
.238                        0 DAFC A   .239                        0 2C6C A   
.23A                        0 DAF1 A   .23B                        0 DAEA A   
.23C                        0 DAE3 A   .23D                        0 2C79 A   
.23E                        0 2C74 A   .23F                        0 2C7C A   
.24                         0 08A9 A   .240                        0 2CD6 A   
.241                        0 2CAF A   .242                        0 2C9A A   
.243                        0 DAE0 A   .244                        0 2CD6 A   
.245                        0 2D0B A   .246                        0 2CF4 A   
.247                        0 DAC6 A   .248                        0 2D20 A   
.249                        0 DAB4 A   .24A                        0 2D22 A   
.24B                        0 DA9A A   .24C                        0 DA93 A   
.24D                        0 DA8C A   .24E                        0 2D2F A   
.24F                        0 2D2A A   .25                         0 0895 A   
.250                        0 2D32 A   .251                        0 2D72 A   
.252                        0 DA8A A   .253                        0 2EFA A   
.254                        0 2E76 A   .255                        0 2E81 A   
.256                        0 2E7D A   .257                        0 2E83 A   
.258                        0 2EE9 A   .259                        0 2EBE A   
.25A                        0 2EB7 A   .25B                        0 2ED8 A   
.25C                        0 2EC5 A   .25D                        0 2EE9 A   
.25E                        0 2FAB A   .25F                        0 2F9F A   
.26                         0 088A A   .260                        0 2FB3 A   
.261                        0 2FFA A   .262                        0 2FF3 A   
.263                        0 317B A   .264                        0 3014 A   
.265                        0 311A A   .266                        0 305E A   
.267                        0 3037 A   .268                        0 302C A   
.269                        0 3020 A   .26A                        0 3022 A   
.26C                        0 31DB A   .26D                        0 31D7 A   
.26E                        0 31DD A   .26F                        0 3232 A   
.27                         0 087D A   .270                        0 3229 A   
.271                        0 3242 A   .272                        0 3242 A   
.273                        0 323B A   .274                        0 32E8 A   
.275                        0 32E5 A   .276                        0 3243 A   
.277                        0 32D3 A   .278                        0 32BF A   
.279                        0 32CF A   .27A                        0 32C8 A   
.27B                        0 32E5 A   .27C                        0 32E3 A   
.27D                        0 32DC A   .27E                        0 32E8 A   
.27F                        0 3394 A   .28                         0 0895 A   
.280                        0 3388 A   .281                        0 339C A   
.282                        0 33E3 A   .283                        0 33DC A   
.284                        0 3564 A   .285                        0 33FD A   
.286                        0 3503 A   .287                        0 3447 A   
.288                        0 3420 A   .289                        0 3415 A   
.28A                        0 3409 A   .28B                        0 340B A   
.28D                        0 35C4 A   .28E                        0 35C0 A   
.28F                        0 35C6 A   .29                         0 08A9 A   
.290                        0 361B A   .291                        0 3612 A   
.292                        0 362B A   .293                        0 362B A   
.294                        0 3624 A   .295                        0 36C2 A   
.296                        0 36BF A   .297                        0 362C A   
.298                        0 36AD A   .299                        0 3699 A   
.29A                        0 36A9 A   .29B                        0 36A2 A   
.29C                        0 36BF A   .29D                        0 36BD A   
.29E                        0 36B6 A   .29F                        0 36C2 A   
.2A                         0 089C A   .2A0                        0 371E A   
.2A1                        0 3709 A   .2A2                        0 DA5E A   
.2A3                        0 372E A   .2A4                        0 3727 A   
.2A5                        0 3797 A   .2A6                        0 3792 A   
.2A7                        0 37A3 A   .2A8                        0 379E A   
.2A9                        0 37EF A   .2AA                        0 37E8 A   
.2AB                        0 385A A   .2AC                        0 3856 A   
.2AD                        0 385C A   .2AE                        0 38AF A   
.2AF                        0 38A6 A   .2B                         0 091C A   
.2B0                        0 38BF A   .2B1                        0 38BF A   
.2B2                        0 38B8 A   .2B3                        0 3916 A   
.2B4                        0 38F3 A   .2B5                        0 3B91 A   
.2B6                        0 3B8E A   .2B7                        0 3B8B A   
.2B8                        0 391F A   .2B9                        0 3948 A   
.2BA                        0 3926 A   .2BB                        0 3959 A   
.2BC                        0 399A A   .2BD                        0 3997 A   
.2BE                        0 398E A   .2BF                        0 39AA A   
.2C                         0 0909 A   .2C0                        0 39A3 A   
.2C1                        0 3A09 A   .2C2                        0 39F3 A   
.2C3                        0 3A1D A   .2C4                        0 3A4A A   
.2C5                        0 3A2A A   .2C6                        0 3A6B A   
.2C7                        0 3A85 A   .2C8                        0 3A80 A   
.2C9                        0 3A93 A   .2CA                        0 3A8E A   
.2CB                        0 3AA1 A   .2CC                        0 3A9C A   
.2CD                        0 3AC8 A   .2CE                        0 3AAA A   
.2CF                        0 3AC8 A   .2D                         0 08F3 A   
.2D0                        0 3AC1 A   .2D1                        0 3AB8 A   
.2D2                        0 3AEF A   .2D3                        0 3ACF A   
.2D4                        0 3B07 A   .2D5                        0 3B8E A   
.2D6                        0 3BA1 A   .2D7                        0 3B9A A   
.2D8                        0 3C13 A   .2D9                        0 3C0C A   
.2DA                        0 3C85 A   .2DB                        0 3C70 A   
.2DC                        0 DA38 A   .2DD                        0 3D77 A   
.2DE                        0 3D67 A   .2DF                        0 3CBC A   
.2E                         0 091C A   .2E0                        0 3CF1 A   
.2E1                        0 3CEB A   .2E2                        0 3D4B A   
.2E3                        0 3D0A A   .2E4                        0 3D18 A   
.2E5                        0 3D11 A   .2E6                        0 3D4B A   
.2E7                        0 3D2D A   .2E8                        0 3D26 A   
.2E9                        0 3D1F A   .2EA                        0 DA10 A   
.2EB                        0 3D77 A   .2EC                        0 3E1E A   
.2ED                        0 3E03 A   .2EE                        0 3DEB A   
.2EF                        0 D9F4 A   .2F                         0 09CC A   
.2F0                        0 3EBB A   .2F1                        0 3EA9 A   
.2F2                        0 3F01 A   .2F3                        0 3EDD A   
.2F4                        0 D9DE A   .2F5                        0 3F48 A   
.2F6                        0 3F42 A   .2F7                        0 3F6C A   
.2F8                        0 3F66 A   .2F9                        0 3F90 A   
.2FA                        0 3F8A A   .2FB                        0 400F A   
.2FC                        0 4015 A   .2FD                        0 4072 A   
.2FE                        0 4061 A   .2FF                        0 406A A   
.3                          0 05E2 A   .30                         0 09BE A   
.300                        0 404F A   .301                        0 4061 A   
.302                        0 405F A   .303                        0 4072 A   
.304                        0 4081 A   .305                        0 407A A   
.306                        0 40B3 A   .307                        0 40A1 A   
.308                        0 4095 A   .309                        0 4097 A   
.30A                        0 D9C4 A   .30B                        0 412A A   
.30C                        0 4123 A   .30D                        0 4139 A   
.30E                        0 4132 A   .30F                        0 4192 A   
.31                         0 0948 A   .310                        0 4180 A   
.311                        0 4189 A   .312                        0 4141 A   
.313                        0 4180 A   .314                        0 4179 A   
.315                        0 4192 A   .316                        0 41EB A   
.317                        0 41D9 A   .318                        0 41E2 A   
.319                        0 419A A   .31A                        0 41D9 A   
.31B                        0 41D2 A   .31C                        0 41EB A   
.31D                        0 4323 A   .31E                        0 431C A   
.31F                        0 4332 A   .32                         0 0992 A   
.320                        0 432B A   .321                        0 4341 A   
.322                        0 433A A   .323                        0 4350 A   
.324                        0 4349 A   .325                        0 435F A   
.326                        0 4358 A   .327                        0 436E A   
.328                        0 4367 A   .329                        0 439D A   
.32A                        0 438A A   .32B                        0 43C8 A   
.32C                        0 43B7 A   .32D                        0 43A5 A   
.32E                        0 43C8 A   .32F                        0 441B A   
.33                         0 096C A   .330                        0 4414 A   
.331                        0 45E0 A   .332                        0 45D9 A   
.333                        0 4728 A   .335                        0 4710 A   
.336                        0 45F0 A   .337                        0 4626 A   
.338                        0 465C A   .339                        0 4692 A   
.33A                        0 478B A   .33B                        0 4739 A   
.33C                        0 476D A   .33D                        0 474A A   
.33E                        0 478B A   .33F                        0 47AD A   
.34                         0 09B2 A   .340                        0 479C A   
.341                        0 4A29 A   .342                        0 4806 A   
.343                        0 47FD A   .344                        0 4A27 A   
.346                        0 4A0F A   .347                        0 480C A   
.348                        0 4851 A   .349                        0 4833 A   
.34A                        0 488A A   .34B                        0 48C8 A   
.34C                        0 491A A   .34D                        0 4901 A   
.34E                        0 48DB A   .34F                        0 4901 A   
.35                         0 09B2 A   .350                        0 48F4 A   
.351                        0 491A A   .352                        0 4913 A   
.353                        0 4930 A   .354                        0 4921 A   
.355                        0 494E A   .356                        0 4946 A   
.357                        0 4959 A   .358                        0 49AB A   
.359                        0 4992 A   .35A                        0 496C A   
.35B                        0 4992 A   .35C                        0 4985 A   
.35D                        0 49AB A   .35E                        0 49A4 A   
.35F                        0 49C4 A   .36                         0 09A0 A   
.360                        0 49B2 A   .361                        0 49D3 A   
.362                        0 49DD A   .363                        0 4A05 A   
.364                        0 4A31 A   .365                        0 4F6B A   
.367                        0 4F1A A   .368                        0 4A54 A   
.369                        0 4AF9 A   .36B                        0 4AE3 A   
.36C                        0 4A5A A   .36D                        0 4A72 A   
.36E                        0 4A8A A   .36F                        0 4AAB A   
.37                         0 09CC A   .370                        0 4AC0 A   
.371                        0 D984 A   .372                        0 4AFC A   
.373                        0 4B0C A   .374                        0 4B17 A   
.375                        0 4B27 A   .376                        0 4BF1 A   
.377                        0 4B30 A   .378                        0 4BE2 A   
.379                        0 4B46 A   .37A                        0 4BEF A   
.37B                        0 4C45 A   .37C                        0 4C31 A   
.37D                        0 4BF8 A   .37E                        0 4C45 A   
.37F                        0 4C48 A   .38                         0 0A15 A   
.380                        0 4C83 A   .381                        0 4C7C A   
.382                        0 4E55 A   .383                        0 4E7B A   
.384                        0 4E75 A   .385                        0 4E86 A   
.386                        0 4E89 A   .387                        0 4E8C A   
.388                        0 D955 A   .389                        0 4EAA A   
.38A                        0 4EC6 A   .38B                        0 4ED7 A   
.38C                        0 D93E A   .38D                        0 4EF5 A   
.38E                        0 D904 A   .38F                        0 55E8 A   
.39                         0 0A06 A   .391                        0 55E0 A   
.392                        0 4F8E A   .393                        0 55B9 A   
.395                        0 5594 A   .396                        0 4F94 A   
.397                        0 5091 A   .399                        0 5083 A   
.39A                        0 4F9A A   .39B                        0 4FDB A   
.39C                        0 4FB0 A   .39D                        0 4FDB A   
.39E                        0 4FCA A   .39F                        0 4FC3 A   
.3A                         0 0A0D A   .3A0                        0 4FF0 A   
.3A1                        0 501A A   .3A2                        0 5009 A   
.3A3                        0 505E A   .3A4                        0 5030 A   
.3A5                        0 505E A   .3A6                        0 504A A   
.3A7                        0 5043 A   .3A8                        0 5070 A   
.3A9                        0 5094 A   .3AA                        0 5094 A   
.3AB                        0 50F9 A   .3AC                        0 509B A   
.3AD                        0 50B3 A   .3AE                        0 50A2 A   
.3AF                        0 519A A   .3B                         0 09F5 A   
.3B0                        0 5111 A   .3B1                        0 5130 A   
.3B2                        0 5124 A   .3B3                        0 514B A   
.3B4                        0 5137 A   .3B5                        0 D8D9 A   
.3B6                        0 519A A   .3B7                        0 5152 A   
.3B8                        0 519A A   .3B9                        0 5165 A   
.3BA                        0 519A A   .3BB                        0 517A A   
.3BC                        0 51AC A   .3BD                        0 520C A   
.3BF                        0 51E9 A   .3C                         0 0A06 A   
.3C0                        0 51B1 A   .3C1                        0 51B8 A   
.3C2                        0 51BF A   .3C3                        0 51C6 A   
.3C4                        0 51CD A   .3C5                        0 51D4 A   
.3C6                        0 51DB A   .3C7                        0 51E2 A   
.3C8                        0 520A A   .3C9                        0 51FC A   
.3CA                        0 526A A   .3CB                        0 5213 A   
.3CC                        0 525B A   .3CD                        0 5226 A   
.3CE                        0 5268 A   .3CF                        0 5277 A   
.3D                         0 0A04 A   .3D0                        0 527A A   
.3D1                        0 5316 A   .3D2                        0 5289 A   
.3D3                        0 5307 A   .3D4                        0 529C A   
.3D5                        0 52C3 A   .3D6                        0 52AF A   
.3D7                        0 D8AD A   .3D8                        0 52F8 A   
.3D9                        0 52E4 A   .3DA                        0 D881 A   
.3DB                        0 5314 A   .3DC                        0 5323 A   
.3DD                        0 5331 A   .3DE                        0 5374 A   
.3DF                        0 5347 A   .3E                         0 0A15 A   
.3E0                        0 5381 A   .3E1                        0 5384 A   
.3E2                        0 54F8 A   .3E4                        0 54E4 A   
.3E5                        0 538A A   .3E6                        0 543A A   
.3E7                        0 53A5 A   .3E8                        0 53CC A   
.3E9                        0 53B8 A   .3EA                        0 D855 A   
.3EB                        0 543A A   .3EC                        0 53D3 A   
.3ED                        0 543A A   .3EE                        0 53E6 A   
.3EF                        0 543A A   .3F                         0 0A59 A   
.3F0                        0 53F9 A   .3F1                        0 543A A   
.3F2                        0 540C A   .3F3                        0 5457 A   
.3F4                        0 5457 A   .3F5                        0 5472 A   
.3F6                        0 5464 A   .3F7                        0 547E A   
.3F8                        0 549E A   .3F9                        0 5485 A   
.3FA                        0 5499 A   .3FB                        0 549B A   
.3FC                        0 54B4 A   .3FD                        0 54A5 A   
.3FE                        0 54C1 A   .3FF                        0 54CE A   
.4                          0 05CD A   .40                         0 0A3E A   
.400                        0 D83B A   .401                        0 54FB A   
.402                        0 555B A   .403                        0 5545 A   
.404                        0 553E A   .405                        0 5559 A   
.406                        0 554E A   .407                        0 5563 A   
.408                        0 5585 A   .409                        0 55B7 A   
.40A                        0 55A7 A   .40B                        0 55BB A   
.40C                        0 D801 A   .40D                        0 5A44 A   
.40F                        0 5A36 A   .41                         0 DE2E A   
.410                        0 56E1 A   .411                        0 5727 A   
.412                        0 5A0F A   .414                        0 5A01 A   
.415                        0 572D A   .416                        0 5761 A   
.417                        0 575B A   .418                        0 57FA A   
.419                        0 5776 A   .41A                        0 579C A   
.41B                        0 5781 A   .41C                        0 57F7 A   
.41D                        0 57ED A   .41E                        0 58B5 A   
.41F                        0 58AF A   .42                         0 0DDB A   
.420                        0 5804 A   .421                        0 5875 A   
.422                        0 5864 A   .423                        0 586D A   
.424                        0 580B A   .425                        0 5864 A   
.426                        0 5862 A   .427                        0 584A A   
.428                        0 5875 A   .429                        0 5888 A   
.42A                        0 587D A   .42B                        0 58B5 A   
.42C                        0 58D7 A   .42D                        0 591A A   
.42E                        0 5914 A   .42F                        0 598B A   
.43                         0 0DC5 A   .430                        0 597A A   
.431                        0 5983 A   .432                        0 5921 A   
.433                        0 597A A   .434                        0 5978 A   
.435                        0 5960 A   .436                        0 598B A   
.437                        0 59EC A   .438                        0 5998 A   
.439                        0 59EC A   .43A                        0 59C4 A   
.43B                        0 59FA A   .43C                        0 5A11 A   
.43D                        0 D7C7 A   .43E                        0 5B2F A   
.43F                        0 5A8C A   .44                         0 0A5C A   
.440                        0 5ABA A   .441                        0 5AAB A   
.442                        0 5A9D A   .443                        0 5ABA A   
.444                        0 5B2E A   .445                        0 5AC7 A   
.446                        0 5B11 A   .447                        0 5B02 A   
.448                        0 5AF4 A   .449                        0 5B11 A   
.44A                        0 5E86 A   .44C                        0 5E3C A   
.44D                        0 5B39 A   .44E                        0 5B5D A   
.44F                        0 5B4F A   .45                         0 0A71 A   
.450                        0 D7A3 A   .451                        0 5B72 A   
.452                        0 5B6B A   .453                        0 5B64 A   
.454                        0 5B7E A   .455                        0 5B7E A   
.456                        0 5B79 A   .457                        0 5B90 A   
.458                        0 5BB1 A   .459                        0 5BA5 A   
.45A                        0 5BC6 A   .45B                        0 5BBF A   
.45C                        0 5BB8 A   .45D                        0 5BD2 A   
.45E                        0 5BD2 A   .45F                        0 5BCD A   
.46                         0 0A63 A   .460                        0 5BEC A   
.461                        0 5C0B A   .462                        0 5C2F A   
.463                        0 5C23 A   .464                        0 5C39 A   
.465                        0 5C3C A   .466                        0 5C49 A   
.467                        0 5C90 A   .468                        0 5C76 A   
.469                        0 5C69 A   .46A                        0 5C90 A   
.46B                        0 5C85 A   .46C                        0 5D04 A   
.46D                        0 5C97 A   .46E                        0 5D04 A   
.46F                        0 5CA4 A   .47                         0 0DBE A   
.470                        0 5D04 A   .471                        0 5CF9 A   
.472                        0 5CA4 A   .473                        0 5CD3 A   
.474                        0 5CB9 A   .475                        0 5CAC A   
.476                        0 5CD3 A   .477                        0 5CC8 A   
.478                        0 5CF9 A   .479                        0 5CDA A   
.47A                        0 5D04 A   .47B                        0 5D0D A   
.47C                        0 5D31 A   .47D                        0 5D23 A   
.47E                        0 D77F A   .47F                        0 5D44 A   
.48                         0 0DAF A   .480                        0 5D3F A   
.481                        0 5D38 A   .482                        0 5D56 A   
.483                        0 5D77 A   .484                        0 5D6B A   
.485                        0 5D8A A   .486                        0 5D85 A   
.487                        0 5D7E A   .488                        0 5DA4 A   
.489                        0 5E03 A   .48A                        0 5E10 A   
.48B                        0 5E12 A   .48C                        0 5E24 A   
.48D                        0 5E19 A   .48E                        0 5E24 A   
.48F                        0 D757 A   .49                         0 0A7A A   
.490                        0 5E75 A   .491                        0 5E4F A   
.492                        0 5F61 A   .493                        0 5EDE A   
.494                        0 5F58 A   .495                        0 5F31 A   
.496                        0 5F47 A   .497                        0 5F41 A   
.498                        0 5F67 A   .499                        0 5F6B A   
.49A                        0 5FB1 A   .49B                        0 5F9F A   
.49C                        0 D74C A   .49D                        0 5FD0 A   
.49E                        0 5FC1 A   .49F                        0 5FC1 A   
.4A                         0 0AA9 A   .4A0                        0 5FD0 A   
.4A1                        0 6003 A   .4A2                        0 5FF1 A   
.4A3                        0 D741 A   .4A4                        0 605E A   
.4A5                        0 604C A   .4A6                        0 D737 A   
.4A7                        0 607D A   .4A8                        0 606E A   
.4A9                        0 606E A   .4AA                        0 607D A   
.4AB                        0 60AA A   .4AC                        0 6098 A   
.4AD                        0 D72D A   .4AE                        0 6102 A   
.4AF                        0 60F0 A   .4B                         0 0A88 A   
.4B0                        0 D723 A   .4B1                        0 613D A   
.4B2                        0 612E A   .4B3                        0 612E A   
.4B4                        0 613D A   .4B5                        0 618A A   
.4B6                        0 6179 A   .4B7                        0 D718 A   
.4B8                        0 61DA A   .4B9                        0 61C8 A   
.4BA                        0 D6FE A   .4BB                        0 6807 A   
.4BD                        0 67AA A   .4BE                        0 6218 A   
.4BF                        0 6253 A   .4C                         0 0A81 A   
.4C0                        0 6272 A   .4C1                        0 6291 A   
.4C2                        0 62B0 A   .4C3                        0 62CF A   
.4C4                        0 62EE A   .4C5                        0 6356 A   
.4C6                        0 62F7 A   .4C7                        0 633A A   
.4C8                        0 631C A   .4C9                        0 6356 A   
.4CA                        0 6359 A   .4CB                        0 63C1 A   
.4CC                        0 6362 A   .4CD                        0 63A5 A   
.4CE                        0 6387 A   .4CF                        0 63C1 A   
.4D                         0 0DAD A   .4D0                        0 63C4 A   
.4D1                        0 6407 A   .4D2                        0 63E9 A   
.4D3                        0 6423 A   .4D4                        0 6426 A   
.4D5                        0 6469 A   .4D6                        0 644B A   
.4D7                        0 6485 A   .4D8                        0 6488 A   
.4D9                        0 64C9 A   .4DA                        0 6491 A   
.4DB                        0 64CC A   .4DC                        0 64F1 A   
.4DD                        0 64D5 A   .4DE                        0 64F4 A   
.4DF                        0 652F A   .4E                         0 0B46 A   
.4E0                        0 654E A   .4E1                        0 655A A   
.4E2                        0 6557 A   .4E3                        0 655A A   
.4E4                        0 6566 A   .4E5                        0 6563 A   
.4E6                        0 6585 A   .4E7                        0 656D A   
.4E8                        0 D6C7 A   .4E9                        0 65CB A   
.4EA                        0 658E A   .4EB                        0 6778 A   
.4EC                        0 6611 A   .4ED                        0 65D4 A   
.4EE                        0 6778 A   .4EF                        0 664C A   
.4F                         0 0AD0 A   .4F0                        0 6628 A   
.4F1                        0 661A A   .4F2                        0 6621 A   
.4F3                        0 6778 A   .4F4                        0 66E9 A   
.4F5                        0 6657 A   .4F6                        0 66AC A   
.4F7                        0 6676 A   .4F8                        0 66E6 A   
.4F9                        0 6778 A   .4FA                        0 6744 A   
.4FB                        0 6708 A   .4FC                        0 6778 A   
.4FD                        0 6794 A   .4FE                        0 6786 A   
.4FF                        0 677F A   .5                          0 05E2 A   
.50                         0 0AC7 A   .500                        0 D690 A   
.501                        0 6818 A   .502                        0 6810 A   
.503                        0 689E A   .504                        0 6898 A   
.505                        0 68AC A   .506                        0 68A6 A   
.507                        0 6923 A   .508                        0 691F A   
.509                        0 695C A   .50A                        0 6958 A   
.50B                        0 69E9 A   .50C                        0 6998 A   
.50D                        0 69E7 A   .50E                        0 69E1 A   
.50F                        0 69F0 A   .51                         0 0ADD A   
.510                        0 6A62 A   .511                        0 6A40 A   
.512                        0 6A39 A   .513                        0 D659 A   
.514                        0 6AA6 A   .515                        0 6A84 A   
.516                        0 D61B A   .517                        0 799F A   
.519                        0 7921 A   .51A                        0 6AB0 A   
.51B                        0 6AC4 A   .51C                        0 6B0C A   
.51D                        0 6B04 A   .51E                        0 6B12 A   
.51F                        0 6B15 A   .52                         0 0AD7 A   
.520                        0 6B15 A   .521                        0 6B15 A   
.522                        0 6B8B A   .523                        0 6B6F A   
.524                        0 6B68 A   .525                        0 6B61 A   
.526                        0 D5E3 A   .527                        0 6C1F A   
.528                        0 6BFA A   .529                        0 6BF2 A   
.52A                        0 6BEA A   .52B                        0 D59B A   
.52C                        0 6C31 A   .52D                        0 6C2B A   
.52E                        0 6CED A   .52F                        0 6C7B A   
.53                         0 0AEC A   .530                        0 6C73 A   
.531                        0 6D2C A   .532                        0 6CF9 A   
.533                        0 6D5D A   .534                        0 6DAC A   
.535                        0 6D7F A   .536                        0 D56E A   
.537                        0 6DB5 A   .538                        0 D554 A   
.539                        0 6DD0 A   .53A                        0 6EAE A   
.53B                        0 6EE6 A   .53C                        0 6EDE A   
.53D                        0 6EF7 A   .53E                        0 6EFA A   
.53F                        0 6FAB A   .54                         0 0AE4 A   
.540                        0 6FCB A   .541                        0 6FCB A   
.542                        0 6FCB A   .543                        0 6FCB A   
.544                        0 705B A   .545                        0 703F A   
.546                        0 D523 A   .547                        0 70D7 A   
.548                        0 70BB A   .549                        0 7097 A   
.54A                        0 D4F2 A   .54B                        0 70F5 A   
.54C                        0 70EF A   .54D                        0 70E3 A   
.54E                        0 7134 A   .54F                        0 7101 A   
.55                         0 0AF2 A   .550                        0 7165 A   
.551                        0 71BB A   .552                        0 718E A   
.553                        0 D4C5 A   .554                        0 71C4 A   
.555                        0 71C4 A   .556                        0 71CD A   
.557                        0 71E1 A   .558                        0 71FF A   
.559                        0 71F9 A   .55A                        0 73EC A   
.55B                        0 7209 A   .55C                        0 7355 A   
.55D                        0 732D A   .55E                        0 72DD A   
.55F                        0 731E A   .56                         0 0B43 A   
.560                        0 7320 A   .562                        0 737F A   
.563                        0 7669 A   .564                        0 73F6 A   
.565                        0 74D1 A   .566                        0 74CD A   
.567                        0 74D3 A   .568                        0 74EF A   
.569                        0 74EB A   .56A                        0 74F1 A   
.56B                        0 7508 A   .56C                        0 7504 A   
.56D                        0 750A A   .56E                        0 7523 A   
.56F                        0 751F A   .57                         0 0B35 A   
.570                        0 7525 A   .571                        0 7604 A   
.572                        0 75F1 A   .573                        0 7615 A   
.574                        0 764C A   .575                        0 763E A   
.576                        0 7645 A   .577                        0 7621 A   
.578                        0 764C A   .579                        0 78AE A   
.57A                        0 7673 A   .57B                        0 776C A   
.57C                        0 771B A   .57D                        0 776C A   
.57E                        0 7800 A   .57F                        0 77C2 A   
.58                         0 0B3C A   .580                        0 7800 A   
.581                        0 788E A   .582                        0 7880 A   
.583                        0 7887 A   .584                        0 7862 A   
.585                        0 788E A   .586                        0 78B7 A   
.587                        0 78DE A   .589                        0 78CC A   
.58A                        0 78BC A   .58B                        0 78BC A   
.58C                        0 78BC A   .58D                        0 78BC A   
.58E                        0 78C4 A   .58F                        0 78E1 A   
.59                         0 0AFB A   .590                        0 78E1 A   
.591                        0 78E1 A   .592                        0 78E1 A   
.593                        0 78E1 A   .594                        0 D486 A   
.595                        0 7900 A   .596                        0 7900 A   
.597                        0 7900 A   .598                        0 7900 A   
.599                        0 7900 A   .59A                        0 D44C A   
.59B                        0 7969 A   .59C                        0 7937 A   
.59D                        0 799C A   .59E                        0 797C A   
.59F                        0 7A50 A   .5A                         0 0B22 A   
.5A0                        0 7A2E A   .5A1                        0 7A27 A   
.5A2                        0 D418 A   .5A3                        0 7A94 A   
.5A4                        0 7A72 A   .5A5                        0 D3DD A   
.5A6                        0 84CE A   .5A8                        0 8450 A   
.5A9                        0 7A9E A   .5AA                        0 7A9E A   
.5AB                        0 7A9E A   .5AC                        0 7A9E A   
.5AD                        0 7A9E A   .5AE                        0 7A9E A   
.5AF                        0 7A9E A   .5B                         0 0B1A A   
.5B0                        0 7A9E A   .5B1                        0 7AA7 A   
.5B2                        0 7AA7 A   .5B3                        0 7AA7 A   
.5B4                        0 7ABB A   .5B5                        0 7B03 A   
.5B6                        0 7AFB A   .5B7                        0 7B09 A   
.5B8                        0 7B0C A   .5B9                        0 7B20 A   
.5BA                        0 7B40 A   .5BB                        0 7B40 A   
.5BC                        0 7B40 A   .5BD                        0 7BC3 A   
.5BE                        0 7BA7 A   .5BF                        0 D3AB A   
.5C                         0 0B2B A   .5C0                        0 7BF9 A   
.5C1                        0 7BF3 A   .5C2                        0 7BE7 A   
.5C3                        0 7D1C A   .5C4                        0 7CEF A   
.5C5                        0 D380 A   .5C6                        0 7D25 A   
.5C7                        0 7D32 A   .5C8                        0 7D2C A   
.5C9                        0 7E3A A   .5CB                        0 7E2A A   
.5CC                        0 7D55 A   .5CD                        0 7D77 A   
.5CE                        0 7D5C A   .5CF                        0 7DA8 A   
.5D                         0 0B43 A   .5D0                        0 7DCA A   
.5D1                        0 7DAF A   .5D2                        0 7DF9 A   
.5D3                        0 7DF5 A   .5D4                        0 7DFB A   
.5D5                        0 7E0B A   .5D6                        0 7E16 A   
.5D7                        0 7E12 A   .5D8                        0 7E18 A   
.5D9                        0 7E43 A   .5DA                        0 7E78 A   
.5DB                        0 7E67 A   .5DC                        0 7EA3 A   
.5DD                        0 7E92 A   .5DE                        0 7EAC A   
.5DF                        0 7ECA A   .5E                         0 0DA8 A   
.5E0                        0 7EC4 A   .5E1                        0 7FA0 A   
.5E2                        0 7ED4 A   .5E3                        0 81A3 A   
.5E4                        0 7FAA A   .5E5                        0 807E A   
.5E6                        0 807A A   .5E7                        0 8080 A   
.5E8                        0 8186 A   .5E9                        0 8178 A   
.5EA                        0 817F A   .5EB                        0 815B A   
.5EC                        0 8186 A   .5ED                        0 83E8 A   
.5EE                        0 81AD A   .5EF                        0 82A6 A   
.5F                         0 0B62 A   .5F0                        0 8255 A   
.5F1                        0 82A6 A   .5F2                        0 833A A   
.5F3                        0 82FC A   .5F4                        0 833A A   
.5F5                        0 83C8 A   .5F6                        0 83BA A   
.5F7                        0 83C1 A   .5F8                        0 839C A   
.5F9                        0 83C8 A   .5FA                        0 83F1 A   
.5FB                        0 8405 A   .5FC                        0 842C A   
.5FE                        0 841A A   .5FF                        0 840A A   
.6                          0 05DC A   .60                         0 0B4D A   
.600                        0 840A A   .601                        0 840A A   
.602                        0 840A A   .603                        0 8412 A   
.604                        0 842F A   .605                        0 842F A   
.606                        0 842F A   .607                        0 842F A   
.608                        0 842F A   .609                        0 842F A   
.60A                        0 842F A   .60B                        0 842F A   
.60C                        0 D35E A   .60D                        0 8498 A   
.60E                        0 8466 A   .60F                        0 84CB A   
.61                         0 0DA8 A   .610                        0 84AB A   
.611                        0 8721 A   .613                        0 8703 A   
.614                        0 8545 A   .615                        0 8545 A   
.616                        0 8545 A   .617                        0 D32D A   
.618                        0 855F A   .619                        0 86DD A   
.61A                        0 86CD A   .61B                        0 86E4 A   
.61C                        0 D308 A   .61D                        0 8817 A   
.61E                        0 87F5 A   .61F                        0 87DC A   
.62                         0 0CF8 A   .620                        0 D2C9 A   
.621                        0 8D7A A   .623                        0 8CFF A   
.624                        0 8821 A   .625                        0 8821 A   
.626                        0 8821 A   .627                        0 8821 A   
.628                        0 8821 A   .629                        0 8821 A   
.62A                        0 8821 A   .62B                        0 8821 A   
.62C                        0 882A A   .62D                        0 882A A   
.62E                        0 883E A   .62F                        0 8886 A   
.63                         0 0B6B A   .630                        0 887E A   
.631                        0 888C A   .632                        0 888F A   
.633                        0 888F A   .634                        0 8924 A   
.635                        0 891E A   .636                        0 8942 A   
.637                        0 893C A   .638                        0 8934 A   
.639                        0 892C A   .63A                        0 8954 A   
.63B                        0 894E A   .63C                        0 8BCD A   
.63D                        0 8B96 A   .63E                        0 D29F A   
.63F                        0 8BD6 A   .64                         0 0C13 A   
.640                        0 8CB5 A   .642                        0 8CA9 A   
.643                        0 8C83 A   .644                        0 8C8F A   
.645                        0 8C9B A   .646                        0 8CCB A   
.647                        0 8CDF A   .648                        0 8CDF A   
.649                        0 8CDF A   .64A                        0 8CDF A   
.64B                        0 8CDF A   .64C                        0 8CDF A   
.64D                        0 8CDF A   .64E                        0 8CDF A   
.64F                        0 8CDF A   .65                         0 0BA0 A   
.650                        0 8CDF A   .651                        0 8CDF A   
.652                        0 8CDF A   .653                        0 8CDF A   
.654                        0 8CDF A   .655                        0 8CDF A   
.656                        0 D267 A   .657                        0 8D44 A   
.658                        0 8D12 A   .659                        0 8D77 A   
.65A                        0 8D57 A   .65B                        0 8E18 A   
.65C                        0 8E0F A   .65D                        0 8E03 A   
.65E                        0 8E18 A   .65F                        0 8E6B A   
.66                         0 0BE7 A   .660                        0 8E64 A   
.661                        0 8E70 A   .662                        0 8EB8 A   
.663                        0 8EAF A   .664                        0 8EA3 A   
.665                        0 8EB8 A   .666                        0 8EF7 A   
.667                        0 8EBF A   .668                        0 8EDA A   
.669                        0 8ED1 A   .66A                        0 8EC0 A   
.66B                        0 8EDA A   .66C                        0 8F23 A   
.66D                        0 8F19 A   .66E                        0 8F38 A   
.66F                        0 8F32 A   .67                         0 0BAA A   
.670                        0 8F4C A   .671                        0 8F45 A   
.672                        0 8F77 A   .673                        0 8F71 A   
.674                        0 8F96 A   .675                        0 8F90 A   
.676                        0 8FB7 A   .677                        0 8FA9 A   
.678                        0 8FBF A   .679                        0 8FD9 A   
.67A                        0 8FC6 A   .67B                        0 909A A   
.67C                        0 8FF3 A   .67D                        0 8FE0 A   
.67E                        0 909A A   .67F                        0 900D A   
.68                         0 0C10 A   .680                        0 8FFA A   
.681                        0 909A A   .682                        0 9027 A   
.683                        0 9014 A   .684                        0 909A A   
.685                        0 9040 A   .686                        0 902E A   
.687                        0 909A A   .688                        0 9059 A   
.689                        0 9047 A   .68A                        0 909A A   
.68B                        0 9072 A   .68C                        0 9060 A   
.68D                        0 909A A   .68E                        0 908B A   
.68F                        0 9079 A   .69                         0 0CF5 A   
.690                        0 909A A   .691                        0 90A9 A   
.692                        0 90A1 A   .693                        0 90AF A   
.694                        0 9121 A   .695                        0 911A A   
.696                        0 9107 A   .697                        0 9121 A   
.698                        0 9157 A   .699                        0 9147 A   
.69A                        0 9165 A   .69B                        0 91B6 A   
.69C                        0 91A8 A   .69D                        0 91BE A   
.69E                        0 91CD A   .69F                        0 91C5 A   
.6A                         0 0C46 A   .6A0                        0 91D4 A   
.6A1                        0 A2F0 A   .6A3                        0 A2B1 A   
.6A4                        0 91EE A   .6A5                        0 921B A   
.6A6                        0 91FB A   .6A7                        0 923C A   
.6A8                        0 922E A   .6A9                        0 9244 A   
.6AA                        0 926B A   .6AB                        0 924B A   
.6AC                        0 9298 A   .6AD                        0 92D6 A   
.6AE                        0 92CE A   .6AF                        0 92DA A   
.6B                         0 0C1A A   .6B0                        0 92DA A   
.6B1                        0 92DA A   .6B2                        0 935B A   
.6B3                        0 9323 A   .6B4                        0 931C A   
.6B5                        0 9315 A   .6B6                        0 930E A   
.6B7                        0 9307 A   .6B8                        0 D22C A   
.6B9                        0 9394 A   .6BA                        0 936A A   
.6BB                        0 93DC A   .6BC                        0 93A3 A   
.6BD                        0 93DC A   .6BE                        0 93B2 A   
.6BF                        0 9799 A   .6C                         0 0CF5 A   
.6C0                        0 93E5 A   .6C1                        0 9415 A   
.6C2                        0 940E A   .6C3                        0 945E A   
.6C4                        0 9434 A   .6C5                        0 9605 A   
.6C6                        0 95FE A   .6C7                        0 95A6 A   
.6C8                        0 95EB A   .6C9                        0 95BE A   
.6CA                        0 9605 A   .6CB                        0 965B A   
.6CC                        0 964D A   .6CD                        0 D20C A   
.6CE                        0 976E A   .6CF                        0 9744 A   
.6D                         0 0CF5 A   .6D0                        0 9B70 A   
.6D1                        0 9B48 A   .6D2                        0 97A2 A   
.6D3                        0 97D2 A   .6D4                        0 97CB A   
.6D5                        0 981B A   .6D6                        0 97F1 A   
.6D7                        0 99B4 A   .6D8                        0 99AD A   
.6D9                        0 9955 A   .6DA                        0 999A A   
.6DB                        0 996D A   .6DC                        0 99B4 A   
.6DD                        0 9A0A A   .6DE                        0 99FC A   
.6DF                        0 D1EC A   .6E                         0 0C56 A   
.6E0                        0 9B1E A   .6E1                        0 9AF3 A   
.6E2                        0 9B10 A   .6E3                        0 9AFC A   
.6E4                        0 9B1E A   .6E5                        0 D1C7 A   
.6E6                        0 9B70 A   .6E7                        0 9B73 A   
.6E8                        0 9BD2 A   .6E9                        0 9BB6 A   
.6EA                        0 9BAF A   .6EB                        0 9BA8 A   
.6EC                        0 9BA1 A   .6ED                        0 9B9A A   
.6EE                        0 9C01 A   .6EF                        0 9BE1 A   
.6F                         0 0C4D A   .6F0                        0 9C49 A   
.6F1                        0 9C10 A   .6F2                        0 9C49 A   
.6F3                        0 9C1F A   .6F4                        0 9C79 A   
.6F5                        0 9C72 A   .6F6                        0 9CC1 A   
.6F7                        0 9C97 A   .6F8                        0 9E19 A   
.6F9                        0 9E12 A   .6FA                        0 9DC4 A   
.6FB                        0 9DFF A   .6FC                        0 9DDC A   
.6FD                        0 9E19 A   .6FE                        0 9E6F A   
.6FF                        0 9E61 A   .7                          0 05ED A   
.70                         0 0C63 A   .700                        0 D1A7 A   
.701                        0 9F83 A   .702                        0 9F58 A   
.703                        0 9F75 A   .704                        0 9F61 A   
.705                        0 9F83 A   .706                        0 D181 A   
.707                        0 9FB0 A   .708                        0 9FF2 A   
.709                        0 9FBD A   .70A                        0 A013 A   
.70B                        0 A00C A   .70C                        0 A023 A   
.70D                        0 A01C A   .70E                        0 A038 A   
.70F                        0 A02A A   .71                         0 0C5D A   
.710                        0 A040 A   .711                        0 A15D A   
.713                        0 A136 A   .714                        0 A07A A   
.715                        0 A08C A   .716                        0 A0A0 A   
.717                        0 A0B4 A   .718                        0 A0C8 A   
.719                        0 A0DC A   .71A                        0 A0EF A   
.71B                        0 A101 A   .71C                        0 A113 A   
.71D                        0 A126 A   .71E                        0 D161 A   
.71F                        0 A15B A   .72                         0 0C72 A   
.720                        0 A149 A   .721                        0 A176 A   
.722                        0 A199 A   .723                        0 A183 A   
.724                        0 A1BA A   .725                        0 A1AC A   
.726                        0 A1C2 A   .727                        0 A1DD A   
.728                        0 A1D1 A   .729                        0 A1E8 A   
.72A                        0 A1EC A   .72B                        0 A219 A   
.72C                        0 A1F9 A   .72D                        0 A239 A   
.72E                        0 A259 A   .72F                        0 A279 A   
.73                         0 0C6A A   .730                        0 D13C A   
.731                        0 A2D6 A   .732                        0 A2C4 A   
.733                        0 A323 A   .734                        0 A316 A   
.735                        0 D115 A   .736                        0 A46A A   
.737                        0 A377 A   .738                        0 A36E A   
.739                        0 A364 A   .73A                        0 A3FE A   
.73B                        0 A398 A   .73C                        0 A3FE A   
.73D                        0 A3E7 A   .73E                        0 A3E0 A   
.73F                        0 A3FE A   .74                         0 0C78 A   
.740                        0 A3F7 A   .741                        0 A43C A   
.742                        0 A405 A   .743                        0 A460 A   
.744                        0 A458 A   .745                        0 A472 A   
.746                        0 A513 A   .747                        0 A4E9 A   
.748                        0 A54F A   .749                        0 A54F A   
.74A                        0 A51A A   .74B                        0 D0FF A   
.74C                        0 D0E2 A   .74D                        0 D0E1 A   
.74E                        0 A57C A   .74F                        0 A567 A   
.75                         0 0CF5 A   .750                        0 D0C5 A   
.751                        0 A6D7 A   .753                        0 A6BB A   
.754                        0 A591 A   .755                        0 A591 A   
.756                        0 A59D A   .757                        0 A599 A   
.758                        0 A59F A   .759                        0 A5EF A   
.75A                        0 A5DE A   .75B                        0 A628 A   
.75C                        0 A606 A   .75D                        0 A5F7 A   
.75E                        0 A628 A   .75F                        0 A618 A   
.76                         0 0CE7 A   .760                        0 A641 A   
.761                        0 A667 A   .762                        0 A64E A   
.763                        0 A699 A   .764                        0 A6B5 A   
.765                        0 D0B1 A   .766                        0 AAB3 A   
.768                        0 AA88 A   .769                        0 A719 A   
.76A                        0 A73D A   .76B                        0 A760 A   
.76C                        0 A772 A   .76D                        0 A767 A   
.76E                        0 A7B9 A   .76F                        0 A7C3 A   
.77                         0 0CEE A   .770                        0 A7C0 A   
.771                        0 A833 A   .772                        0 A84A A   
.773                        0 A83F A   .774                        0 A88B A   
.775                        0 A8A0 A   .776                        0 A892 A   
.777                        0 A914 A   .778                        0 A939 A   
.779                        0 A92E A   .77A                        0 A943 A   
.77B                        0 A940 A   .77C                        0 A9AA A   
.77D                        0 A9DE A   .77E                        0 A9F6 A   
.77F                        0 A9E5 A   .78                         0 0C81 A   
.780                        0 D096 A   .781                        0 AA6E A   
.782                        0 AA13 A   .783                        0 A9FD A   
.784                        0 D070 A   .785                        0 AA6E A   
.786                        0 AA2D A   .787                        0 AA1A A   
.788                        0 D058 A   .789                        0 AA6E A   
.78A                        0 AA6E A   .78B                        0 AA34 A   
.78C                        0 AA54 A   .78D                        0 AA3B A   
.78E                        0 D02C A   .78F                        0 AA6E A   
.79                         0 0CD4 A   .790                        0 CFF0 A   
.791                        0 AA7E A   .792                        0 AAAB A   
.793                        0 AA9B A   .794                        0 ABD8 A   
.795                        0 AAE9 A   .796                        0 AAF6 A   
.797                        0 AAF2 A   .798                        0 ABD8 A   
.799                        0 AB01 A   .79A                        0 ABD8 A   
.79B                        0 AB15 A   .79C                        0 ABA5 A   
.79D                        0 AB3B A   .79E                        0 ABD5 A   
.79F                        0 B5A8 A   .7A                         0 0CCC A   
.7A1                        0 B5A0 A   .7A2                        0 B4E4 A   
.7A3                        0 B510 A   .7A4                        0 B504 A   
.7A5                        0 B4EB A   .7A6                        0 B592 A   
.7A8                        0 B56D A   .7A9                        0 B515 A   
.7AA                        0 B515 A   .7AB                        0 B515 A   
.7AC                        0 B515 A   .7AD                        0 B515 A   
.7AE                        0 B515 A   .7AF                        0 B515 A   
.7B                         0 0CDD A   .7B0                        0 B515 A   
.7B1                        0 B563 A   .7B2                        0 B590 A   
.7B3                        0 B580 A   .7B4                        0 B594 A   
.7B5                        0 CFF0 A   .7B6                        0 D02C A   
.7B7                        0 D058 A   .7B8                        0 D070 A   
.7B9                        0 D096 A   .7BA                        0 D0B1 A   
.7BB                        0 D0C5 A   .7BC                        0 D0E1 A   
.7BD                        0 D0E2 A   .7BE                        0 D0FF A   
.7BF                        0 D115 A   .7C                         0 0CF5 A   
.7C0                        0 D13C A   .7C1                        0 D161 A   
.7C2                        0 D181 A   .7C3                        0 D1A7 A   
.7C4                        0 D1C7 A   .7C5                        0 D1EC A   
.7C6                        0 D20C A   .7C7                        0 D22C A   
.7C8                        0 D267 A   .7C9                        0 D29F A   
.7CA                        0 D2C9 A   .7CB                        0 D308 A   
.7CC                        0 D32D A   .7CD                        0 D35E A   
.7CE                        0 D380 A   .7CF                        0 D3AB A   
.7D                         0 0DA8 A   .7D0                        0 D3DD A   
.7D1                        0 D418 A   .7D2                        0 D44C A   
.7D3                        0 D486 A   .7D4                        0 D4C5 A   
.7D5                        0 D4F2 A   .7D6                        0 D523 A   
.7D7                        0 D554 A   .7D8                        0 D56E A   
.7D9                        0 D59B A   .7DA                        0 D5E3 A   
.7DB                        0 D61B A   .7DC                        0 D659 A   
.7DD                        0 D690 A   .7DE                        0 D6C7 A   
.7DF                        0 D6FE A   .7E                         0 0D37 A   
.7E0                        0 D718 A   .7E1                        0 D723 A   
.7E2                        0 D72D A   .7E3                        0 D737 A   
.7E4                        0 D741 A   .7E5                        0 D74C A   
.7E6                        0 D757 A   .7E7                        0 D77F A   
.7E8                        0 D7A3 A   .7E9                        0 D7C7 A   
.7EA                        0 D801 A   .7EB                        0 D83B A   
.7EC                        0 D855 A   .7ED                        0 D881 A   
.7EE                        0 D8AD A   .7EF                        0 D8D9 A   
.7F                         0 0CFF A   .7F0                        0 D904 A   
.7F1                        0 D93E A   .7F2                        0 D955 A   
.7F3                        0 D984 A   .7F4                        0 D9C4 A   
.7F5                        0 D9DE A   .7F6                        0 D9F4 A   
.7F7                        0 DA10 A   .7F8                        0 DA38 A   
.7F9                        0 DA5E A   .7FA                        0 DA8A A   
.7FB                        0 DA8C A   .7FC                        0 DA93 A   
.7FD                        0 DA9A A   .7FE                        0 DAB4 A   
.7FF                        0 DAC6 A   .8                          0 06F1 A   
.80                         0 0D23 A   .800                        0 DAE0 A   
.801                        0 DAE3 A   .802                        0 DAEA A   
.803                        0 DAF1 A   .804                        0 DAFC A   
.805                        0 DB1C A   .806                        0 DB3C A   
.807                        0 DB3F A   .808                        0 DB46 A   
.809                        0 DB4D A   .80A                        0 DB58 A   
.80B                        0 DB83 A   .80C                        0 DB93 A   
.80D                        0 DB9A A   .80E                        0 DBA0 A   
.80F                        0 DBA4 A   .81                         0 0D09 A   
.810                        0 DBA9 A   .811                        0 DBCE A   
.812                        0 DBF7 A   .813                        0 DC05 A   
.814                        0 DC1E A   .815                        0 DC39 A   
.816                        0 DC3D A   .817                        0 DC52 A   
.818                        0 DC66 A   .819                        0 DC86 A   
.81A                        0 DC89 A   .81B                        0 DCA8 A   
.81C                        0 DCBE A   .81D                        0 DCD2 A   
.81E                        0 DCE2 A   .81F                        0 DCE7 A   
.82                         0 0D35 A   .820                        0 DCED A   
.821                        0 DCFD A   .822                        0 DD0D A   
.823                        0 DD0F A   .824                        0 DD11 A   
.825                        0 DD17 A   .826                        0 DD1A A   
.827                        0 DD1E A   .828                        0 DD23 A   
.829                        0 DD39 A   .82A                        0 DD56 A   
.82B                        0 DD76 A   .82C                        0 DD7F A   
.82D                        0 DDA3 A   .82E                        0 DDBD A   
.82F                        0 DDE2 A   .83                         0 0DA8 A   
.830                        0 DDFE A   .831                        0 DE11 A   
.832                        0 DE2E A   .84                         0 0D50 A   
.85                         0 0D3E A   .86                         0 0DA8 A   
.87                         0 0D85 A   .88                         0 0D57 A   
.89                         0 0DA8 A   .8A                         0 0D9A A   
.8B                         0 0D8C A   .8C                         0 0DA8 A   
.8D                         0 DE11 A   .8E                         0 0DBE A   
.8F                         0 0DDB A   .9                          0 06E2 A   
.90                         0 0DE8 A   .91                         0 0DE4 A   
.92                         0 0E20 A   .93                         0 0E06 A   
.94                         0 0DF9 A   .95                         0 0E20 A   
.96                         0 0E15 A   .97                         0 0E5E A   
.98                         0 0E53 A   .99                         0 0E28 A   
.9A                         0 0E53 A   .9B                         0 0E44 A   
.9C                         0 0E5E A   .9D                         0 0E9B A   
.9E                         0 0E81 A   .9F                         0 0E74 A   
.A                          0 0709 A   .A0                         0 0E9B A   
.A1                         0 0E90 A   .A2                         0 0EAA A   
.A3                         0 0EA2 A   .A4                         0 0EDA A   
.A5                         0 0EC0 A   .A6                         0 0EB2 A   
.A7                         0 0EDA A   .A8                         0 0ECF A   
.A9                         0 0EEA A   .AA                         0 0EE1 A   
.AB                         0 0F00 A   .AC                         0 0EF7 A   
.AD                         0 0F3E A   .AE                         0 0F24 A   
.AF                         0 0F16 A   .B                          0 06FA A   
.B0                         0 0F3E A   .B1                         0 0F33 A   
.B2                         0 0F4E A   .B3                         0 0F45 A   
.B4                         0 0F7E A   .B5                         0 0F64 A   
.B6                         0 0F56 A   .B7                         0 0F7E A   
.B8                         0 0F73 A   .B9                         0 0F8E A   
.BA                         0 0F85 A   .BB                         0 0FA4 A   
.BC                         0 0F9B A   .BD                         0 0FFE A   
.BE                         0 0FE4 A   .BF                         0 0FD6 A   
.C                          0 072D A   .C0                         0 0FFE A   
.C1                         0 0FF3 A   .C2                         0 100E A   
.C3                         0 1005 A   .C4                         0 103E A   
.C5                         0 1024 A   .C6                         0 1016 A   
.C7                         0 103E A   .C8                         0 1033 A   
.C9                         0 104E A   .CA                         0 1045 A   
.CB                         0 1064 A   .CC                         0 105B A   
.CD                         0 1094 A   .CE                         0 107A A   
.CF                         0 106C A   .D                          0 0712 A   
.D0                         0 1094 A   .D1                         0 1089 A   
.D2                         0 10A4 A   .D3                         0 109B A   
.D4                         0 10BA A   .D5                         0 10B1 A   
.D6                         0 10F8 A   .D7                         0 10DE A   
.D8                         0 10D0 A   .D9                         0 10F8 A   
.DA                         0 10ED A   .DB                         0 1108 A   
.DC                         0 10FF A   .DD                         0 1138 A   
.DE                         0 111E A   .DF                         0 1110 A   
.E                          0 0722 A   .E0                         0 1138 A   
.E1                         0 112D A   .E2                         0 1148 A   
.E3                         0 113F A   .E4                         0 115E A   
.E5                         0 1155 A   .E6                         0 119C A   
.E7                         0 1182 A   .E8                         0 1174 A   
.E9                         0 119C A   .EA                         0 1191 A   
.EB                         0 11AC A   .EC                         0 11A3 A   
.ED                         0 11EA A   .EE                         0 11D0 A   
.EF                         0 11C2 A   .F                          0 0719 A   
.F0                         0 11EA A   .F1                         0 11DF A   
.F2                         0 11FA A   .F3                         0 11F1 A   
.F4                         0 1238 A   .F5                         0 121E A   
.F6                         0 1210 A   .F7                         0 1238 A   
.F8                         0 122D A   .F9                         0 1248 A   
.FA                         0 123F A   .FB                         0 1278 A   
.FC                         0 125E A   .FD                         0 1250 A   
.FE                         0 1278 A   .FF                         0 126D A   
.FFDD                       0 8DB1 A   .FFDE                       0 8D9B A   
.FFDF                       0 8D85 A   .FFE0                       0 8DA7 A   
.FFE2                       0 8D7A A   .FFE3                       0 874E A   
.FFE4                       0 8721 A   .FFE6                       0 8508 A   
.FFE7                       0 84F2 A   .FFE8                       0 84DC A   
.FFE9                       0 84FE A   .FFEB                       0 84D1 A   
.FFEC                       0 79AD A   .FFED                       0 79D9 A   
.FFEE                       0 79C3 A   .FFEF                       0 79CF A   
.FFF1                       0 79A2 A   .FFF4                       0 5A11 A   
.FFFA                       0 3D7E A   BcdToBin                    0 AFE0 A   
Upcall                      0 B384 A   _TCGInterruptHandler        0 B41D A   
_apm16_entry                0 B18E A   _apm32_entry                0 B0A5 A   
_apmreal_entry              0 B25B A   _ata_cmd_data_in            0 2F16 A E 
_ata_cmd_data_out           0 32FF A E _ata_cmd_non_data           0 2F0F A E 
_ata_cmd_packet             0 36D9 A E _ata_detect                 0 1E82 A E 
_ata_init                   0 1A30 A E _ata_reset                  0 2DBE A E 
_atapi_get_sense            0 3BB8 A E _atapi_is_cdrom             0 3F25 A E 
_atapi_is_ready             0 3C3D A E _await_ide                  0 1D0A A   
_bios_cvs_version_string    0 0194 A   _bios_printf                0 0A19 A E 
_cdemu_emulated_drive       0 3FE8 A E _cdemu_init                 0 3F97 A E 
_cdemu_isactive             0 3FC1 A E _cdrom_boot                 0 402D A E 
_check_for_keystroke        0 09D2 A E _clobber_entry_point        0 130B A E 
_debugger_off               0 194F A E _debugger_on                0 193D A E 
_delay_ticks                0 0920 A E _delay_ticks_and_check_for+ 0 09E8 A E 
_dequeue_key                0 5E8A A E _determine_floppy_media     0 A33D A E 
_disable_rom_write_access   0 06A5 A E _drivetypes                 0 1372 A   
_eltorito                   0 4015 A   _enable_mouse_int_and_even+ 0 6038 A E 
_enable_rom_write_access    0 0694 A E _enqueue_key                0 6838 A E 
_fixup_base_mem_in_k        0 0650 A E _floppy_drive_exists        0 9190 A E 
_floppy_drive_recal         0 90DD A E _floppy_media_known         0 8EFB A E 
_floppy_media_sense         0 8F7E A E _floppy_prepare_controller  0 8E1C A E 
_floppy_reset_controller    0 8DCE A E _get_CS                     0 064A A E 
_get_SS                     0 064D A E _get_boot_vector            0 1501 A   
_get_keystroke              0 09E0 A E _get_mouse_data             0 6126 A E 
_get_s3_waking_vector       0 B46B A   _inb                        0 053E A E 
_inb_cmos                   0 0583 A E _inhibit_mouse_int_and_eve+ 0 5F8B A E 
_init_boot_vectors          0 13A4 A   _init_rtc                   0 058F A E 
_int09_function             0 61B5 A E _int13_cdemu                0 8775 A E 
_int13_cdrom                0 79F6 A E _int13_diskette_function    0 91D8 A E 
_int13_eltorito             0 8525 A E _int13_harddisk             0 6A07 A E 
_int14_function             0 47C5 A E _int15_function             0 4A35 A E 
_int15_function32           0 56C8 A E _int15_function_mouse       0 4F6F A E 
_int16_function             0 5A48 A E _int17_function             0 A33E A E 
_int18_function             0 A476 A E _int18_panic_msg            0 18C2 A E 
_int1a_function             0 A70D A E _int1a_function32           0 B4D9 A E 
_int70_function             0 AAB7 A E _int74_function             0 68EC A E 
_interactive_bootkey        0 1562 A E _inw                        0 0549 A E 
_isotag                     0 400F A   _keyboard_init              0 0DEC A E 
_keyboard_panic             0 12B0 A E _log_bios_start             0 18D4 A E 
_machine_reset              0 12C5 A E _memcpyb                    0 0024 A E 
_memcpyd                    0 0053 A E _memsetb                    0 0000 A E 
_nmi_handler_msg            0 18B0 A E _outb                       0 0554 A E 
_outb_cmos                  0 0574 A E _outw                       0 0564 A E 
_panic_msg_keyb_buffer_ful+ 0 5F6B A   _pmm                        0 B471 A   
_print_bios_banner          0 134B A E _print_boot_device          0 175A A E 
_print_boot_failure         0 1823 A E _print_cdromboot_failure    0 189B A E 
_put_int                    0 072F A E _put_luint                  0 0835 A E 
_put_str                    0 08EC A E _put_uint                   0 07B2 A E 
_read_byte                  0 05F4 A E _read_dword                 0 0083 A E 
_read_word                  0 0607 A E _rtc_updating               0 05C0 A E 
_s3_resume                  0 1960 A E _s3_resume_panic            0 1339 A E 
_scan_to_scanascii          0 01C4 A   _send                       0 06C7 A E 
_send_to_mouse_ctrl         0 60DC A E _set_diskette_current_cyl   0 A30C A E 
_set_diskette_ret_status    0 A2F4 A E _set_e820_range             0 55EC A E 
_set_enable_a20             0 18EA A E _set_kbd_command_byte       0 6167 A E 
_shutdown_status_panic      0 1321 A E _tcpa_acpi_init             0 B423 A   
_tcpa_add_bootdevice        0 B447 A   _tcpa_add_event_separators  0 B43B A   
_tcpa_calling_int19h        0 B42F A   _tcpa_do_measure_POSTs      0 B477 A E 
_tcpa_extend_acpi_log       0 B429 A   _tcpa_initialize_tpm        0 B465 A   
_tcpa_ipl                   0 B459 A   _tcpa_measure_post          0 B45F A   
_tcpa_option_rom            0 B453 A   _tcpa_returned_int19h       0 B435 A   
_tcpa_start_option_rom_sca+ 0 B44D A   _tcpa_wake_event            0 B441 A   
_vgafont8                   0 FA6E A   _wrch                       0 06B7 A E 
_write_byte                 0 061A A E _write_dword                0 009B A E 
_write_word                 0 0632 A E apm16_04                    0 B18F A   
apm16_05                    0 B196 A   apm16_07                    0 B1A1 A   
apm16_07_1                  0 B1C5 A   apm16_07_poweroff           0 B1BB A   
apm16_07_poweroff_str       0 B175 A   apm16_07_standby            0 B1D7 A   
apm16_07_standby_str        0 B186 A   apm16_07_suspend            0 B1C8 A   
apm16_07_suspend_str        0 B17E A   apm16_08                    0 B1E6 A   
apm16_0a                    0 B1EC A   apm16_0b                    0 B200 A   
apm16_0e                    0 B208 A   apm16_0f                    0 B212 A   
apm16_10                    0 B218 A   apm16_error                 0 B226 A   
apm16_ok                    0 B223 A   apm16_out_str               0 B15D A   
apm16_out_str1              0 B164 A   apm16_out_str2              0 B170 A   
apm16_unimplemented         0 B226 A   apm32_04                    0 B0A7 A   
apm32_05                    0 B0B0 A   apm32_07                    0 B0BF A   
apm32_07_1                  0 B0F0 A   apm32_07_poweroff           0 B0E2 A   
apm32_07_poweroff_str       0 B08C A   apm32_07_standby            0 B104 A   
apm32_07_standby_str        0 B09D A   apm32_07_suspend            0 B0F3 A   
apm32_07_suspend_str        0 B095 A   apm32_08                    0 B115 A   
apm32_0a                    0 B11B A   apm32_0b                    0 B131 A   
apm32_0e                    0 B139 A   apm32_0f                    0 B143 A   
apm32_10                    0 B149 A   apm32_error                 0 B159 A   
apm32_ok                    0 B155 A   apm32_out_str               0 B079 A   
apm32_out_str1              0 B07D A   apm32_out_str2              0 B089 A   
apm32_unimplemented         0 B159 A   apm_call                    0 F87B A   
apmreal_00                  0 B25B A   apmreal_01                  0 B26D A   
apmreal_02                  0 B274 A   apmreal_03                  0 B28A A   
apmreal_04                  0 B2A9 A   apmreal_05                  0 B2B0 A   
apmreal_07                  0 B2BB A   apmreal_07_1                0 B2DF A   
apmreal_07_poweroff         0 B2D5 A   apmreal_07_poweroff_str     0 B241 A   
apmreal_07_standby          0 B2F1 A   apmreal_07_standby_str      0 B252 A   
apmreal_07_suspend          0 B2E2 A   apmreal_07_suspend_str      0 B24A A   
apmreal_08                  0 B300 A   apmreal_0a                  0 B306 A   
apmreal_0b                  0 B31A A   apmreal_0e                  0 B322 A   
apmreal_0f                  0 B32C A   apmreal_10                  0 B332 A   
apmreal_error               0 B342 A   apmreal_ok                  0 B33D A   
apmreal_out_str             0 B229 A   apmreal_out_str1            0 B230 A   
apmreal_out_str2            0 B23C A   apmreal_unimplemented       0 B342 A   
ata_in_16                   0 3269 A   ata_in_32                   0 326D A   
ata_in_adjust               0 3255 A   ata_in_done                 0 3270 A   
ata_in_no_adjust            0 325C A   ata_out_16                  0 3652 A   
ata_out_32                  0 3657 A   ata_out_adjust              0 363E A   
ata_out_done                0 365B A   ata_out_no_adjust           0 3645 A   
ata_packet_after            0 3B43 A   ata_packet_done             0 3B5D A   
ata_packet_in_16            0 3B3C A   ata_packet_in_32            0 3B40 A   
ata_packet_in_after_16      0 3B50 A   ata_packet_in_after_32      0 3B55 A   
ata_packet_in_after_32_loo+ 0 3B57 A   ata_packet_in_before_16     0 3B1A A   
ata_packet_in_before_32     0 3B1F A   ata_packet_in_before_32_lo+ 0 3B21 A   
ata_packet_no_before        0 3B27 A   bios32_end                  0 B5F3 A   
bios32_entry_point          0 B5C0 A   bios32_structure            0 B5B0 A   
bios_table_area_end         0 CFF0 A   bios_table_area_start       0 BBA0 A   
block_count_rounded         0 BA69 A   carry_set                   0 AC13 A   
check_for_hd1               0 AE9B A   checksum_loop               0 BA17 A   
checksum_out                0 BA31 A   detect_parport              0 B9BC A   
detect_serial               0 B9DB A   diskette_param_table        0 EFC7 A   
diskette_param_table2       0 EFDE A   done                        0 09DF A   
dummy_iret_handler          0 FF53 A   ebda_post                   0 AF89 A   
eoi_both_pics               0 AFD7 A   eoi_jmp_post                0 AF9E A   
eoi_master_pic              0 AFDB A   f0_missing                  0 AD15 A   
f1_missing                  0 AD20 A   fetch_bdf                   0 BA82 A   
floppy_drive_post           0 ACDA A   gdt_base                    0 B350 A   
gdt_entry_end               0 B378 A   gdt_entry_pm_16bit_cs       0 B360 A   
gdt_entry_pm_16bit_ds       0 B370 A   gdt_entry_pm_32bit_cs       0 B358 A   
gdt_entry_pm_32bit_ds       0 B368 A   halt2_loop                  0 0DE5 A   
hard_drive_post             0 AD61 A   hd0_post_above_2048         0 AE5D A   
hd0_post_above_4096         0 AE6B A   hd0_post_above_8192         0 AE79 A   
hd0_post_checksum_loop      0 AE8E A   hd0_post_logical_chs        0 AE3C A   
hd0_post_physical_chs       0 AE2E A   hd0_post_store_logical      0 AE7F A   
hd1_post_above_2048         0 AF4A A   hd1_post_above_4096         0 AF58 A   
hd1_post_above_8192         0 AF66 A   hd1_post_checksum_loop      0 AF7B A   
hd1_post_logical_chs        0 AF29 A   hd1_post_physical_chs       0 AF1C A   
hd1_post_store_logical      0 AF6C A   idiv_                       0 0165 A   
idiv_u                      0 0169 A   int08_floppy_off            0 FEC4 A   
int08_handler               0 FEA5 A   int08_store_ticks           0 FED9 A   
int09_check_pause           0 E9B5 A   int09_done                  0 E9CF A   
int09_finish                0 E9D5 A   int09_handler               0 E987 A   
int09_process_key           0 E9C7 A   int0e_handler               0 EF57 A   
int0e_loop1                 0 EF69 A   int0e_loop2                 0 EF73 A   
int0e_normal                0 EF81 A   int10_handler               0 F065 A   
int11_handler               0 F84D A   int12_handler               0 F841 A   
int13_cdemu_inactive        0 AC67 A   int13_cdrom_rme_end         0 7E8A A   
int13_disk                  0 AC96 A   int13_diskette              0 EC59 A   
int13_handler               0 E3FE A   int13_legacy                0 AC6F A   
int13_nocdemu               0 AC54 A   int13_noeltorito            0 AC6B A   
int13_not_eltorito          0 AC31 A   int13_notcdrom              0 AC96 A   
int13_notfloppy             0 AC82 A   int13_out                   0 ACA3 A   
int13_relocated             0 AC1C A   int14_handler               0 E739 A   
int1586_tick                0 5716 A   int1586_tick_end            0 5724 A   
int15_handler               0 F859 A   int15_handler32             0 F883 A   
int15_handler32_ret         0 F875 A   int15_handler_mouse         0 F87E A   
int15_handler_mouse_ret     0 F874 A   int16_F00                   0 E85B A   
int16_handler               0 E82E A   int16_key_found             0 E86F A   
int16_wait_for_key          0 E860 A   int16_zero_clear            0 E849 A   
int16_zero_set              0 E852 A   int17_handler               0 EFD2 A   
int18_handler               0 ACA7 A   int19_handler               0 E6F2 A   
int19_load_done             0 A5D2 A   int19_relocated             0 ACCC A   
int1a_callfunction          0 FE8D A   int1a_handler               0 FE6E A   
int1a_normal                0 FE87 A   int1c_handler               0 ACD9 A   
int70_handler               0 FE93 A   int74_done                  0 ABFE A   
int74_handler               0 ABDF A   int75_handler               0 E2C7 A   
int76_handler               0 B066 A   iret_modify_cf              0 AC08 A   
iret_post_0x467             0 AFAE A   jmp_post_0x467              0 AFA6 A   
laddl                       0 00C3 A   laddul                      0 00C3 A   
landl                       0 00BB A   landul                      0 00BB A   
lcmpl                       0 00CB A   lcmpul                      0 00CB A   
ldecl                       0 0102 A   ldecul                      0 0102 A   
ldivul                      0 016E A   lincl                       0 010F A   
lincul                      0 010F A   lmull                       0 00E9 A   
lmulul                      0 00E9 A   look_drive0                 0 AD0C A   
look_drive1                 0 AD17 A   lorl                        0 0107 A   
lorul                       0 0107 A   lsl_exit                    0 0164 A   
lsl_loop                    0 0158 A   lsll                        0 0147 A   
lslul                       0 0147 A   lsr_exit                    0 0146 A   
lsr_loop                    0 013A A   lsrul                       0 0129 A   
lsubl                       0 00E1 A   lsubul                      0 00E1 A   
ltstl                       0 0114 A   ltstul                      0 0114 A   
memcpyb_end                 0 004B A   memcpyd_end                 0 007B A   
memsetb_end                 0 001E A   nmi                         0 E2C3 A   
no_bcv                      0 BAD4 A   no_bev                      0 BB16 A   
no_key                      0 09DD A   no_parport                  0 B9DA A   
no_prod_str                 0 BB0E A   no_serial                   0 B9FE A   
normal_post                 0 E0A7 A   pci_present                 0 B77D A   
pci_pro_devloop             0 B62D A   pci_pro_devloop2            0 B663 A   
pci_pro_f02                 0 B61C A   pci_pro_f03                 0 B658 A   
pci_pro_f08                 0 B691 A   pci_pro_f09                 0 B6B0 A   
pci_pro_f0a                 0 B6CE A   pci_pro_f0b                 0 B6E2 A   
pci_pro_f0c                 0 B6FE A   pci_pro_f0d                 0 B71C A   
pci_pro_fail                0 B732 A   pci_pro_nextdev             0 B648 A   
pci_pro_nextdev2            0 B681 A   pci_pro_ok                  0 B737 A   
pci_pro_select_reg          0 B73E A   pci_pro_unknown             0 B730 A   
pci_real_devloop            0 B7B1 A   pci_real_devloop2           0 B7E3 A   
pci_real_f02                0 B79E A   pci_real_f03                0 B7DA A   
pci_real_f08                0 B810 A   pci_real_f09                0 B828 A   
pci_real_f0a                0 B840 A   pci_real_f0b                0 B854 A   
pci_real_f0c                0 B86B A   pci_real_f0d                0 B882 A   
pci_real_f0e                0 B895 A   pci_real_fail               0 B8D5 A   
pci_real_nextdev            0 B7C7 A   pci_real_nextdev2           0 B7FD A   
pci_real_ok                 0 B8DB A   pci_real_select_reg         0 B8E3 A   
pci_real_too_small          0 B8CA A   pci_real_unknown            0 B8D3 A   
pci_routing_table_structur+ 0 B900 A   pci_routing_table_structur+ 0 B980 A   
pci_routing_table_structur+ 0 B920 A   pcibios_error               0 FE7B A   
pcibios_protected           0 B600 A   pcibios_real                0 B75B A   
pmm_entry_point             0 B990 A   pmm_structure               0 B980 A   
pmode_IDT_info              0 F88C A   pnp_string                  0 BA41 A   
post                        0 E05B A   post_d0_extended            0 ADC3 A   
post_d0_type47              0 ADD4 A   post_d1_exists              0 AEA6 A   
post_d1_extended            0 AEB1 A   post_d1_type47              0 AEC2 A   
post_default_ints           0 E0D7 A   post_init_pic               0 BB4D A   
protected_mode              0 4DFE A   protmode_gdtdesc            0 B378 A   
real_mode                   0 4E28 A   realmode_gdtdesc            0 B37E A   
retf_post_0x467             0 AFBB A   rmode_IDT_info              0 F891 A   
rom_checksum                0 BA00 A   rom_scan                    0 BA45 A   
rom_scan_increment          0 BB18 A   rom_scan_loop               0 BA45 A   
s3_post                     0 AFC8 A   smbios_entry_point          0 BB80 A   
smbios_init                 0 BB2A A   timer_tick_post             0 AFEF A   
unknown_service             0 B5F1 A   upcall1                     0 B3B4 A   
upcall2                     0 B3C3 A   upcall3                     0 B3EB A   
upcall4                     0 B401 A   

00000 errors
00000 warnings
